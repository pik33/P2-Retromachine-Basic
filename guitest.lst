00000                 | 
00000                 | #line 1 "D:/Programowanie/P2-Retromachine-Basic/guitest.p2asm"
00000                 | con
00000                 | 	_clkfreq = 338695652
00000                 | 	_clkmode = 28773115
00000                 | 	fbReadOnly = 1
00000                 | 	fbHidden = 2
00000                 | 	fbSystem = 4
00000                 | 	fbDirectory = 16
00000                 | 	fbArchive = 32
00000                 | 	fbNormal = 33
00000                 | 	HEAPSIZE = 96000
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 338695652
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $1b70afb
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 76 06 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 03 90 5D |  if_ne	jmp	#spininit
0040c 002 3A F1 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 02 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 85 DB 80 FF 
00420 007 00 F0 65 FD | 	hubset	##28773112
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 85 DB 00 FF 
00430 00b FB EC 07 F6 | 	mov	pa, ##28773115
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 0A 18 8A FF 
00440 00f 14 C8 6F FC | 	wrlong	##338695652, #20
00444 010 BC 02 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
006fc 0be 00 00 00 00 
00700 0bf 00 00 00 00 | 	orgf	192
00704 0c0             | skip_clock_set_
00704 0c0 E0 09 A0 FD | 	call	#_program
00708 0c1             | cogexit
00708 0c1 38 01 80 FF 
0070c 0c2 1F 00 66 FD | 	waitx	##160000
00710 0c3 01 90 62 FD | 	cogid	arg01
00714 0c4 03 90 62 FD | 	cogstop	arg01
00718 0c5             | spininit
00718 0c5 61 63 06 FB | 	rdlong	objptr, ptra++
0071c 0c6 61 77 06 FB | 	rdlong	result1, ptra++
00720 0c7 28 06 64 FD | 	setq	#3
00724 0c8 00 91 06 FB | 	rdlong	arg01, ptra
00728 0c9 04 F0 87 F1 | 	sub	ptra, #4
0072c 0ca 2D 76 62 FD | 	call	result1
00730 0cb D4 FF 9F FD | 	jmp	#cogexit
00734 0cc             | FCACHE_LOAD_
00734 0cc F9 AD 01 F6 |     mov	fcache_tmpb_,ptrb
00738 0cd 2B F2 63 FD |     pop	ptrb
0073c 0ce D5 EC 8B F9 |     altd	pa,ret_instr_
00740 0cf D5 00 00 F6 |     mov	 0-0, ret_instr_
00744 0d0 28 EC 63 FD |     setq	pa
00748 0d1 E1 01 04 FB |     rdlong	$0, ptrb++
0074c 0d2 2A F2 63 FD |     push	ptrb
00750 0d3 D6 F2 03 F6 |     mov ptrb,fcache_tmpb_
00754 0d4 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00758 0d5             | ret_instr_
00758 0d5 00 FE 07 02 |     _ret_ cmp inb,#0
0075c 0d6             | fcache_tmpb_
0075c 0d6 00 00 00 00 |     long 0
00760 0d7             | fcache_load_ptr_
00760 0d7 CC 00 00 00 |     long FCACHE_LOAD_
00764 0d8             | builtin_bytefill_
00764 0d8 01 94 56 F0 |         shr	arg03, #1 wc
00768 0d9 48 93 42 CC |  if_c   wrbyte	arg02, arg01
0076c 0da 01 90 06 C1 |  if_c   add	arg01, #1
00770 0db 00 92 FE F9 |         movbyts	arg02, #0
00774 0dc             | builtin_wordfill_
00774 0dc 01 94 56 F0 |         shr	arg03, #1 wc
00778 0dd 48 93 52 CC |  if_c   wrword	arg02, arg01
0077c 0de 02 90 06 C1 |  if_c   add	arg01, #2
00780 0df 49 93 2A F9 |         setword	arg02, arg02, #1
00784 0e0             | builtin_longfill_
00784 0e0 48 01 88 FC |         wrfast	#0,arg01
00788 0e1 00 94 0E F2 |         cmp	arg03, #0 wz
0078c 0e2 4A 03 D8 5C |  if_nz  rep	#1, arg03
00790 0e3 17 92 62 5D |  if_nz  wflong	arg02
00794 0e4 2D 00 64 FD |         ret
00798 0e5             | COUNT_
00798 0e5 00 00 00 00 |     long 0
0079c 0e6             | RETADDR_
0079c 0e6 00 00 00 00 |     long 0
007a0 0e7             | fp
007a0 0e7 00 00 00 00 |     long 0
007a4 0e8             | pushregs_
007a4 0e8 2B EC 63 FD |     pop  pa
007a8 0e9 2B CC 61 FD |     pop  RETADDR_
007ac 0ea 03 CA 95 FB |     tjz  COUNT_, #pushregs_done_
007b0 0eb FF CB 8D F9 |     altd  COUNT_, #511
007b4 0ec 28 00 64 FD |     setq #0-0
007b8 0ed 61 A7 66 FC |     wrlong local01, ptra++
007bc 0ee             | pushregs_done_
007bc 0ee 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
007c0 0ef 61 CB 65 FC |     wrlong COUNT_, ptra++
007c4 0f0 F8 CF 01 F6 |     mov    fp, ptra
007c8 0f1 2C EC 63 FD |     jmp  pa
007cc 0f2             |  popregs_
007cc 0f2 2B EC 63 FD |     pop    pa
007d0 0f3 28 04 64 FD |     setq   #2
007d4 0f4 5F CB 05 FB |     rdlong COUNT_, --ptra
007d8 0f5 02 CA 75 FB |     djf    COUNT_, #popregs__ret
007dc 0f6 28 CA 61 FD |     setq   COUNT_
007e0 0f7 5F A7 06 FB |     rdlong local01, --ptra
007e4 0f8             | popregs__ret
007e4 0f8 2A CC 61 FD |     push   RETADDR_
007e8 0f9 2C EC 63 FD |     jmp    pa
007ec 0fa             | 
007ec 0fa             | divide_
007ec 0fa 7D FB 5A F6 |        abs     muldivb_,muldivb_     wcz      'abs(y)
007f0 0fb 6C 60 62 FD |        wrc     itmp2_                         'store sign of y
007f4 0fc 7C F9 52 F6 |        abs     muldiva_,muldiva_     wc       'abs(x)
007f8 0fd 7D F9 12 FD |        qdiv    muldiva_, muldivb_             'queue divide
007fc 0fe 01 60 66 C5 |  if_c  xor     itmp2_,#1                      'store sign of x
00800 0ff 18 FA 62 FD |        getqx   muldivb_                       'get quotient
00804 100 19 F8 62 FD |        getqy   muldiva_                       'get remainder
00808 101 7C F9 82 F6 |        negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
0080c 102 00 60 16 F4 |        testb   itmp2_,#0             wc       'restore sign, division result
00810 103 7D FB 82 06 |  _ret_ negc    muldivb_,muldivb_     
00814 104             | __pc long 0
00814 104 00 00 00 00 
00818 105             | __setjmp
00818 105 2B 08 62 FD |     pop __pc
0081c 106 00 76 06 F6 |     mov result1, #0
00820 107 00 78 06 F6 |     mov result2, #0
00824 108 48 5D 02 F6 |     mov abortchain, arg01
00828 109 48 CF 61 FC |     wrlong fp, arg01
0082c 10a 04 90 06 F1 |     add arg01, #4
00830 10b 48 F1 63 FC |     wrlong ptra, arg01
00834 10c 04 90 06 F1 |     add arg01, #4
00838 10d 48 63 62 FC |     wrlong objptr, arg01
0083c 10e 04 90 06 F1 |     add arg01, #4
00840 10f 48 09 62 FC |     wrlong __pc, arg01
00844 110 2C 08 62 FD |     jmp __pc
00848 111             | __unwind_pc long 0
00848 111 00 00 00 00 
0084c 112             | __unwind_stack
0084c 112 2B 22 62 FD |    pop  __unwind_pc
00850 113             | __unwind_loop
00850 113 49 91 0A F2 |    cmp  arg01, arg02 wz
00854 114 10 00 90 AD |   if_z jmp #__unwind_stack_ret
00858 115 48 F1 03 F6 |    mov   ptra, arg01
0085c 116 6C FF BF FD |    call  #popregs_
00860 117 E7 90 02 F6 |    mov   arg01, fp
00864 118 E8 FF 9F FD |    jmp   #__unwind_loop
00868 119             | __unwind_stack_ret
00868 119 2C 22 62 FD |    jmp  __unwind_pc
0086c 11a             | __longjmp
0086c 11a 2B 08 62 FD |     pop __pc
00870 11b 00 90 0E F2 |     cmp    arg01, #0 wz
00874 11c 30 00 90 AD |  if_z jmp #nocatch
00878 11d 49 77 02 F6 |     mov result1, arg02
0087c 11e 01 78 06 F6 |     mov result2, #1
00880 11f 48 93 02 FB |     rdlong arg02, arg01
00884 120 04 90 06 F1 |     add arg01, #4
00888 121 48 F1 03 FB |     rdlong ptra, arg01
0088c 122 04 90 06 F1 |     add arg01, #4
00890 123 48 63 02 FB |     rdlong objptr, arg01
00894 124 04 90 06 F1 |     add arg01, #4
00898 125 48 09 02 FB |     rdlong __pc, arg01
0089c 126 E7 90 02 F6 |     mov arg01, fp
008a0 127 A8 FF BF FD |     call #__unwind_stack
008a4 128             | __longjmp_ret
008a4 128 2C 08 62 FD |     jmp  __pc
008a8 129             | nocatch
008a8 129 00 94 0E F2 |     cmp arg03, #0 wz
008ac 12a 58 FE 9F AD |  if_z jmp #cogexit
008b0 12b F0 FF 9F FD |     jmp #__longjmp_ret
008b4 12c             | 
008b4 12c             | __heap_ptr
008b4 12c 6C 6E 01 00 | 	long	@__heap_base
008b8 12d             | __methods__
008b8 12d B8 6D 01 00 | 	long	@__methodtable__
008bc 12e             | abortchain
008bc 12e 00 00 00 00 | 	long	0
008c0 12f             | itmp1_
008c0 12f 00 00 00 00 | 	long	0
008c4 130             | itmp2_
008c4 130 00 00 00 00 | 	long	0
008c8 131             | objptr
008c8 131 74 E5 02 00 | 	long	@objmem
008cc 132             | ptr__Audio2_004_spin2_dat__
008cc 132 40 5F 01 00 | 	long	@_Audio2_004_spin2_dat_
008d0 133             | ptr___system__dat__
008d0 133 3C 63 01 00 | 	long	@__system__dat_
008d4 134             | ptr__dat__
008d4 134 78 DF 00 00 | 	long	@_dat_
008d8 135             | ptr__fatfs_cc_dat__
008d8 135 28 68 01 00 | 	long	@_fatfs_cc_dat_
008dc 136             | ptr__hg010b_spin2_dat__
008dc 136 78 E5 00 00 | 	long	@_hg010b_spin2_dat_
008e0 137             | ptr__psram16drv_spin2_dat__
008e0 137 28 25 01 00 | 	long	@_psram16drv_spin2_dat_
008e4 138             | ptr__psram_spin2_dat__
008e4 138 E0 22 01 00 | 	long	@_psram_spin2_dat_
008e8 139             | ptr__usbnew_spin2_dat__
008e8 139 B8 34 01 00 | 	long	@_usbnew_spin2_dat_
008ec 13a             | ptr_stackspace_
008ec 13a CC 18 03 00 | 	long	@stackspace
008f0 13b             | result1
008f0 13b 00 00 00 00 | 	long	0
008f4 13c             | result2
008f4 13c 01 00 00 00 | 	long	1
008f8 13d             | result3
008f8 13d 02 00 00 00 | 	long	2
008fc 13e             | COG_BSS_START
008fc 13e             | 	fit	480
008fc                 | 	orgh
008fc                 | hubentry
008fc                 | 
008fc                 | ' trackbar1.create(v,100,100,16,300)
008fc                 | ' 
008fc                 | ' 
008fc                 | ' 
008fc                 | ' sub startpsram
008fc                 | _startpsram
008fc     00 90 06 F6 | 	mov	arg01, #0
00900     0A 92 C6 F9 | 	decod	arg02, #10
00904     0B 94 06 F6 | 	mov	arg03, #11
00908     07 96 06 F6 | 	mov	arg04, #7
0090c     0B 00 00 FF 
00910     F0 62 06 F1 | 	add	objptr, ##5872
00914     F0 13 B0 FD | 	call	#_psram_spin2_startx
00918     0B 00 00 FF 
0091c     E4 62 86 F1 | 	sub	objptr, ##5860
00920     31 77 62 FC | 	wrlong	result1, objptr
00924     04 62 06 F1 | 	add	objptr, #4
00928     31 79 62 FC | 	wrlong	result2, objptr
0092c     10 62 86 F1 | 	sub	objptr, #16
00930                 | _startpsram_ret
00930     2D 00 64 FD | 	ret
00934                 | 
00934                 | ' 
00934                 | ' function startvideo(mode=64, pin=0, mb=0) 'todo return a cog#
00934                 | _startvideo
00934     01 CA 05 F6 | 	mov	COUNT_, #1
00938     E8 00 A0 FD | 	call	#pushregs_
0093c     10 62 06 F1 | 	add	objptr, #16
00940     31 97 02 FB | 	rdlong	arg04, objptr
00944     49 91 02 F6 | 	mov	arg01, arg02
00948     4B 93 02 F6 | 	mov	arg02, arg04
0094c     14 62 06 F1 | 	add	objptr, #20
00950     E0 02 B0 FD | 	call	#_hg010b_spin2_start
00954     10 62 86 F1 | 	sub	objptr, #16
00958     31 77 62 FC | 	wrlong	result1, objptr
0095c                 | ' 
0095c                 | ' videocog=v.start(pin,mbox)
0095c                 | ' for thecog=0 to 7:psram.setQos(thecog, 80 << 16) :next thecog
0095c     00 A6 06 F6 | 	mov	local01, #0
00960     0B 00 00 FF 
00964     DC 62 06 F1 | 	add	objptr, ##5852
00968                 | LR__0001
00968     53 91 02 F6 | 	mov	arg01, local01
0096c     00 28 00 FF 
00970     00 92 06 F6 | 	mov	arg02, ##5242880
00974     10 18 B0 FD | 	call	#_psram_spin2_setQos
00978     01 A6 06 F1 | 	add	local01, #1
0097c     08 A6 56 F2 | 	cmps	local01, #8 wc
00980     E4 FF 9F CD |  if_b	jmp	#LR__0001
00984     0B 00 00 FF 
00988     DC 62 86 F1 | 	sub	objptr, ##5852
0098c     31 91 02 FB | 	rdlong	arg01, objptr
00990     7A 00 02 FF 
00994     00 92 06 F6 | 	mov	arg02, ##67171328
00998     0B 00 00 FF 
0099c     DC 62 06 F1 | 	add	objptr, ##5852
009a0     E4 17 B0 FD | 	call	#_psram_spin2_setQos
009a4                 | ' psram.setQoS(videocog, $0400f400) 
009a4                 | ' open SendRecvDevice(@v.putchar, nil, nil) as #0
009a4     0B 00 00 FF 
009a8     CC 62 86 F1 | 	sub	objptr, ##5836
009ac     31 93 02 F6 | 	mov	arg02, objptr
009b0     24 62 86 F1 | 	sub	objptr, #36
009b4     14 92 26 F4 | 	bith	arg02, #20
009b8     00 94 06 F6 | 	mov	arg03, #0
009bc     00 96 06 F6 | 	mov	arg04, #0
009c0     00 90 06 F6 | 	mov	arg01, #0
009c4     30 2C B0 FD | 	call	#__system___basic_open
009c8                 | ' return videocog
009c8     14 62 06 F1 | 	add	objptr, #20
009cc     31 77 02 FB | 	rdlong	result1, objptr
009d0     14 62 86 F1 | 	sub	objptr, #20
009d4     E7 F0 03 F6 | 	mov	ptra, fp
009d8     F2 00 A0 FD | 	call	#popregs_
009dc                 | _startvideo_ret
009dc     2D 00 64 FD | 	ret
009e0                 | 
009e0                 | _program
009e0     01 CA 05 F6 | 	mov	COUNT_, #1
009e4     E8 00 A0 FD | 	call	#pushregs_
009e8     10 FF BF FD | 	call	#_startpsram
009ec     10 62 06 F1 | 	add	objptr, #16
009f0     31 91 02 FB | 	rdlong	arg01, objptr
009f4     00 92 06 F6 | 	mov	arg02, #0
009f8     F0 03 00 FF 
009fc     00 94 06 F6 | 	mov	arg03, ##516096
00a00     0B 00 00 FF 
00a04     E0 62 06 F1 | 	add	objptr, ##5856
00a08     78 19 B0 FD | 	call	#_Audio2_004_spin2_start
00a0c     0B 00 00 FF 
00a10     F0 62 86 F1 | 	sub	objptr, ##5872
00a14     3C A3 02 F6 | 	mov	arg10, result2
00a18     31 77 62 FC | 	wrlong	result1, objptr
00a1c     04 62 06 F1 | 	add	objptr, #4
00a20     31 A3 62 FC | 	wrlong	arg10, objptr
00a24     04 62 86 F1 | 	sub	objptr, #4
00a28     32 90 06 F6 | 	mov	arg01, #50
00a2c     6C 24 B0 FD | 	call	#__system___waitms
00a30     58 18 B0 FD | 	call	#_usbnew_spin2_start
00a34     08 62 06 F1 | 	add	objptr, #8
00a38     31 77 62 FC | 	wrlong	result1, objptr
00a3c     08 62 86 F1 | 	sub	objptr, #8
00a40     40 90 06 F6 | 	mov	arg01, #64
00a44     00 92 06 F6 | 	mov	arg02, #0
00a48     00 94 06 F6 | 	mov	arg03, #0
00a4c     E4 FE BF FD | 	call	#_startvideo
00a50                 | '   mouse_limits[0] := xlim
00a50     0F 00 00 FF 
00a54     C8 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##7880
00a58     01 00 80 FF 
00a5c     39 FF 6B FC | 	wrlong	##1023, ptr__usbnew_spin2_dat__
00a60                 | '   mouse_limits[1] := ylim
00a60     04 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, #4
00a64     01 00 80 FF 
00a68     39 AF 68 FC | 	wrlong	##599, ptr__usbnew_spin2_dat__
00a6c     31 91 02 F6 | 	mov	arg01, objptr
00a70     F9 91 06 F1 | 	add	arg01, #505
00a74                 | '   mouse_outptr := ptr
00a74     04 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, #4
00a78     39 91 62 FC | 	wrlong	arg01, ptr__usbnew_spin2_dat__
00a7c     0F 00 00 FF 
00a80     D0 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##7888
00a84     34 93 02 F6 | 	mov	arg02, ptr__dat__
00a88     01 00 00 FF 
00a8c     00 92 06 F1 | 	add	arg02, ##512
00a90     10 90 06 F6 | 	mov	arg01, #16
00a94     24 62 06 F1 | 	add	objptr, #36
00a98     58 07 B0 FD | 	call	#_hg010b_spin2_setspriteptr
00a9c     10 90 06 F6 | 	mov	arg01, #16
00aa0     20 92 06 F6 | 	mov	arg02, #32
00aa4     20 94 06 F6 | 	mov	arg03, #32
00aa8     D4 07 B0 FD | 	call	#_hg010b_spin2_setspritesize
00aac     24 62 86 F1 | 	sub	objptr, #36
00ab0     09 90 C6 F9 | 	decod	arg01, #9
00ab4     2C 93 06 F6 | 	mov	arg02, #300
00ab8     2C 18 B0 FD | 	call	#_usbnew_spin2_mouse_move
00abc     18 62 06 F1 | 	add	objptr, #24
00ac0     31 27 69 FC | 	wrlong	#147, objptr
00ac4     04 62 06 F1 | 	add	objptr, #4
00ac8     31 35 69 FC | 	wrlong	#154, objptr
00acc     04 62 06 F1 | 	add	objptr, #4
00ad0     31 09 68 FC | 	wrlong	#4, objptr
00ad4     04 62 86 F1 | 	sub	objptr, #4
00ad8     31 91 02 FB | 	rdlong	arg01, objptr
00adc     04 62 86 F1 | 	sub	objptr, #4
00ae0     31 93 02 FB | 	rdlong	arg02, objptr
00ae4     0C 62 06 F1 | 	add	objptr, #12
00ae8     E4 0C B0 FD | 	call	#_hg010b_spin2_cls
00aec     04 62 86 F1 | 	sub	objptr, #4
00af0     31 91 02 FB | 	rdlong	arg01, objptr
00af4     04 62 06 F1 | 	add	objptr, #4
00af8     28 0C B0 FD | 	call	#_hg010b_spin2_setfontfamily
00afc                 | ' 
00afc                 | ' leading_spaces:=amount
00afc     01 00 00 FF 
00b00     B6 62 06 F1 | 	add	objptr, ##694
00b04     31 05 68 FC | 	wrlong	#2, objptr
00b08     01 00 00 FF 
00b0c     DA 62 86 F1 | 	sub	objptr, ##730
00b10     6F 00 00 FF 
00b14     5C A7 06 F6 | 	mov	local01, ##@LR__2152
00b18     3D 90 06 F6 | 	mov	arg01, #61
00b1c     3C 92 06 F6 | 	mov	arg02, #60
00b20     3B 94 06 F6 | 	mov	arg03, #59
00b24     3A 96 06 F6 | 	mov	arg04, #58
00b28     7C 4B B0 FD | 	call	#__system___vfs_open_sdcardx
00b2c     3B 93 02 F6 | 	mov	arg02, result1
00b30     53 91 02 F6 | 	mov	arg01, local01
00b34     3C 24 B0 FD | 	call	#__system___mount
00b38     6F 00 00 FF 
00b3c     60 91 06 F6 | 	mov	arg01, ##@LR__2153
00b40     F4 26 B0 FD | 	call	#__system___chdir
00b44     6F 00 00 FF 
00b48     68 A7 06 F6 | 	mov	local01, ##@LR__2154
00b4c     0E 00 00 FF 
00b50     5C 62 06 F1 | 	add	objptr, ##7260
00b54     31 A7 62 FC | 	wrlong	local01, objptr
00b58     0E 00 00 FF 
00b5c     5C 62 86 F1 | 	sub	objptr, ##7260
00b60                 | ' print: print "kwas"
00b60     00 90 06 F6 | 	mov	arg01, #0
00b64     90 56 B0 FD | 	call	#__system___getiolock_0133
00b68     3B 91 02 F6 | 	mov	arg01, result1
00b6c     48 22 B0 FD | 	call	#__system___lockmem
00b70     00 90 06 F6 | 	mov	arg01, #0
00b74     0A 92 06 F6 | 	mov	arg02, #10
00b78     00 94 06 F6 | 	mov	arg03, #0
00b7c     20 2C B0 FD | 	call	#__system___basic_print_char
00b80     00 90 06 F6 | 	mov	arg01, #0
00b84     70 56 B0 FD | 	call	#__system___getiolock_0133
00b88     3B 01 68 FC | 	wrlong	#0, result1
00b8c     00 90 06 F6 | 	mov	arg01, #0
00b90     64 56 B0 FD | 	call	#__system___getiolock_0133
00b94     3B 91 02 F6 | 	mov	arg01, result1
00b98     1C 22 B0 FD | 	call	#__system___lockmem
00b9c     6F 00 00 FF 
00ba0     70 93 06 F6 | 	mov	arg02, ##@LR__2155
00ba4     00 90 06 F6 | 	mov	arg01, #0
00ba8     00 94 06 F6 | 	mov	arg03, #0
00bac     48 2C B0 FD | 	call	#__system___basic_print_string
00bb0     00 90 06 F6 | 	mov	arg01, #0
00bb4     0A 92 06 F6 | 	mov	arg02, #10
00bb8     00 94 06 F6 | 	mov	arg03, #0
00bbc     E0 2B B0 FD | 	call	#__system___basic_print_char
00bc0     00 90 06 F6 | 	mov	arg01, #0
00bc4     30 56 B0 FD | 	call	#__system___getiolock_0133
00bc8     3B 01 68 FC | 	wrlong	#0, result1
00bcc     00 92 06 F6 | 	mov	arg02, #0
00bd0     01 92 D6 F7 | 	test	arg02, #1 wc
00bd4     5A 4C 64 FD | 	drvc	#38
00bd8     01 92 D6 F7 | 	test	arg02, #1 wc
00bdc     5A 4E 64 FD | 	drvc	#39
00be0     24 62 06 F1 | 	add	objptr, #36
00be4     31 91 02 F6 | 	mov	arg01, objptr
00be8     6F 00 00 FF 
00bec     75 A5 06 F6 | 	mov	arg11, ##@LR__2156
00bf0     64 92 06 F6 | 	mov	arg02, #100
00bf4     64 94 06 F6 | 	mov	arg03, #100
00bf8     10 96 06 F6 | 	mov	arg04, #16
00bfc     2C 99 06 F6 | 	mov	arg05, #300
00c00     00 9A 06 F6 | 	mov	arg06, #0
00c04     0A 9C 06 F6 | 	mov	arg07, #10
00c08     0B 9E 06 F6 | 	mov	arg08, #11
00c0c     F4 A0 06 F6 | 	mov	arg09, #244
00c10     F8 A2 06 F6 | 	mov	arg10, #248
00c14     0E 00 00 FF 
00c18     3C 62 06 F1 | 	add	objptr, ##7228
00c1c     00 1A B0 FD | 	call	#_trackbar_create
00c20     0E 00 00 FF 
00c24     60 62 86 F1 | 	sub	objptr, ##7264
00c28     E7 F0 03 F6 | 	mov	ptra, fp
00c2c     F2 00 A0 FD | 	call	#popregs_
00c30                 | _program_ret
00c30     2D 00 64 FD | 	ret
00c34                 | 
00c34                 | ' '' this is not a main program.
00c34                 | ' 
00c34                 | ' '****************************************************************************************************************
00c34                 | ' '                                                                                                             	*
00c34                 | ' 'Start the driver  at pins 'base'                            					rev 20230829 	*
00c34                 | ' '                                                                                                            	*
00c34                 | ' ' base - HDMI base pin												*
00c34                 | ' ' mb - PSRAM mailbox pointer, 0 if no PSRAM									*
00c34                 | ' '														*
00c34                 | ' '														*
00c34                 | ' '****************************************************************************************************************
00c34                 | ' 
00c34                 | ' pub start(base,mb):result |i
00c34                 | _hg010b_spin2_start
00c34                 | ' 
00c34                 | ' '--------------------------- initialize pointers and variables
00c34                 | ' 
00c34                 | ' border_ptr:=@bordercolor					' Initial border color pointer, can be changed via DL
00c34     34 62 06 F1 | 	add	objptr, #52
00c38     31 77 02 F6 | 	mov	result1, objptr
00c3c     28 62 86 F1 | 	sub	objptr, #40
00c40     31 77 62 FC | 	wrlong	result1, objptr
00c44                 | ' 'font_ptr:=@amiga_font						' Initial 8x16 font definition
00c44                 | ' hdmibase:=base							' HDMI base pin, 8*n
00c44     18 62 06 F1 | 	add	objptr, #24
00c48     31 91 62 FC | 	wrlong	arg01, objptr
00c4c                 | ' mailbox_ptr:=mb		
00c4c     04 62 06 F1 | 	add	objptr, #4
00c50     31 93 62 FC | 	wrlong	arg02, objptr
00c54                 | ' mailbox0:=mb				' PSRAM mailbox pointer
00c54     C1 63 06 F1 | 	add	objptr, #449
00c58     31 93 62 FC | 	wrlong	arg02, objptr
00c5c                 | ' sprite_ptr:=@spr1ptr
00c5c     D8 62 86 F1 | 	sub	objptr, #216
00c60     31 77 02 F6 | 	mov	result1, objptr
00c64     E5 62 86 F1 | 	sub	objptr, #229
00c68     31 77 62 FC | 	wrlong	result1, objptr
00c6c                 | ' 
00c6c                 | ' 		'
00c6c                 | ' word[spr1ptr+17*12+4]:=8				' spr18w
00c6c     E5 62 06 F1 | 	add	objptr, #229
00c70     31 77 02 FB | 	rdlong	result1, objptr
00c74     D0 76 06 F1 | 	add	result1, #208
00c78     3B 11 58 FC | 	wrword	#8, result1
00c7c                 | ' word[spr1ptr+17*12+6]:=16				' for a blinking cursor
00c7c     31 95 02 FB | 	rdlong	arg03, objptr
00c80     D2 94 06 F1 | 	add	arg03, #210
00c84     4A 21 58 FC | 	wrword	#16, arg03
00c88                 | ' leading_spaces:=0				'
00c88     A5 63 06 F1 | 	add	objptr, #421
00c8c     31 01 68 FC | 	wrlong	#0, objptr
00c90                 | ' 
00c90                 | ' emptydl[0]:=%0100_0000_0000_0000_0000_0000_0000_0111
00c90     99 62 86 F1 | 	sub	objptr, #153
00c94     00 00 A0 FF 
00c98     31 0F 68 FC | 	wrlong	##1073741831, objptr
00c9c                 | ' emptydl[1]:=0
00c9c     04 62 06 F1 | 	add	objptr, #4
00ca0     31 01 68 FC | 	wrlong	#0, objptr
00ca4                 | ' 
00ca4                 | ' '---------------------------- the mode has to be set here to enable computing the buffer length
00ca4                 | ' 
00ca4                 | ' s_debug:=debugger						' check if debug mode defined (eats 16 kB upper RAM so don't use it)					' 
00ca4     28 63 86 F1 | 	sub	objptr, #296
00ca8     31 03 68 FC | 	wrlong	#1, objptr
00cac                 | ' if s_debug<>0
00cac                 | '   s_debug:=16384						' the buffers adresses will be corrected to not interfere with the debugger
00cac     20 00 80 FF 
00cb0     31 01 68 FC | 	wrlong	##16384, objptr
00cb4     F9 62 86 F1 | 	sub	objptr, #249
00cb8                 | ' setmode()							' set the mode, see below
00cb8     30 02 B0 FD | 	call	#_hg010b_spin2_setmode
00cbc                 | ' vblank_ptr:=@vblank						' set pointers before starting the driver
00cbc     49 62 06 F1 | 	add	objptr, #73
00cc0     31 77 02 F6 | 	mov	result1, objptr
00cc4     35 62 86 F1 | 	sub	objptr, #53
00cc8     31 77 62 FC | 	wrlong	result1, objptr
00ccc                 | ' cursor_ptr:=@cursor_x						
00ccc     28 62 06 F1 | 	add	objptr, #40
00cd0     31 95 02 F6 | 	mov	arg03, objptr
00cd4     2C 62 86 F1 | 	sub	objptr, #44
00cd8     31 95 62 FC | 	wrlong	arg03, objptr
00cdc                 | ' fontnum:=0  							' start with a PC type font 
00cdc     55 62 06 F1 | 	add	objptr, #85
00ce0     31 01 68 FC | 	wrlong	#0, objptr
00ce4                 | ' bytemove(@colors,@vgacolors,16)					' prepare standard DOS VGA colors
00ce4     1C 62 06 F1 | 	add	objptr, #28
00ce8     31 91 02 F6 | 	mov	arg01, objptr
00cec     81 62 86 F1 | 	sub	objptr, #129
00cf0     36 93 02 F6 | 	mov	arg02, ptr__hg010b_spin2_dat__
00cf4     1C 00 00 FF 
00cf8     80 92 06 F1 | 	add	arg02, ##14464
00cfc     10 94 06 F6 | 	mov	arg03, #16
00d00     D4 1F B0 FD | 	call	#__system____builtin_memmove
00d04                 | ' leading_spaces:=0
00d04     01 00 00 FF 
00d08     B6 62 06 F1 | 	add	objptr, ##694
00d0c     31 01 68 FC | 	wrlong	#0, objptr
00d10     01 00 00 FF 
00d14     B6 62 86 F1 | 	sub	objptr, ##694
00d18                 | ' '---------------------------- initialize a cursor (MSDOS type)
00d18                 | ' 
00d18                 | ' initcursor(154)
00d18     9A 90 06 F6 | 	mov	arg01, #154
00d1c     48 00 B0 FD | 	call	#_hg010b_spin2_initcursor
00d20                 | ' 
00d20                 | ' '---------------------------- start the cog
00d20                 | ' 
00d20                 | ' cog:=coginit(16,@hdmi, @vblank_ptr)				' start the driver cog			
00d20     36 93 02 F6 | 	mov	arg02, ptr__hg010b_spin2_dat__
00d24     1C 00 00 FF 
00d28     90 92 06 F1 | 	add	arg02, ##14480
00d2c     31 95 02 F6 | 	mov	arg03, objptr
00d30     14 94 06 F1 | 	add	arg03, #20
00d34     10 76 06 F6 | 	mov	result1, #16
00d38     28 94 62 FD | 	setq	arg03
00d3c     49 77 F2 FC | 	coginit	result1, arg02 wc
00d40     01 76 66 C6 |  if_b	neg	result1, #1
00d44     30 62 06 F1 | 	add	objptr, #48
00d48     31 77 62 FC | 	wrlong	result1, objptr
00d4c     30 62 86 F1 | 	sub	objptr, #48
00d50                 | ' waitms(40)							' wait for stabilize
00d50     28 90 06 F6 | 	mov	arg01, #40
00d54     44 21 B0 FD | 	call	#__system___waitms
00d58                 | ' return cog							' return the driver's cog #
00d58     30 62 06 F1 | 	add	objptr, #48
00d5c     31 77 02 FB | 	rdlong	result1, objptr
00d60     30 62 86 F1 | 	sub	objptr, #48
00d64                 | _hg010b_spin2_start_ret
00d64     2D 00 64 FD | 	ret
00d68                 | 
00d68                 | ' 
00d68                 | ' '---------------------------- initialize a cursor (MSDOS type)
00d68                 | ' pub initcursor(color) |i
00d68                 | _hg010b_spin2_initcursor
00d68     03 CA 05 F6 | 	mov	COUNT_, #3
00d6c     E8 00 A0 FD | 	call	#pushregs_
00d70     48 A7 02 F6 | 	mov	local01, arg01
00d74                 | ' 
00d74                 | ' cursor_x:=0							' place the cursor at 0:0
00d74     3C 62 06 F1 | 	add	objptr, #60
00d78     31 01 58 FC | 	wrword	#0, objptr
00d7c                 | ' cursor_y:=0
00d7c     02 62 06 F1 | 	add	objptr, #2
00d80     31 01 48 FC | 	wrbyte	#0, objptr
00d84                 | ' repeat i from 0 to 111
00d84     00 A8 06 F6 | 	mov	local02, #0
00d88     F8 63 06 F1 | 	add	objptr, #504
00d8c     D7 0C 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
00d90                 | LR__0010
00d90                 | '   cursor[i]:=0
00d90     54 AB 02 F6 | 	mov	local03, local02
00d94     31 AB 02 F1 | 	add	local03, objptr
00d98     55 01 48 FC | 	wrbyte	#0, local03
00d9c     01 A8 06 F1 | 	add	local02, #1
00da0     70 A8 56 F2 | 	cmps	local02, #112 wc
00da4     E8 FF 9F CD |  if_b	jmp	#LR__0010
00da8                 | LR__0011
00da8                 | ' repeat i from 112 to 127
00da8     70 A8 06 F6 | 	mov	local02, #112
00dac     D7 0C 48 FB | 	callpa	#(@LR__0013-@LR__0012)>>2,fcache_load_ptr_
00db0                 | LR__0012
00db0                 | '   cursor[i]:=color  
00db0     54 AB 02 F6 | 	mov	local03, local02
00db4     31 AB 02 F1 | 	add	local03, objptr
00db8     55 A7 42 FC | 	wrbyte	local01, local03
00dbc     01 A8 06 F1 | 	add	local02, #1
00dc0     80 A8 16 F2 | 	cmp	local02, #128 wc
00dc4     E8 FF 9F CD |  if_b	jmp	#LR__0012
00dc8                 | LR__0013
00dc8     01 00 00 FF 
00dcc     36 62 86 F1 | 	sub	objptr, ##566
00dd0                 | ' 'repeat i from 0 to 127
00dd0                 | ' '  if ((i/8)//2)
00dd0                 | ' '    cursor[i]:=15
00dd0                 | ' '  else
00dd0                 | ' '    cursor[i]:=0
00dd0                 | ' '  if i>=120    
00dd0                 | ' '    cursor[i]:=40
00dd0                 | ' setspriteptr(17,@cursor)
00dd0     31 93 02 F6 | 	mov	arg02, objptr
00dd4     01 00 00 FF 
00dd8     36 92 06 F1 | 	add	arg02, ##566
00ddc     11 90 06 F6 | 	mov	arg01, #17
00de0     10 04 B0 FD | 	call	#_hg010b_spin2_setspriteptr
00de4                 | ' setspritesize(17,8,16)
00de4     11 90 06 F6 | 	mov	arg01, #17
00de8     08 92 06 F6 | 	mov	arg02, #8
00dec     10 94 06 F6 | 	mov	arg03, #16
00df0     8C 04 B0 FD | 	call	#_hg010b_spin2_setspritesize
00df4                 | ' setspritepos(17,0,0)
00df4     11 90 06 F6 | 	mov	arg01, #17
00df8     00 92 06 F6 | 	mov	arg02, #0
00dfc     00 94 06 F6 | 	mov	arg03, #0
00e00     14 04 B0 FD | 	call	#_hg010b_spin2_setspritepos
00e04                 | ' cursorshape:=14
00e04     0B 00 00 FF 
00e08     C6 62 06 F1 | 	add	objptr, ##5830
00e0c     31 1D 68 FC | 	wrlong	#14, objptr
00e10                 | ' cursorcolor:=color
00e10     04 62 86 F1 | 	sub	objptr, #4
00e14     31 A7 62 FC | 	wrlong	local01, objptr
00e18     0B 00 00 FF 
00e1c     C2 62 86 F1 | 	sub	objptr, ##5826
00e20     E7 F0 03 F6 | 	mov	ptra, fp
00e24     F2 00 A0 FD | 	call	#popregs_
00e28                 | _hg010b_spin2_initcursor_ret
00e28     2D 00 64 FD | 	ret
00e2c                 | 
00e2c                 | ' 
00e2c                 | ' pub setcursorcolor(color) | i
00e2c                 | _hg010b_spin2_setcursorcolor
00e2c                 | ' 
00e2c                 | ' cursorcolor:=color
00e2c     0B 00 00 FF 
00e30     C2 62 06 F1 | 	add	objptr, ##5826
00e34     31 91 62 FC | 	wrlong	arg01, objptr
00e38                 | ' repeat i from 0 to (8*cursorshape)-1
00e38     00 90 06 F6 | 	mov	arg01, #0
00e3c     04 62 06 F1 | 	add	objptr, #4
00e40     31 7D 02 FB | 	rdlong	_var01, objptr
00e44     03 7C 66 F0 | 	shl	_var01, #3
00e48     01 7C 86 F1 | 	sub	_var01, #1
00e4c     00 7C 56 F2 | 	cmps	_var01, #0 wc
00e50     01 7E 86 F6 | 	negc	_var02, #1
00e54     3F 81 02 F6 | 	mov	_var03, _var02
00e58     3F 7D 02 F1 | 	add	_var01, _var02
00e5c     0A 00 00 FF 
00e60     90 62 86 F1 | 	sub	objptr, ##5264
00e64     D7 0C 48 FB | 	callpa	#(@LR__0021-@LR__0020)>>2,fcache_load_ptr_
00e68                 | LR__0020
00e68                 | '   cursor[i]:=0
00e68     48 7F 02 F6 | 	mov	_var02, arg01
00e6c     31 7F 02 F1 | 	add	_var02, objptr
00e70     3F 01 48 FC | 	wrbyte	#0, _var02
00e74     40 91 02 F1 | 	add	arg01, _var03
00e78     3E 91 0A F2 | 	cmp	arg01, _var01 wz
00e7c     E8 FF 9F 5D |  if_ne	jmp	#LR__0020
00e80                 | LR__0021
00e80                 | ' repeat i from 8*cursorshape to 127
00e80     0A 00 00 FF 
00e84     90 62 06 F1 | 	add	objptr, ##5264
00e88     31 81 02 FB | 	rdlong	_var03, objptr
00e8c     40 91 02 F6 | 	mov	arg01, _var03
00e90     03 90 66 F0 | 	shl	arg01, #3
00e94     0B 00 00 FF 
00e98     C6 62 86 F1 | 	sub	objptr, ##5830
00e9c     03 80 66 F0 | 	shl	_var03, #3
00ea0     80 80 56 F2 | 	cmps	_var03, #128 wc
00ea4     01 7E A6 F6 | 	negnc	_var02, #1
00ea8     7F 7C 06 F6 | 	mov	_var01, #127
00eac     3F 7D 02 F1 | 	add	_var01, _var02
00eb0     D7 1A 48 FB | 	callpa	#(@LR__0023-@LR__0022)>>2,fcache_load_ptr_
00eb4                 | LR__0022
00eb4                 | '   cursor[i]:=cursorcolor
00eb4     48 81 02 F6 | 	mov	_var03, arg01
00eb8     01 00 00 FF 
00ebc     36 62 06 F1 | 	add	objptr, ##566
00ec0     31 81 02 F1 | 	add	_var03, objptr
00ec4     0A 00 00 FF 
00ec8     8C 62 06 F1 | 	add	objptr, ##5260
00ecc     31 83 02 FB | 	rdlong	_var04, objptr
00ed0     0B 00 00 FF 
00ed4     C2 62 86 F1 | 	sub	objptr, ##5826
00ed8     40 83 42 FC | 	wrbyte	_var04, _var03
00edc     3F 91 02 F1 | 	add	arg01, _var02
00ee0     3E 91 0A F2 | 	cmp	arg01, _var01 wz
00ee4     CC FF 9F 5D |  if_ne	jmp	#LR__0022
00ee8                 | LR__0023
00ee8                 | _hg010b_spin2_setcursorcolor_ret
00ee8     2D 00 64 FD | 	ret
00eec                 | 
00eec                 | '   
00eec                 | '   
00eec                 | '   
00eec                 | ' pub setmode() | i', 'xzoom, yzoom, azoom
00eec                 | _hg010b_spin2_setmode
00eec     02 CA 05 F6 | 	mov	COUNT_, #2
00ef0     E8 00 A0 FD | 	call	#pushregs_
00ef4                 | ' 
00ef4                 | ' 
00ef4                 | ' dl_ptr:=@emptydl[0]
00ef4     01 00 00 FF 
00ef8     1D 62 06 F1 | 	add	objptr, ##541
00efc     31 99 02 F6 | 	mov	arg05, objptr
00f00     FD 63 86 F1 | 	sub	objptr, #509
00f04     31 99 62 FC | 	wrlong	arg05, objptr
00f08                 | ' 
00f08                 | ' if cog>0 
00f08     10 62 06 F1 | 	add	objptr, #16
00f0c     31 99 02 FB | 	rdlong	arg05, objptr
00f10     30 62 86 F1 | 	sub	objptr, #48
00f14     01 98 56 F2 | 	cmps	arg05, #1 wc
00f18                 | '    waitvbl(1)						    	' if the driver is active, wait for vblank to set the new mode and DL	
00f18     01 90 06 36 |  if_ae	mov	arg01, #1
00f1c     40 08 B0 3D |  if_ae	call	#_hg010b_spin2_waitvbl
00f20                 | ' xres:=1024
00f20     01 00 00 FF 
00f24     26 62 06 F1 | 	add	objptr, ##550
00f28     02 00 80 FF 
00f2c     31 01 68 FC | 	wrlong	##1024, objptr
00f30                 | ' yres:=600
00f30     04 62 06 F1 | 	add	objptr, #4
00f34     01 00 80 FF 
00f38     31 B1 68 FC | 	wrlong	##600, objptr
00f3c                 | ' ppl:=(timings[3])
00f3c     1C 00 00 FF 
00f40     4C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14412
00f44     36 99 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
00f48     51 63 86 F1 | 	sub	objptr, #337
00f4c     31 99 62 FC | 	wrlong	arg05, objptr
00f50                 | ' cpl:=timings[7]<<1                                      	' now cpl is longs per line
00f50     10 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, #16
00f54     36 A7 02 FB | 	rdlong	local01, ptr__hg010b_spin2_dat__
00f58     01 A6 66 F0 | 	shl	local01, #1
00f5c     80 62 86 F1 | 	sub	objptr, #128
00f60     31 A7 62 FC | 	wrlong	local01, objptr
00f64                 | ' cpl1:=cpl '' todo remove
00f64     04 62 06 F1 | 	add	objptr, #4
00f68     31 A7 62 FC | 	wrlong	local01, objptr
00f6c                 | ' palette_ptr:=@ataripalette				    	' use 256-colors palettr
00f6c     04 00 00 FF 
00f70     1C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##2076
00f74     41 62 86 F1 | 	sub	objptr, #65
00f78     31 6D 62 FC | 	wrlong	ptr__hg010b_spin2_dat__, objptr
00f7c                 | ' repeat i from 0 to 3
00f7c     00 A8 06 F6 | 	mov	local02, #0
00f80     04 00 00 FF 
00f84     00 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##2048
00f88     08 62 06 F1 | 	add	objptr, #8
00f8c     D7 20 48 FB | 	callpa	#(@LR__0031-@LR__0030)>>2,fcache_load_ptr_
00f90                 | LR__0030
00f90                 | '   timings[i]:=timings[i]+hdmibase<<17+ timingsxxt          	' add a streamer config (imm->pins) to horizontal timings 
00f90     54 A7 02 F6 | 	mov	local01, local02
00f94     02 A6 66 F0 | 	shl	local01, #2
00f98     36 A7 02 F1 | 	add	local01, ptr__hg010b_spin2_dat__
00f9c     31 99 02 FB | 	rdlong	arg05, objptr
00fa0     11 98 66 F0 | 	shl	arg05, #17
00fa4     53 A7 02 FB | 	rdlong	local01, local01
00fa8     4C A7 02 F1 | 	add	local01, arg05
00fac     80 40 38 FF 
00fb0     00 A6 06 F1 | 	add	local01, ##1887502336
00fb4     54 99 02 F6 | 	mov	arg05, local02
00fb8     02 98 66 F0 | 	shl	arg05, #2
00fbc     36 99 02 F1 | 	add	arg05, ptr__hg010b_spin2_dat__
00fc0     4C A7 62 FC | 	wrlong	local01, arg05
00fc4     01 A8 06 F1 | 	add	local02, #1
00fc8     04 A8 56 F2 | 	cmps	local02, #4 wc
00fcc     C0 FF 9F CD |  if_b	jmp	#LR__0030
00fd0                 | LR__0031
00fd0     24 62 86 F1 | 	sub	objptr, #36
00fd4     1C 00 00 FF 
00fd8     40 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14400
00fdc                 | ' 'clkfreq:=timings[9]					    	' set the clock frequency for the mode
00fdc                 | ' 'hubset(timings[10])
00fdc                 | ' waitms(1)                                                   	' wait for stabilization
00fdc     01 90 06 F6 | 	mov	arg01, #1
00fe0     B8 1E B0 FD | 	call	#__system___waitms
00fe4     1C 00 00 FF 
00fe8     6C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14444
00fec     36 A9 02 FB | 	rdlong	local02, ptr__hg010b_spin2_dat__
00ff0     61 62 06 F1 | 	add	objptr, #97
00ff4     31 A9 62 FC | 	wrlong	local02, objptr
00ff8     54 A7 52 F6 | 	abs	local01, local02 wc
00ffc     04 A6 46 F0 | 	shr	local01, #4
01000     53 A7 82 F6 | 	negc	local01, local01
01004     9C 62 06 F1 | 	add	objptr, #156
01008     31 A7 62 FC | 	wrlong	local01, objptr
0100c     A4 62 86 F1 | 	sub	objptr, #164
01010     31 A9 02 FB | 	rdlong	local02, objptr
01014     08 62 06 F1 | 	add	objptr, #8
01018     31 A7 02 FB | 	rdlong	local01, objptr
0101c     53 A9 02 FD | 	qmul	local02, local01
01020                 | ' lines:=timings[11]
01020                 | ' t_lines:=lines/16
01020                 | ' buflen:=cpl*lines						' framebuffer length in longs
01020     29 62 86 F1 | 	sub	objptr, #41
01024     19 A6 C6 F9 | 	decod	local01, #25
01028     10 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, #16
0102c     18 A8 62 FD | 	getqx	local02
01030     31 A9 62 FC | 	wrlong	local02, objptr
01034     38 62 86 F1 | 	sub	objptr, #56
01038     02 A8 66 F0 | 	shl	local02, #2
0103c     54 A7 82 F1 | 	sub	local01, local02
01040     31 A7 62 FC | 	wrlong	local01, objptr
01044     FD 62 06 F1 | 	add	objptr, #253
01048     31 A9 02 FB | 	rdlong	local02, objptr
0104c     36 99 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
01050     4C A9 02 FD | 	qmul	local02, arg05
01054                 | ' buf_ptr:=$2000000-4*buflen                          	     	' todo: get a PSRAM real himem 
01054                 | ' textbuf_ptr:=buf_ptr-t_lines*timings[7]
01054     F9 62 86 F1 | 	sub	objptr, #249
01058                 | ' mode_ptr:=@timings						' set pointers to timings
01058     1C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, #28
0105c                 | ' graphmode:=1024+512+192+48							' det global variable
0105c                 | ' makedl(graphmode)							' make a DL for the mode
0105c     03 00 00 FF 
01060     F0 90 06 F6 | 	mov	arg01, ##1776
01064     18 A8 62 FD | 	getqx	local02
01068     54 A7 82 F1 | 	sub	local01, local02
0106c     31 A7 62 FC | 	wrlong	local01, objptr
01070     14 62 06 F1 | 	add	objptr, #20
01074     31 6D 62 FC | 	wrlong	ptr__hg010b_spin2_dat__, objptr
01078     79 62 06 F1 | 	add	objptr, #121
0107c     03 00 80 FF 
01080     31 E1 69 FC | 	wrlong	##1776, objptr
01084     91 62 86 F1 | 	sub	objptr, #145
01088     1C 00 00 FF 
0108c     40 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14400
01090     E0 00 B0 FD | 	call	#_hg010b_spin2_makedl
01094                 | ' s_buf_ptr:=buf_ptr						' secondary copies of main framebuffer parameters 
01094     31 A7 02 FB | 	rdlong	local01, objptr
01098     DD 62 06 F1 | 	add	objptr, #221
0109c     31 A7 62 FC | 	wrlong	local01, objptr
010a0                 | ' s_font_ptr:=font_ptr
010a0     D5 62 86 F1 | 	sub	objptr, #213
010a4     31 A7 02 FB | 	rdlong	local01, objptr
010a8     D9 62 06 F1 | 	add	objptr, #217
010ac     31 A7 62 FC | 	wrlong	local01, objptr
010b0                 | ' s_lines:=lines
010b0     80 62 86 F1 | 	sub	objptr, #128
010b4     31 A7 02 FB | 	rdlong	local01, objptr
010b8     84 62 06 F1 | 	add	objptr, #132
010bc     31 A7 62 FC | 	wrlong	local01, objptr
010c0                 | ' s_buflen:=buflen
010c0     AD 62 86 F1 | 	sub	objptr, #173
010c4     31 A7 02 FB | 	rdlong	local01, objptr
010c8     B5 62 06 F1 | 	add	objptr, #181
010cc     31 A7 62 FC | 	wrlong	local01, objptr
010d0                 | ' s_cpl:=cpl
010d0     94 62 86 F1 | 	sub	objptr, #148
010d4     31 A7 02 FB | 	rdlong	local01, objptr
010d8     90 62 06 F1 | 	add	objptr, #144
010dc     31 A7 62 FC | 	wrlong	local01, objptr
010e0                 | ' s_cpl1:=cpl
010e0     90 62 86 F1 | 	sub	objptr, #144
010e4     31 A7 02 FB | 	rdlong	local01, objptr
010e8     98 62 06 F1 | 	add	objptr, #152
010ec     31 A7 62 FC | 	wrlong	local01, objptr
010f0                 | ' st_lines:=t_lines
010f0     0C 62 06 F1 | 	add	objptr, #12
010f4     31 A7 02 FB | 	rdlong	local01, objptr
010f8     04 62 06 F1 | 	add	objptr, #4
010fc     31 A7 62 FC | 	wrlong	local01, objptr
01100                 | ' ppl:=ppl/xzoom  
01100     28 62 86 F1 | 	sub	objptr, #40
01104     31 F9 02 FB | 	rdlong	muldiva_, objptr
01108     2C 62 06 F1 | 	add	objptr, #44
0110c     31 FB 02 FB | 	rdlong	muldivb_, objptr
01110     05 63 86 F1 | 	sub	objptr, #261
01114     FA 00 A0 FD | 	call	#divide_
01118     D9 62 06 F1 | 	add	objptr, #217
0111c     31 FB 62 FC | 	wrlong	muldivb_, objptr
01120                 | ' s_ppl:=ppl
01120     1C 62 06 F1 | 	add	objptr, #28
01124     31 FB 62 FC | 	wrlong	muldivb_, objptr
01128     F5 62 86 F1 | 	sub	objptr, #245
0112c                 | ' waitms(20)							' wait 
0112c     14 90 06 F6 | 	mov	arg01, #20
01130     68 1D B0 FD | 	call	#__system___waitms
01134                 | ' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
01134     04 62 06 F1 | 	add	objptr, #4
01138     31 91 02 FB | 	rdlong	arg01, objptr
0113c     04 62 86 F1 | 	sub	objptr, #4
01140     31 95 02 FB | 	rdlong	arg03, objptr
01144     48 95 82 F1 | 	sub	arg03, arg01
01148     20 92 06 F6 | 	mov	arg02, #32
0114c     00 96 06 F6 | 	mov	arg04, #0
01150     01 98 06 F6 | 	mov	arg05, #1
01154     0B 00 00 FF 
01158     CC 62 06 F1 | 	add	objptr, ##5836
0115c     30 0F B0 FD | 	call	#_psram_spin2_fill
01160     0B 00 00 FF 
01164     CC 62 86 F1 | 	sub	objptr, ##5836
01168     E7 F0 03 F6 | 	mov	ptra, fp
0116c     F2 00 A0 FD | 	call	#popregs_
01170                 | _hg010b_spin2_setmode_ret
01170     2D 00 64 FD | 	ret
01174                 | 
01174                 | ' 
01174                 | ' '****************************************************************************************************************
01174                 | ' '                                                                                                             	*
01174                 | ' '  Make a display list for simple standard modes                                             	rev.20220319    *
01174                 | ' '                                                                                                             	*
01174                 | ' '****************************************************************************************************************
01174                 | ' 
01174                 | ' pub makedl(mode) |i,vzoom,border,psbuf,lines2
01174                 | _hg010b_spin2_makedl
01174                 | ' 
01174                 | ' psbuf:=$80000-s_debug-1024                                                     ' HUB line buffer on the top of HUB RAM (-16 kB if debug enabled)
01174                 | ' vzoom:=1<<((mode>>2) & 3)                                                      ' real vzoom from mode#
01174                 | ' repeat i from 0 to 11                                                           ' clear DL
01174     00 7C 06 F6 | 	mov	_var01, #0
01178     ED 63 06 F1 | 	add	objptr, #493
0117c     D7 0E 48 FB | 	callpa	#(@LR__0041-@LR__0040)>>2,fcache_load_ptr_
01180                 | LR__0040
01180                 | '   displaylist[i]:=0 
01180     3E 7F 02 F6 | 	mov	_var02, _var01
01184     02 7E 66 F0 | 	shl	_var02, #2
01188     31 7F 02 F1 | 	add	_var02, objptr
0118c     3F 01 68 FC | 	wrlong	#0, _var02
01190     01 7C 06 F1 | 	add	_var01, #1
01194     0C 7C 56 F2 | 	cmps	_var01, #12 wc
01198     E4 FF 9F CD |  if_b	jmp	#LR__0040
0119c                 | LR__0041
0119c                 | '                         ' 
0119c                 | ' displaylist[0]:=lines<<20+(0)<<16+%0001+ (0+(cpl1<<2)) <<4             
0119c     8C 63 86 F1 | 	sub	objptr, #396
011a0     31 7F 02 FB | 	rdlong	_var02, objptr
011a4     14 7E 66 F0 | 	shl	_var02, #20
011a8     01 7E 06 F1 | 	add	_var02, #1
011ac     04 62 86 F1 | 	sub	objptr, #4
011b0     31 7D 02 FB | 	rdlong	_var01, objptr
011b4     06 7C 66 F0 | 	shl	_var01, #6
011b8     3E 7F 02 F1 | 	add	_var02, _var01
011bc     90 63 06 F1 | 	add	objptr, #400
011c0     31 7F 62 FC | 	wrlong	_var02, objptr
011c4     ED 63 86 F1 | 	sub	objptr, #493
011c8                 | ' displaylist[1]:=buf_ptr<<4+%10  
011c8     31 7F 02 FB | 	rdlong	_var02, objptr
011cc     04 7E 66 F0 | 	shl	_var02, #4
011d0     02 7E 06 F1 | 	add	_var02, #2
011d4     F1 63 06 F1 | 	add	objptr, #497
011d8     31 7F 62 FC | 	wrlong	_var02, objptr
011dc                 | ' dl_ptr:=@displaylist[0] 						      ' tell the driver where to find the DL
011dc     04 62 86 F1 | 	sub	objptr, #4
011e0     31 7F 02 F6 | 	mov	_var02, objptr
011e4     CD 63 86 F1 | 	sub	objptr, #461
011e8     31 7F 62 FC | 	wrlong	_var02, objptr
011ec     20 62 86 F1 | 	sub	objptr, #32
011f0                 | _hg010b_spin2_makedl_ret
011f0     2D 00 64 FD | 	ret
011f4                 | 
011f4                 | ' 
011f4                 | ' 
011f4                 | ' '****************************************************************************************************************
011f4                 | ' '                                                                        					*
011f4                 | ' '  Graphic primitives                                                    					*
011f4                 | ' '                                                                        					*
011f4                 | ' '****************************************************************************************************************
011f4                 | ' 
011f4                 | ' pub setspriteptr(num,ptr)
011f4                 | _hg010b_spin2_setspriteptr
011f4                 | ' long[@spr1ptr+12*num]:=ptr
011f4     31 7D 02 F6 | 	mov	_var01, objptr
011f8     11 7D 06 F1 | 	add	_var01, #273
011fc     48 7F 02 F6 | 	mov	_var02, arg01
01200     01 7E 66 F0 | 	shl	_var02, #1
01204     48 7F 02 F1 | 	add	_var02, arg01
01208     02 7E 66 F0 | 	shl	_var02, #2
0120c     3F 7D 02 F1 | 	add	_var01, _var02
01210     3E 93 62 FC | 	wrlong	arg02, _var01
01214                 | _hg010b_spin2_setspriteptr_ret
01214     2D 00 64 FD | 	ret
01218                 | 
01218                 | ' 
01218                 | ' pub setspritepos(num,x,y)
01218                 | _hg010b_spin2_setspritepos
01218                 | ' if y>601
01218     01 00 00 FF 
0121c     5A 94 56 F2 | 	cmps	arg03, ##602 wc
01220                 | '   y:=601
01220     01 00 00 3F 
01224     59 94 06 36 |  if_ae	mov	arg03, ##601
01228                 | ' if x>1024
01228     02 00 00 FF 
0122c     01 92 56 F2 | 	cmps	arg02, ##1025 wc
01230                 | '   x:=1024
01230     0A 92 C6 39 |  if_ae	decod	arg02, #10
01234                 | ' word[@spr1ptr+12*num+4]:=x
01234     11 63 06 F1 | 	add	objptr, #273
01238     31 7D 02 F6 | 	mov	_var01, objptr
0123c     48 7F 02 F6 | 	mov	_var02, arg01
01240     01 7E 66 F0 | 	shl	_var02, #1
01244     48 7F 02 F1 | 	add	_var02, arg01
01248     02 7E 66 F0 | 	shl	_var02, #2
0124c     3F 7D 02 F1 | 	add	_var01, _var02
01250     04 7C 06 F1 | 	add	_var01, #4
01254     3E 93 52 FC | 	wrword	arg02, _var01
01258                 | ' word[@spr1ptr+12*num+6]:=y
01258     31 7D 02 F6 | 	mov	_var01, objptr
0125c     48 7F 02 F6 | 	mov	_var02, arg01
01260     01 7E 66 F0 | 	shl	_var02, #1
01264     48 7F 02 F1 | 	add	_var02, arg01
01268     02 7E 66 F0 | 	shl	_var02, #2
0126c     3F 7D 02 F1 | 	add	_var01, _var02
01270     06 7C 06 F1 | 	add	_var01, #6
01274     3E 95 52 FC | 	wrword	arg03, _var01
01278     11 63 86 F1 | 	sub	objptr, #273
0127c                 | _hg010b_spin2_setspritepos_ret
0127c     2D 00 64 FD | 	ret
01280                 | 
01280                 | ' 
01280                 | ' pub setspritesize(num,w,h)
01280                 | _hg010b_spin2_setspritesize
01280                 | ' word[@spr1ptr+12*num+8]:=w
01280     11 63 06 F1 | 	add	objptr, #273
01284     31 7D 02 F6 | 	mov	_var01, objptr
01288     48 7F 02 F6 | 	mov	_var02, arg01
0128c     01 7E 66 F0 | 	shl	_var02, #1
01290     48 7F 02 F1 | 	add	_var02, arg01
01294     02 7E 66 F0 | 	shl	_var02, #2
01298     3F 7D 02 F1 | 	add	_var01, _var02
0129c     08 7C 06 F1 | 	add	_var01, #8
012a0     3E 93 52 FC | 	wrword	arg02, _var01
012a4                 | ' word[@spr1ptr+12*num+10]:=h
012a4     31 7D 02 F6 | 	mov	_var01, objptr
012a8     48 7F 02 F6 | 	mov	_var02, arg01
012ac     01 7E 66 F0 | 	shl	_var02, #1
012b0     48 7F 02 F1 | 	add	_var02, arg01
012b4     02 7E 66 F0 | 	shl	_var02, #2
012b8     3F 7D 02 F1 | 	add	_var01, _var02
012bc     0A 7C 06 F1 | 	add	_var01, #10
012c0     3E 95 52 FC | 	wrword	arg03, _var01
012c4     11 63 86 F1 | 	sub	objptr, #273
012c8                 | _hg010b_spin2_setspritesize_ret
012c8     2D 00 64 FD | 	ret
012cc                 | 
012cc                 | ' 
012cc                 | ' 
012cc                 | ' ''---------- putpixel - put a pixel on the screen - a mother of all graphic functions ---------------------------
012cc                 | ' 
012cc                 | ' 
012cc                 | ' pub putpixel(x,y,c)
012cc                 | _hg010b_spin2_putpixel
012cc     04 CA 05 F6 | 	mov	COUNT_, #4
012d0     E8 00 A0 FD | 	call	#pushregs_
012d4     48 A7 02 F6 | 	mov	local01, arg01
012d8                 | ' 
012d8                 | ' if ((x>=0) & (x<4*s_cpl) & (y>=0) & (y<s_lines))
012d8     00 A8 06 F6 | 	mov	local02, #0
012dc     00 A6 56 F2 | 	cmps	local01, #0 wc
012e0     01 A8 66 36 |  if_ae	neg	local02, #1
012e4     E9 62 06 F1 | 	add	objptr, #233
012e8     31 99 02 FB | 	rdlong	arg05, objptr
012ec     02 98 66 F0 | 	shl	arg05, #2
012f0     4C A7 52 F2 | 	cmps	local01, arg05 wc
012f4     55 AB A2 F1 | 	subx	local03, local03
012f8     55 A9 02 F5 | 	and	local02, local03
012fc     00 AA 06 F6 | 	mov	local03, #0
01300     00 92 56 F2 | 	cmps	arg02, #0 wc
01304     01 AA 66 36 |  if_ae	neg	local03, #1
01308     55 A9 02 F5 | 	and	local02, local03
0130c     04 62 86 F1 | 	sub	objptr, #4
01310     31 AB 02 FB | 	rdlong	local03, objptr
01314     E5 62 86 F1 | 	sub	objptr, #229
01318     55 93 52 F2 | 	cmps	arg02, local03 wc
0131c     56 AD A2 F1 | 	subx	local04, local04
01320     56 A9 CA F7 | 	test	local02, local04 wz
01324     48 00 90 AD |  if_e	jmp	#LR__0050
01328     DD 62 06 F1 | 	add	objptr, #221
0132c     31 91 02 FB | 	rdlong	arg01, objptr
01330     14 62 06 F1 | 	add	objptr, #20
01334     31 AD 02 FB | 	rdlong	local04, objptr
01338     02 AC 66 F0 | 	shl	local04, #2
0133c     49 AD 02 FD | 	qmul	local04, arg02
01340                 | '   ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
01340     4A 93 02 F6 | 	mov	arg02, arg03
01344     01 94 06 F6 | 	mov	arg03, #1
01348     00 96 06 F6 | 	mov	arg04, #0
0134c     01 98 06 F6 | 	mov	arg05, #1
01350     0A 00 00 FF 
01354     DB 63 06 F1 | 	add	objptr, ##5595
01358     18 AC 62 FD | 	getqx	local04
0135c     53 AD 02 F1 | 	add	local04, local01
01360     56 91 02 F1 | 	add	arg01, local04
01364     28 0D B0 FD | 	call	#_psram_spin2_fill
01368     0B 00 00 FF 
0136c     CC 62 86 F1 | 	sub	objptr, ##5836
01370                 | LR__0050
01370     E7 F0 03 F6 | 	mov	ptra, fp
01374     F2 00 A0 FD | 	call	#popregs_
01378                 | _hg010b_spin2_putpixel_ret
01378     2D 00 64 FD | 	ret
0137c                 | 
0137c                 | '   
0137c                 | ' '----------- A line drawing family. BASIC doesn't like the name, so it is named "draw" and aliased  -----------------------------
0137c                 | ' 
0137c                 | ' pub fastline(x1,x2,y,c)									' a fast 8bpp horizontal line
0137c                 | _hg010b_spin2_fastline
0137c     02 CA 05 F6 | 	mov	COUNT_, #2
01380     E8 00 A0 FD | 	call	#pushregs_
01384     48 A7 02 F6 | 	mov	local01, arg01
01388     49 A9 02 F6 | 	mov	local02, arg02
0138c                 | ' 
0138c                 | ' if y<0 || y>=yres || (x1<0 && x2<0) || (x1>xres && x2>xres)
0138c     00 94 56 F2 | 	cmps	arg03, #0 wc
01390     F4 00 90 CD |  if_b	jmp	#LR__0060
01394     01 00 00 FF 
01398     2A 62 06 F1 | 	add	objptr, ##554
0139c     31 99 02 FB | 	rdlong	arg05, objptr
013a0     01 00 00 FF 
013a4     2A 62 86 F1 | 	sub	objptr, ##554
013a8     4C 95 52 F2 | 	cmps	arg03, arg05 wc
013ac     D8 00 90 3D |  if_ae	jmp	#LR__0060
013b0     00 A6 56 F2 | 	cmps	local01, #0 wc
013b4     00 A8 56 C2 |  if_b	cmps	local02, #0 wc
013b8     CC 00 90 CD |  if_b	jmp	#LR__0060
013bc     01 00 00 FF 
013c0     26 62 06 F1 | 	add	objptr, ##550
013c4     31 99 02 FB | 	rdlong	arg05, objptr
013c8     01 00 00 FF 
013cc     26 62 86 F1 | 	sub	objptr, ##550
013d0     4C A7 5A F2 | 	cmps	local01, arg05 wcz
013d4     01 00 00 1F 
013d8     26 62 06 11 |  if_a	add	objptr, ##550
013dc     31 91 02 1B |  if_a	rdlong	arg01, objptr
013e0     01 00 00 1F 
013e4     26 62 86 11 |  if_a	sub	objptr, ##550
013e8     48 A9 5A 12 |  if_a	cmps	local02, arg01 wcz
013ec                 | '   return
013ec     98 00 90 1D |  if_a	jmp	#LR__0060
013f0     54 A7 5A F2 | 	cmps	local01, local02 wcz
013f4     53 99 02 16 |  if_a	mov	arg05, local01
013f8     54 A7 02 16 |  if_a	mov	local01, local02
013fc     4C A9 02 16 |  if_a	mov	local02, arg05
01400     00 A6 56 F2 | 	cmps	local01, #0 wc
01404     00 A6 06 C6 |  if_b	mov	local01, #0
01408     01 00 00 FF 
0140c     26 62 06 F1 | 	add	objptr, ##550
01410     31 99 02 FB | 	rdlong	arg05, objptr
01414     01 00 00 FF 
01418     26 62 86 F1 | 	sub	objptr, ##550
0141c     4C A9 52 F2 | 	cmps	local02, arg05 wc
01420     01 00 00 3F 
01424     26 62 06 31 |  if_ae	add	objptr, ##550
01428     31 A9 02 3B |  if_ae	rdlong	local02, objptr
0142c     01 00 00 3F 
01430     26 62 86 31 |  if_ae	sub	objptr, ##550
01434     DD 62 06 F1 | 	add	objptr, #221
01438     31 91 02 FB | 	rdlong	arg01, objptr
0143c     14 62 06 F1 | 	add	objptr, #20
01440     31 99 02 FB | 	rdlong	arg05, objptr
01444     02 98 66 F0 | 	shl	arg05, #2
01448     4A 99 02 FD | 	qmul	arg05, arg03
0144c                 | ' if x1>x2
0144c                 | '   x1,x2:=x2,x1
0144c                 | ' if x1<0 
0144c                 | '   x1:=0
0144c                 | ' if x2>=xres
0144c                 | '   x2:=xres-1  
0144c     01 A8 86 31 |  if_ae	sub	local02, #1
01450                 | ' ram.fill(s_buf_ptr+(4*s_cpl1*y+x1),c,1+x2-x1,0,1)
01450     01 94 06 F6 | 	mov	arg03, #1
01454     54 95 02 F1 | 	add	arg03, local02
01458     53 95 82 F1 | 	sub	arg03, local01
0145c     4B 93 02 F6 | 	mov	arg02, arg04
01460     00 96 06 F6 | 	mov	arg04, #0
01464     01 98 06 F6 | 	mov	arg05, #1
01468     0A 00 00 FF 
0146c     DB 63 06 F1 | 	add	objptr, ##5595
01470     18 A8 62 FD | 	getqx	local02
01474     53 A9 02 F1 | 	add	local02, local01
01478     54 91 02 F1 | 	add	arg01, local02
0147c     10 0C B0 FD | 	call	#_psram_spin2_fill
01480     0B 00 00 FF 
01484     CC 62 86 F1 | 	sub	objptr, ##5836
01488                 | LR__0060
01488     E7 F0 03 F6 | 	mov	ptra, fp
0148c     F2 00 A0 FD | 	call	#popregs_
01490                 | _hg010b_spin2_fastline_ret
01490     2D 00 64 FD | 	ret
01494                 | 
01494                 | ' 
01494                 | ' '-- A box (a filled rectangle) ----------------------------------------
01494                 | ' 
01494                 | ' pub box(x1,y1,x2,y2,c) |yy
01494                 | _hg010b_spin2_box
01494     06 CA 05 F6 | 	mov	COUNT_, #6
01498     E8 00 A0 FD | 	call	#pushregs_
0149c     48 A7 02 F6 | 	mov	local01, arg01
014a0     49 A9 02 F6 | 	mov	local02, arg02
014a4     4A AB 02 F6 | 	mov	local03, arg03
014a8     4B AD 02 F6 | 	mov	local04, arg04
014ac     4C AF 02 F6 | 	mov	local05, arg05
014b0                 | ' 
014b0                 | ' repeat yy from y1 to y2
014b0     54 AD 52 F2 | 	cmps	local04, local02 wc
014b4     01 B0 86 F6 | 	negc	local06, #1
014b8     58 AD 02 F1 | 	add	local04, local06
014bc                 | LR__0070
014bc                 | '   fastline(x1,x2,yy,c)
014bc     53 91 02 F6 | 	mov	arg01, local01
014c0     55 93 02 F6 | 	mov	arg02, local03
014c4     57 97 02 F6 | 	mov	arg04, local05
014c8     54 95 02 F6 | 	mov	arg03, local02
014cc     AC FE BF FD | 	call	#_hg010b_spin2_fastline
014d0     58 A9 02 F1 | 	add	local02, local06
014d4     56 A9 0A F2 | 	cmp	local02, local04 wz
014d8     E0 FF 9F 5D |  if_ne	jmp	#LR__0070
014dc     E7 F0 03 F6 | 	mov	ptra, fp
014e0     F2 00 A0 FD | 	call	#popregs_
014e4                 | _hg010b_spin2_box_ret
014e4     2D 00 64 FD | 	ret
014e8                 | 
014e8                 | '     
014e8                 | ' '****************************************************************************************************************
014e8                 | ' '                                                                       		 			*
014e8                 | ' '  Characters on graphic screen                                          					*
014e8                 | ' '                                                                       					*
014e8                 | ' '****************************************************************************************************************    
014e8                 | ' 
014e8                 | ' ' ------  Transparent character
014e8                 | ' 
014e8                 | ' pub putcharxycf(x,y,achar,f) |xx, yy, bb
014e8                 | _hg010b_spin2_putcharxycf
014e8     07 CA 05 F6 | 	mov	COUNT_, #7
014ec     E8 00 A0 FD | 	call	#pushregs_
014f0     48 A7 02 F6 | 	mov	local01, arg01
014f4     49 A9 02 F6 | 	mov	local02, arg02
014f8     4A AB 02 F6 | 	mov	local03, arg03
014fc     4B AD 02 F6 | 	mov	local04, arg04
01500                 | ' 
01500                 | ' repeat yy from 0 to 15
01500     00 AE 06 F6 | 	mov	local05, #0
01504                 | LR__0080
01504                 | '   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
01504     36 97 02 F6 | 	mov	arg04, ptr__hg010b_spin2_dat__
01508     95 62 06 F1 | 	add	objptr, #149
0150c     31 95 02 FB | 	rdlong	arg03, objptr
01510     95 62 86 F1 | 	sub	objptr, #149
01514     0A 94 66 F0 | 	shl	arg03, #10
01518     4A 97 02 F1 | 	add	arg04, arg03
0151c     55 95 02 F6 | 	mov	arg03, local03
01520     04 94 66 F0 | 	shl	arg03, #4
01524     4A 97 02 F1 | 	add	arg04, arg03
01528     57 97 02 F1 | 	add	arg04, local05
0152c     4B B1 C2 FA | 	rdbyte	local06, arg04
01530                 | '   repeat xx from 0 to 7
01530     00 B2 06 F6 | 	mov	local07, #0
01534                 | LR__0081
01534                 | '     if (bb&(1<<xx))<>0
01534     59 97 C2 F9 | 	decod	arg04, local07
01538     4B B1 CA F7 | 	test	local06, arg04 wz
0153c     18 00 90 AD |  if_e	jmp	#LR__0082
01540                 | '       putpixel(xx+x,yy+y,f)
01540     59 91 02 F6 | 	mov	arg01, local07
01544     53 91 02 F1 | 	add	arg01, local01
01548     57 93 02 F6 | 	mov	arg02, local05
0154c     54 93 02 F1 | 	add	arg02, local02
01550     56 95 02 F6 | 	mov	arg03, local04
01554     74 FD BF FD | 	call	#_hg010b_spin2_putpixel
01558                 | LR__0082
01558     01 B2 06 F1 | 	add	local07, #1
0155c     08 B2 56 F2 | 	cmps	local07, #8 wc
01560     D0 FF 9F CD |  if_b	jmp	#LR__0081
01564     01 AE 06 F1 | 	add	local05, #1
01568     10 AE 56 F2 | 	cmps	local05, #16 wc
0156c     94 FF 9F CD |  if_b	jmp	#LR__0080
01570     E7 F0 03 F6 | 	mov	ptra, fp
01574     F2 00 A0 FD | 	call	#popregs_
01578                 | _hg010b_spin2_putcharxycf_ret
01578     2D 00 64 FD | 	ret
0157c                 | 
0157c                 | '       
0157c                 | ' pub putcharxycgf(x,y,achar,f,b) |xx, yy,bb,c1,c2
0157c                 | _hg010b_spin2_putcharxycgf
0157c                 | ' 
0157c                 | '  
0157c                 | ' repeat yy from 0 to 15
0157c     00 7C 06 F6 | 	mov	_var01, #0
01580     D7 8A 48 FB | 	callpa	#(@LR__0092-@LR__0090)>>2,fcache_load_ptr_
01584                 | LR__0090
01584                 | ' 
01584                 | '   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
01584     95 62 06 F1 | 	add	objptr, #149
01588     31 7F 02 FB | 	rdlong	_var02, objptr
0158c     0A 7E 66 F0 | 	shl	_var02, #10
01590     36 81 02 F6 | 	mov	_var03, ptr__hg010b_spin2_dat__
01594     3F 81 02 F1 | 	add	_var03, _var02
01598     4A 7F 02 F6 | 	mov	_var02, arg03
0159c     04 7E 66 F0 | 	shl	_var02, #4
015a0     3F 81 02 F1 | 	add	_var03, _var02
015a4     3E 81 02 F1 | 	add	_var03, _var01
015a8     40 81 C2 FA | 	rdbyte	_var03, _var03
015ac                 | '   asm
015ac     00 80 0E F4 | 	testb	_var03, #0 wz
015b0     4B 83 C2 A8 |  if_e	setbyte	_var04, arg04, #0
015b4     4C 83 C2 58 |  if_ne	setbyte	_var04, arg05, #0
015b8     01 80 0E F4 | 	testb	_var03, #1 wz
015bc     4B 83 CA A8 |  if_e	setbyte	_var04, arg04, #1
015c0     4C 83 CA 58 |  if_ne	setbyte	_var04, arg05, #1
015c4     02 80 0E F4 | 	testb	_var03, #2 wz
015c8     4B 83 D2 A8 |  if_e	setbyte	_var04, arg04, #2
015cc     4C 83 D2 58 |  if_ne	setbyte	_var04, arg05, #2
015d0     03 80 0E F4 | 	testb	_var03, #3 wz
015d4     4B 83 DA A8 |  if_e	setbyte	_var04, arg04, #3
015d8     4C 83 DA 58 |  if_ne	setbyte	_var04, arg05, #3
015dc     04 80 0E F4 | 	testb	_var03, #4 wz
015e0     4B 85 C2 A8 |  if_e	setbyte	_var05, arg04, #0
015e4     4C 85 C2 58 |  if_ne	setbyte	_var05, arg05, #0
015e8     05 80 0E F4 | 	testb	_var03, #5 wz
015ec     4B 85 CA A8 |  if_e	setbyte	_var05, arg04, #1
015f0     4C 85 CA 58 |  if_ne	setbyte	_var05, arg05, #1
015f4     06 80 0E F4 | 	testb	_var03, #6 wz
015f8     4B 85 D2 A8 |  if_e	setbyte	_var05, arg04, #2
015fc     4C 85 D2 58 |  if_ne	setbyte	_var05, arg05, #2
01600     07 80 0E F4 | 	testb	_var03, #7 wz
01604     4B 85 DA A8 |  if_e	setbyte	_var05, arg04, #3
01608     4C 85 DA 58 |  if_ne	setbyte	_var05, arg05, #3
0160c                 | '   
0160c                 | '   ccc[0]:=c1
0160c     99 63 06 F1 | 	add	objptr, #409
01610     31 83 62 FC | 	wrlong	_var04, objptr
01614                 | '   ccc[1]:=c2 
01614     04 62 06 F1 | 	add	objptr, #4
01618     31 85 62 FC | 	wrlong	_var05, objptr
0161c                 | '   long[mailbox0][2]:=8
0161c     49 62 86 F1 | 	sub	objptr, #73
01620     31 81 02 FB | 	rdlong	_var03, objptr
01624     08 80 06 F1 | 	add	_var03, #8
01628     40 11 68 FC | 	wrlong	#8, _var03
0162c                 | '   long[mailbox0][1]:=@ccc
0162c     31 81 02 F6 | 	mov	_var03, objptr
01630     45 80 06 F1 | 	add	_var03, #69
01634     31 7F 02 FB | 	rdlong	_var02, objptr
01638     04 7E 06 F1 | 	add	_var02, #4
0163c     3F 81 62 FC | 	wrlong	_var03, _var02
01640                 | '   long[mailbox0]:= s_buf_ptr+((y+yy)<<10+x<<2)+$f0000000   
01640     0C 63 86 F1 | 	sub	objptr, #268
01644     31 81 02 FB | 	rdlong	_var03, objptr
01648     49 7F 02 F6 | 	mov	_var02, arg02
0164c     3E 7F 02 F1 | 	add	_var02, _var01
01650     0A 7E 66 F0 | 	shl	_var02, #10
01654     48 87 02 F6 | 	mov	_var06, arg01
01658     02 86 66 F0 | 	shl	_var06, #2
0165c     43 7F 02 F1 | 	add	_var02, _var06
01660     3F 81 02 F1 | 	add	_var03, _var02
01664     00 00 78 FF 
01668     00 80 06 F1 | 	add	_var03, ##-268435456
0166c     0C 63 06 F1 | 	add	objptr, #268
01670     31 87 02 FB | 	rdlong	_var06, objptr
01674     43 81 62 FC | 	wrlong	_var03, _var06
01678                 | '   repeat
01678                 | LR__0091
01678     31 81 02 FB | 	rdlong	_var03, objptr
0167c     40 7F 02 FB | 	rdlong	_var02, _var03
01680     00 7E 56 F2 | 	cmps	_var02, #0 wc
01684     F0 FF 9F CD |  if_b	jmp	#LR__0091
01688     E9 63 86 F1 | 	sub	objptr, #489
0168c     01 7C 06 F1 | 	add	_var01, #1
01690     10 7C 56 F2 | 	cmps	_var01, #16 wc
01694     EC FE 9F CD |  if_b	jmp	#LR__0090
01698                 | LR__0092
01698                 | _hg010b_spin2_putcharxycgf_ret
01698     2D 00 64 FD | 	ret
0169c                 | 
0169c                 | '   
0169c                 | ' pub outtextxycf(x,y,text,f) | iii,c
0169c                 | _hg010b_spin2_outtextxycf
0169c     07 CA 05 F6 | 	mov	COUNT_, #7
016a0     E8 00 A0 FD | 	call	#pushregs_
016a4     48 A7 02 F6 | 	mov	local01, arg01
016a8     49 A9 02 F6 | 	mov	local02, arg02
016ac     4A AB 02 F6 | 	mov	local03, arg03
016b0     4B AD 02 F6 | 	mov	local04, arg04
016b4                 | ' 
016b4                 | ' repeat iii from 0 to strsize(text)-1
016b4     00 AE 06 F6 | 	mov	local05, #0
016b8     55 91 02 F6 | 	mov	arg01, local03
016bc     48 B1 02 F6 | 	mov	local06, arg01
016c0     D7 06 48 FB | 	callpa	#(@LR__0101-@LR__0100)>>2,fcache_load_ptr_
016c4                 | LR__0100
016c4     58 77 CA FA | 	rdbyte	result1, local06 wz
016c8     01 B0 06 51 |  if_ne	add	local06, #1
016cc     F4 FF 9F 5D |  if_ne	jmp	#LR__0100
016d0                 | LR__0101
016d0     48 B1 82 F1 | 	sub	local06, arg01
016d4     01 B0 86 F1 | 	sub	local06, #1
016d8     00 B0 56 F2 | 	cmps	local06, #0 wc
016dc     01 B2 86 F6 | 	negc	local07, #1
016e0     59 B1 02 F1 | 	add	local06, local07
016e4                 | LR__0102
016e4                 | '   putcharxycf(x+8*iii,y,byte[text+iii],f)
016e4     53 91 02 F6 | 	mov	arg01, local01
016e8     57 97 02 F6 | 	mov	arg04, local05
016ec     03 96 66 F0 | 	shl	arg04, #3
016f0     4B 91 02 F1 | 	add	arg01, arg04
016f4     54 93 02 F6 | 	mov	arg02, local02
016f8     55 97 02 F6 | 	mov	arg04, local03
016fc     57 97 02 F1 | 	add	arg04, local05
01700     4B 95 C2 FA | 	rdbyte	arg03, arg04
01704     56 97 02 F6 | 	mov	arg04, local04
01708     DC FD BF FD | 	call	#_hg010b_spin2_putcharxycf
0170c     59 AF 02 F1 | 	add	local05, local07
01710     58 AF 0A F2 | 	cmp	local05, local06 wz
01714     CC FF 9F 5D |  if_ne	jmp	#LR__0102
01718     E7 F0 03 F6 | 	mov	ptra, fp
0171c     F2 00 A0 FD | 	call	#popregs_
01720                 | _hg010b_spin2_outtextxycf_ret
01720     2D 00 64 FD | 	ret
01724                 | 
01724                 | ' 
01724                 | ' 
01724                 | ' '**********************************************************************r***
01724                 | ' '                                                                        *
01724                 | ' ' Font related functions                                                 *
01724                 | ' '                                                                        *
01724                 | ' '*************************************************************************
01724                 | ' 
01724                 | ' ''--------- Set a font offset. TODO: remove, use byte#1 instead
01724                 | ' 
01724                 | ' pub setfontfamily(afontnum)
01724                 | _hg010b_spin2_setfontfamily
01724                 | ' 
01724                 | ' font_family:=afontnum
01724     95 62 06 F1 | 	add	objptr, #149
01728     31 91 62 FC | 	wrlong	arg01, objptr
0172c     95 62 86 F1 | 	sub	objptr, #149
01730                 | ' 'if afontnum==8
01730                 | ' '  font_ptr:=@amiga_font
01730                 | ' 
01730                 | ' if afontnum==4
01730     04 90 0E F2 | 	cmp	arg01, #4 wz
01734                 | '   font_ptr:=@st_font
01734     36 7D 02 A6 |  if_e	mov	_var01, ptr__hg010b_spin2_dat__
01738     08 00 00 AF 
0173c     00 7C 06 A1 |  if_e	add	_var01, ##4096
01740     08 62 06 A1 |  if_e	add	objptr, #8
01744     31 7D 62 AC |  if_e	wrlong	_var01, objptr
01748     08 62 86 A1 |  if_e	sub	objptr, #8
0174c                 | ' if afontnum==0
0174c     00 90 0E F2 | 	cmp	arg01, #0 wz
01750                 | '   font_ptr:=@vga_font
01750     08 62 06 A1 |  if_e	add	objptr, #8
01754     31 6D 62 AC |  if_e	wrlong	ptr__hg010b_spin2_dat__, objptr
01758     08 62 86 A1 |  if_e	sub	objptr, #8
0175c                 | _hg010b_spin2_setfontfamily_ret
0175c     2D 00 64 FD | 	ret
01760                 | 
01760                 | ' 
01760                 | ' '*************************************************************************
01760                 | ' '                                                                        *
01760                 | ' '  VBlank functions                                                      *
01760                 | ' '                                                                        *
01760                 | ' '*************************************************************************
01760                 | ' 
01760                 | ' pub waitvbl(amount) | i
01760                 | _hg010b_spin2_waitvbl
01760     03 CA 05 F6 | 	mov	COUNT_, #3
01764     E8 00 A0 FD | 	call	#pushregs_
01768     48 A7 02 F6 | 	mov	local01, arg01
0176c                 | ' 
0176c                 | ' ''---------- Wait for start of vblank. Amount=delay in frames
0176c                 | ' 
0176c                 | ' repeat i from 1 to amount
0176c     01 A8 06 F6 | 	mov	local02, #1
01770     01 A6 56 F2 | 	cmps	local01, #1 wc
01774     01 AA 86 F6 | 	negc	local03, #1
01778     55 A7 02 F1 | 	add	local01, local03
0177c                 | LR__0110
0177c                 | '   repeat until vblank==0
0177c                 | LR__0111
0177c     49 62 06 F1 | 	add	objptr, #73
01780     31 91 0A FB | 	rdlong	arg01, objptr wz
01784     49 62 86 F1 | 	sub	objptr, #73
01788     0C 00 90 AD |  if_e	jmp	#LR__0112
0178c                 | '     waitus(100)
0178c     64 90 06 F6 | 	mov	arg01, #100
01790     74 17 B0 FD | 	call	#__system___waitus
01794     E4 FF 9F FD | 	jmp	#LR__0111
01798                 | LR__0112
01798                 | '   repeat until vblank==1
01798                 | LR__0113
01798     49 62 06 F1 | 	add	objptr, #73
0179c     31 91 02 FB | 	rdlong	arg01, objptr
017a0     49 62 86 F1 | 	sub	objptr, #73
017a4     01 90 0E F2 | 	cmp	arg01, #1 wz
017a8     0C 00 90 AD |  if_e	jmp	#LR__0114
017ac                 | '     waitus(100)
017ac     64 90 06 F6 | 	mov	arg01, #100
017b0     54 17 B0 FD | 	call	#__system___waitus
017b4     E0 FF 9F FD | 	jmp	#LR__0113
017b8                 | LR__0114
017b8     55 A9 02 F1 | 	add	local02, local03
017bc     53 A9 0A F2 | 	cmp	local02, local01 wz
017c0     B8 FF 9F 5D |  if_ne	jmp	#LR__0110
017c4     E7 F0 03 F6 | 	mov	ptra, fp
017c8     F2 00 A0 FD | 	call	#popregs_
017cc                 | _hg010b_spin2_waitvbl_ret
017cc     2D 00 64 FD | 	ret
017d0                 | 
017d0                 | ' 
017d0                 | ' 
017d0                 | ' pub cls(fc,bc)   :c,i
017d0                 | _hg010b_spin2_cls
017d0     02 CA 05 F6 | 	mov	COUNT_, #2
017d4     E8 00 A0 FD | 	call	#pushregs_
017d8     48 A7 02 F6 | 	mov	local01, arg01
017dc     49 A9 02 F6 | 	mov	local02, arg02
017e0                 | ' 
017e0                 | ' c:=bc
017e0                 | ' ram.fill(s_buf_ptr,c,4*buflen,0,1)  
017e0     DD 62 06 F1 | 	add	objptr, #221
017e4     31 91 02 FB | 	rdlong	arg01, objptr
017e8     A5 62 86 F1 | 	sub	objptr, #165
017ec     31 95 02 FB | 	rdlong	arg03, objptr
017f0     02 94 66 F0 | 	shl	arg03, #2
017f4     54 93 02 F6 | 	mov	arg02, local02
017f8     00 96 06 F6 | 	mov	arg04, #0
017fc     01 98 06 F6 | 	mov	arg05, #1
01800     0B 00 00 FF 
01804     94 62 06 F1 | 	add	objptr, ##5780
01808     84 08 B0 FD | 	call	#_psram_spin2_fill
0180c                 | ' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
0180c     0B 00 00 FF 
01810     C8 62 86 F1 | 	sub	objptr, ##5832
01814     31 91 02 FB | 	rdlong	arg01, objptr
01818     04 62 86 F1 | 	sub	objptr, #4
0181c     31 95 02 FB | 	rdlong	arg03, objptr
01820     48 95 82 F1 | 	sub	arg03, arg01
01824     20 92 06 F6 | 	mov	arg02, #32
01828     00 96 06 F6 | 	mov	arg04, #0
0182c     01 98 06 F6 | 	mov	arg05, #1
01830     0B 00 00 FF 
01834     CC 62 06 F1 | 	add	objptr, ##5836
01838     54 08 B0 FD | 	call	#_psram_spin2_fill
0183c                 | ' setwritecolors(fc,bc)
0183c                 | ' 
0183c                 | ' write_color:=ff
0183c     0B 00 00 FF 
01840     8B 62 86 F1 | 	sub	objptr, ##5771
01844     31 A7 62 FC | 	wrlong	local01, objptr
01848                 | ' write_background:=bb
01848     04 62 06 F1 | 	add	objptr, #4
0184c     31 A9 62 FC | 	wrlong	local02, objptr
01850                 | ' cursor_x:=0
01850     09 62 86 F1 | 	sub	objptr, #9
01854     31 01 58 FC | 	wrword	#0, objptr
01858                 | ' cursor_y:=0
01858     02 62 06 F1 | 	add	objptr, #2
0185c     31 01 48 FC | 	wrbyte	#0, objptr
01860                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )
01860     02 62 86 F1 | 	sub	objptr, #2
01864     31 93 E2 FA | 	rdword	arg02, objptr
01868     02 92 66 F0 | 	shl	arg02, #2
0186c     3C 62 86 F1 | 	sub	objptr, #60
01870     04 94 06 F6 | 	mov	arg03, #4
01874     11 90 06 F6 | 	mov	arg01, #17
01878     9C F9 BF FD | 	call	#_hg010b_spin2_setspritepos
0187c                 | ' setcursorcolor(fc)
0187c     53 91 02 F6 | 	mov	arg01, local01
01880     A8 F5 BF FD | 	call	#_hg010b_spin2_setcursorcolor
01884     54 77 02 F6 | 	mov	result1, local02
01888     00 78 06 F6 | 	mov	result2, #0
0188c     E7 F0 03 F6 | 	mov	ptra, fp
01890     F2 00 A0 FD | 	call	#popregs_
01894                 | _hg010b_spin2_cls_ret
01894     2D 00 64 FD | 	ret
01898                 | 
01898                 | ' 
01898                 | ' ''---------- Output a char at the cursor position, move the cursor 
01898                 | ' 
01898                 | ' pub putchar(achar) | c,x,y,l,newcpl
01898                 | _hg010b_spin2_putchar
01898     02 CA 05 F6 | 	mov	COUNT_, #2
0189c     E8 00 A0 FD | 	call	#pushregs_
018a0     48 A7 02 F6 | 	mov	local01, arg01
018a4                 | ' 
018a4                 | ' if achar==10
018a4     0A A6 0E F2 | 	cmp	local01, #10 wz
018a8                 | '   crlf()
018a8     B8 03 B0 AD |  if_e	call	#_hg010b_spin2_crlf
018ac                 | ' if achar==9
018ac     09 A6 0E F2 | 	cmp	local01, #9 wz
018b0     18 00 90 5D |  if_ne	jmp	#LR__0120
018b4                 | '   cursor_x:=(cursor_x& %11110000)+16
018b4     3C 62 06 F1 | 	add	objptr, #60
018b8     31 95 E2 FA | 	rdword	arg03, objptr
018bc     F0 94 06 F5 | 	and	arg03, #240
018c0     10 94 06 F1 | 	add	arg03, #16
018c4     31 95 52 FC | 	wrword	arg03, objptr
018c8     3C 62 86 F1 | 	sub	objptr, #60
018cc                 | LR__0120
018cc                 | '   
018cc                 | ' if (achar<>9) && (achar<>10) 
018cc     09 A6 0E F2 | 	cmp	local01, #9 wz
018d0     0A A6 0E 52 |  if_ne	cmp	local01, #10 wz
018d4     A8 00 90 AD |  if_e	jmp	#LR__0121
018d8                 | '   putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
018d8     3C 62 06 F1 | 	add	objptr, #60
018dc     31 91 E2 FA | 	rdword	arg01, objptr
018e0     02 62 06 F1 | 	add	objptr, #2
018e4     31 93 C2 FA | 	rdbyte	arg02, objptr
018e8     04 92 66 F0 | 	shl	arg02, #4
018ec     04 92 06 F1 | 	add	arg02, #4
018f0     03 62 06 F1 | 	add	objptr, #3
018f4     31 97 02 FB | 	rdlong	arg04, objptr
018f8     04 62 06 F1 | 	add	objptr, #4
018fc     31 99 02 FB | 	rdlong	arg05, objptr
01900     45 62 86 F1 | 	sub	objptr, #69
01904     53 95 02 F6 | 	mov	arg03, local01
01908     70 FC BF FD | 	call	#_hg010b_spin2_putcharxycgf
0190c     04 62 06 F1 | 	add	objptr, #4
01910     31 91 02 FB | 	rdlong	arg01, objptr
01914     1C 00 00 FF 
01918     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
0191c     36 95 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
01920     3A 62 06 F1 | 	add	objptr, #58
01924     31 99 C2 FA | 	rdbyte	arg05, objptr
01928     4C 95 02 FD | 	qmul	arg03, arg05
0192c                 | '   ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
0192c     1C 00 00 FF 
01930     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01934     02 62 86 F1 | 	sub	objptr, #2
01938     31 A9 E2 FA | 	rdword	local02, objptr
0193c     01 A8 46 F0 | 	shr	local02, #1
01940     53 93 02 F6 | 	mov	arg02, local01
01944     01 94 06 F6 | 	mov	arg03, #1
01948     00 96 06 F6 | 	mov	arg04, #0
0194c     01 98 06 F6 | 	mov	arg05, #1
01950     0B 00 00 FF 
01954     90 62 06 F1 | 	add	objptr, ##5776
01958     18 A6 62 FD | 	getqx	local01
0195c     54 A7 02 F1 | 	add	local01, local02
01960     53 91 02 F1 | 	add	arg01, local01
01964     28 07 B0 FD | 	call	#_psram_spin2_fill
01968                 | '   cursor_x+=2
01968     0B 00 00 FF 
0196c     90 62 86 F1 | 	sub	objptr, ##5776
01970     31 A9 E2 FA | 	rdword	local02, objptr
01974     02 A8 06 F1 | 	add	local02, #2
01978     31 A9 52 FC | 	wrword	local02, objptr
0197c     3C 62 86 F1 | 	sub	objptr, #60
01980                 | LR__0121
01980                 | ' 
01980                 | ' if cursor_x>=256
01980     3C 62 06 F1 | 	add	objptr, #60
01984     31 A9 E2 FA | 	rdword	local02, objptr
01988     3C 62 86 F1 | 	sub	objptr, #60
0198c     00 A9 56 F2 | 	cmps	local02, #256 wc
01990     64 00 90 CD |  if_b	jmp	#LR__0123
01994                 | '   cursor_x:=0
01994     3C 62 06 F1 | 	add	objptr, #60
01998     31 01 58 FC | 	wrword	#0, objptr
0199c                 | '   cursor_y+=1
0199c     02 62 06 F1 | 	add	objptr, #2
019a0     31 A9 C2 FA | 	rdbyte	local02, objptr
019a4     01 A8 06 F1 | 	add	local02, #1
019a8     31 A9 42 FC | 	wrbyte	local02, objptr
019ac                 | '   if cursor_y>st_lines-1
019ac     C3 62 06 F1 | 	add	objptr, #195
019b0     31 A9 02 FB | 	rdlong	local02, objptr
019b4     01 A8 86 F1 | 	sub	local02, #1
019b8     C3 62 86 F1 | 	sub	objptr, #195
019bc     31 95 C2 FA | 	rdbyte	arg03, objptr
019c0     3E 62 86 F1 | 	sub	objptr, #62
019c4     54 95 5A F2 | 	cmps	arg03, local02 wcz
019c8     2C 00 90 ED |  if_be	jmp	#LR__0122
019cc                 | '     scrollup2()
019cc     00 90 06 F6 | 	mov	arg01, #0
019d0     01 00 00 FF 
019d4     58 92 06 F6 | 	mov	arg02, ##600
019d8     10 94 06 F6 | 	mov	arg03, #16
019dc     4C 00 B0 FD | 	call	#_hg010b_spin2_scrollup2
019e0                 | '     cursor_y:=st_lines-1
019e0     01 63 06 F1 | 	add	objptr, #257
019e4     31 A9 02 FB | 	rdlong	local02, objptr
019e8     01 A8 86 F1 | 	sub	local02, #1
019ec     C3 62 86 F1 | 	sub	objptr, #195
019f0     31 A9 42 FC | 	wrbyte	local02, objptr
019f4     3E 62 86 F1 | 	sub	objptr, #62
019f8                 | LR__0122
019f8                 | LR__0123
019f8                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )
019f8     3C 62 06 F1 | 	add	objptr, #60
019fc     31 93 E2 FA | 	rdword	arg02, objptr
01a00     02 92 66 F0 | 	shl	arg02, #2
01a04     02 62 06 F1 | 	add	objptr, #2
01a08     31 95 C2 FA | 	rdbyte	arg03, objptr
01a0c     3E 62 86 F1 | 	sub	objptr, #62
01a10     04 94 66 F0 | 	shl	arg03, #4
01a14     04 94 06 F1 | 	add	arg03, #4
01a18     11 90 06 F6 | 	mov	arg01, #17
01a1c     F8 F7 BF FD | 	call	#_hg010b_spin2_setspritepos
01a20     E7 F0 03 F6 | 	mov	ptra, fp
01a24     F2 00 A0 FD | 	call	#popregs_
01a28                 | _hg010b_spin2_putchar_ret
01a28     2D 00 64 FD | 	ret
01a2c                 | 
01a2c                 | '    
01a2c                 | ' ' a version for text scrolling in Basic shifted 4 lines down
01a2c                 | ' 
01a2c                 | ' pub scrollup2(start=0, end=600 , amount=16) | i
01a2c                 | _hg010b_spin2_scrollup2
01a2c     03 CA 05 F6 | 	mov	COUNT_, #3
01a30     E8 00 A0 FD | 	call	#pushregs_
01a34                 | ' 	
01a34                 | ' repeat i from 4 to 579 
01a34     04 A6 06 F6 | 	mov	local01, #4
01a38                 | LR__0130
01a38     DD 62 06 F1 | 	add	objptr, #221
01a3c     31 93 02 FB | 	rdlong	arg02, objptr
01a40     53 99 02 F6 | 	mov	arg05, local01
01a44     10 98 06 F1 | 	add	arg05, #16
01a48     02 98 66 F0 | 	shl	arg05, #2
01a4c     14 62 06 F1 | 	add	objptr, #20
01a50     31 95 02 FB | 	rdlong	arg03, objptr
01a54     4A 99 02 FD | 	qmul	arg05, arg03
01a58                 | '   ram.read1($7E800, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
01a58     02 94 66 F0 | 	shl	arg03, #2
01a5c     F4 03 00 FF 
01a60     00 90 06 F6 | 	mov	arg01, ##518144
01a64     0A 00 00 FF 
01a68     DB 63 06 F1 | 	add	objptr, ##5595
01a6c     18 98 62 FD | 	getqx	arg05
01a70     4C 93 02 F1 | 	add	arg02, arg05
01a74     DC 04 B0 FD | 	call	#_psram_spin2_read1
01a78     0A 00 00 FF 
01a7c     EF 63 86 F1 | 	sub	objptr, ##5615
01a80     31 93 02 FB | 	rdlong	arg02, objptr
01a84     53 99 02 F6 | 	mov	arg05, local01
01a88     02 98 66 F0 | 	shl	arg05, #2
01a8c     14 62 06 F1 | 	add	objptr, #20
01a90     31 95 02 FB | 	rdlong	arg03, objptr
01a94     4A 99 02 FD | 	qmul	arg05, arg03
01a98                 | '   ram.write($7E800, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
01a98     02 94 66 F0 | 	shl	arg03, #2
01a9c     F4 03 00 FF 
01aa0     00 90 06 F6 | 	mov	arg01, ##518144
01aa4     0A 00 00 FF 
01aa8     DB 63 06 F1 | 	add	objptr, ##5595
01aac     18 98 62 FD | 	getqx	arg05
01ab0     4C 93 02 F1 | 	add	arg02, arg05
01ab4     38 05 B0 FD | 	call	#_psram_spin2_write
01ab8     0B 00 00 FF 
01abc     CC 62 86 F1 | 	sub	objptr, ##5836
01ac0     01 A6 06 F1 | 	add	local01, #1
01ac4     01 00 00 FF 
01ac8     44 A6 16 F2 | 	cmp	local01, ##580 wc
01acc     68 FF 9F CD |  if_b	jmp	#LR__0130
01ad0                 | ' 
01ad0                 | ' repeat i from 580 to 599
01ad0     01 00 00 FF 
01ad4     44 A6 06 F6 | 	mov	local01, ##580
01ad8                 | LR__0131
01ad8                 | '    fastline(0,1023,i,write_background)   
01ad8     45 62 06 F1 | 	add	objptr, #69
01adc     31 97 02 FB | 	rdlong	arg04, objptr
01ae0     45 62 86 F1 | 	sub	objptr, #69
01ae4     00 90 06 F6 | 	mov	arg01, #0
01ae8     09 92 CE F9 | 	bmask	arg02, #9
01aec     53 95 02 F6 | 	mov	arg03, local01
01af0     88 F8 BF FD | 	call	#_hg010b_spin2_fastline
01af4     01 A6 06 F1 | 	add	local01, #1
01af8     01 00 00 FF 
01afc     58 A6 16 F2 | 	cmp	local01, ##600 wc
01b00     D4 FF 9F CD |  if_b	jmp	#LR__0131
01b04                 | ' repeat i from 0 to 3
01b04     00 A6 06 F6 | 	mov	local01, #0
01b08                 | LR__0132
01b08                 | '    fastline(0,1023,i,write_background)      
01b08     45 62 06 F1 | 	add	objptr, #69
01b0c     31 97 02 FB | 	rdlong	arg04, objptr
01b10     45 62 86 F1 | 	sub	objptr, #69
01b14     00 90 06 F6 | 	mov	arg01, #0
01b18     09 92 CE F9 | 	bmask	arg02, #9
01b1c     53 95 02 F6 | 	mov	arg03, local01
01b20     58 F8 BF FD | 	call	#_hg010b_spin2_fastline
01b24     01 A6 06 F1 | 	add	local01, #1
01b28     04 A6 56 F2 | 	cmps	local01, #4 wc
01b2c     D8 FF 9F CD |  if_b	jmp	#LR__0132
01b30                 | ' 
01b30                 | ' repeat i from 0 to 35
01b30     00 A6 06 F6 | 	mov	local01, #0
01b34                 | LR__0133
01b34     53 99 02 F6 | 	mov	arg05, local01
01b38     01 98 06 F1 | 	add	arg05, #1
01b3c     1C 00 00 FF 
01b40     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01b44     36 95 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
01b48     4A 99 02 FD | 	qmul	arg05, arg03
01b4c                 | '   ram.read1($7E800, textbuf_ptr+(i+1)*timings[7], timings[7])
01b4c     04 62 06 F1 | 	add	objptr, #4
01b50     31 93 02 FB | 	rdlong	arg02, objptr
01b54     1C 00 00 FF 
01b58     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01b5c     F4 03 00 FF 
01b60     00 90 06 F6 | 	mov	arg01, ##518144
01b64     0B 00 00 FF 
01b68     C8 62 06 F1 | 	add	objptr, ##5832
01b6c     18 98 62 FD | 	getqx	arg05
01b70     4C 93 02 F1 | 	add	arg02, arg05
01b74     DC 03 B0 FD | 	call	#_psram_spin2_read1
01b78     1C 00 00 FF 
01b7c     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01b80     36 95 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
01b84     4A A7 02 FD | 	qmul	local01, arg03
01b88                 | '   ram.write($7E800, textbuf_ptr+i*timings[7], timings[7])
01b88     0B 00 00 FF 
01b8c     C8 62 86 F1 | 	sub	objptr, ##5832
01b90     31 93 02 FB | 	rdlong	arg02, objptr
01b94     1C 00 00 FF 
01b98     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01b9c     F4 03 00 FF 
01ba0     00 90 06 F6 | 	mov	arg01, ##518144
01ba4     0B 00 00 FF 
01ba8     C8 62 06 F1 | 	add	objptr, ##5832
01bac     18 98 62 FD | 	getqx	arg05
01bb0     4C 93 02 F1 | 	add	arg02, arg05
01bb4     38 04 B0 FD | 	call	#_psram_spin2_write
01bb8     0B 00 00 FF 
01bbc     CC 62 86 F1 | 	sub	objptr, ##5836
01bc0     01 A6 06 F1 | 	add	local01, #1
01bc4     24 A6 56 F2 | 	cmps	local01, #36 wc
01bc8     68 FF 9F CD |  if_b	jmp	#LR__0133
01bcc                 | ' repeat i from 0 to timings[7]-1
01bcc     00 A6 06 F6 | 	mov	local01, #0
01bd0     1C 00 00 FF 
01bd4     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01bd8     36 A9 02 FB | 	rdlong	local02, ptr__hg010b_spin2_dat__
01bdc     1C 00 00 FF 
01be0     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01be4     01 A8 86 F1 | 	sub	local02, #1
01be8     00 A8 56 F2 | 	cmps	local02, #0 wc
01bec     01 AA 86 F6 | 	negc	local03, #1
01bf0     55 A9 02 F1 | 	add	local02, local03
01bf4                 | LR__0134
01bf4                 | '   ram.fill(textbuf_ptr+(36*timings[7]+i),32,1,0,1) 
01bf4     04 62 06 F1 | 	add	objptr, #4
01bf8     31 91 02 FB | 	rdlong	arg01, objptr
01bfc     1C 00 00 FF 
01c00     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01c04     36 99 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
01c08     1C 00 00 FF 
01c0c     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01c10     4C 97 02 F6 | 	mov	arg04, arg05
01c14     03 96 66 F0 | 	shl	arg04, #3
01c18     4C 97 02 F1 | 	add	arg04, arg05
01c1c     02 96 66 F0 | 	shl	arg04, #2
01c20     53 97 02 F1 | 	add	arg04, local01
01c24     4B 91 02 F1 | 	add	arg01, arg04
01c28     20 92 06 F6 | 	mov	arg02, #32
01c2c     01 94 06 F6 | 	mov	arg03, #1
01c30     00 96 06 F6 | 	mov	arg04, #0
01c34     01 98 06 F6 | 	mov	arg05, #1
01c38     0B 00 00 FF 
01c3c     C8 62 06 F1 | 	add	objptr, ##5832
01c40     4C 04 B0 FD | 	call	#_psram_spin2_fill
01c44     0B 00 00 FF 
01c48     CC 62 86 F1 | 	sub	objptr, ##5836
01c4c     55 A7 02 F1 | 	add	local01, local03
01c50     54 A7 0A F2 | 	cmp	local01, local02 wz
01c54     9C FF 9F 5D |  if_ne	jmp	#LR__0134
01c58     E7 F0 03 F6 | 	mov	ptra, fp
01c5c     F2 00 A0 FD | 	call	#popregs_
01c60                 | _hg010b_spin2_scrollup2_ret
01c60     2D 00 64 FD | 	ret
01c64                 | 
01c64                 | ' 
01c64                 | ' ''----------- Set cursor at the first character in a new line, scroll if needed 
01c64                 | ' 
01c64                 | ' pub crlf()
01c64                 | _hg010b_spin2_crlf
01c64                 | ' 
01c64                 | ' cursor_x:=leading_spaces*2
01c64     01 00 00 FF 
01c68     B6 62 06 F1 | 	add	objptr, ##694
01c6c     31 95 02 FB | 	rdlong	arg03, objptr
01c70     01 94 66 F0 | 	shl	arg03, #1
01c74     01 00 00 FF 
01c78     7A 62 86 F1 | 	sub	objptr, ##634
01c7c     31 95 52 FC | 	wrword	arg03, objptr
01c80                 | ' cursor_y+=1
01c80     02 62 06 F1 | 	add	objptr, #2
01c84     31 95 C2 FA | 	rdbyte	arg03, objptr
01c88     01 94 06 F1 | 	add	arg03, #1
01c8c     31 95 42 FC | 	wrbyte	arg03, objptr
01c90                 | ' if cursor_y>st_lines-1
01c90     C3 62 06 F1 | 	add	objptr, #195
01c94     31 95 02 FB | 	rdlong	arg03, objptr
01c98     01 94 86 F1 | 	sub	arg03, #1
01c9c     C3 62 86 F1 | 	sub	objptr, #195
01ca0     31 93 C2 FA | 	rdbyte	arg02, objptr
01ca4     3E 62 86 F1 | 	sub	objptr, #62
01ca8     4A 93 5A F2 | 	cmps	arg02, arg03 wcz
01cac     2C 00 90 ED |  if_be	jmp	#LR__0140
01cb0                 | '   scrollup2()
01cb0     00 90 06 F6 | 	mov	arg01, #0
01cb4     01 00 00 FF 
01cb8     58 92 06 F6 | 	mov	arg02, ##600
01cbc     10 94 06 F6 | 	mov	arg03, #16
01cc0     68 FD BF FD | 	call	#_hg010b_spin2_scrollup2
01cc4                 | '   cursor_y:=st_lines-1
01cc4     01 63 06 F1 | 	add	objptr, #257
01cc8     31 95 02 FB | 	rdlong	arg03, objptr
01ccc     01 94 86 F1 | 	sub	arg03, #1
01cd0     C3 62 86 F1 | 	sub	objptr, #195
01cd4     31 95 42 FC | 	wrbyte	arg03, objptr
01cd8     3E 62 86 F1 | 	sub	objptr, #62
01cdc                 | LR__0140
01cdc                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )  
01cdc     3C 62 06 F1 | 	add	objptr, #60
01ce0     31 93 E2 FA | 	rdword	arg02, objptr
01ce4     02 92 66 F0 | 	shl	arg02, #2
01ce8     02 62 06 F1 | 	add	objptr, #2
01cec     31 95 C2 FA | 	rdbyte	arg03, objptr
01cf0     3E 62 86 F1 | 	sub	objptr, #62
01cf4     04 94 66 F0 | 	shl	arg03, #4
01cf8     04 94 06 F1 | 	add	arg03, #4
01cfc     11 90 06 F6 | 	mov	arg01, #17
01d00     14 F5 BF FD | 	call	#_hg010b_spin2_setspritepos
01d04                 | _hg010b_spin2_crlf_ret
01d04     2D 00 64 FD | 	ret
01d08                 | 
01d08                 | ' 
01d08                 | ' '..............................................................................
01d08                 | ' 
01d08                 | ' {{
01d08                 | ' }}
01d08                 | ' PUB startx(freq, burst, delay, desiredcog) : cog,mail | driverAddr
01d08                 | _psram_spin2_startx
01d08     04 CA 05 F6 | 	mov	COUNT_, #4
01d0c     E8 00 A0 FD | 	call	#pushregs_
01d10     48 A7 02 F6 | 	mov	local01, arg01
01d14     4A A9 02 F6 | 	mov	local02, arg03
01d18     4B AB 02 F6 | 	mov	local03, arg04
01d1c                 | '     stop() ' restart driver if required
01d1c     74 01 B0 FD | 	call	#_psram_spin2_stop
01d20     00 A6 0E F2 | 	cmp	local01, #0 wz
01d24     14 A6 06 AB |  if_e	rdlong	local01, #20
01d28     53 93 52 F6 | 	abs	arg02, local01 wc
01d2c     A1 07 00 FF 
01d30     40 92 16 FD | 	qdiv	arg02, ##1000000
01d34                 | ' 
01d34                 | '     ' use current frequency if none specified
01d34                 | ' 
01d34                 | '     if freq == 0 
01d34                 | '         freq := clkfreq 
01d34                 | ' 
01d34                 | '     ' compute the device burst size including overheads to keep CS low time below 8us
01d34                 | ' 
01d34                 | '     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
01d34                 | '     if burst < 0
01d34                 | '         return ERR_TOO_SLOW,0 ' P2 frequency is too low for any 8us transfers
01d34     18 92 62 FD | 	getqx	arg02
01d38     49 97 82 F6 | 	negc	arg04, arg02
01d3c     03 96 66 F0 | 	shl	arg04, #3
01d40     84 96 86 F1 | 	sub	arg04, #132
01d44     04 96 46 F0 | 	shr	arg04, #4
01d48     04 96 66 F0 | 	shl	arg04, #4
01d4c     00 96 56 F2 | 	cmps	arg04, #0 wc
01d50     00 78 06 C6 |  if_b	mov	result2, #0
01d54     0E 76 66 C6 |  if_b	neg	result1, #14
01d58     2C 01 90 CD |  if_b	jmp	#LR__0154
01d5c                 | ' 
01d5c                 | '     ' compute the input delay
01d5c                 | ' 
01d5c                 | '     if delay <= 0
01d5c     01 A8 56 F2 | 	cmps	local02, #1 wc
01d60     10 00 90 3D |  if_ae	jmp	#LR__0150
01d64                 | '         delay := lookupDelay(freq)
01d64     53 91 02 F6 | 	mov	arg01, local01
01d68     DC 04 B0 FD | 	call	#_psram_spin2_lookupDelay
01d6c     3B A9 02 F6 | 	mov	local02, result1
01d70     04 00 90 FD | 	jmp	#LR__0151
01d74                 | LR__0150
01d74                 | '     else
01d74                 | '         delay <#= $f ' limit to 15
01d74     0F A8 66 F3 | 	fles	local02, #15
01d78                 | LR__0151
01d78                 | ' 
01d78                 | '     ' create our lock
01d78                 | ' 
01d78                 | '     driverlock := LOCKNEW()  
01d78     00 76 06 F6 | 	mov	result1, #0
01d7c     04 76 62 FD | 	locknew	result1
01d80     04 71 06 F1 | 	add	ptr__psram_spin2_dat__, #260
01d84     38 77 62 FC | 	wrlong	result1, ptr__psram_spin2_dat__
01d88                 | '     if driverlock == -1
01d88     04 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
01d8c     FF FF 7F FF 
01d90     FF 77 0E F2 | 	cmp	result1, ##-1 wz
01d94                 | '         return ERR_NO_LOCK,0
01d94     00 78 06 A6 |  if_e	mov	result2, #0
01d98     1A 76 66 A6 |  if_e	neg	result1, #26
01d9c     E8 00 90 AD |  if_e	jmp	#LR__0154
01da0                 | ' 
01da0                 | '     ' patch in the proper data and HUB addresses to the startup structure
01da0                 | ' 
01da0                 | '     long[@startupData][0]:=clkfreq
01da0     14 A6 06 FB | 	rdlong	local01, #20
01da4     28 71 06 F1 | 	add	ptr__psram_spin2_dat__, #296
01da8     38 A7 62 FC | 	wrlong	local01, ptr__psram_spin2_dat__
01dac                 | ' '    long[@startupData][1]:=$1000_0000
01dac                 | '     long[@startupData][5]:=@deviceData
01dac     38 A7 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
01db0     20 A6 06 F1 | 	add	local01, #32
01db4     38 93 02 F6 | 	mov	arg02, ptr__psram_spin2_dat__
01db8     14 92 06 F1 | 	add	arg02, #20
01dbc     49 A7 62 FC | 	wrlong	local01, arg02
01dc0                 | '     long[@startupData][6]:=@qosData
01dc0     38 A7 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
01dc4     A0 A6 06 F1 | 	add	local01, #160
01dc8     38 93 02 F6 | 	mov	arg02, ptr__psram_spin2_dat__
01dcc     18 92 06 F1 | 	add	arg02, #24
01dd0     49 A7 62 FC | 	wrlong	local01, arg02
01dd4                 | ' 
01dd4                 | ' 
01dd4                 | '     long[@startupData][7]:=mailbox
01dd4     38 A7 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
01dd8     1C A6 06 F1 | 	add	local01, #28
01ddc     DF 03 80 FF 
01de0     53 01 6A FC | 	wrlong	##507648, local01
01de4                 | '   
01de4                 | '     ' setup some default bank and QoS parameter values
01de4                 | ' 
01de4                 | '     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
01de4     20 70 06 F1 | 	add	ptr__psram_spin2_dat__, #32
01de8     38 91 02 F6 | 	mov	arg01, ptr__psram_spin2_dat__
01dec     48 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #328
01df0     10 96 66 F0 | 	shl	arg04, #16
01df4     0C A8 66 F0 | 	shl	local02, #12
01df8     54 97 42 F5 | 	or	arg04, local02
01dfc     18 96 46 F5 | 	or	arg04, #24
01e00     4B 93 02 F6 | 	mov	arg02, arg04
01e04     02 94 06 F6 | 	mov	arg03, #2
01e08     E0 00 A0 FD | 	call	#\builtin_longfill_
01e0c                 | '     longfill(@qosData, $FFFF0000, 8)
01e0c     38 91 02 F6 | 	mov	arg01, ptr__psram_spin2_dat__
01e10     C8 91 06 F1 | 	add	arg01, #456
01e14     07 94 06 F6 | 	mov	arg03, #7
01e18     28 94 62 FD | 	setq	arg03
01e1c     80 FF FF FF 
01e20     48 01 68 FC | 	wrlong	##-65536, arg01
01e24                 | ' 
01e24                 | '     ' get the address of the PSRAM memory driver so we can start it
01e24                 | ' 
01e24                 | '     driverAddr:= driver.getDriverAddr()
01e24                 | '     return @driver_start
01e24     37 93 02 F6 | 	mov	arg02, ptr__psram16drv_spin2_dat__
01e28     20 92 06 F1 | 	add	arg02, #32
01e2c                 | ' 
01e2c                 | '     ' start the PSRAM memory driver and wait for it to complete initialization
01e2c                 | ' 
01e2c                 | '     if desiredcog < 0
01e2c     00 AA 56 F2 | 	cmps	local03, #0 wc
01e30                 | '         desiredcog := NEWCOG
01e30     10 AA 06 C6 |  if_b	mov	local03, #16
01e34                 | '     drivercog := coginit(desiredcog, driverAddr, @startupData)
01e34     38 95 02 F6 | 	mov	arg03, ptr__psram_spin2_dat__
01e38     28 95 06 F1 | 	add	arg03, #296
01e3c     55 AD 02 F6 | 	mov	local04, local03
01e40     28 94 62 FD | 	setq	arg03
01e44     49 AD F2 FC | 	coginit	local04, arg02 wc
01e48     01 AC 66 C6 |  if_b	neg	local04, #1
01e4c     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01e50     38 AD 62 FC | 	wrlong	local04, ptr__psram_spin2_dat__
01e54     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01e58     D7 08 48 FB | 	callpa	#(@LR__0153-@LR__0152)>>2,fcache_load_ptr_
01e5c                 | '     repeat until long[@startupData] == 0 
01e5c                 | LR__0152
01e5c     38 AD 02 F6 | 	mov	local04, ptr__psram_spin2_dat__
01e60     28 AD 06 F1 | 	add	local04, #296
01e64     56 AD 0A FB | 	rdlong	local04, local04 wz
01e68     F0 FF 9F 5D |  if_ne	jmp	#LR__0152
01e6c                 | LR__0153
01e6c                 | ' 
01e6c                 | '     return drivercog,long[@startupData][7]
01e6c     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01e70     38 77 02 FB | 	rdlong	result1, ptr__psram_spin2_dat__
01e74     28 70 06 F1 | 	add	ptr__psram_spin2_dat__, #40
01e78     38 AD 02 F6 | 	mov	local04, ptr__psram_spin2_dat__
01e7c     1C AC 06 F1 | 	add	local04, #28
01e80     56 79 02 FB | 	rdlong	result2, local04
01e84     28 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #296
01e88                 | LR__0154
01e88     E7 F0 03 F6 | 	mov	ptra, fp
01e8c     F2 00 A0 FD | 	call	#popregs_
01e90                 | _psram_spin2_startx_ret
01e90     2D 00 64 FD | 	ret
01e94                 | 
01e94                 | ' 
01e94                 | ' '..............................................................................
01e94                 | ' 
01e94                 | ' {{
01e94                 | ' }}
01e94                 | ' PUB stop() : i
01e94                 | _psram_spin2_stop
01e94     00 7C 06 F6 | 	mov	_var01, #0
01e98                 | '     if drivercog <> -1
01e98     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01e9c     38 91 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
01ea0     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01ea4     FF FF 7F FF 
01ea8     FF 91 0E F2 | 	cmp	arg01, ##-1 wz
01eac     70 00 90 AD |  if_e	jmp	#LR__0163
01eb0                 | '         cogstop(drivercog) ' a rather brutal stop
01eb0     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01eb4     38 91 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
01eb8     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01ebc     03 90 62 FD | 	cogstop	arg01
01ec0     D7 26 48 FB | 	callpa	#(@LR__0162-@LR__0160)>>2,fcache_load_ptr_
01ec4                 | '         repeat i from 0 to 7
01ec4                 | LR__0160
01ec4                 | '             if long[mailbox][i*3] < 0
01ec4     3E 77 02 F6 | 	mov	result1, _var01
01ec8     01 76 66 F0 | 	shl	result1, #1
01ecc     3E 77 02 F1 | 	add	result1, _var01
01ed0     02 76 66 F0 | 	shl	result1, #2
01ed4     DF 03 00 FF 
01ed8     00 77 06 F1 | 	add	result1, ##507648
01edc     3B 77 02 FB | 	rdlong	result1, result1
01ee0     00 76 56 F2 | 	cmps	result1, #0 wc
01ee4     1C 00 90 3D |  if_ae	jmp	#LR__0161
01ee8                 | '                 long[mailbox][i*3] := -ERR_ABORTED ' abort request
01ee8     3E 77 02 F6 | 	mov	result1, _var01
01eec     01 76 66 F0 | 	shl	result1, #1
01ef0     3E 77 02 F1 | 	add	result1, _var01
01ef4     02 76 66 F0 | 	shl	result1, #2
01ef8     DF 03 00 FF 
01efc     00 77 06 F1 | 	add	result1, ##507648
01f00     3B 21 68 FC | 	wrlong	#16, result1
01f04                 | LR__0161
01f04     01 7C 06 F1 | 	add	_var01, #1
01f08     08 7C 56 F2 | 	cmps	_var01, #8 wc
01f0c     B4 FF 9F CD |  if_b	jmp	#LR__0160
01f10                 | LR__0162
01f10                 | '         drivercog := -1
01f10     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01f14     FF FF FF FF 
01f18     38 FF 6B FC | 	wrlong	##-1, ptr__psram_spin2_dat__
01f1c     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01f20                 | LR__0163
01f20                 | '     if driverlock <> -1
01f20     04 71 06 F1 | 	add	ptr__psram_spin2_dat__, #260
01f24     38 7F 02 FB | 	rdlong	_var02, ptr__psram_spin2_dat__
01f28     04 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
01f2c     FF FF 7F FF 
01f30     FF 7F 0E F2 | 	cmp	_var02, ##-1 wz
01f34                 | '         LOCKRET(driverlock)
01f34     04 71 06 51 |  if_ne	add	ptr__psram_spin2_dat__, #260
01f38     38 91 02 5B |  if_ne	rdlong	arg01, ptr__psram_spin2_dat__
01f3c     05 90 62 5D |  if_ne	lockret	arg01
01f40                 | '         driverlock := -1
01f40     FF FF FF 5F 
01f44     38 FF 6B 5C |  if_ne	wrlong	##-1, ptr__psram_spin2_dat__
01f48     04 71 86 51 |  if_ne	sub	ptr__psram_spin2_dat__, #260
01f4c     3E 77 02 F6 | 	mov	result1, _var01
01f50                 | _psram_spin2_stop_ret
01f50     2D 00 64 FD | 	ret
01f54                 | 
01f54                 | ' 
01f54                 | ' '..............................................................................
01f54                 | ' 
01f54                 | ' {{
01f54                 | ' }}
01f54                 | ' PUB read1(dstHubAddr, srcAddr, count) : result | mailbox1
01f54                 | _psram_spin2_read1
01f54                 | ' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
01f54                 | '     if drivercog == -1 ' driver must be running
01f54     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01f58     38 7D 02 FB | 	rdlong	_var01, ptr__psram_spin2_dat__
01f5c     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01f60     FF FF 7F FF 
01f64     FF 7D 0E F2 | 	cmp	_var01, ##-1 wz
01f68                 | '         return ERR_INACTIVE
01f68     0F 76 66 A6 |  if_e	neg	result1, #15
01f6c     7C 00 90 AD |  if_e	jmp	#LR__0171
01f70                 | '     if count == 0 ' don't even bother reading
01f70     00 94 0E F2 | 	cmp	arg03, #0 wz
01f74                 | '         return 0
01f74     00 76 06 A6 |  if_e	mov	result1, #0
01f78     70 00 90 AD |  if_e	jmp	#LR__0171
01f7c                 | '     mailbox1 := mailbox + cogid()*12     ' compute COG's mailbox address
01f7c     DF 03 00 FF 
01f80     00 7F 06 F6 | 	mov	_var02, ##507648
01f84     00 76 06 F6 | 	mov	result1, #0
01f88     01 76 62 FD | 	cogid	result1
01f8c     3B 7D 02 F6 | 	mov	_var01, result1
01f90     01 7C 66 F0 | 	shl	_var01, #1
01f94     3B 7D 02 F1 | 	add	_var01, result1
01f98     02 7C 66 F0 | 	shl	_var01, #2
01f9c     3E 7F 02 F1 | 	add	_var02, _var01
01fa0                 | '     if long[mailbox1] < 0
01fa0     3F 7D 02 FB | 	rdlong	_var01, _var02
01fa4     00 7C 56 F2 | 	cmps	_var01, #0 wc
01fa8                 | '         return ERR_MAILBOX_BUSY
01fa8     1C 76 66 C6 |  if_b	neg	result1, #28
01fac     3C 00 90 CD |  if_b	jmp	#LR__0171
01fb0                 | '     long[mailbox1][2] := count
01fb0     08 7E 06 F1 | 	add	_var02, #8
01fb4     3F 95 62 FC | 	wrlong	arg03, _var02
01fb8                 | '     long[mailbox1][1] := dstHubAddr
01fb8     04 7E 86 F1 | 	sub	_var02, #4
01fbc     3F 91 62 FC | 	wrlong	arg01, _var02
01fc0     04 7E 86 F1 | 	sub	_var02, #4
01fc4                 | '     long[mailbox1] := driver.R_READBURST + (srcAddr & $1ffffff) ' trigger burst read operation
01fc4     49 81 02 F6 | 	mov	_var03, arg02
01fc8     D9 80 06 F4 | 	bitl	_var03, #217
01fcc     00 00 58 FF 
01fd0     00 7C 06 F6 | 	mov	_var01, ##-1342177280
01fd4     40 7D 02 F1 | 	add	_var01, _var03
01fd8     3F 7D 62 FC | 	wrlong	_var01, _var02
01fdc                 | '     repeat
01fdc                 | LR__0170
01fdc                 | '         result := long[mailbox1]    
01fdc     3F 81 02 FB | 	rdlong	_var03, _var02
01fe0     00 80 56 F2 | 	cmps	_var03, #0 wc
01fe4     F4 FF 9F CD |  if_b	jmp	#LR__0170
01fe8                 | '     while result < 0   
01fe8                 | '     return -result                       'return success or error
01fe8     40 77 62 F6 | 	neg	result1, _var03
01fec                 | LR__0171
01fec                 | _psram_spin2_read1_ret
01fec     2D 00 64 FD | 	ret
01ff0                 | 
01ff0                 | ' 
01ff0                 | ' '..............................................................................
01ff0                 | ' 
01ff0                 | ' {{
01ff0                 | ' }}
01ff0                 | ' PUB write(srcHubAddr, dstAddr, count) : result | mailbox1
01ff0                 | _psram_spin2_write
01ff0                 | ' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
01ff0                 | '     if drivercog == -1 ' driver must be running
01ff0     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01ff4     38 7D 02 FB | 	rdlong	_var01, ptr__psram_spin2_dat__
01ff8     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01ffc     FF FF 7F FF 
02000     FF 7D 0E F2 | 	cmp	_var01, ##-1 wz
02004                 | '         return ERR_INACTIVE
02004     0F 76 66 A6 |  if_e	neg	result1, #15
02008     80 00 90 AD |  if_e	jmp	#LR__0181
0200c                 | '     if count == 0 ' don't even bother writing
0200c     00 94 0E F2 | 	cmp	arg03, #0 wz
02010                 | '         return 0
02010     00 76 06 A6 |  if_e	mov	result1, #0
02014     74 00 90 AD |  if_e	jmp	#LR__0181
02018                 | '     mailbox1 := mailbox + cogid()*12     ' compute COG's mailbox address
02018     DF 03 00 FF 
0201c     00 7F 06 F6 | 	mov	_var02, ##507648
02020     00 76 06 F6 | 	mov	result1, #0
02024     01 76 62 FD | 	cogid	result1
02028     3B 7D 02 F6 | 	mov	_var01, result1
0202c     01 7C 66 F0 | 	shl	_var01, #1
02030     3B 7D 02 F1 | 	add	_var01, result1
02034     02 7C 66 F0 | 	shl	_var01, #2
02038     3E 7F 02 F1 | 	add	_var02, _var01
0203c                 | '     if long[mailbox] < 0
0203c     DF 03 00 FF 
02040     00 7D 06 FB | 	rdlong	_var01, ##507648
02044     00 7C 56 F2 | 	cmps	_var01, #0 wc
02048                 | '         return ERR_MAILBOX_BUSY
02048     1C 76 66 C6 |  if_b	neg	result1, #28
0204c     3C 00 90 CD |  if_b	jmp	#LR__0181
02050                 | '     long[mailbox1][2] := count
02050     08 7E 06 F1 | 	add	_var02, #8
02054     3F 95 62 FC | 	wrlong	arg03, _var02
02058                 | '     long[mailbox1][1] := srcHubAddr
02058     04 7E 86 F1 | 	sub	_var02, #4
0205c     3F 91 62 FC | 	wrlong	arg01, _var02
02060     04 7E 86 F1 | 	sub	_var02, #4
02064                 | '     long[mailbox1] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
02064     49 81 02 F6 | 	mov	_var03, arg02
02068     D9 80 06 F4 | 	bitl	_var03, #217
0206c     00 00 78 FF 
02070     00 7C 06 F6 | 	mov	_var01, ##-268435456
02074     40 7D 02 F1 | 	add	_var01, _var03
02078     3F 7D 62 FC | 	wrlong	_var01, _var02
0207c                 | '     repeat
0207c                 | LR__0180
0207c                 | '         result := long[mailbox1]    
0207c     3F 81 02 FB | 	rdlong	_var03, _var02
02080     00 80 56 F2 | 	cmps	_var03, #0 wc
02084     F4 FF 9F CD |  if_b	jmp	#LR__0180
02088                 | '     while result < 0   
02088                 | '     return -result                       'return success or error
02088     40 77 62 F6 | 	neg	result1, _var03
0208c                 | LR__0181
0208c                 | _psram_spin2_write_ret
0208c     2D 00 64 FD | 	ret
02090                 | 
02090                 | ' 
02090                 | ' ' generalized fill
02090                 | ' PUB fill(addr, pattern, count, listPtr, datasize) : r | mailbox1, req
02090                 | _psram_spin2_fill
02090     48 7D 02 F6 | 	mov	_var01, arg01
02094     49 7F 02 F6 | 	mov	_var02, arg02
02098     4A 81 02 F6 | 	mov	_var03, arg03
0209c     4C 83 02 F6 | 	mov	_var04, arg05
020a0                 | '     case datasize 
020a0     01 82 86 F1 | 	sub	_var04, #1
020a4     04 82 26 F3 | 	fle	_var04, #4
020a8     30 82 62 FD | 	jmprel	_var04
020ac                 | LR__0190
020ac     10 00 90 FD | 	jmp	#LR__0191
020b0     18 00 90 FD | 	jmp	#LR__0192
020b4     2C 00 90 FD | 	jmp	#LR__0194
020b8     1C 00 90 FD | 	jmp	#LR__0193
020bc     24 00 90 FD | 	jmp	#LR__0194
020c0                 | LR__0191
020c0                 | '         1: req := driver.R_WRITEBYTE
020c0     00 00 60 FF 
020c4     00 84 06 F6 | 	mov	_var05, ##-1073741824
020c8     20 00 90 FD | 	jmp	#LR__0195
020cc                 | LR__0192
020cc                 | '         2: req := driver.R_WRITEWORD
020cc     00 00 68 FF 
020d0     00 84 06 F6 | 	mov	_var05, ##-805306368
020d4     14 00 90 FD | 	jmp	#LR__0195
020d8                 | LR__0193
020d8                 | '         4: req := driver.R_WRITELONG
020d8     00 00 70 FF 
020dc     00 84 06 F6 | 	mov	_var05, ##-536870912
020e0     08 00 90 FD | 	jmp	#LR__0195
020e4                 | LR__0194
020e4                 | '         other : return ERR_INVALID
020e4     06 76 66 F6 | 	neg	result1, #6
020e8     98 00 90 FD | 	jmp	#LR__0197
020ec                 | LR__0195
020ec                 | '     if count == 0   ' nothing to do
020ec     00 80 0E F2 | 	cmp	_var03, #0 wz
020f0                 | '         return 0
020f0     00 76 06 A6 |  if_e	mov	result1, #0
020f4     8C 00 90 AD |  if_e	jmp	#LR__0197
020f8                 | '     if drivercog == -1
020f8     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
020fc     38 83 02 FB | 	rdlong	_var04, ptr__psram_spin2_dat__
02100     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
02104     FF FF 7F FF 
02108     FF 83 0E F2 | 	cmp	_var04, ##-1 wz
0210c                 | '         return ERR_INACTIVE
0210c     0F 76 66 A6 |  if_e	neg	result1, #15
02110     70 00 90 AD |  if_e	jmp	#LR__0197
02114                 | '     mailbox1 := mailbox + 12*cogid() ' get mailbox base address for this COG
02114     DF 03 00 FF 
02118     00 87 06 F6 | 	mov	_var06, ##507648
0211c     00 76 06 F6 | 	mov	result1, #0
02120     01 76 62 FD | 	cogid	result1
02124     3B 83 02 F6 | 	mov	_var04, result1
02128     01 82 66 F0 | 	shl	_var04, #1
0212c     3B 83 02 F1 | 	add	_var04, result1
02130     02 82 66 F0 | 	shl	_var04, #2
02134     41 87 02 F1 | 	add	_var06, _var04
02138                 | '     if long[mailbox] < 0
02138     DF 03 00 FF 
0213c     00 83 06 FB | 	rdlong	_var04, ##507648
02140     00 82 56 F2 | 	cmps	_var04, #0 wc
02144                 | '         return ERR_MAILBOX_BUSY
02144     1C 76 66 C6 |  if_b	neg	result1, #28
02148     38 00 90 CD |  if_b	jmp	#LR__0197
0214c                 | '     long[mailbox1][2] := count
0214c     08 86 06 F1 | 	add	_var06, #8
02150     43 81 62 FC | 	wrlong	_var03, _var06
02154                 | '     long[mailbox1][1] := pattern
02154     04 86 86 F1 | 	sub	_var06, #4
02158     43 7F 62 FC | 	wrlong	_var02, _var06
0215c     04 86 86 F1 | 	sub	_var06, #4
02160                 | '     long[mailbox1] := req + (addr & $1ffffff)
02160     42 89 02 F6 | 	mov	_var07, _var05
02164     3E 8B 02 F6 | 	mov	_var08, _var01
02168     D9 8A 06 F4 | 	bitl	_var08, #217
0216c     45 89 02 F1 | 	add	_var07, _var08
02170     43 89 62 FC | 	wrlong	_var07, _var06
02174                 | '     repeat
02174                 | LR__0196
02174                 | '         r := long[mailbox1]
02174     43 8B 02 FB | 	rdlong	_var08, _var06
02178     00 8A 56 F2 | 	cmps	_var08, #0 wc
0217c     F4 FF 9F CD |  if_b	jmp	#LR__0196
02180                 | '     while r < 0
02180                 | '     return -r                  ' return 0 for success or negated error code
02180     45 77 62 F6 | 	neg	result1, _var08
02184                 | LR__0197
02184                 | _psram_spin2_fill_ret
02184     2D 00 64 FD | 	ret
02188                 | 
02188                 | ' 
02188                 | ' '..............................................................................
02188                 | ' 
02188                 | ' {{
02188                 | ' }}
02188                 | ' PUB setQos(cog, qos) : result | mailbox1
02188                 | _psram_spin2_setQos
02188     48 7D 02 F6 | 	mov	_var01, arg01
0218c                 | '     if drivercog == -1 ' driver must be running
0218c     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
02190     38 7F 02 FB | 	rdlong	_var02, ptr__psram_spin2_dat__
02194     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
02198     FF FF 7F FF 
0219c     FF 7F 0E F2 | 	cmp	_var02, ##-1 wz
021a0                 | '         return ERR_INACTIVE
021a0     0F 76 66 A6 |  if_e	neg	result1, #15
021a4     9C 00 90 AD |  if_e	jmp	#LR__0204
021a8                 | '     if cog < 0 or cog > 7 ' enforce cog id range
021a8     00 7C 56 F2 | 	cmps	_var01, #0 wc
021ac     08 00 90 CD |  if_b	jmp	#LR__0200
021b0     08 7C 56 F2 | 	cmps	_var01, #8 wc
021b4     08 00 90 CD |  if_b	jmp	#LR__0201
021b8                 | LR__0200
021b8                 | '         return ERR_INVALID
021b8     06 76 66 F6 | 	neg	result1, #6
021bc     84 00 90 FD | 	jmp	#LR__0204
021c0                 | LR__0201
021c0                 | '     long[@qosData][cog] := qos & !$1ff
021c0     FF 93 26 F5 | 	andn	arg02, #511
021c4     C8 71 06 F1 | 	add	ptr__psram_spin2_dat__, #456
021c8     02 7C 66 F0 | 	shl	_var01, #2
021cc     38 7D 02 F1 | 	add	_var01, ptr__psram_spin2_dat__
021d0     3E 93 62 FC | 	wrlong	arg02, _var01
021d4                 | '     mailbox1 := mailbox + drivercog*12
021d4     DF 03 00 FF 
021d8     00 81 06 F6 | 	mov	_var03, ##507648
021dc     C8 70 86 F1 | 	sub	ptr__psram_spin2_dat__, #200
021e0     38 83 02 FB | 	rdlong	_var04, ptr__psram_spin2_dat__
021e4     41 85 02 F6 | 	mov	_var05, _var04
021e8     01 84 66 F0 | 	shl	_var05, #1
021ec     41 85 02 F1 | 	add	_var05, _var04
021f0     02 84 66 F0 | 	shl	_var05, #2
021f4     42 81 02 F1 | 	add	_var03, _var05
021f8                 | '     repeat until LOCKTRY(driverlock)
021f8     04 70 06 F1 | 	add	ptr__psram_spin2_dat__, #4
021fc                 | LR__0202
021fc     38 91 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
02200     06 90 72 FD | 	locktry	arg01 wc
02204     F4 FF 9F 3D |  if_ae	jmp	#LR__0202
02208     04 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
0220c                 | '     long[mailbox1] := driver.R_CONFIG + cogid()
0220c     00 84 06 F6 | 	mov	_var05, #0
02210     01 84 62 FD | 	cogid	_var05
02214     00 00 78 FF 
02218     00 7E 06 F6 | 	mov	_var02, ##-268435456
0221c     42 7F 02 F1 | 	add	_var02, _var05
02220     40 7F 62 FC | 	wrlong	_var02, _var03
02224                 | '     repeat while long[mailbox1] < 0
02224                 | LR__0203
02224     40 7F 02 FB | 	rdlong	_var02, _var03
02228     00 7E 56 F2 | 	cmps	_var02, #0 wc
0222c     F4 FF 9F CD |  if_b	jmp	#LR__0203
02230                 | '     LOCKREL(driverlock)
02230     04 71 06 F1 | 	add	ptr__psram_spin2_dat__, #260
02234     38 91 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
02238     04 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
0223c     07 90 72 FD | 	lockrel	arg01 wc
02240     00 76 06 F6 | 	mov	result1, #0
02244                 | LR__0204
02244                 | _psram_spin2_setQos_ret
02244     2D 00 64 FD | 	ret
02248                 | 
02248                 | ' 
02248                 | ' '..............................................................................
02248                 | ' 
02248                 | ' {{
02248                 | ' }}
02248                 | ' PRI lookupDelay(freq) : delay | profile
02248                 | _psram_spin2_lookupDelay
02248                 | '     profile := @delayTable
02248     38 7D 02 F6 | 	mov	_var01, ptr__psram_spin2_dat__
0224c     08 7D 06 F1 | 	add	_var01, #264
02250                 | '     delay := long[profile][0]
02250     3E 7F 02 FB | 	rdlong	_var02, _var01
02254     D7 16 48 FB | 	callpa	#(@LR__0211-@LR__0210)>>2,fcache_load_ptr_
02258                 | '     repeat while long[profile][1] 
02258                 | LR__0210
02258     04 7C 06 F1 | 	add	_var01, #4
0225c     3E 77 0A FB | 	rdlong	result1, _var01 wz
02260     04 7C 86 F1 | 	sub	_var01, #4
02264     1C 00 90 AD |  if_e	jmp	#LR__0212
02268                 | '         if freq +< long[profile][1] 
02268     04 7C 06 F1 | 	add	_var01, #4
0226c     3E 77 02 FB | 	rdlong	result1, _var01
02270     04 7C 86 F1 | 	sub	_var01, #4
02274     3B 91 12 F2 | 	cmp	arg01, result1 wc
02278                 | '             quit
02278                 | '         profile += 4
02278     04 7C 06 31 |  if_ae	add	_var01, #4
0227c                 | '         delay++
0227c     01 7E 06 31 |  if_ae	add	_var02, #1
02280     D4 FF 9F 3D |  if_ae	jmp	#LR__0210
02284                 | LR__0211
02284                 | LR__0212
02284     3F 77 02 F6 | 	mov	result1, _var02
02288                 | _psram_spin2_lookupDelay_ret
02288     2D 00 64 FD | 	ret
0228c                 | 
0228c                 | ' 
0228c                 | ' PUB start() : r
0228c                 | _usbnew_spin2_start
0228c     00 7C 06 F6 | 	mov	_var01, #0
02290                 | '   ifnot driver_cog
02290     15 00 00 FF 
02294     87 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10887
02298     39 7F CA FA | 	rdbyte	_var02, ptr__usbnew_spin2_dat__ wz
0229c     15 00 00 FF 
022a0     87 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##10887
022a4     38 00 90 5D |  if_ne	jmp	#LR__0220
022a8                 | '     r := coginit(COGEXEC_NEW,@usb_host_start,0)
022a8     39 93 02 F6 | 	mov	arg02, ptr__usbnew_spin2_dat__
022ac     10 7C 06 F6 | 	mov	_var01, #16
022b0     00 94 06 F6 | 	mov	arg03, #0
022b4     28 94 62 FD | 	setq	arg03
022b8     49 7D F2 FC | 	coginit	_var01, arg02 wc
022bc     01 7C 66 C6 |  if_b	neg	_var01, #1
022c0                 | '     if r >= 0
022c0     00 7C 56 F2 | 	cmps	_var01, #0 wc
022c4                 | '       driver_cog := r+1
022c4     3E 7F 02 36 |  if_ae	mov	_var02, _var01
022c8     01 7E 06 31 |  if_ae	add	_var02, #1
022cc     15 00 00 3F 
022d0     87 72 06 31 |  if_ae	add	ptr__usbnew_spin2_dat__, ##10887
022d4     39 7F 42 3C |  if_ae	wrbyte	_var02, ptr__usbnew_spin2_dat__
022d8     15 00 00 3F 
022dc     87 72 86 31 |  if_ae	sub	ptr__usbnew_spin2_dat__, ##10887
022e0                 | LR__0220
022e0     3E 77 02 F6 | 	mov	result1, _var01
022e4                 | _usbnew_spin2_start_ret
022e4     2D 00 64 FD | 	ret
022e8                 | 
022e8                 | ' 
022e8                 | ' '' Emulate mouse movement
022e8                 | ' PUB mouse_move(x,y)
022e8                 | _usbnew_spin2_mouse_move
022e8     02 CA 05 F6 | 	mov	COUNT_, #2
022ec     E8 00 A0 FD | 	call	#pushregs_
022f0     48 A7 02 F6 | 	mov	local01, arg01
022f4     49 A9 02 F6 | 	mov	local02, arg02
022f8                 | '   mouse_lock := 1
022f8     14 00 00 FF 
022fc     F1 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10481
02300     39 03 48 FC | 	wrbyte	#1, ptr__usbnew_spin2_dat__
02304     14 00 00 FF 
02308     F1 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##10481
0230c                 | '   waitus(2) ' hope driver is now done
0230c     02 90 06 F6 | 	mov	arg01, #2
02310     F4 0B B0 FD | 	call	#__system___waitus
02314                 | '   mouse_xacc := x
02314     14 00 00 FF 
02318     E1 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10465
0231c     39 A7 62 FC | 	wrlong	local01, ptr__usbnew_spin2_dat__
02320                 | '   mouse_yacc := y
02320     04 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, #4
02324     39 A9 62 FC | 	wrlong	local02, ptr__usbnew_spin2_dat__
02328                 | '   if mouse_outptr
02328     05 00 00 FF 
0232c     15 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##2581
02330     39 93 0A FB | 	rdlong	arg02, ptr__usbnew_spin2_dat__ wz
02334     0F 00 00 FF 
02338     D0 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##7888
0233c     24 00 90 AD |  if_e	jmp	#LR__0230
02340                 | '     long[mouse_outptr] := y << 16 | x & $FFFF
02340     10 A8 66 F0 | 	shl	local02, #16
02344     53 A7 32 F9 | 	getword	local01, local01, #0
02348     53 A9 42 F5 | 	or	local02, local01
0234c     0F 00 00 FF 
02350     D0 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##7888
02354     39 A7 02 FB | 	rdlong	local01, ptr__usbnew_spin2_dat__
02358     0F 00 00 FF 
0235c     D0 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##7888
02360     53 A9 62 FC | 	wrlong	local02, local01
02364                 | LR__0230
02364                 | '   mouse_lock := 0
02364     14 00 00 FF 
02368     F1 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10481
0236c     39 01 48 FC | 	wrbyte	#0, ptr__usbnew_spin2_dat__
02370     14 00 00 FF 
02374     F1 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##10481
02378     E7 F0 03 F6 | 	mov	ptra, fp
0237c     F2 00 A0 FD | 	call	#popregs_
02380                 | _usbnew_spin2_mouse_move_ret
02380     2D 00 64 FD | 	ret
02384                 | 
02384                 | ' 
02384                 | ' '--------------------------------------------------------------
02384                 | ' '---------- Init the variables, start the cog. ----------------
02384                 | ' '--------------------------------------------------------------
02384                 | ' 
02384                 | ' pub start(mbox,scope,cache) :cog,base | iii
02384                 | _Audio2_004_spin2_start
02384     04 CA 05 F6 | 	mov	COUNT_, #4
02388     E8 00 A0 FD | 	call	#pushregs_
0238c     48 A7 02 F6 | 	mov	local01, arg01
02390                 | ' 
02390                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
02390                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
02390                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
02390                 | ' 
02390                 | ' mailboxaddr:=mbox 
02390     31 A7 62 FC | 	wrlong	local01, objptr
02394                 | ' scope_ptr:=scope
02394     04 62 06 F1 | 	add	objptr, #4
02398     31 93 62 FC | 	wrlong	arg02, objptr
0239c                 | ' cache_ptr:=cache
0239c     04 62 06 F1 | 	add	objptr, #4
023a0     31 95 62 FC | 	wrlong	arg03, objptr
023a4                 | ' base:=@channel0[0]
023a4     04 62 06 F1 | 	add	objptr, #4
023a8     31 A9 02 F6 | 	mov	local02, objptr
023ac                 | ' 
023ac                 | ' repeat iii from 0 to 15
023ac     00 AA 06 F6 | 	mov	local03, #0
023b0     0C 62 86 F1 | 	sub	objptr, #12
023b4     D7 1A 49 FB | 	callpa	#(@LR__0241-@LR__0240)>>2,fcache_load_ptr_
023b8                 | LR__0240
023b8                 | '   long[base+64*iii]:=0
023b8     54 A7 02 F6 | 	mov	local01, local02
023bc     55 79 02 F6 | 	mov	result2, local03
023c0     06 78 66 F0 | 	shl	result2, #6
023c4     3C A7 02 F1 | 	add	local01, result2
023c8     53 01 68 FC | 	wrlong	#0, local01
023cc                 | '   long[base+64*iii+4]:=0  		
023cc     54 A7 02 F6 | 	mov	local01, local02
023d0     55 79 02 F6 | 	mov	result2, local03
023d4     06 78 66 F0 | 	shl	result2, #6
023d8     3C A7 02 F1 | 	add	local01, result2
023dc     04 A6 06 F1 | 	add	local01, #4
023e0     53 01 68 FC | 	wrlong	#0, local01
023e4                 | '   long[base+64*iii+8]:=0
023e4     54 AD 02 F6 | 	mov	local04, local02
023e8     55 A7 02 F6 | 	mov	local01, local03
023ec     06 A6 66 F0 | 	shl	local01, #6
023f0     53 AD 02 F1 | 	add	local04, local01
023f4     08 AC 06 F1 | 	add	local04, #8
023f8     56 01 68 FC | 	wrlong	#0, local04
023fc                 | '   long[base+64*iii+12]:=0
023fc     54 AD 02 F6 | 	mov	local04, local02
02400     55 A7 02 F6 | 	mov	local01, local03
02404     06 A6 66 F0 | 	shl	local01, #6
02408     53 AD 02 F1 | 	add	local04, local01
0240c     0C AC 06 F1 | 	add	local04, #12
02410     56 01 68 FC | 	wrlong	#0, local04
02414                 | '   long[base+64*iii+16]:=0
02414     54 AD 02 F6 | 	mov	local04, local02
02418     55 A7 02 F6 | 	mov	local01, local03
0241c     06 A6 66 F0 | 	shl	local01, #6
02420     53 AD 02 F1 | 	add	local04, local01
02424     10 AC 06 F1 | 	add	local04, #16
02428     56 01 68 FC | 	wrlong	#0, local04
0242c                 | '   long[base+64*iii+20]:=0
0242c     54 AD 02 F6 | 	mov	local04, local02
02430     55 A7 02 F6 | 	mov	local01, local03
02434     06 A6 66 F0 | 	shl	local01, #6
02438     53 AD 02 F1 | 	add	local04, local01
0243c     14 AC 06 F1 | 	add	local04, #20
02440     56 01 68 FC | 	wrlong	#0, local04
02444                 | '   long[base+64*iii+24]:=0
02444     54 AD 02 F6 | 	mov	local04, local02
02448     55 A7 02 F6 | 	mov	local01, local03
0244c     06 A6 66 F0 | 	shl	local01, #6
02450     53 AD 02 F1 | 	add	local04, local01
02454     18 AC 06 F1 | 	add	local04, #24
02458     56 01 68 FC | 	wrlong	#0, local04
0245c                 | '   long[base+64*iii+28]:=0
0245c     54 AD 02 F6 | 	mov	local04, local02
02460     55 A7 02 F6 | 	mov	local01, local03
02464     06 A6 66 F0 | 	shl	local01, #6
02468     53 AD 02 F1 | 	add	local04, local01
0246c     1C AC 06 F1 | 	add	local04, #28
02470     56 01 68 FC | 	wrlong	#0, local04
02474                 | '   word[base+64*iii+32]:=8192
02474     54 AD 02 F6 | 	mov	local04, local02
02478     55 A7 02 F6 | 	mov	local01, local03
0247c     06 A6 66 F0 | 	shl	local01, #6
02480     53 AD 02 F1 | 	add	local04, local01
02484     20 AC 06 F1 | 	add	local04, #32
02488     10 00 80 FF 
0248c     56 01 58 FC | 	wrword	##8192, local04
02490                 | '   word[base+64*iii+34]:=8192
02490     54 AD 02 F6 | 	mov	local04, local02
02494     55 A7 02 F6 | 	mov	local01, local03
02498     06 A6 66 F0 | 	shl	local01, #6
0249c     53 AD 02 F1 | 	add	local04, local01
024a0     22 AC 06 F1 | 	add	local04, #34
024a4     10 00 80 FF 
024a8     56 01 58 FC | 	wrword	##8192, local04
024ac                 | '   long[base+64*iii+36]:=0
024ac     54 AD 02 F6 | 	mov	local04, local02
024b0     55 A7 02 F6 | 	mov	local01, local03
024b4     06 A6 66 F0 | 	shl	local01, #6
024b8     53 AD 02 F1 | 	add	local04, local01
024bc     24 AC 06 F1 | 	add	local04, #36
024c0     56 01 68 FC | 	wrlong	#0, local04
024c4                 | '   long[base+64*iii+40]:=0
024c4     54 AD 02 F6 | 	mov	local04, local02
024c8     55 A7 02 F6 | 	mov	local01, local03
024cc     06 A6 66 F0 | 	shl	local01, #6
024d0     53 AD 02 F1 | 	add	local04, local01
024d4     28 AC 06 F1 | 	add	local04, #40
024d8     56 01 68 FC | 	wrlong	#0, local04
024dc                 | '   long[base+64*iii+44]:=0
024dc     54 AD 02 F6 | 	mov	local04, local02
024e0     55 A7 02 F6 | 	mov	local01, local03
024e4     06 A6 66 F0 | 	shl	local01, #6
024e8     53 AD 02 F1 | 	add	local04, local01
024ec     2C AC 06 F1 | 	add	local04, #44
024f0     56 01 68 FC | 	wrlong	#0, local04
024f4                 | '   long[base+64*iii+48]:=0
024f4     54 AD 02 F6 | 	mov	local04, local02
024f8     55 A7 02 F6 | 	mov	local01, local03
024fc     06 A6 66 F0 | 	shl	local01, #6
02500     53 AD 02 F1 | 	add	local04, local01
02504     30 AC 06 F1 | 	add	local04, #48
02508     56 01 68 FC | 	wrlong	#0, local04
0250c                 | '   long[base+64*iii+52]:=0
0250c     54 AD 02 F6 | 	mov	local04, local02
02510     55 A7 02 F6 | 	mov	local01, local03
02514     06 A6 66 F0 | 	shl	local01, #6
02518     53 AD 02 F1 | 	add	local04, local01
0251c     34 AC 06 F1 | 	add	local04, #52
02520     56 01 68 FC | 	wrlong	#0, local04
02524                 | '   freqs[iii]:=440000
02524     55 AD 02 F6 | 	mov	local04, local03
02528     02 AC 66 F0 | 	shl	local04, #2
0252c     02 00 00 FF 
02530     0C 62 06 F1 | 	add	objptr, ##1036
02534     31 AD 02 F1 | 	add	local04, objptr
02538     5B 03 80 FF 
0253c     56 81 69 FC | 	wrlong	##440000, local04
02540                 | '   delays[iii]:=0
02540     55 AD 02 F6 | 	mov	local04, local03
02544     01 AC 66 F0 | 	shl	local04, #1
02548     40 62 06 F1 | 	add	objptr, #64
0254c     31 AD 02 F1 | 	add	local04, objptr
02550     56 01 58 FC | 	wrword	#0, local04
02554                 | '   volumes[iii]:=4096
02554     55 AD 02 F6 | 	mov	local04, local03
02558     01 AC 66 F0 | 	shl	local04, #1
0255c     20 62 06 F1 | 	add	objptr, #32
02560     31 AD 02 F1 | 	add	local04, objptr
02564     08 00 80 FF 
02568     56 01 58 FC | 	wrword	##4096, local04
0256c                 | '   waveforms[iii]:=0
0256c     55 AD 02 F6 | 	mov	local04, local03
02570     02 AC 66 F0 | 	shl	local04, #2
02574     20 62 06 F1 | 	add	objptr, #32
02578     31 AD 02 F1 | 	add	local04, objptr
0257c     56 01 68 FC | 	wrlong	#0, local04
02580                 | '   envelopes[iii]:=0
02580     55 AD 02 F6 | 	mov	local04, local03
02584     02 AC 66 F0 | 	shl	local04, #2
02588     40 62 06 F1 | 	add	objptr, #64
0258c     31 AD 02 F1 | 	add	local04, objptr
02590     56 01 68 FC | 	wrlong	#0, local04
02594                 | '   lengths[iii]:=1000
02594     55 AD 02 F6 | 	mov	local04, local03
02598     01 AC 66 F0 | 	shl	local04, #1
0259c     40 62 06 F1 | 	add	objptr, #64
025a0     31 AD 02 F1 | 	add	local04, objptr
025a4     01 00 80 FF 
025a8     56 D1 5B FC | 	wrword	##1000, local04
025ac                 | '   pans[iii]:=8192
025ac     55 AD 02 F6 | 	mov	local04, local03
025b0     01 AC 66 F0 | 	shl	local04, #1
025b4     20 62 06 F1 | 	add	objptr, #32
025b8     31 AD 02 F1 | 	add	local04, objptr
025bc     10 00 80 FF 
025c0     56 01 58 FC | 	wrword	##8192, local04
025c4                 | '   sustains[iii]:=255
025c4     55 AD 02 F6 | 	mov	local04, local03
025c8     01 AC 66 F0 | 	shl	local04, #1
025cc     20 62 06 F1 | 	add	objptr, #32
025d0     31 AD 02 F1 | 	add	local04, objptr
025d4     56 FF 59 FC | 	wrword	#255, local04
025d8     01 AA 06 F1 | 	add	local03, #1
025dc     10 AA 56 F2 | 	cmps	local03, #16 wc
025e0     02 00 00 FF 
025e4     4C 63 86 F1 | 	sub	objptr, ##1356
025e8     CC FD 9F CD |  if_b	jmp	#LR__0240
025ec                 | LR__0241
025ec                 | '   
025ec                 | ' cog:=coginit(16,@audio,@mailboxaddr)
025ec     32 93 02 F6 | 	mov	arg02, ptr__Audio2_004_spin2_dat__
025f0     31 95 02 F6 | 	mov	arg03, objptr
025f4     10 AC 06 F6 | 	mov	local04, #16
025f8     28 94 62 FD | 	setq	arg03
025fc     49 AD F2 FC | 	coginit	local04, arg02 wc
02600     01 AC 66 C6 |  if_b	neg	local04, #1
02604                 | ' waitms(10)
02604     0A 90 06 F6 | 	mov	arg01, #10
02608     90 08 B0 FD | 	call	#__system___waitms
0260c                 | ' return cog,base
0260c     54 79 02 F6 | 	mov	result2, local02
02610     56 77 02 F6 | 	mov	result1, local04
02614     E7 F0 03 F6 | 	mov	ptra, fp
02618     F2 00 A0 FD | 	call	#popregs_
0261c                 | _Audio2_004_spin2_start_ret
0261c     2D 00 64 FD | 	ret
02620                 | 
02620                 | ' 
02620                 | ' sub create(avdrv as vdrv,ax=0,ay=0,aw=16,ah=128,amin=0,amax=10,aticks=11,ac1=244,ac2=248,alabel$="")
02620                 | _trackbar_create
02620     04 62 06 F1 | 	add	objptr, #4
02624     31 93 62 FC | 	wrlong	arg02, objptr
02628     04 62 06 F1 | 	add	objptr, #4
0262c     31 95 62 FC | 	wrlong	arg03, objptr
02630     04 62 06 F1 | 	add	objptr, #4
02634     31 97 62 FC | 	wrlong	arg04, objptr
02638     04 62 06 F1 | 	add	objptr, #4
0263c     31 99 62 FC | 	wrlong	arg05, objptr
02640     04 62 06 F1 | 	add	objptr, #4
02644     31 9B 62 FC | 	wrlong	arg06, objptr
02648     04 62 06 F1 | 	add	objptr, #4
0264c     31 9D 62 FC | 	wrlong	arg07, objptr
02650     04 62 06 F1 | 	add	objptr, #4
02654     31 9F 62 FC | 	wrlong	arg08, objptr
02658     04 62 06 F1 | 	add	objptr, #4
0265c     31 A1 62 FC | 	wrlong	arg09, objptr
02660     04 62 06 F1 | 	add	objptr, #4
02664     31 A3 62 FC | 	wrlong	arg10, objptr
02668     04 62 06 F1 | 	add	objptr, #4
0266c     31 A5 62 FC | 	wrlong	arg11, objptr
02670     04 62 06 F1 | 	add	objptr, #4
02674     48 93 02 F6 | 	mov	arg02, arg01
02678     31 91 02 F6 | 	mov	arg01, objptr
0267c     0B 00 00 FF 
02680     CC 94 06 F6 | 	mov	arg03, ##5836
02684     2C 62 86 F1 | 	sub	objptr, #44
02688     4C 06 B0 FD | 	call	#__system____builtin_memmove
0268c     04 00 B0 FD | 	call	#_trackbar_draw
02690                 | _trackbar_create_ret
02690     2D 00 64 FD | 	ret
02694                 | 
02694                 | ' 
02694                 | ' 
02694                 | ' sub draw
02694                 | _trackbar_draw
02694     09 CA 05 F6 | 	mov	COUNT_, #9
02698     E8 00 A0 FD | 	call	#pushregs_
0269c     04 62 06 F1 | 	add	objptr, #4
026a0     31 91 02 FB | 	rdlong	arg01, objptr
026a4     04 62 06 F1 | 	add	objptr, #4
026a8     31 93 02 FB | 	rdlong	arg02, objptr
026ac     48 95 02 F6 | 	mov	arg03, arg01
026b0     04 62 06 F1 | 	add	objptr, #4
026b4     31 77 02 FB | 	rdlong	result1, objptr
026b8     3B 95 02 F1 | 	add	arg03, result1
026bc     01 94 86 F1 | 	sub	arg03, #1
026c0     49 97 02 F6 | 	mov	arg04, arg02
026c4     04 62 06 F1 | 	add	objptr, #4
026c8     31 77 02 FB | 	rdlong	result1, objptr
026cc     3B 97 02 F1 | 	add	arg04, result1
026d0     01 96 86 F1 | 	sub	arg04, #1
026d4     10 62 06 F1 | 	add	objptr, #16
026d8     31 99 02 FB | 	rdlong	arg05, objptr
026dc     0C 62 06 F1 | 	add	objptr, #12
026e0     B0 ED BF FD | 	call	#_hg010b_spin2_box
026e4     28 62 86 F1 | 	sub	objptr, #40
026e8     31 91 02 FB | 	rdlong	arg01, objptr
026ec     03 90 06 F1 | 	add	arg01, #3
026f0     04 62 06 F1 | 	add	objptr, #4
026f4     31 93 02 FB | 	rdlong	arg02, objptr
026f8     03 92 06 F1 | 	add	arg02, #3
026fc     04 62 86 F1 | 	sub	objptr, #4
02700     31 95 02 FB | 	rdlong	arg03, objptr
02704     08 62 06 F1 | 	add	objptr, #8
02708     31 77 02 FB | 	rdlong	result1, objptr
0270c     3B 95 02 F1 | 	add	arg03, result1
02710     04 94 86 F1 | 	sub	arg03, #4
02714     04 62 86 F1 | 	sub	objptr, #4
02718     31 97 02 FB | 	rdlong	arg04, objptr
0271c     08 62 06 F1 | 	add	objptr, #8
02720     31 77 02 FB | 	rdlong	result1, objptr
02724     3B 97 02 F1 | 	add	arg04, result1
02728     04 96 86 F1 | 	sub	arg04, #4
0272c     14 62 06 F1 | 	add	objptr, #20
02730     31 99 02 FB | 	rdlong	arg05, objptr
02734     08 62 06 F1 | 	add	objptr, #8
02738     58 ED BF FD | 	call	#_hg010b_spin2_box
0273c     1C 62 86 F1 | 	sub	objptr, #28
02740     31 91 02 FB | 	rdlong	arg01, objptr
02744     10 62 86 F1 | 	sub	objptr, #16
02748     48 91 52 F6 | 	abs	arg01, arg01 wc
0274c     1F A6 C6 C9 |  if_b	decod	local01, #31
02750     00 A6 06 36 |  if_ae	mov	local01, #0
02754     74 1A B0 FD | 	call	#__system___float_fromuns
02758     53 77 62 F5 | 	xor	result1, local01
0275c     3B A9 02 F6 | 	mov	local02, result1
02760     1C 62 06 F1 | 	add	objptr, #28
02764     31 91 02 FB | 	rdlong	arg01, objptr
02768     1C 62 86 F1 | 	sub	objptr, #28
0276c     01 90 86 F1 | 	sub	arg01, #1
02770     48 91 52 F6 | 	abs	arg01, arg01 wc
02774     1F A6 C6 C9 |  if_b	decod	local01, #31
02778     00 A6 06 36 |  if_ae	mov	local01, #0
0277c     4C 1A B0 FD | 	call	#__system___float_fromuns
02780     53 77 62 F5 | 	xor	result1, local01
02784     3B 93 02 F6 | 	mov	arg02, result1
02788     54 91 02 F6 | 	mov	arg01, local02
0278c     6C 1F B0 FD | 	call	#__system___float_div
02790     3B AB 02 F6 | 	mov	local03, result1
02794     00 90 06 F6 | 	mov	arg01, #0
02798     5C 3A B0 FD | 	call	#__system___getiolock_0133
0279c     3B 91 02 F6 | 	mov	arg01, result1
027a0     14 06 B0 FD | 	call	#__system___lockmem
027a4     00 90 06 F6 | 	mov	arg01, #0
027a8     55 93 02 F6 | 	mov	arg02, local03
027ac     00 94 06 F6 | 	mov	arg03, #0
027b0     23 96 06 F6 | 	mov	arg04, #35
027b4     64 23 B0 FD | 	call	#__system___basic_print_float
027b8     00 90 06 F6 | 	mov	arg01, #0
027bc     0A 92 06 F6 | 	mov	arg02, #10
027c0     00 94 06 F6 | 	mov	arg03, #0
027c4     D8 0F B0 FD | 	call	#__system___basic_print_char
027c8     00 90 06 F6 | 	mov	arg01, #0
027cc     28 3A B0 FD | 	call	#__system___getiolock_0133
027d0     3B 01 68 FC | 	wrlong	#0, result1
027d4     18 62 06 F1 | 	add	objptr, #24
027d8     31 91 02 FB | 	rdlong	arg01, objptr
027dc     04 62 86 F1 | 	sub	objptr, #4
027e0     31 A9 02 FB | 	rdlong	local02, objptr
027e4     14 62 86 F1 | 	sub	objptr, #20
027e8     54 91 82 F1 | 	sub	arg01, local02
027ec     48 91 52 F6 | 	abs	arg01, arg01 wc
027f0     1F A6 C6 C9 |  if_b	decod	local01, #31
027f4     00 A6 06 36 |  if_ae	mov	local01, #0
027f8     D0 19 B0 FD | 	call	#__system___float_fromuns
027fc     53 77 62 F5 | 	xor	result1, local01
02800     3B A9 02 F6 | 	mov	local02, result1
02804     1C 62 06 F1 | 	add	objptr, #28
02808     31 91 02 FB | 	rdlong	arg01, objptr
0280c     1C 62 86 F1 | 	sub	objptr, #28
02810     01 90 86 F1 | 	sub	arg01, #1
02814     48 91 52 F6 | 	abs	arg01, arg01 wc
02818     1F A6 C6 C9 |  if_b	decod	local01, #31
0281c     00 A6 06 36 |  if_ae	mov	local01, #0
02820     A8 19 B0 FD | 	call	#__system___float_fromuns
02824     53 77 62 F5 | 	xor	result1, local01
02828     3B 93 02 F6 | 	mov	arg02, result1
0282c     54 91 02 F6 | 	mov	arg01, local02
02830     C8 1E B0 FD | 	call	#__system___float_div
02834     3B AD 02 F6 | 	mov	local04, result1
02838     00 90 06 F6 | 	mov	arg01, #0
0283c     B8 39 B0 FD | 	call	#__system___getiolock_0133
02840     3B 91 02 F6 | 	mov	arg01, result1
02844     70 05 B0 FD | 	call	#__system___lockmem
02848     00 90 06 F6 | 	mov	arg01, #0
0284c     56 93 02 F6 | 	mov	arg02, local04
02850     00 94 06 F6 | 	mov	arg03, #0
02854     23 96 06 F6 | 	mov	arg04, #35
02858     C0 22 B0 FD | 	call	#__system___basic_print_float
0285c     00 90 06 F6 | 	mov	arg01, #0
02860     0A 92 06 F6 | 	mov	arg02, #10
02864     00 94 06 F6 | 	mov	arg03, #0
02868     34 0F B0 FD | 	call	#__system___basic_print_char
0286c     00 90 06 F6 | 	mov	arg01, #0
02870     84 39 B0 FD | 	call	#__system___getiolock_0133
02874     3B 01 68 FC | 	wrlong	#0, result1
02878                 | ' 
02878                 | ' for i=0 to ticks-1: v.fastline(x,x+3,round(y+h-i*hr),0) : v.outtextxycf(x-8-4*len(str$(round(min+i*dv))),round(y+h-i*hr)-8,str$(round(min+i*dv)),c2):next i
02878     00 AE 06 F6 | 	mov	local05, #0
0287c     1C 62 06 F1 | 	add	objptr, #28
02880     31 B1 02 FB | 	rdlong	local06, objptr
02884     1C 62 86 F1 | 	sub	objptr, #28
02888                 | LR__0250
02888     58 AF 52 F2 | 	cmps	local05, local06 wc
0288c     54 02 90 3D |  if_ae	jmp	#LR__0253
02890     04 62 06 F1 | 	add	objptr, #4
02894     31 B3 02 FB | 	rdlong	local07, objptr
02898     59 A9 02 F6 | 	mov	local02, local07
0289c     04 62 06 F1 | 	add	objptr, #4
028a0     31 91 02 FB | 	rdlong	arg01, objptr
028a4     08 62 06 F1 | 	add	objptr, #8
028a8     31 99 02 FB | 	rdlong	arg05, objptr
028ac     10 62 86 F1 | 	sub	objptr, #16
028b0     4C 91 02 F1 | 	add	arg01, arg05
028b4     03 B2 06 F1 | 	add	local07, #3
028b8     48 91 52 F6 | 	abs	arg01, arg01 wc
028bc     1F A6 C6 C9 |  if_b	decod	local01, #31
028c0     00 A6 06 36 |  if_ae	mov	local01, #0
028c4     04 19 B0 FD | 	call	#__system___float_fromuns
028c8     53 77 62 F5 | 	xor	result1, local01
028cc     3B B5 02 F6 | 	mov	local08, result1
028d0     57 91 52 F6 | 	abs	arg01, local05 wc
028d4     1F A6 C6 C9 |  if_b	decod	local01, #31
028d8     00 A6 06 36 |  if_ae	mov	local01, #0
028dc     EC 18 B0 FD | 	call	#__system___float_fromuns
028e0     53 77 62 F5 | 	xor	result1, local01
028e4     3B 91 02 F6 | 	mov	arg01, result1
028e8     55 93 02 F6 | 	mov	arg02, local03
028ec     08 1C B0 FD | 	call	#__system___float_mul
028f0     3B 93 02 F6 | 	mov	arg02, result1
028f4     5A 91 02 F6 | 	mov	arg01, local08
028f8     1F 92 E6 F4 | 	bitnot	arg02, #31
028fc     00 19 B0 FD | 	call	#__system___float_add
02900     3B 91 02 F6 | 	mov	arg01, result1
02904     01 92 06 F6 | 	mov	arg02, #1
02908     B4 20 B0 FD | 	call	#__system___float_tointeger
0290c     3B 95 02 F6 | 	mov	arg03, result1
02910     54 91 02 F6 | 	mov	arg01, local02
02914     59 93 02 F6 | 	mov	arg02, local07
02918     00 96 06 F6 | 	mov	arg04, #0
0291c     2C 62 06 F1 | 	add	objptr, #44
02920     58 EA BF FD | 	call	#_hg010b_spin2_fastline
02924     28 62 86 F1 | 	sub	objptr, #40
02928     31 A9 02 FB | 	rdlong	local02, objptr
0292c     08 A8 86 F1 | 	sub	local02, #8
02930     10 62 06 F1 | 	add	objptr, #16
02934     31 91 02 FB | 	rdlong	arg01, objptr
02938     14 62 86 F1 | 	sub	objptr, #20
0293c     48 91 52 F6 | 	abs	arg01, arg01 wc
02940     1F A6 C6 C9 |  if_b	decod	local01, #31
02944     00 A6 06 36 |  if_ae	mov	local01, #0
02948     80 18 B0 FD | 	call	#__system___float_fromuns
0294c     53 77 62 F5 | 	xor	result1, local01
02950     3B B5 02 F6 | 	mov	local08, result1
02954     57 91 52 F6 | 	abs	arg01, local05 wc
02958     1F A6 C6 C9 |  if_b	decod	local01, #31
0295c     00 A6 06 36 |  if_ae	mov	local01, #0
02960     68 18 B0 FD | 	call	#__system___float_fromuns
02964     53 77 62 F5 | 	xor	result1, local01
02968     3B 91 02 F6 | 	mov	arg01, result1
0296c     56 93 02 F6 | 	mov	arg02, local04
02970     84 1B B0 FD | 	call	#__system___float_mul
02974     3B 93 02 F6 | 	mov	arg02, result1
02978     5A 91 02 F6 | 	mov	arg01, local08
0297c     80 18 B0 FD | 	call	#__system___float_add
02980     3B 91 02 F6 | 	mov	arg01, result1
02984     01 92 06 F6 | 	mov	arg02, #1
02988     34 20 B0 FD | 	call	#__system___float_tointeger
0298c     3B 91 52 F6 | 	abs	arg01, result1 wc
02990     1F A6 C6 C9 |  if_b	decod	local01, #31
02994     00 A6 06 36 |  if_ae	mov	local01, #0
02998     30 18 B0 FD | 	call	#__system___float_fromuns
0299c     53 77 62 F5 | 	xor	result1, local01
029a0     3B 91 02 F6 | 	mov	arg01, result1
029a4     E0 16 B0 FD | 	call	#__system__str_S
029a8     3B 91 02 F6 | 	mov	arg01, result1
029ac     48 B7 02 F6 | 	mov	local09, arg01
029b0     D7 06 48 FB | 	callpa	#(@LR__0252-@LR__0251)>>2,fcache_load_ptr_
029b4                 | LR__0251
029b4     5B 77 CA FA | 	rdbyte	result1, local09 wz
029b8     01 B6 06 51 |  if_ne	add	local09, #1
029bc     F4 FF 9F 5D |  if_ne	jmp	#LR__0251
029c0                 | LR__0252
029c0     48 B7 82 F1 | 	sub	local09, arg01
029c4     5B 77 02 F6 | 	mov	result1, local09
029c8     02 76 66 F0 | 	shl	result1, #2
029cc     3B A9 82 F1 | 	sub	local02, result1
029d0     08 62 06 F1 | 	add	objptr, #8
029d4     31 91 02 FB | 	rdlong	arg01, objptr
029d8     08 62 06 F1 | 	add	objptr, #8
029dc     31 B5 02 FB | 	rdlong	local08, objptr
029e0     10 62 86 F1 | 	sub	objptr, #16
029e4     5A 91 02 F1 | 	add	arg01, local08
029e8     48 91 52 F6 | 	abs	arg01, arg01 wc
029ec     1F A6 C6 C9 |  if_b	decod	local01, #31
029f0     00 A6 06 36 |  if_ae	mov	local01, #0
029f4     D4 17 B0 FD | 	call	#__system___float_fromuns
029f8     53 77 62 F5 | 	xor	result1, local01
029fc     3B B5 02 F6 | 	mov	local08, result1
02a00     57 91 52 F6 | 	abs	arg01, local05 wc
02a04     1F A6 C6 C9 |  if_b	decod	local01, #31
02a08     00 A6 06 36 |  if_ae	mov	local01, #0
02a0c     BC 17 B0 FD | 	call	#__system___float_fromuns
02a10     53 77 62 F5 | 	xor	result1, local01
02a14     3B 91 02 F6 | 	mov	arg01, result1
02a18     55 93 02 F6 | 	mov	arg02, local03
02a1c     D8 1A B0 FD | 	call	#__system___float_mul
02a20     3B 93 02 F6 | 	mov	arg02, result1
02a24     5A 91 02 F6 | 	mov	arg01, local08
02a28     1F 92 E6 F4 | 	bitnot	arg02, #31
02a2c     D0 17 B0 FD | 	call	#__system___float_add
02a30     3B 91 02 F6 | 	mov	arg01, result1
02a34     01 92 06 F6 | 	mov	arg02, #1
02a38     84 1F B0 FD | 	call	#__system___float_tointeger
02a3c     08 76 86 F1 | 	sub	result1, #8
02a40     3B B3 02 F6 | 	mov	local07, result1
02a44     14 62 06 F1 | 	add	objptr, #20
02a48     31 91 02 FB | 	rdlong	arg01, objptr
02a4c     14 62 86 F1 | 	sub	objptr, #20
02a50     48 91 52 F6 | 	abs	arg01, arg01 wc
02a54     1F A6 C6 C9 |  if_b	decod	local01, #31
02a58     00 A6 06 36 |  if_ae	mov	local01, #0
02a5c     6C 17 B0 FD | 	call	#__system___float_fromuns
02a60     53 77 62 F5 | 	xor	result1, local01
02a64     3B B5 02 F6 | 	mov	local08, result1
02a68     57 91 52 F6 | 	abs	arg01, local05 wc
02a6c     1F A6 C6 C9 |  if_b	decod	local01, #31
02a70     00 A6 06 36 |  if_ae	mov	local01, #0
02a74     54 17 B0 FD | 	call	#__system___float_fromuns
02a78     53 77 62 F5 | 	xor	result1, local01
02a7c     3B 91 02 F6 | 	mov	arg01, result1
02a80     56 93 02 F6 | 	mov	arg02, local04
02a84     70 1A B0 FD | 	call	#__system___float_mul
02a88     3B 93 02 F6 | 	mov	arg02, result1
02a8c     5A 91 02 F6 | 	mov	arg01, local08
02a90     6C 17 B0 FD | 	call	#__system___float_add
02a94     3B 91 02 F6 | 	mov	arg01, result1
02a98     01 92 06 F6 | 	mov	arg02, #1
02a9c     20 1F B0 FD | 	call	#__system___float_tointeger
02aa0     3B 91 52 F6 | 	abs	arg01, result1 wc
02aa4     1F A6 C6 C9 |  if_b	decod	local01, #31
02aa8     00 A6 06 36 |  if_ae	mov	local01, #0
02aac     1C 17 B0 FD | 	call	#__system___float_fromuns
02ab0     53 77 62 F5 | 	xor	result1, local01
02ab4     3B 91 02 F6 | 	mov	arg01, result1
02ab8     CC 15 B0 FD | 	call	#__system__str_S
02abc     3B 95 02 F6 | 	mov	arg03, result1
02ac0     24 62 06 F1 | 	add	objptr, #36
02ac4     31 97 02 FB | 	rdlong	arg04, objptr
02ac8     54 91 02 F6 | 	mov	arg01, local02
02acc     59 93 02 F6 | 	mov	arg02, local07
02ad0     08 62 06 F1 | 	add	objptr, #8
02ad4     C4 EB BF FD | 	call	#_hg010b_spin2_outtextxycf
02ad8     2C 62 86 F1 | 	sub	objptr, #44
02adc     01 AE 06 F1 | 	add	local05, #1
02ae0     A4 FD 9F FD | 	jmp	#LR__0250
02ae4                 | LR__0253
02ae4     E7 F0 03 F6 | 	mov	ptra, fp
02ae8     F2 00 A0 FD | 	call	#popregs_
02aec                 | _trackbar_draw_ret
02aec     2D 00 64 FD | 	ret
02af0                 | hubexit
02af0     C1 00 80 FD | 	jmp	#cogexit
02af4                 | 
02af4                 | __system___setbaud
02af4     14 F8 06 FB | 	rdlong	muldiva_, #20
02af8     48 FB 02 F6 | 	mov	muldivb_, arg01
02afc     FA 00 A0 FD | 	call	#divide_
02b00     D7 06 48 FB | 	callpa	#(@LR__0261-@LR__0260)>>2,fcache_load_ptr_
02b04                 | LR__0260
02b04     3E 76 9E FA | 	rdpin	result1, #62 wc
02b08     3C 79 A2 F1 | 	subx	result2, result2
02b0c     F4 FF 9F CD |  if_b	jmp	#LR__0260
02b10                 | LR__0261
02b10     40 7C 64 FD | 	dirl	#62
02b14     40 7E 64 FD | 	dirl	#63
02b18     33 FB 62 FC | 	wrlong	muldivb_, ptr___system__dat__
02b1c     10 FA 66 F0 | 	shl	muldivb_, #16
02b20     07 92 06 F6 | 	mov	arg02, #7
02b24     7D 93 02 F1 | 	add	arg02, muldivb_
02b28     3E F8 0C FC | 	wrpin	#124, #62
02b2c     3E 92 16 FC | 	wxpin	arg02, #62
02b30     3F 7C 0C FC | 	wrpin	#62, #63
02b34     14 92 06 F1 | 	add	arg02, #20
02b38     3F 92 16 FC | 	wxpin	arg02, #63
02b3c     41 7C 64 FD | 	dirh	#62
02b40     41 7E 64 FD | 	dirh	#63
02b44                 | __system___setbaud_ret
02b44     2D 00 64 FD | 	ret
02b48                 | 
02b48                 | __system___txraw
02b48     01 CA 05 F6 | 	mov	COUNT_, #1
02b4c     E8 00 A0 FD | 	call	#pushregs_
02b50     48 A7 02 F6 | 	mov	local01, arg01
02b54     D7 06 48 FB | 	callpa	#(@LR__0271-@LR__0270)>>2,fcache_load_ptr_
02b58                 | LR__0270
02b58     3E 76 9E FA | 	rdpin	result1, #62 wc
02b5c     3C 79 A2 F1 | 	subx	result2, result2
02b60     F4 FF 9F CD |  if_b	jmp	#LR__0270
02b64                 | LR__0271
02b64     33 77 0A FB | 	rdlong	result1, ptr___system__dat__ wz
02b68     42 0F 00 AF 
02b6c     80 90 06 A6 |  if_e	mov	arg01, ##2000000
02b70     80 FF BF AD |  if_e	call	#__system___setbaud
02b74     58 7C 64 FD | 	drvl	#62
02b78     3E A6 26 FC | 	wypin	local01, #62
02b7c     01 76 06 F6 | 	mov	result1, #1
02b80     E7 F0 03 F6 | 	mov	ptra, fp
02b84     F2 00 A0 FD | 	call	#popregs_
02b88                 | __system___txraw_ret
02b88     2D 00 64 FD | 	ret
02b8c                 | 
02b8c                 | __system___rxraw
02b8c     0D CA 05 F6 | 	mov	COUNT_, #13
02b90     E8 00 A0 FD | 	call	#pushregs_
02b94     48 A7 02 F6 | 	mov	local01, arg01
02b98     33 A9 0A FB | 	rdlong	local02, ptr___system__dat__ wz
02b9c     42 0F 00 AF 
02ba0     80 90 06 A6 |  if_e	mov	arg01, ##2000000
02ba4     4C FF BF AD |  if_e	call	#__system___setbaud
02ba8     00 A6 0E F2 | 	cmp	local01, #0 wz
02bac     20 00 90 AD |  if_e	jmp	#LR__0280
02bb0     14 AA 06 FB | 	rdlong	local03, #20
02bb4     0A AA 46 F0 | 	shr	local03, #10
02bb8     55 A7 02 FD | 	qmul	local01, local03
02bbc     1A 76 62 FD | 	getct	result1
02bc0     18 AC 62 FD | 	getqx	local04
02bc4     56 77 02 F1 | 	add	result1, local04
02bc8     3B AF 02 F6 | 	mov	local05, result1
02bcc     04 00 90 FD | 	jmp	#LR__0281
02bd0                 | LR__0280
02bd0     00 AE 06 F6 | 	mov	local05, #0
02bd4                 | LR__0281
02bd4     01 B0 66 F6 | 	neg	local06, #1
02bd8     3F B2 06 F6 | 	mov	local07, #63
02bdc     00 B4 06 F6 | 	mov	local08, #0
02be0     04 66 06 F1 | 	add	ptr___system__dat__, #4
02be4     33 B7 02 FB | 	rdlong	local09, ptr___system__dat__
02be8     04 66 86 F1 | 	sub	ptr___system__dat__, #4
02bec                 | LR__0282
02bec     08 B6 16 F4 | 	testb	local09, #8 wc
02bf0     09 B6 76 F4 | 	testbn	local09, #9 andc
02bf4     0A B6 46 F0 | 	shr	local09, #10
02bf8     01 B4 06 C6 |  if_b	mov	local08, #1
02bfc     40 7E 6C 3D |  if_ae	testp	#63 wz
02c00     01 B4 06 26 |  if_nc_and_z	mov	local08, #1
02c04     3F B6 8E 2A |  if_nc_and_z	rdpin	local09, #63
02c08     04 B6 46 20 |  if_nc_and_z	shr	local09, #4
02c0c                 | LR__0283
02c0c     00 A8 06 F6 | 	mov	local02, #0
02c10     00 B4 0E F2 | 	cmp	local08, #0 wz
02c14     01 A8 66 56 |  if_ne	neg	local02, #1
02c18     00 B8 06 F6 | 	mov	local10, #0
02c1c     00 AA 06 F6 | 	mov	local03, #0
02c20     00 A6 0E F2 | 	cmp	local01, #0 wz
02c24     01 AA 66 56 |  if_ne	neg	local03, #1
02c28     00 AC 06 F6 | 	mov	local04, #0
02c2c     00 BA 06 F6 | 	mov	local11, #0
02c30     57 BD 02 F6 | 	mov	local12, local05
02c34     1A 76 62 FD | 	getct	result1
02c38     3B BF 02 F6 | 	mov	local13, result1
02c3c     5F BD 82 F1 | 	sub	local12, local13
02c40     00 BC 56 F2 | 	cmps	local12, #0 wc
02c44     00 BA 26 C6 |  if_b	not	local11, #0
02c48     00 BA 0E F2 | 	cmp	local11, #0 wz
02c4c     00 AC 26 56 |  if_ne	not	local04, #0
02c50     56 AB CA F7 | 	test	local03, local04 wz
02c54     00 B8 26 56 |  if_ne	not	local10, #0
02c58     5C A9 4A F5 | 	or	local02, local10 wz
02c5c     8C FF 9F AD |  if_e	jmp	#LR__0282
02c60     00 B4 0E F2 | 	cmp	local08, #0 wz
02c64     5B B1 02 56 |  if_ne	mov	local06, local09
02c68     58 B1 E2 58 |  if_ne	getbyte	local06, local06, #0
02c6c     04 66 06 F1 | 	add	ptr___system__dat__, #4
02c70     33 B7 62 FC | 	wrlong	local09, ptr___system__dat__
02c74     04 66 86 F1 | 	sub	ptr___system__dat__, #4
02c78     58 77 02 F6 | 	mov	result1, local06
02c7c     E7 F0 03 F6 | 	mov	ptra, fp
02c80     F2 00 A0 FD | 	call	#popregs_
02c84                 | __system___rxraw_ret
02c84     2D 00 64 FD | 	ret
02c88                 | 
02c88                 | __system___getus
02c88     1A 78 72 FD | 	getct	result2 wc
02c8c     1A 7C 62 FD | 	getct	_var01
02c90     10 66 06 F1 | 	add	ptr___system__dat__, #16
02c94     33 7F 0A FB | 	rdlong	_var02, ptr___system__dat__ wz
02c98     10 66 86 F1 | 	sub	ptr___system__dat__, #16
02c9c     20 00 90 5D |  if_ne	jmp	#LR__0290
02ca0     14 7E 06 FB | 	rdlong	_var02, #20
02ca4     A1 07 00 FF 
02ca8     40 7E 16 FD | 	qdiv	_var02, ##1000000
02cac     10 66 06 F1 | 	add	ptr___system__dat__, #16
02cb0     18 76 62 FD | 	getqx	result1
02cb4     3B 7F 02 F6 | 	mov	_var02, result1
02cb8     33 77 62 FC | 	wrlong	result1, ptr___system__dat__
02cbc     10 66 86 F1 | 	sub	ptr___system__dat__, #16
02cc0                 | LR__0290
02cc0     3F 79 12 FD | 	qdiv	result2, _var02
02cc4     19 78 62 FD | 	getqy	result2
02cc8     28 78 62 FD | 	setq	result2
02ccc     3F 7D 12 FD | 	qdiv	_var01, _var02
02cd0     18 76 62 FD | 	getqx	result1
02cd4                 | __system___getus_ret
02cd4     2D 00 64 FD | 	ret
02cd8                 | 
02cd8                 | __system____builtin_memmove
02cd8     48 7D 02 F6 | 	mov	_var01, arg01
02cdc     49 91 52 F2 | 	cmps	arg01, arg02 wc
02ce0     10 00 90 CD |  if_b	jmp	#LR__0300
02ce4     49 7F 02 F6 | 	mov	_var02, arg02
02ce8     4A 7F 02 F1 | 	add	_var02, arg03
02cec     3F 91 52 F2 | 	cmps	arg01, _var02 wc
02cf0     48 00 90 CD |  if_b	jmp	#LR__0306
02cf4                 | LR__0300
02cf4     4A 81 02 F6 | 	mov	_var03, arg03
02cf8     02 80 4E F0 | 	shr	_var03, #2 wz
02cfc     18 00 90 AD |  if_e	jmp	#LR__0305
02d00     D7 0A 48 FB | 	callpa	#(@LR__0303-@LR__0301)>>2,fcache_load_ptr_
02d04                 | LR__0301
02d04     40 09 D8 FC | 	rep	@LR__0304, _var03
02d08                 | LR__0302
02d08     49 81 02 FB | 	rdlong	_var03, arg02
02d0c     48 81 62 FC | 	wrlong	_var03, arg01
02d10     04 90 06 F1 | 	add	arg01, #4
02d14     04 92 06 F1 | 	add	arg02, #4
02d18                 | LR__0303
02d18                 | LR__0304
02d18                 | LR__0305
02d18     02 94 CE F7 | 	test	arg03, #2 wz
02d1c     49 7F E2 5A |  if_ne	rdword	_var02, arg02
02d20     48 7F 52 5C |  if_ne	wrword	_var02, arg01
02d24     02 90 06 51 |  if_ne	add	arg01, #2
02d28     02 92 06 51 |  if_ne	add	arg02, #2
02d2c     01 94 CE F7 | 	test	arg03, #1 wz
02d30     49 7F C2 5A |  if_ne	rdbyte	_var02, arg02
02d34     48 7F 42 5C |  if_ne	wrbyte	_var02, arg01
02d38     28 00 90 FD | 	jmp	#LR__0312
02d3c                 | LR__0306
02d3c     4A 91 02 F1 | 	add	arg01, arg03
02d40     4A 93 02 F1 | 	add	arg02, arg03
02d44     4A 83 0A F6 | 	mov	_var04, arg03 wz
02d48     18 00 90 AD |  if_e	jmp	#LR__0311
02d4c     D7 0A 48 FB | 	callpa	#(@LR__0309-@LR__0307)>>2,fcache_load_ptr_
02d50                 | LR__0307
02d50     41 09 D8 FC | 	rep	@LR__0310, _var04
02d54                 | LR__0308
02d54     01 90 86 F1 | 	sub	arg01, #1
02d58     01 92 86 F1 | 	sub	arg02, #1
02d5c     49 7F C2 FA | 	rdbyte	_var02, arg02
02d60     48 7F 42 FC | 	wrbyte	_var02, arg01
02d64                 | LR__0309
02d64                 | LR__0310
02d64                 | LR__0311
02d64                 | LR__0312
02d64     3E 77 02 F6 | 	mov	result1, _var01
02d68                 | __system____builtin_memmove_ret
02d68     2D 00 64 FD | 	ret
02d6c                 | 
02d6c                 | __system____builtin_strcpy
02d6c     48 7D 02 F6 | 	mov	_var01, arg01
02d70     D7 0A 48 FB | 	callpa	#(@LR__0321-@LR__0320)>>2,fcache_load_ptr_
02d74                 | LR__0320
02d74     49 77 CA FA | 	rdbyte	result1, arg02 wz
02d78     48 77 42 FC | 	wrbyte	result1, arg01
02d7c     01 92 06 F1 | 	add	arg02, #1
02d80     01 90 06 F1 | 	add	arg01, #1
02d84     EC FF 9F 5D |  if_ne	jmp	#LR__0320
02d88                 | LR__0321
02d88     3E 77 02 F6 | 	mov	result1, _var01
02d8c                 | __system____builtin_strcpy_ret
02d8c     2D 00 64 FD | 	ret
02d90                 | 
02d90                 | __system____topofstack
02d90     00 CA 05 F6 | 	mov	COUNT_, #0
02d94     E8 00 A0 FD | 	call	#pushregs_
02d98     08 F0 07 F1 | 	add	ptra, #8
02d9c     04 CE 05 F1 | 	add	fp, #4
02da0     E7 90 62 FC | 	wrlong	arg01, fp
02da4     E7 76 02 F6 | 	mov	result1, fp
02da8     04 CE 85 F1 | 	sub	fp, #4
02dac     E7 F0 03 F6 | 	mov	ptra, fp
02db0     F2 00 A0 FD | 	call	#popregs_
02db4                 | __system____topofstack_ret
02db4     2D 00 64 FD | 	ret
02db8                 | 
02db8                 | __system___lockmem
02db8     00 76 06 F6 | 	mov	result1, #0
02dbc     01 76 62 FD | 	cogid	result1
02dc0     00 77 06 F1 | 	add	result1, #256
02dc4                 | LR__0330
02dc4     48 7D 0A FB | 	rdlong	_var01, arg01 wz
02dc8     48 77 62 AC |  if_e	wrlong	result1, arg01
02dcc     48 7D 02 AB |  if_e	rdlong	_var01, arg01
02dd0     48 7D 02 AB |  if_e	rdlong	_var01, arg01
02dd4     3B 7D 0A F2 | 	cmp	_var01, result1 wz
02dd8     E8 FF 9F 5D |  if_ne	jmp	#LR__0330
02ddc                 | __system___lockmem_ret
02ddc     2D 00 64 FD | 	ret
02de0                 | 
02de0                 | __system___tx
02de0     02 CA 05 F6 | 	mov	COUNT_, #2
02de4     E8 00 A0 FD | 	call	#pushregs_
02de8     48 A7 02 F6 | 	mov	local01, arg01
02dec     0A A6 0E F2 | 	cmp	local01, #10 wz
02df0     18 00 90 5D |  if_ne	jmp	#LR__0340
02df4     08 66 06 F1 | 	add	ptr___system__dat__, #8
02df8     33 A9 02 FB | 	rdlong	local02, ptr___system__dat__
02dfc     08 66 86 F1 | 	sub	ptr___system__dat__, #8
02e00     02 A8 CE F7 | 	test	local02, #2 wz
02e04     0D 90 06 56 |  if_ne	mov	arg01, #13
02e08     3C FD BF 5D |  if_ne	call	#__system___txraw
02e0c                 | LR__0340
02e0c     53 91 02 F6 | 	mov	arg01, local01
02e10     34 FD BF FD | 	call	#__system___txraw
02e14     E7 F0 03 F6 | 	mov	ptra, fp
02e18     F2 00 A0 FD | 	call	#popregs_
02e1c                 | __system___tx_ret
02e1c     2D 00 64 FD | 	ret
02e20                 | 
02e20                 | __system___rx
02e20     01 CA 05 F6 | 	mov	COUNT_, #1
02e24     E8 00 A0 FD | 	call	#pushregs_
02e28                 | LR__0350
02e28     00 90 06 F6 | 	mov	arg01, #0
02e2c     5C FD BF FD | 	call	#__system___rxraw
02e30     3B A7 02 F6 | 	mov	local01, result1
02e34     FF FF 7F FF 
02e38     FF A7 0E F2 | 	cmp	local01, ##-1 wz
02e3c     E8 FF 9F AD |  if_e	jmp	#LR__0350
02e40     0D A6 0E F2 | 	cmp	local01, #13 wz
02e44     14 00 90 5D |  if_ne	jmp	#LR__0351
02e48     08 66 06 F1 | 	add	ptr___system__dat__, #8
02e4c     33 77 02 FB | 	rdlong	result1, ptr___system__dat__
02e50     08 66 86 F1 | 	sub	ptr___system__dat__, #8
02e54     02 76 CE F7 | 	test	result1, #2 wz
02e58     0A A6 06 56 |  if_ne	mov	local01, #10
02e5c                 | LR__0351
02e5c     08 66 06 F1 | 	add	ptr___system__dat__, #8
02e60     33 91 02 FB | 	rdlong	arg01, ptr___system__dat__
02e64     08 66 86 F1 | 	sub	ptr___system__dat__, #8
02e68     01 90 CE F7 | 	test	arg01, #1 wz
02e6c     1C 00 90 AD |  if_e	jmp	#LR__0354
02e70     7F A6 0E F2 | 	cmp	local01, #127 wz
02e74     0C 00 90 5D |  if_ne	jmp	#LR__0352
02e78     08 90 06 F6 | 	mov	arg01, #8
02e7c     60 FF BF FD | 	call	#__system___tx
02e80     08 00 90 FD | 	jmp	#LR__0353
02e84                 | LR__0352
02e84     53 91 02 F6 | 	mov	arg01, local01
02e88     54 FF BF FD | 	call	#__system___tx
02e8c                 | LR__0353
02e8c                 | LR__0354
02e8c     53 77 02 F6 | 	mov	result1, local01
02e90     E7 F0 03 F6 | 	mov	ptra, fp
02e94     F2 00 A0 FD | 	call	#popregs_
02e98                 | __system___rx_ret
02e98     2D 00 64 FD | 	ret
02e9c                 | 
02e9c                 | __system___waitms
02e9c     48 7D 02 F6 | 	mov	_var01, arg01
02ea0     1A 7E 62 FD | 	getct	_var02
02ea4     14 80 06 FB | 	rdlong	_var03, #20
02ea8     D7 14 48 FB | 	callpa	#(@LR__0361-@LR__0360)>>2,fcache_load_ptr_
02eac                 | LR__0360
02eac     01 00 00 FF 
02eb0     E8 7D 56 F2 | 	cmps	_var01, ##1000 wc
02eb4     1C 00 90 CD |  if_b	jmp	#LR__0362
02eb8     40 7F 02 F1 | 	add	_var02, _var03
02ebc     3F 91 02 F6 | 	mov	arg01, _var02
02ec0     00 90 66 FA | 	addct1	arg01, #0
02ec4     24 22 60 FD | 	waitct1
02ec8     01 00 00 FF 
02ecc     E8 7D 86 F1 | 	sub	_var01, ##1000
02ed0     D8 FF 9F FD | 	jmp	#LR__0360
02ed4                 | LR__0361
02ed4                 | LR__0362
02ed4     01 7C 56 F2 | 	cmps	_var01, #1 wc
02ed8     28 00 90 CD |  if_b	jmp	#LR__0363
02edc     40 7D 02 FD | 	qmul	_var01, _var03
02ee0     01 00 00 FF 
02ee4     E8 95 06 F6 | 	mov	arg03, ##1000
02ee8     19 76 62 FD | 	getqy	result1
02eec     18 90 62 FD | 	getqx	arg01
02ef0     28 76 62 FD | 	setq	result1
02ef4     4A 91 12 FD | 	qdiv	arg01, arg03
02ef8     18 90 62 FD | 	getqx	arg01
02efc     3F 91 62 FA | 	addct1	arg01, _var02
02f00     24 22 60 FD | 	waitct1
02f04                 | LR__0363
02f04                 | __system___waitms_ret
02f04     2D 00 64 FD | 	ret
02f08                 | 
02f08                 | __system___waitus
02f08     48 7D 02 F6 | 	mov	_var01, arg01
02f0c     1A 7E 62 FD | 	getct	_var02
02f10     14 80 06 FB | 	rdlong	_var03, #20
02f14     D7 14 48 FB | 	callpa	#(@LR__0371-@LR__0370)>>2,fcache_load_ptr_
02f18                 | LR__0370
02f18     A1 07 00 FF 
02f1c     40 7C 56 F2 | 	cmps	_var01, ##1000000 wc
02f20     1C 00 90 CD |  if_b	jmp	#LR__0372
02f24     40 7F 02 F1 | 	add	_var02, _var03
02f28     3F 91 02 F6 | 	mov	arg01, _var02
02f2c     00 90 66 FA | 	addct1	arg01, #0
02f30     24 22 60 FD | 	waitct1
02f34     A1 07 00 FF 
02f38     40 7C 86 F1 | 	sub	_var01, ##1000000
02f3c     D8 FF 9F FD | 	jmp	#LR__0370
02f40                 | LR__0371
02f40                 | LR__0372
02f40     01 7C 56 F2 | 	cmps	_var01, #1 wc
02f44     28 00 90 CD |  if_b	jmp	#LR__0373
02f48     40 7D 02 FD | 	qmul	_var01, _var03
02f4c     A1 07 00 FF 
02f50     40 94 06 F6 | 	mov	arg03, ##1000000
02f54     19 76 62 FD | 	getqy	result1
02f58     18 90 62 FD | 	getqx	arg01
02f5c     28 76 62 FD | 	setq	result1
02f60     4A 91 12 FD | 	qdiv	arg01, arg03
02f64     18 76 62 FD | 	getqx	result1
02f68     3B 7F 62 FA | 	addct1	_var02, result1
02f6c     24 22 60 FD | 	waitct1
02f70                 | LR__0373
02f70                 | __system___waitus_ret
02f70     2D 00 64 FD | 	ret
02f74                 | 
02f74                 | __system___mount
02f74     09 CA 05 F6 | 	mov	COUNT_, #9
02f78     E8 00 A0 FD | 	call	#pushregs_
02f7c     48 A7 02 F6 | 	mov	local01, arg01
02f80     49 A9 0A F6 | 	mov	local02, arg02 wz
02f84     01 AA 66 F6 | 	neg	local03, #1
02f88     01 76 66 A6 |  if_e	neg	result1, #1
02f8c     9C 02 90 AD |  if_e	jmp	#LR__0395
02f90     53 77 C2 FA | 	rdbyte	result1, local01
02f94     2F 76 0E F2 | 	cmp	result1, #47 wz
02f98     28 00 90 5D |  if_ne	jmp	#LR__0382
02f9c     53 91 02 F6 | 	mov	arg01, local01
02fa0     48 AD 02 F6 | 	mov	local04, arg01
02fa4     D7 06 48 FB | 	callpa	#(@LR__0381-@LR__0380)>>2,fcache_load_ptr_
02fa8                 | LR__0380
02fa8     56 77 CA FA | 	rdbyte	result1, local04 wz
02fac     01 AC 06 51 |  if_ne	add	local04, #1
02fb0     F4 FF 9F 5D |  if_ne	jmp	#LR__0380
02fb4                 | LR__0381
02fb4     48 AD 82 F1 | 	sub	local04, arg01
02fb8     56 77 02 F6 | 	mov	result1, local04
02fbc     10 76 56 F2 | 	cmps	result1, #16 wc
02fc0     14 00 90 CD |  if_b	jmp	#LR__0383
02fc4                 | LR__0382
02fc4     20 66 06 F1 | 	add	ptr___system__dat__, #32
02fc8     33 15 68 FC | 	wrlong	#10, ptr___system__dat__
02fcc     20 66 86 F1 | 	sub	ptr___system__dat__, #32
02fd0     01 76 66 F6 | 	neg	result1, #1
02fd4     54 02 90 FD | 	jmp	#LR__0395
02fd8                 | LR__0383
02fd8     00 AE 06 F6 | 	mov	local05, #0
02fdc                 | LR__0384
02fdc     04 AE 56 F2 | 	cmps	local05, #4 wc
02fe0     B4 00 90 3D |  if_ae	jmp	#LR__0389
02fe4     57 91 02 F6 | 	mov	arg01, local05
02fe8     02 90 66 F0 | 	shl	arg01, #2
02fec     33 77 02 F6 | 	mov	result1, ptr___system__dat__
02ff0     64 76 06 F1 | 	add	result1, #100
02ff4     3B 91 02 F1 | 	add	arg01, result1
02ff8     48 77 0A FB | 	rdlong	result1, arg01 wz
02ffc     00 AA 56 A2 |  if_e	cmps	local03, #0 wc
03000     57 AB 02 86 |  if_c_and_z	mov	local03, local05
03004     88 00 90 8D |  if_c_and_z	jmp	#LR__0388
03008     57 91 02 F6 | 	mov	arg01, local05
0300c     02 90 66 F0 | 	shl	arg01, #2
03010     33 AD 02 F6 | 	mov	local04, ptr___system__dat__
03014     64 AC 06 F1 | 	add	local04, #100
03018     56 91 02 F1 | 	add	arg01, local04
0301c     48 91 02 FB | 	rdlong	arg01, arg01
03020     48 AD 02 F6 | 	mov	local04, arg01
03024     D7 06 48 FB | 	callpa	#(@LR__0386-@LR__0385)>>2,fcache_load_ptr_
03028                 | LR__0385
03028     56 77 CA FA | 	rdbyte	result1, local04 wz
0302c     01 AC 06 51 |  if_ne	add	local04, #1
03030     F4 FF 9F 5D |  if_ne	jmp	#LR__0385
03034                 | LR__0386
03034     48 AD 82 F1 | 	sub	local04, arg01
03038     56 77 02 F6 | 	mov	result1, local04
0303c     3B B1 02 F6 | 	mov	local06, result1
03040     58 91 02 F6 | 	mov	arg01, local06
03044     53 91 02 F1 | 	add	arg01, local01
03048     48 AD C2 FA | 	rdbyte	local04, arg01
0304c     2F AC 0E F2 | 	cmp	local04, #47 wz
03050     58 B3 02 56 |  if_ne	mov	local07, local06
03054     53 B3 02 51 |  if_ne	add	local07, local01
03058     59 91 CA 5A |  if_ne	rdbyte	arg01, local07 wz
0305c     30 00 90 5D |  if_ne	jmp	#LR__0387
03060     57 AD 02 F6 | 	mov	local04, local05
03064     02 AC 66 F0 | 	shl	local04, #2
03068     33 95 02 F6 | 	mov	arg03, ptr___system__dat__
0306c     64 94 06 F1 | 	add	arg03, #100
03070     4A AD 02 F1 | 	add	local04, arg03
03074     56 93 02 FB | 	rdlong	arg02, local04
03078     53 91 02 F6 | 	mov	arg01, local01
0307c     58 95 02 F6 | 	mov	arg03, local06
03080     F0 2A B0 FD | 	call	#__system__strncmp
03084     00 76 0E F2 | 	cmp	result1, #0 wz
03088     57 AB 02 A6 |  if_e	mov	local03, local05
0308c     08 00 90 AD |  if_e	jmp	#LR__0389
03090                 | LR__0387
03090                 | LR__0388
03090     01 AE 06 F1 | 	add	local05, #1
03094     44 FF 9F FD | 	jmp	#LR__0384
03098                 | LR__0389
03098     FF FF 7F FF 
0309c     FF AB 0E F2 | 	cmp	local03, ##-1 wz
030a0     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
030a4     33 17 68 AC |  if_e	wrlong	#11, ptr___system__dat__
030a8     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
030ac     01 76 66 A6 |  if_e	neg	result1, #1
030b0     78 01 90 AD |  if_e	jmp	#LR__0395
030b4     55 AF 02 F6 | 	mov	local05, local03
030b8     57 B3 02 F6 | 	mov	local07, local05
030bc     02 B2 66 F0 | 	shl	local07, #2
030c0     33 B1 02 F6 | 	mov	local06, ptr___system__dat__
030c4     74 B0 06 F1 | 	add	local06, #116
030c8     58 B3 02 F1 | 	add	local07, local06
030cc     59 B1 0A FB | 	rdlong	local06, local07 wz
030d0     58 00 90 AD |  if_e	jmp	#LR__0390
030d4     4C B0 06 F1 | 	add	local06, #76
030d8     58 B3 0A FB | 	rdlong	local07, local06 wz
030dc     4C B0 86 F1 | 	sub	local06, #76
030e0     48 00 90 AD |  if_e	jmp	#LR__0390
030e4     4C B0 06 F1 | 	add	local06, #76
030e8     58 B3 02 FB | 	rdlong	local07, local06
030ec     59 AD 02 F6 | 	mov	local04, local07
030f0     13 B2 46 F7 | 	zerox	local07, #19
030f4     14 AC 46 F0 | 	shr	local04, #20
030f8     02 AC 66 F0 | 	shl	local04, #2
030fc     2D AD 02 F1 | 	add	local04, __methods__
03100     56 AD 02 FB | 	rdlong	local04, local04
03104     57 B1 02 F6 | 	mov	local06, local05
03108     02 B0 66 F0 | 	shl	local06, #2
0310c     33 AB 02 F6 | 	mov	local03, ptr___system__dat__
03110     64 AA 06 F1 | 	add	local03, #100
03114     55 B1 02 F1 | 	add	local06, local03
03118     58 91 02 FB | 	rdlong	arg01, local06
0311c     31 B1 02 F6 | 	mov	local06, objptr
03120     59 63 02 F6 | 	mov	objptr, local07
03124     2D AC 62 FD | 	call	local04
03128     58 63 02 F6 | 	mov	objptr, local06
0312c                 | LR__0390
0312c     57 B1 02 F6 | 	mov	local06, local05
03130     02 B0 66 F0 | 	shl	local06, #2
03134     33 B3 02 F6 | 	mov	local07, ptr___system__dat__
03138     74 B2 06 F1 | 	add	local07, #116
0313c     59 B1 02 F1 | 	add	local06, local07
03140     58 A9 62 FC | 	wrlong	local02, local06
03144     00 A8 0E F2 | 	cmp	local02, #0 wz
03148     18 00 90 5D |  if_ne	jmp	#LR__0391
0314c     02 AE 66 F0 | 	shl	local05, #2
03150     33 B3 02 F6 | 	mov	local07, ptr___system__dat__
03154     64 B2 06 F1 | 	add	local07, #100
03158     59 AF 02 F1 | 	add	local05, local07
0315c     57 01 68 FC | 	wrlong	#0, local05
03160     C4 00 90 FD | 	jmp	#LR__0394
03164                 | LR__0391
03164     57 B5 02 F6 | 	mov	local08, local05
03168     04 B4 66 F0 | 	shl	local08, #4
0316c     33 B3 02 F6 | 	mov	local07, ptr___system__dat__
03170     24 B2 06 F1 | 	add	local07, #36
03174     59 B5 02 F1 | 	add	local08, local07
03178     5A 91 02 F6 | 	mov	arg01, local08
0317c     53 93 02 F6 | 	mov	arg02, local01
03180     10 94 06 F6 | 	mov	arg03, #16
03184     30 29 B0 FD | 	call	#__system__strncpy
03188     48 A8 06 F1 | 	add	local02, #72
0318c     54 B3 0A FB | 	rdlong	local07, local02 wz
03190     48 A8 86 F1 | 	sub	local02, #72
03194     7C 00 90 AD |  if_e	jmp	#LR__0393
03198     48 A8 06 F1 | 	add	local02, #72
0319c     54 B3 02 FB | 	rdlong	local07, local02
031a0     59 B7 02 F6 | 	mov	local09, local07
031a4     13 B2 46 F7 | 	zerox	local07, #19
031a8     14 B6 46 F0 | 	shr	local09, #20
031ac     02 B6 66 F0 | 	shl	local09, #2
031b0     2D B7 02 F1 | 	add	local09, __methods__
031b4     5B B7 02 FB | 	rdlong	local09, local09
031b8     5A 91 02 F6 | 	mov	arg01, local08
031bc     31 B1 02 F6 | 	mov	local06, objptr
031c0     59 63 02 F6 | 	mov	objptr, local07
031c4     2D B6 62 FD | 	call	local09
031c8     58 63 02 F6 | 	mov	objptr, local06
031cc     3B 91 0A F6 | 	mov	arg01, result1 wz
031d0     40 00 90 AD |  if_e	jmp	#LR__0392
031d4     57 B5 02 F6 | 	mov	local08, local05
031d8     02 B4 66 F0 | 	shl	local08, #2
031dc     74 66 06 F1 | 	add	ptr___system__dat__, #116
031e0     33 B5 02 F1 | 	add	local08, ptr___system__dat__
031e4     5A 01 68 FC | 	wrlong	#0, local08
031e8     02 AE 66 F0 | 	shl	local05, #2
031ec     10 66 86 F1 | 	sub	ptr___system__dat__, #16
031f0     33 AF 02 F1 | 	add	local05, ptr___system__dat__
031f4     57 01 68 FC | 	wrlong	#0, local05
031f8     48 91 6A F6 | 	neg	arg01, arg01 wz
031fc     44 66 86 F1 | 	sub	ptr___system__dat__, #68
03200     33 91 62 FC | 	wrlong	arg01, ptr___system__dat__
03204     20 66 86 F1 | 	sub	ptr___system__dat__, #32
03208     01 76 66 56 |  if_ne	neg	result1, #1
0320c     00 76 06 A6 |  if_e	mov	result1, #0
03210     18 00 90 FD | 	jmp	#LR__0395
03214                 | LR__0392
03214                 | LR__0393
03214     02 AE 66 F0 | 	shl	local05, #2
03218     33 B3 02 F6 | 	mov	local07, ptr___system__dat__
0321c     64 B2 06 F1 | 	add	local07, #100
03220     59 AF 02 F1 | 	add	local05, local07
03224     57 B5 62 FC | 	wrlong	local08, local05
03228                 | LR__0394
03228     00 76 06 F6 | 	mov	result1, #0
0322c                 | LR__0395
0322c     E7 F0 03 F6 | 	mov	ptra, fp
03230     F2 00 A0 FD | 	call	#popregs_
03234                 | __system___mount_ret
03234     2D 00 64 FD | 	ret
03238                 | 
03238                 | __system___chdir
03238     02 CA 05 F6 | 	mov	COUNT_, #2
0323c     E8 00 A0 FD | 	call	#pushregs_
03240     44 F0 07 F1 | 	add	ptra, #68
03244     48 A7 02 F6 | 	mov	local01, arg01
03248     E7 92 02 F6 | 	mov	arg02, fp
0324c     08 92 06 F1 | 	add	arg02, #8
03250     53 91 02 F6 | 	mov	arg01, local01
03254     78 27 B0 FD | 	call	#__system__stat
03258     00 76 0E F2 | 	cmp	result1, #0 wz
0325c     88 00 90 5D |  if_ne	jmp	#LR__0402
03260     10 CE 05 F1 | 	add	fp, #16
03264     E7 90 02 FB | 	rdlong	arg01, fp
03268     10 CE 85 F1 | 	sub	fp, #16
0326c     78 00 00 FF 
03270     00 90 06 F5 | 	and	arg01, ##61440
03274     08 00 00 FF 
03278     00 90 0E F2 | 	cmp	arg01, ##4096 wz
0327c     20 66 06 51 |  if_ne	add	ptr___system__dat__, #32
03280     33 1B 68 5C |  if_ne	wrlong	#13, ptr___system__dat__
03284     20 66 86 51 |  if_ne	sub	ptr___system__dat__, #32
03288     01 76 66 56 |  if_ne	neg	result1, #1
0328c     58 00 90 5D |  if_ne	jmp	#LR__0402
03290     53 95 C2 FA | 	rdbyte	arg03, local01
03294     2F 94 0E F2 | 	cmp	arg03, #47 wz
03298     18 00 90 5D |  if_ne	jmp	#LR__0400
0329c     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
032a0     84 90 06 F1 | 	add	arg01, #132
032a4     53 93 02 F6 | 	mov	arg02, local01
032a8     00 95 06 F6 | 	mov	arg03, #256
032ac     08 28 B0 FD | 	call	#__system__strncpy
032b0     30 00 90 FD | 	jmp	#LR__0401
032b4                 | LR__0400
032b4     33 A9 02 F6 | 	mov	local02, ptr___system__dat__
032b8     84 A9 06 F1 | 	add	local02, #388
032bc     33 93 02 F6 | 	mov	arg02, ptr___system__dat__
032c0     84 92 06 F1 | 	add	arg02, #132
032c4     54 91 02 F6 | 	mov	arg01, local02
032c8     00 95 06 F6 | 	mov	arg03, #256
032cc     E8 27 B0 FD | 	call	#__system__strncpy
032d0     33 95 02 F6 | 	mov	arg03, ptr___system__dat__
032d4     84 94 06 F1 | 	add	arg03, #132
032d8     54 91 02 F6 | 	mov	arg01, local02
032dc     53 93 02 F6 | 	mov	arg02, local01
032e0     10 00 B0 FD | 	call	#__system____getvfsforfile
032e4                 | LR__0401
032e4     00 76 06 F6 | 	mov	result1, #0
032e8                 | LR__0402
032e8     E7 F0 03 F6 | 	mov	ptra, fp
032ec     F2 00 A0 FD | 	call	#popregs_
032f0                 | __system___chdir_ret
032f0     2D 00 64 FD | 	ret
032f4                 | 
032f4                 | __system____getvfsforfile
032f4     0E CA 05 F6 | 	mov	COUNT_, #14
032f8     E8 00 A0 FD | 	call	#pushregs_
032fc     48 A7 02 F6 | 	mov	local01, arg01
03300     49 A9 02 F6 | 	mov	local02, arg02
03304     4A AB 02 F6 | 	mov	local03, arg03
03308     D7 10 48 FB | 	callpa	#(@LR__0411-@LR__0410)>>2,fcache_load_ptr_
0330c                 | LR__0410
0330c     54 77 C2 FA | 	rdbyte	result1, local02
03310     2F 76 0E F2 | 	cmp	result1, #47 wz
03314     01 A8 06 A1 |  if_e	add	local02, #1
03318     54 AD C2 AA |  if_e	rdbyte	local04, local02
0331c     01 A8 86 A1 |  if_e	sub	local02, #1
03320     2F AC 0E A2 |  if_e	cmp	local04, #47 wz
03324     01 A8 06 A1 |  if_e	add	local02, #1
03328     E0 FF 9F AD |  if_e	jmp	#LR__0410
0332c                 | LR__0411
0332c     54 AD C2 FA | 	rdbyte	local04, local02
03330     2F AC 0E F2 | 	cmp	local04, #47 wz
03334     14 00 90 5D |  if_ne	jmp	#LR__0412
03338     53 91 02 F6 | 	mov	arg01, local01
0333c     54 93 02 F6 | 	mov	arg02, local02
03340     00 95 06 F6 | 	mov	arg03, #256
03344     70 27 B0 FD | 	call	#__system__strncpy
03348     78 00 90 FD | 	jmp	#LR__0414
0334c                 | LR__0412
0334c     33 93 02 F6 | 	mov	arg02, ptr___system__dat__
03350     84 92 06 F1 | 	add	arg02, #132
03354     53 91 02 F6 | 	mov	arg01, local01
03358     00 95 06 F6 | 	mov	arg03, #256
0335c     58 27 B0 FD | 	call	#__system__strncpy
03360     54 AD CA FA | 	rdbyte	local04, local02 wz
03364     5C 00 90 AD |  if_e	jmp	#LR__0413
03368     54 AD C2 FA | 	rdbyte	local04, local02
0336c     2E AC 0E F2 | 	cmp	local04, #46 wz
03370     01 A8 06 A1 |  if_e	add	local02, #1
03374     54 AF C2 AA |  if_e	rdbyte	local05, local02
03378     01 A8 86 A1 |  if_e	sub	local02, #1
0337c     57 B1 02 A6 |  if_e	mov	local06, local05
03380     07 B0 4E A7 |  if_e	zerox	local06, #7 wz
03384     3C 00 90 AD |  if_e	jmp	#LR__0413
03388     53 AF C2 FA | 	rdbyte	local05, local01
0338c     2F AE 0E F2 | 	cmp	local05, #47 wz
03390     01 A6 06 A1 |  if_e	add	local01, #1
03394     53 AD C2 AA |  if_e	rdbyte	local04, local01
03398     01 A6 86 A1 |  if_e	sub	local01, #1
0339c     00 AC 4E A2 |  if_e	cmps	local04, #0 wz
033a0     6F 00 00 5F 
033a4     E0 92 06 56 |  if_ne	mov	arg02, ##@LR__2140
033a8     53 91 02 56 |  if_ne	mov	arg01, local01
033ac     00 95 06 56 |  if_ne	mov	arg03, #256
033b0     5C 27 B0 5D |  if_ne	call	#__system__strncat
033b4     53 91 02 F6 | 	mov	arg01, local01
033b8     54 93 02 F6 | 	mov	arg02, local02
033bc     00 95 06 F6 | 	mov	arg03, #256
033c0     4C 27 B0 FD | 	call	#__system__strncat
033c4                 | LR__0413
033c4                 | LR__0414
033c4     53 91 02 F6 | 	mov	arg01, local01
033c8     08 29 B0 FD | 	call	#__system___normalizeName
033cc     53 AD CA FA | 	rdbyte	local04, local01 wz
033d0     1C 00 90 AD |  if_e	jmp	#LR__0415
033d4     53 AD C2 FA | 	rdbyte	local04, local01
033d8     2F AC 0E F2 | 	cmp	local04, #47 wz
033dc     01 A6 06 A1 |  if_e	add	local01, #1
033e0     53 B1 C2 AA |  if_e	rdbyte	local06, local01
033e4     01 A6 86 A1 |  if_e	sub	local01, #1
033e8     00 B0 4E A2 |  if_e	cmps	local06, #0 wz
033ec     10 00 90 5D |  if_ne	jmp	#LR__0416
033f0                 | LR__0415
033f0     33 77 02 F6 | 	mov	result1, ptr___system__dat__
033f4     01 00 00 FF 
033f8     84 76 06 F1 | 	add	result1, ##644
033fc     EC 01 90 FD | 	jmp	#LR__0430
03400                 | LR__0416
03400     00 B2 06 F6 | 	mov	local07, #0
03404                 | LR__0417
03404     04 B2 56 F2 | 	cmps	local07, #4 wc
03408     CC 01 90 3D |  if_ae	jmp	#LR__0429
0340c     59 B1 02 F6 | 	mov	local06, local07
03410     02 B0 66 F0 | 	shl	local06, #2
03414     33 AD 02 F6 | 	mov	local04, ptr___system__dat__
03418     64 AC 06 F1 | 	add	local04, #100
0341c     56 B1 02 F1 | 	add	local06, local04
03420     58 B1 0A FB | 	rdlong	local06, local06 wz
03424     A8 01 90 AD |  if_e	jmp	#LR__0428
03428     59 AD 02 F6 | 	mov	local04, local07
0342c     02 AC 66 F0 | 	shl	local04, #2
03430     33 B1 02 F6 | 	mov	local06, ptr___system__dat__
03434     64 B0 06 F1 | 	add	local06, #100
03438     58 AD 02 F1 | 	add	local04, local06
0343c     56 91 02 FB | 	rdlong	arg01, local04
03440     48 B5 02 F6 | 	mov	local08, arg01
03444     D7 06 48 FB | 	callpa	#(@LR__0419-@LR__0418)>>2,fcache_load_ptr_
03448                 | LR__0418
03448     5A 77 CA FA | 	rdbyte	result1, local08 wz
0344c     01 B4 06 51 |  if_ne	add	local08, #1
03450     F4 FF 9F 5D |  if_ne	jmp	#LR__0418
03454                 | LR__0419
03454     48 B5 82 F1 | 	sub	local08, arg01
03458     5A B7 02 F6 | 	mov	local09, local08
0345c     5B AD 02 F6 | 	mov	local04, local09
03460     53 AD 02 F1 | 	add	local04, local01
03464     56 B1 C2 FA | 	rdbyte	local06, local04
03468     2F B0 0E F2 | 	cmp	local06, #47 wz
0346c     5B B9 02 56 |  if_ne	mov	local10, local09
03470     53 B9 02 51 |  if_ne	add	local10, local01
03474     5C AF CA 5A |  if_ne	rdbyte	local05, local10 wz
03478     54 01 90 5D |  if_ne	jmp	#LR__0427
0347c     59 AD 02 F6 | 	mov	local04, local07
03480     02 AC 66 F0 | 	shl	local04, #2
03484     33 95 02 F6 | 	mov	arg03, ptr___system__dat__
03488     64 94 06 F1 | 	add	arg03, #100
0348c     4A AD 02 F1 | 	add	local04, arg03
03490     56 93 02 FB | 	rdlong	arg02, local04
03494     5B 95 02 F6 | 	mov	arg03, local09
03498     53 91 02 F6 | 	mov	arg01, local01
0349c     D4 26 B0 FD | 	call	#__system__strncmp
034a0     00 76 4E F2 | 	cmps	result1, #0 wz
034a4     28 01 90 5D |  if_ne	jmp	#LR__0427
034a8     59 BB 02 F6 | 	mov	local11, local07
034ac     02 BA 66 F0 | 	shl	local11, #2
034b0     33 AD 02 F6 | 	mov	local04, ptr___system__dat__
034b4     74 AC 06 F1 | 	add	local04, #116
034b8     56 BB 02 F1 | 	add	local11, local04
034bc     5D BD 02 FB | 	rdlong	local12, local11
034c0     D7 22 48 FB | 	callpa	#(@LR__0421-@LR__0420)>>2,fcache_load_ptr_
034c4                 | LR__0420
034c4     5B B1 02 F6 | 	mov	local06, local09
034c8     01 B0 06 F1 | 	add	local06, #1
034cc     53 B1 02 F1 | 	add	local06, local01
034d0     58 BB C2 FA | 	rdbyte	local11, local06
034d4     2E BA 0E F2 | 	cmp	local11, #46 wz
034d8     2C 00 90 5D |  if_ne	jmp	#LR__0422
034dc     5B BB 02 F6 | 	mov	local11, local09
034e0     02 BA 06 F1 | 	add	local11, #2
034e4     53 BB 02 F1 | 	add	local11, local01
034e8     5D B9 C2 FA | 	rdbyte	local10, local11
034ec     2F B8 0E F2 | 	cmp	local10, #47 wz
034f0     5B BF 02 56 |  if_ne	mov	local13, local09
034f4     02 BE 06 51 |  if_ne	add	local13, #2
034f8     53 BF 02 51 |  if_ne	add	local13, local01
034fc     5F C1 CA 5A |  if_ne	rdbyte	local14, local13 wz
03500     01 B6 06 A1 |  if_e	add	local09, #1
03504     BC FF 9F AD |  if_e	jmp	#LR__0420
03508                 | LR__0421
03508                 | LR__0422
03508     00 AA 0E F2 | 	cmp	local03, #0 wz
0350c     55 91 02 56 |  if_ne	mov	arg01, local03
03510     53 93 02 56 |  if_ne	mov	arg02, local01
03514     00 95 06 56 |  if_ne	mov	arg03, #256
03518     9C 25 B0 5D |  if_ne	call	#__system__strncpy
0351c     53 93 02 F6 | 	mov	arg02, local01
03520     5B 93 02 F1 | 	add	arg02, local09
03524     01 92 06 F1 | 	add	arg02, #1
03528     53 91 02 F6 | 	mov	arg01, local01
0352c     3C F8 BF FD | 	call	#__system____builtin_strcpy
03530     53 91 02 F6 | 	mov	arg01, local01
03534     48 B5 02 F6 | 	mov	local08, arg01
03538     D7 06 48 FB | 	callpa	#(@LR__0424-@LR__0423)>>2,fcache_load_ptr_
0353c                 | LR__0423
0353c     5A 77 CA FA | 	rdbyte	result1, local08 wz
03540     01 B4 06 51 |  if_ne	add	local08, #1
03544     F4 FF 9F 5D |  if_ne	jmp	#LR__0423
03548                 | LR__0424
03548     48 B5 82 F1 | 	sub	local08, arg01
0354c     5A B7 02 F6 | 	mov	local09, local08
03550                 | LR__0425
03550     01 B6 56 F2 | 	cmps	local09, #1 wc
03554     70 00 90 CD |  if_b	jmp	#LR__0426
03558     5B AD 02 F6 | 	mov	local04, local09
0355c     53 AD 02 F1 | 	add	local04, local01
03560     56 BB C2 FA | 	rdbyte	local11, local04
03564     2F BA 0E F2 | 	cmp	local11, #47 wz
03568     5B BB 02 A6 |  if_e	mov	local11, local09
0356c     53 BB 02 A1 |  if_e	add	local11, local01
03570     5D 01 48 AC |  if_e	wrbyte	#0, local11
03574     01 B6 86 A1 |  if_e	sub	local09, #1
03578     D4 FF 9F AD |  if_e	jmp	#LR__0425
0357c     5B AD 02 F6 | 	mov	local04, local09
03580     53 AD 02 F1 | 	add	local04, local01
03584     56 BB C2 FA | 	rdbyte	local11, local04
03588     2E BA 0E F2 | 	cmp	local11, #46 wz
0358c     38 00 90 5D |  if_ne	jmp	#LR__0426
03590     02 B6 56 F2 | 	cmps	local09, #2 wc
03594     30 00 90 CD |  if_b	jmp	#LR__0426
03598     5B C1 02 F6 | 	mov	local14, local09
0359c     01 C0 86 F1 | 	sub	local14, #1
035a0     53 C1 02 F1 | 	add	local14, local01
035a4     60 AF C2 FA | 	rdbyte	local05, local14
035a8     2F AE 0E F2 | 	cmp	local05, #47 wz
035ac     18 00 90 5D |  if_ne	jmp	#LR__0426
035b0     5B AD 02 F6 | 	mov	local04, local09
035b4     01 AC 86 F1 | 	sub	local04, #1
035b8     53 AD 02 F1 | 	add	local04, local01
035bc     56 01 48 FC | 	wrbyte	#0, local04
035c0     02 B6 86 F1 | 	sub	local09, #2
035c4     88 FF 9F FD | 	jmp	#LR__0425
035c8                 | LR__0426
035c8     5E 77 02 F6 | 	mov	result1, local12
035cc     1C 00 90 FD | 	jmp	#LR__0430
035d0                 | LR__0427
035d0                 | LR__0428
035d0     01 B2 06 F1 | 	add	local07, #1
035d4     2C FE 9F FD | 	jmp	#LR__0417
035d8                 | LR__0429
035d8     02 00 00 FF 
035dc     E8 66 06 F1 | 	add	ptr___system__dat__, ##1256
035e0     33 77 02 FB | 	rdlong	result1, ptr___system__dat__
035e4     02 00 00 FF 
035e8     E8 66 86 F1 | 	sub	ptr___system__dat__, ##1256
035ec                 | LR__0430
035ec     E7 F0 03 F6 | 	mov	ptra, fp
035f0     F2 00 A0 FD | 	call	#popregs_
035f4                 | __system____getvfsforfile_ret
035f4     2D 00 64 FD | 	ret
035f8                 | 
035f8                 | __system___basic_open
035f8     05 CA 05 F6 | 	mov	COUNT_, #5
035fc     E8 00 A0 FD | 	call	#pushregs_
03600     49 A7 02 F6 | 	mov	local01, arg02
03604     4A A9 02 F6 | 	mov	local02, arg03
03608     4B AB 02 F6 | 	mov	local03, arg04
0360c     00 AC 06 F6 | 	mov	local04, #0
03610     80 24 B0 FD | 	call	#__system____getftab
03614     3B AF 0A F6 | 	mov	local05, result1 wz
03618     18 00 90 5D |  if_ne	jmp	#LR__0440
0361c     2E 91 02 F6 | 	mov	arg01, abortchain
03620     0C 92 06 F6 | 	mov	arg02, #12
03624     01 94 06 F6 | 	mov	arg03, #1
03628     1A 01 A0 FD | 	call	#__longjmp
0362c     01 76 66 F6 | 	neg	result1, #1
03630     0C 01 90 FD | 	jmp	#LR__0449
03634                 | LR__0440
03634     08 AE 06 F1 | 	add	local05, #8
03638     57 77 0A FB | 	rdlong	result1, local05 wz
0363c     08 AE 86 F1 | 	sub	local05, #8
03640     57 91 02 56 |  if_ne	mov	arg01, local05
03644     D0 1E B0 5D |  if_ne	call	#__system___closeraw
03648     00 A6 0E F2 | 	cmp	local01, #0 wz
0364c     00 A8 0E A2 |  if_e	cmp	local02, #0 wz
03650     00 AA 0E A2 |  if_e	cmp	local03, #0 wz
03654     3C 00 90 AD |  if_e	jmp	#LR__0442
03658     0C 90 06 F6 | 	mov	arg01, #12
0365c     78 18 B0 FD | 	call	#__system___gc_alloc_managed
03660     3B AD 0A F6 | 	mov	local04, result1 wz
03664     18 00 90 5D |  if_ne	jmp	#LR__0441
03668     2E 91 02 F6 | 	mov	arg01, abortchain
0366c     07 92 06 F6 | 	mov	arg02, #7
03670     01 94 06 F6 | 	mov	arg03, #1
03674     1A 01 A0 FD | 	call	#__longjmp
03678     01 76 66 F6 | 	neg	result1, #1
0367c     C0 00 90 FD | 	jmp	#LR__0449
03680                 | LR__0441
03680     56 01 68 FC | 	wrlong	#0, local04
03684     04 AC 06 F1 | 	add	local04, #4
03688     56 01 68 FC | 	wrlong	#0, local04
0368c     04 AC 86 F1 | 	sub	local04, #4
03690     57 AD 62 FC | 	wrlong	local04, local05
03694                 | LR__0442
03694     00 A6 0E F2 | 	cmp	local01, #0 wz
03698     1C 00 90 AD |  if_e	jmp	#LR__0443
0369c     56 A7 62 FC | 	wrlong	local01, local04
036a0     56 77 02 F6 | 	mov	result1, local04
036a4     15 76 26 F4 | 	bith	result1, #21
036a8     1C AE 06 F1 | 	add	local05, #28
036ac     57 77 62 FC | 	wrlong	result1, local05
036b0     1C AE 86 F1 | 	sub	local05, #28
036b4     0C 00 90 FD | 	jmp	#LR__0444
036b8                 | LR__0443
036b8     1C AE 06 F1 | 	add	local05, #28
036bc     57 01 68 FC | 	wrlong	#0, local05
036c0     1C AE 86 F1 | 	sub	local05, #28
036c4                 | LR__0444
036c4     00 A8 0E F2 | 	cmp	local02, #0 wz
036c8     24 00 90 AD |  if_e	jmp	#LR__0445
036cc     04 AC 06 F1 | 	add	local04, #4
036d0     56 A9 62 FC | 	wrlong	local02, local04
036d4     04 AC 86 F1 | 	sub	local04, #4
036d8     56 77 02 F6 | 	mov	result1, local04
036dc     34 76 26 F4 | 	bith	result1, #52
036e0     20 AE 06 F1 | 	add	local05, #32
036e4     57 77 62 FC | 	wrlong	result1, local05
036e8     20 AE 86 F1 | 	sub	local05, #32
036ec     0C 00 90 FD | 	jmp	#LR__0446
036f0                 | LR__0445
036f0     20 AE 06 F1 | 	add	local05, #32
036f4     57 01 68 FC | 	wrlong	#0, local05
036f8     20 AE 86 F1 | 	sub	local05, #32
036fc                 | LR__0446
036fc     00 AA 0E F2 | 	cmp	local03, #0 wz
03700     20 00 90 AD |  if_e	jmp	#LR__0447
03704     08 AC 06 F1 | 	add	local04, #8
03708     56 AB 62 FC | 	wrlong	local03, local04
0370c     08 AC 86 F1 | 	sub	local04, #8
03710     16 AC 26 F4 | 	bith	local04, #22
03714     24 AE 06 F1 | 	add	local05, #36
03718     57 AD 62 FC | 	wrlong	local04, local05
0371c     24 AE 86 F1 | 	sub	local05, #36
03720     0C 00 90 FD | 	jmp	#LR__0448
03724                 | LR__0447
03724     24 AE 06 F1 | 	add	local05, #36
03728     57 01 68 FC | 	wrlong	#0, local05
0372c     24 AE 86 F1 | 	sub	local05, #36
03730                 | LR__0448
03730     08 AE 06 F1 | 	add	local05, #8
03734     40 00 80 FF 
03738     57 07 68 FC | 	wrlong	##32771, local05
0373c     00 76 06 F6 | 	mov	result1, #0
03740                 | LR__0449
03740     E7 F0 03 F6 | 	mov	ptra, fp
03744     F2 00 A0 FD | 	call	#popregs_
03748                 | __system___basic_open_ret
03748     2D 00 64 FD | 	ret
0374c                 | 
0374c                 | __system___find_free_file
0374c     33 7D 02 F6 | 	mov	_var01, ptr___system__dat__
03750     01 00 00 FF 
03754     E0 7C 06 F1 | 	add	_var01, ##736
03758     00 7E 06 F6 | 	mov	_var02, #0
0375c     D7 12 48 FB | 	callpa	#(@LR__0451-@LR__0450)>>2,fcache_load_ptr_
03760                 | LR__0450
03760     0A 7E 56 F2 | 	cmps	_var02, #10 wc
03764     1C 00 90 3D |  if_ae	jmp	#LR__0452
03768     34 7E 06 FD | 	qmul	_var02, #52
0376c     18 76 62 FD | 	getqx	result1
03770     3E 77 02 F1 | 	add	result1, _var01
03774     08 76 06 F1 | 	add	result1, #8
03778     3B 77 0A FB | 	rdlong	result1, result1 wz
0377c     01 7E 06 51 |  if_ne	add	_var02, #1
03780     DC FF 9F 5D |  if_ne	jmp	#LR__0450
03784                 | LR__0451
03784                 | LR__0452
03784     0A 7E 0E F2 | 	cmp	_var02, #10 wz
03788     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0378c     33 17 68 AC |  if_e	wrlong	#11, ptr___system__dat__
03790     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
03794     01 76 66 A6 |  if_e	neg	result1, #1
03798     3F 77 02 56 |  if_ne	mov	result1, _var02
0379c                 | __system___find_free_file_ret
0379c     2D 00 64 FD | 	ret
037a0                 | 
037a0                 | __system___basic_print_char
037a0     03 CA 05 F6 | 	mov	COUNT_, #3
037a4     E8 00 A0 FD | 	call	#pushregs_
037a8     49 A7 02 F6 | 	mov	local01, arg02
037ac     90 2A B0 FD | 	call	#__system___gettxfunc
037b0     3B A9 0A F6 | 	mov	local02, result1 wz
037b4     00 76 06 A6 |  if_e	mov	result1, #0
037b8     30 00 90 AD |  if_e	jmp	#LR__0460
037bc     54 AB 02 F6 | 	mov	local03, local02
037c0     13 A8 46 F7 | 	zerox	local02, #19
037c4     14 AA 46 F0 | 	shr	local03, #20
037c8     02 AA 66 F0 | 	shl	local03, #2
037cc     2D AB 02 F1 | 	add	local03, __methods__
037d0     55 AB 02 FB | 	rdlong	local03, local03
037d4     53 91 02 F6 | 	mov	arg01, local01
037d8     31 A7 02 F6 | 	mov	local01, objptr
037dc     54 63 02 F6 | 	mov	objptr, local02
037e0     2D AA 62 FD | 	call	local03
037e4     53 63 02 F6 | 	mov	objptr, local01
037e8     01 76 06 F6 | 	mov	result1, #1
037ec                 | LR__0460
037ec     E7 F0 03 F6 | 	mov	ptra, fp
037f0     F2 00 A0 FD | 	call	#popregs_
037f4                 | __system___basic_print_char_ret
037f4     2D 00 64 FD | 	ret
037f8                 | 
037f8                 | __system___basic_print_string
037f8     03 CA 05 F6 | 	mov	COUNT_, #3
037fc     E8 00 A0 FD | 	call	#pushregs_
03800     49 A7 02 F6 | 	mov	local01, arg02
03804     4A A9 02 F6 | 	mov	local02, arg03
03808     34 2A B0 FD | 	call	#__system___gettxfunc
0380c     3B AB 0A F6 | 	mov	local03, result1 wz
03810     00 76 06 A6 |  if_e	mov	result1, #0
03814     18 00 90 AD |  if_e	jmp	#LR__0470
03818     00 A6 0E F2 | 	cmp	local01, #0 wz
0381c     00 76 06 A6 |  if_e	mov	result1, #0
03820     55 91 02 56 |  if_ne	mov	arg01, local03
03824     54 93 02 56 |  if_ne	mov	arg02, local02
03828     53 95 02 56 |  if_ne	mov	arg03, local01
0382c     0C 00 B0 5D |  if_ne	call	#__system___fmtstr
03830                 | LR__0470
03830     E7 F0 03 F6 | 	mov	ptra, fp
03834     F2 00 A0 FD | 	call	#popregs_
03838                 | __system___basic_print_string_ret
03838     2D 00 64 FD | 	ret
0383c                 | 
0383c                 | __system___fmtstr
0383c     09 CA 05 F6 | 	mov	COUNT_, #9
03840     E8 00 A0 FD | 	call	#pushregs_
03844     48 A7 02 F6 | 	mov	local01, arg01
03848     49 A9 02 F6 | 	mov	local02, arg02
0384c     4A AB 02 F6 | 	mov	local03, arg03
03850     54 97 E2 F8 | 	getbyte	arg04, local02, #0
03854     55 91 02 F6 | 	mov	arg01, local03
03858     48 AD 02 F6 | 	mov	local04, arg01
0385c     D7 06 48 FB | 	callpa	#(@LR__0481-@LR__0480)>>2,fcache_load_ptr_
03860                 | LR__0480
03860     56 77 CA FA | 	rdbyte	result1, local04 wz
03864     01 AC 06 51 |  if_ne	add	local04, #1
03868     F4 FF 9F 5D |  if_ne	jmp	#LR__0480
0386c                 | LR__0481
0386c     48 AD 82 F1 | 	sub	local04, arg01
03870     00 96 0E F2 | 	cmp	arg04, #0 wz
03874     4B AD 7A 53 |  if_ne	fles	local04, arg04 wcz
03878     54 93 02 F6 | 	mov	arg02, local02
0387c     56 95 02 F6 | 	mov	arg03, local04
03880     53 91 02 F6 | 	mov	arg01, local01
03884     02 96 06 F6 | 	mov	arg04, #2
03888     0C 26 B0 FD | 	call	#__system___fmtpad
0388c     3B AF 02 F6 | 	mov	local05, result1
03890     00 AE 56 F2 | 	cmps	local05, #0 wc
03894     57 77 02 C6 |  if_b	mov	result1, local05
03898     80 00 90 CD |  if_b	jmp	#LR__0484
0389c     01 AC 56 F2 | 	cmps	local04, #1 wc
038a0     50 00 90 CD |  if_b	jmp	#LR__0483
038a4     56 B1 02 F6 | 	mov	local06, local04
038a8                 | LR__0482
038a8     53 B3 02 F6 | 	mov	local07, local01
038ac     53 B5 02 F6 | 	mov	local08, local01
038b0     13 B2 46 F7 | 	zerox	local07, #19
038b4     14 B4 46 F0 | 	shr	local08, #20
038b8     02 B4 66 F0 | 	shl	local08, #2
038bc     2D B5 02 F1 | 	add	local08, __methods__
038c0     5A B5 02 FB | 	rdlong	local08, local08
038c4     55 91 C2 FA | 	rdbyte	arg01, local03
038c8     31 B7 02 F6 | 	mov	local09, objptr
038cc     59 63 02 F6 | 	mov	objptr, local07
038d0     01 AA 06 F1 | 	add	local03, #1
038d4     2D B4 62 FD | 	call	local08
038d8     5B 63 02 F6 | 	mov	objptr, local09
038dc     3B B7 02 F6 | 	mov	local09, result1
038e0     00 B6 56 F2 | 	cmps	local09, #0 wc
038e4     5B 77 02 C6 |  if_b	mov	result1, local09
038e8     30 00 90 CD |  if_b	jmp	#LR__0484
038ec     5B AF 02 F1 | 	add	local05, local09
038f0     ED B1 6E FB | 	djnz	local06, #LR__0482
038f4                 | LR__0483
038f4     54 93 02 F6 | 	mov	arg02, local02
038f8     56 95 02 F6 | 	mov	arg03, local04
038fc     53 91 02 F6 | 	mov	arg01, local01
03900     01 96 06 F6 | 	mov	arg04, #1
03904     90 25 B0 FD | 	call	#__system___fmtpad
03908     3B B7 02 F6 | 	mov	local09, result1
0390c     00 B6 56 F2 | 	cmps	local09, #0 wc
03910     5B 77 02 C6 |  if_b	mov	result1, local09
03914     5B AF 02 31 |  if_ae	add	local05, local09
03918     57 77 02 36 |  if_ae	mov	result1, local05
0391c                 | LR__0484
0391c     E7 F0 03 F6 | 	mov	ptra, fp
03920     F2 00 A0 FD | 	call	#popregs_
03924                 | __system___fmtstr_ret
03924     2D 00 64 FD | 	ret
03928                 | 
03928                 | __system___fmtfloat
03928     29 CA 05 F6 | 	mov	COUNT_, #41
0392c     E8 00 A0 FD | 	call	#pushregs_
03930     24 F1 07 F1 | 	add	ptra, #292
03934     48 A7 02 F6 | 	mov	local01, arg01
03938     49 A9 02 F6 | 	mov	local02, arg02
0393c     4A AB 02 F6 | 	mov	local03, arg03
03940     4B AD 02 F6 | 	mov	local04, arg04
03944     0A AE 06 F6 | 	mov	local05, #10
03948     00 B0 06 F6 | 	mov	local06, #0
0394c     00 B2 06 F6 | 	mov	local07, #0
03950     02 B4 06 F6 | 	mov	local08, #2
03954     00 B6 06 F6 | 	mov	local09, #0
03958     00 B8 06 F6 | 	mov	local10, #0
0395c     00 BA 06 F6 | 	mov	local11, #0
03960     E7 BC 02 F6 | 	mov	local12, fp
03964     C8 BC 06 F1 | 	add	local12, #200
03968     5E BF 02 F6 | 	mov	local13, local12
0396c     54 C1 02 F6 | 	mov	local14, local02
03970     10 C0 46 F0 | 	shr	local14, #16
03974     3F C0 0E F5 | 	and	local14, #63 wz
03978     54 C3 02 F6 | 	mov	local15, local02
0397c     1C C2 46 F0 | 	shr	local15, #28
03980     01 C2 06 F5 | 	and	local15, #1
03984     18 00 90 5D |  if_ne	jmp	#LR__0490
03988     61 AC 0E F2 | 	cmp	local04, #97 wz
0398c     0D C0 06 A6 |  if_e	mov	local14, #13
03990     01 B2 06 A6 |  if_e	mov	local07, #1
03994     0C 00 90 AD |  if_e	jmp	#LR__0491
03998     06 C0 06 F6 | 	mov	local14, #6
0399c     04 00 90 FD | 	jmp	#LR__0491
039a0                 | LR__0490
039a0     01 C0 86 F1 | 	sub	local14, #1
039a4                 | LR__0491
039a4     54 C5 02 F6 | 	mov	local16, local02
039a8     16 C4 46 F0 | 	shr	local16, #22
039ac     03 C4 06 F5 | 	and	local16, #3
039b0     54 C7 02 F6 | 	mov	local17, local02
039b4     1D C6 46 F0 | 	shr	local17, #29
039b8     01 C6 06 F5 | 	and	local17, #1
039bc     54 C9 EA F8 | 	getbyte	local18, local02, #1
039c0     54 CB E2 F8 | 	getbyte	local19, local02, #0
039c4     65 AC 0E F2 | 	cmp	local04, #101 wz
039c8     6E CC 62 FD | 	wrz	local20
039cc     66 CF 02 F6 | 	mov	local21, local20
039d0     00 C6 0E F2 | 	cmp	local17, #0 wz
039d4     45 CC 06 56 |  if_ne	mov	local20, #69
039d8     65 CC 06 A6 |  if_e	mov	local20, #101
039dc     66 D1 02 F6 | 	mov	local22, local20
039e0     61 AC 0E F2 | 	cmp	local04, #97 wz
039e4     2C 00 90 5D |  if_ne	jmp	#LR__0492
039e8     01 CE 06 F6 | 	mov	local21, #1
039ec     00 C6 0E F2 | 	cmp	local17, #0 wz
039f0     50 CC 06 56 |  if_ne	mov	local20, #80
039f4     70 CC 06 A6 |  if_e	mov	local20, #112
039f8     66 D1 02 F6 | 	mov	local22, local20
039fc     02 AE 06 F6 | 	mov	local05, #2
03a00     01 B4 06 F6 | 	mov	local08, #1
03a04     00 C6 0E F2 | 	cmp	local17, #0 wz
03a08     58 CC 06 56 |  if_ne	mov	local20, #88
03a0c     78 CC 06 A6 |  if_e	mov	local20, #120
03a10     66 B7 02 F6 | 	mov	local09, local20
03a14                 | LR__0492
03a14     23 AC 0E F2 | 	cmp	local04, #35 wz
03a18     14 00 90 5D |  if_ne	jmp	#LR__0493
03a1c     01 B8 06 F6 | 	mov	local10, #1
03a20     00 C2 0E F2 | 	cmp	local15, #0 wz
03a24     66 AC 06 56 |  if_ne	mov	local04, #102
03a28     00 C2 06 56 |  if_ne	mov	local15, #0
03a2c     01 C2 06 A6 |  if_e	mov	local15, #1
03a30                 | LR__0493
03a30     54 D3 02 F6 | 	mov	local23, local02
03a34     1A D2 46 F0 | 	shr	local23, #26
03a38     03 D2 06 F5 | 	and	local23, #3
03a3c     55 77 02 F6 | 	mov	result1, local03
03a40     1F 76 4E F0 | 	shr	result1, #31 wz
03a44     2D B0 06 56 |  if_ne	mov	local06, #45
03a48     1F AA E6 54 |  if_ne	bitnot	local03, #31
03a4c     14 00 90 5D |  if_ne	jmp	#LR__0495
03a50     01 D2 0E F2 | 	cmp	local23, #1 wz
03a54     2B B0 06 A6 |  if_e	mov	local06, #43
03a58     08 00 90 AD |  if_e	jmp	#LR__0494
03a5c     02 D2 0E F2 | 	cmp	local23, #2 wz
03a60     20 B0 06 A6 |  if_e	mov	local06, #32
03a64                 | LR__0494
03a64                 | LR__0495
03a64     54 D5 02 F6 | 	mov	local24, local02
03a68     18 D4 46 F0 | 	shr	local24, #24
03a6c     03 D4 06 F5 | 	and	local24, #3
03a70     00 CC 06 F6 | 	mov	local20, #0
03a74     00 B0 0E F2 | 	cmp	local06, #0 wz
03a78     0A AE 0E A2 |  if_e	cmp	local05, #10 wz
03a7c     01 CC 06 56 |  if_ne	mov	local20, #1
03a80     66 D7 0A F6 | 	mov	local25, local20 wz
03a84     60 00 90 AD |  if_e	jmp	#LR__0497
03a88     02 D4 0E F2 | 	cmp	local24, #2 wz
03a8c     58 00 90 5D |  if_ne	jmp	#LR__0497
03a90     02 C4 0E F2 | 	cmp	local16, #2 wz
03a94     50 00 90 AD |  if_e	jmp	#LR__0497
03a98     58 93 02 F6 | 	mov	arg02, local06
03a9c     5B D9 02 F6 | 	mov	local26, local09
03aa0     5E 91 02 F6 | 	mov	arg01, local12
03aa4     6C 95 02 F6 | 	mov	arg03, local26
03aa8     1C 27 B0 FD | 	call	#__system__emitsign_0095
03aac     3B DB 02 F6 | 	mov	local27, result1
03ab0     00 DA 56 F2 | 	cmps	local27, #0 wc
03ab4     6D 77 02 C6 |  if_b	mov	result1, local27
03ab8     C0 05 90 CD |  if_b	jmp	#LR__0540
03abc     6D DD 02 F6 | 	mov	local28, local27
03ac0     6D BD 02 F1 | 	add	local12, local27
03ac4     00 C8 0E F2 | 	cmp	local18, #0 wz
03ac8     18 00 90 AD |  if_e	jmp	#LR__0496
03acc     6D C9 82 F1 | 	sub	local18, local27
03ad0     00 C8 56 F3 | 	fges	local18, #0 wc
03ad4     E8 A8 06 F4 | 	bitl	local02, #232
03ad8     64 DD 02 F6 | 	mov	local28, local18
03adc     08 DC 66 F0 | 	shl	local28, #8
03ae0     6E A9 42 F5 | 	or	local02, local28
03ae4                 | LR__0496
03ae4     00 D6 06 F6 | 	mov	local25, #0
03ae8                 | LR__0497
03ae8     55 91 02 F6 | 	mov	arg01, local03
03aec     8C 10 B0 FD | 	call	#__system____builtin_ilogb
03af0     FF FF 3F FF 
03af4     FF 77 0E F2 | 	cmp	result1, ##2147483647 wz
03af8     24 00 90 5D |  if_ne	jmp	#LR__0498
03afc     00 B0 0E F2 | 	cmp	local06, #0 wz
03b00     5E CD 02 56 |  if_ne	mov	local20, local12
03b04     01 BC 06 51 |  if_ne	add	local12, #1
03b08     66 B1 42 5C |  if_ne	wrbyte	local06, local20
03b0c     6F 00 00 FF 
03b10     E2 92 06 F6 | 	mov	arg02, ##@LR__2141
03b14     5E 91 02 F6 | 	mov	arg01, local12
03b18     50 F2 BF FD | 	call	#__system____builtin_strcpy
03b1c     AC 04 90 FD | 	jmp	#LR__0530
03b20                 | LR__0498
03b20     55 91 02 F6 | 	mov	arg01, local03
03b24     54 10 B0 FD | 	call	#__system____builtin_ilogb
03b28     3B CD 02 F6 | 	mov	local20, result1
03b2c     00 00 40 FF 
03b30     00 CC 0E F2 | 	cmp	local20, ##-2147483648 wz
03b34     24 00 90 5D |  if_ne	jmp	#LR__0499
03b38     00 B0 0E F2 | 	cmp	local06, #0 wz
03b3c     5E CD 02 56 |  if_ne	mov	local20, local12
03b40     01 BC 06 51 |  if_ne	add	local12, #1
03b44     66 B1 42 5C |  if_ne	wrbyte	local06, local20
03b48     5E 91 02 F6 | 	mov	arg01, local12
03b4c     6F 00 00 FF 
03b50     E6 92 06 F6 | 	mov	arg02, ##@LR__2142
03b54     14 F2 BF FD | 	call	#__system____builtin_strcpy
03b58     70 04 90 FD | 	jmp	#LR__0530
03b5c                 | LR__0499
03b5c     67 AC 0E F2 | 	cmp	local04, #103 wz
03b60     23 AC 0E 52 |  if_ne	cmp	local04, #35 wz
03b64     0C 01 90 5D |  if_ne	jmp	#LR__0504
03b68     14 CE 05 F1 | 	add	fp, #20
03b6c     E7 92 02 F6 | 	mov	arg02, fp
03b70     0C CE 05 F1 | 	add	fp, #12
03b74     E7 94 02 F6 | 	mov	arg03, fp
03b78     20 CE 85 F1 | 	sub	fp, #32
03b7c     60 97 02 F6 | 	mov	arg04, local14
03b80     57 99 02 F6 | 	mov	arg05, local05
03b84     55 91 02 F6 | 	mov	arg01, local03
03b88     48 24 B0 FD | 	call	#__system__disassemble_0093
03b8c     23 AC 0E F2 | 	cmp	local04, #35 wz
03b90     6C 00 90 5D |  if_ne	jmp	#LR__0501
03b94     20 CE 05 F1 | 	add	fp, #32
03b98     E7 CC 02 FB | 	rdlong	local20, fp
03b9c     20 CE 85 F1 | 	sub	fp, #32
03ba0     60 CD 5A F2 | 	cmps	local20, local14 wcz
03ba4     01 CE 06 16 |  if_a	mov	local21, #1
03ba8     24 01 90 1D |  if_a	jmp	#LR__0507
03bac     20 CE 05 F1 | 	add	fp, #32
03bb0     E7 CC 02 FB | 	rdlong	local20, fp
03bb4     20 CE 85 F1 | 	sub	fp, #32
03bb8     00 CC 56 F2 | 	cmps	local20, #0 wc
03bbc     1C 00 90 3D |  if_ae	jmp	#LR__0500
03bc0     60 CD 62 F6 | 	neg	local20, local14
03bc4     20 CE 05 F1 | 	add	fp, #32
03bc8     E7 DC 02 FB | 	rdlong	local28, fp
03bcc     20 CE 85 F1 | 	sub	fp, #32
03bd0     66 DD 5A F2 | 	cmps	local28, local20 wcz
03bd4     01 CE 06 E6 |  if_be	mov	local21, #1
03bd8     F4 00 90 FD | 	jmp	#LR__0507
03bdc                 | LR__0500
03bdc     20 CE 05 F1 | 	add	fp, #32
03be0     E7 CC 02 FB | 	rdlong	local20, fp
03be4     20 CE 85 F1 | 	sub	fp, #32
03be8     01 CC 56 F2 | 	cmps	local20, #1 wc
03bec     20 CE 05 31 |  if_ae	add	fp, #32
03bf0     E7 DC 02 3B |  if_ae	rdlong	local28, fp
03bf4     20 CE 85 31 |  if_ae	sub	fp, #32
03bf8     6E C1 82 31 |  if_ae	sub	local14, local28
03bfc     D0 00 90 FD | 	jmp	#LR__0507
03c00                 | LR__0501
03c00     00 B2 06 F6 | 	mov	local07, #0
03c04     1C A8 2E F4 | 	testbn	local02, #28 wz
03c08     01 B2 06 A6 |  if_e	mov	local07, #1
03c0c     20 CE 05 F1 | 	add	fp, #32
03c10     E7 CC 02 FB | 	rdlong	local20, fp
03c14     20 CE 85 F1 | 	sub	fp, #32
03c18     60 CD 52 F2 | 	cmps	local20, local14 wc
03c1c     18 00 90 3D |  if_ae	jmp	#LR__0502
03c20     20 CE 05 F1 | 	add	fp, #32
03c24     E7 D8 02 FB | 	rdlong	local26, fp
03c28     20 CE 85 F1 | 	sub	fp, #32
03c2c     FF FF 7F FF 
03c30     FC D9 56 F2 | 	cmps	local26, ##-4 wc
03c34     08 00 90 3D |  if_ae	jmp	#LR__0503
03c38                 | LR__0502
03c38     01 CE 06 F6 | 	mov	local21, #1
03c3c     90 00 90 FD | 	jmp	#LR__0507
03c40                 | LR__0503
03c40     20 CE 05 F1 | 	add	fp, #32
03c44     E7 DC 02 FB | 	rdlong	local28, fp
03c48     6E C1 82 F1 | 	sub	local14, local28
03c4c     0C CE 85 F1 | 	sub	fp, #12
03c50     E7 92 02 F6 | 	mov	arg02, fp
03c54     0C CE 05 F1 | 	add	fp, #12
03c58     E7 94 02 F6 | 	mov	arg03, fp
03c5c     20 CE 85 F1 | 	sub	fp, #32
03c60     60 97 62 F6 | 	neg	arg04, local14
03c64     55 91 02 F6 | 	mov	arg01, local03
03c68     57 99 02 F6 | 	mov	arg05, local05
03c6c     64 23 B0 FD | 	call	#__system__disassemble_0093
03c70     5C 00 90 FD | 	jmp	#LR__0507
03c74                 | LR__0504
03c74     00 CE 0E F2 | 	cmp	local21, #0 wz
03c78     28 00 90 AD |  if_e	jmp	#LR__0505
03c7c     14 CE 05 F1 | 	add	fp, #20
03c80     E7 92 02 F6 | 	mov	arg02, fp
03c84     0C CE 05 F1 | 	add	fp, #12
03c88     E7 94 02 F6 | 	mov	arg03, fp
03c8c     20 CE 85 F1 | 	sub	fp, #32
03c90     55 91 02 F6 | 	mov	arg01, local03
03c94     60 97 02 F6 | 	mov	arg04, local14
03c98     57 99 02 F6 | 	mov	arg05, local05
03c9c     34 23 B0 FD | 	call	#__system__disassemble_0093
03ca0     2C 00 90 FD | 	jmp	#LR__0506
03ca4                 | LR__0505
03ca4     14 CE 05 F1 | 	add	fp, #20
03ca8     E7 92 02 F6 | 	mov	arg02, fp
03cac     0C CE 05 F1 | 	add	fp, #12
03cb0     E7 94 02 F6 | 	mov	arg03, fp
03cb4     20 CE 85 F1 | 	sub	fp, #32
03cb8     60 DD 02 F6 | 	mov	local28, local14
03cbc     01 DC 06 F1 | 	add	local28, #1
03cc0     6E 97 62 F6 | 	neg	arg04, local28
03cc4     55 91 02 F6 | 	mov	arg01, local03
03cc8     57 99 02 F6 | 	mov	arg05, local05
03ccc     04 23 B0 FD | 	call	#__system__disassemble_0093
03cd0                 | LR__0506
03cd0                 | LR__0507
03cd0     02 AE 0E F2 | 	cmp	local05, #2 wz
03cd4     44 00 90 5D |  if_ne	jmp	#LR__0510
03cd8     10 AE 06 F6 | 	mov	local05, #16
03cdc                 | LR__0508
03cdc     14 CE 05 F1 | 	add	fp, #20
03ce0     E7 CC 0A FB | 	rdlong	local20, fp wz
03ce4     14 CE 85 F1 | 	sub	fp, #20
03ce8     30 00 90 AD |  if_e	jmp	#LR__0509
03cec     14 CE 05 F1 | 	add	fp, #20
03cf0     E7 D8 02 FB | 	rdlong	local26, fp
03cf4     14 CE 85 F1 | 	sub	fp, #20
03cf8     00 80 00 FF 
03cfc     00 D8 16 F2 | 	cmp	local26, ##16777216 wc
03d00     18 00 90 3D |  if_ae	jmp	#LR__0509
03d04     14 CE 05 F1 | 	add	fp, #20
03d08     E7 CC 02 FB | 	rdlong	local20, fp
03d0c     01 CC 66 F0 | 	shl	local20, #1
03d10     E7 CC 62 FC | 	wrlong	local20, fp
03d14     14 CE 85 F1 | 	sub	fp, #20
03d18     C0 FF 9F FD | 	jmp	#LR__0508
03d1c                 | LR__0509
03d1c                 | LR__0510
03d1c     70 CE 05 F1 | 	add	fp, #112
03d20     E7 90 02 F6 | 	mov	arg01, fp
03d24     5C CE 85 F1 | 	sub	fp, #92
03d28     E7 92 02 FB | 	rdlong	arg02, fp
03d2c     14 CE 85 F1 | 	sub	fp, #20
03d30     57 95 02 F6 | 	mov	arg03, local05
03d34     01 96 06 F6 | 	mov	arg04, #1
03d38     63 99 02 F6 | 	mov	arg05, local17
03d3c     20 22 B0 FD | 	call	#__system___uitoa
03d40     3B DF 02 F6 | 	mov	local29, result1
03d44     20 CE 05 F1 | 	add	fp, #32
03d48     E7 CC 02 FB | 	rdlong	local20, fp
03d4c     20 CE 85 F1 | 	sub	fp, #32
03d50     00 CC 56 F2 | 	cmps	local20, #0 wc
03d54     44 00 90 3D |  if_ae	jmp	#LR__0511
03d58     2D BA 06 F6 | 	mov	local11, #45
03d5c     B0 CE 05 F1 | 	add	fp, #176
03d60     E7 90 02 F6 | 	mov	arg01, fp
03d64     90 CE 85 F1 | 	sub	fp, #144
03d68     E7 D8 02 FB | 	rdlong	local26, fp
03d6c     20 CE 85 F1 | 	sub	fp, #32
03d70     6C DD 62 F6 | 	neg	local28, local26
03d74     0A D8 06 F6 | 	mov	local26, #10
03d78     5A E1 02 F6 | 	mov	local30, local08
03d7c     63 E3 02 F6 | 	mov	local31, local17
03d80     6E 93 02 F6 | 	mov	arg02, local28
03d84     0A 94 06 F6 | 	mov	arg03, #10
03d88     70 97 02 F6 | 	mov	arg04, local30
03d8c     71 99 02 F6 | 	mov	arg05, local31
03d90     CC 21 B0 FD | 	call	#__system___uitoa
03d94     3B E5 02 F6 | 	mov	local32, result1
03d98     3C 00 90 FD | 	jmp	#LR__0512
03d9c                 | LR__0511
03d9c     2B BA 06 F6 | 	mov	local11, #43
03da0     B0 CE 05 F1 | 	add	fp, #176
03da4     E7 90 02 F6 | 	mov	arg01, fp
03da8     90 CE 85 F1 | 	sub	fp, #144
03dac     E7 DC 02 FB | 	rdlong	local28, fp
03db0     20 CE 85 F1 | 	sub	fp, #32
03db4     0A D8 06 F6 | 	mov	local26, #10
03db8     5A E1 02 F6 | 	mov	local30, local08
03dbc     63 E3 02 F6 | 	mov	local31, local17
03dc0     6E 93 02 F6 | 	mov	arg02, local28
03dc4     0A 94 06 F6 | 	mov	arg03, #10
03dc8     70 97 02 F6 | 	mov	arg04, local30
03dcc     71 99 02 F6 | 	mov	arg05, local31
03dd0     8C 21 B0 FD | 	call	#__system___uitoa
03dd4     3B E5 02 F6 | 	mov	local32, result1
03dd8                 | LR__0512
03dd8     00 CE 0E F2 | 	cmp	local21, #0 wz
03ddc     00 E6 06 56 |  if_ne	mov	local33, #0
03de0     00 E8 06 56 |  if_ne	mov	local34, #0
03de4     60 EB 02 56 |  if_ne	mov	local35, local14
03de8     01 EA 06 51 |  if_ne	add	local35, #1
03dec     54 00 90 5D |  if_ne	jmp	#LR__0515
03df0     20 CE 05 F1 | 	add	fp, #32
03df4     E7 DC 02 FB | 	rdlong	local28, fp
03df8     20 CE 85 F1 | 	sub	fp, #32
03dfc     00 DC 56 F2 | 	cmps	local28, #0 wc
03e00     24 00 90 3D |  if_ae	jmp	#LR__0513
03e04     20 CE 05 F1 | 	add	fp, #32
03e08     E7 DC 02 FB | 	rdlong	local28, fp
03e0c     6E E7 02 F6 | 	mov	local33, local28
03e10     73 E9 02 F6 | 	mov	local34, local33
03e14     20 CE 85 F1 | 	sub	fp, #32
03e18     6E EB 02 F6 | 	mov	local35, local28
03e1c     60 EB 02 F1 | 	add	local35, local14
03e20     01 EA 06 F1 | 	add	local35, #1
03e24     1C 00 90 FD | 	jmp	#LR__0514
03e28                 | LR__0513
03e28     00 E8 06 F6 | 	mov	local34, #0
03e2c     20 CE 05 F1 | 	add	fp, #32
03e30     E7 E6 02 FB | 	rdlong	local33, fp
03e34     20 CE 85 F1 | 	sub	fp, #32
03e38     73 EB 02 F6 | 	mov	local35, local33
03e3c     60 EB 02 F1 | 	add	local35, local14
03e40     01 EA 06 F1 | 	add	local35, #1
03e44                 | LR__0514
03e44                 | LR__0515
03e44     75 CD 02 F6 | 	mov	local20, local35
03e48     74 CD 82 F1 | 	sub	local20, local34
03e4c     01 CC 06 F1 | 	add	local20, #1
03e50     66 ED 02 F6 | 	mov	local36, local20
03e54     00 B0 0E F2 | 	cmp	local06, #0 wz
03e58     76 CD 02 56 |  if_ne	mov	local20, local36
03e5c     76 DD 02 56 |  if_ne	mov	local28, local36
03e60     01 DC 06 51 |  if_ne	add	local28, #1
03e64     6E ED 02 56 |  if_ne	mov	local36, local28
03e68     10 AE 0E F2 | 	cmp	local05, #16 wz
03e6c     02 EC 06 A1 |  if_e	add	local36, #2
03e70     00 CE 0E F2 | 	cmp	local21, #0 wz
03e74     02 DC 06 56 |  if_ne	mov	local28, #2
03e78     72 DD 02 51 |  if_ne	add	local28, local32
03e7c     6E ED 02 51 |  if_ne	add	local36, local28
03e80     41 EC 56 F2 | 	cmps	local36, #65 wc
03e84     01 76 66 36 |  if_ae	neg	result1, #1
03e88     F0 01 90 3D |  if_ae	jmp	#LR__0540
03e8c     00 D6 0E F2 | 	cmp	local25, #0 wz
03e90     28 00 90 AD |  if_e	jmp	#LR__0516
03e94     58 93 02 F6 | 	mov	arg02, local06
03e98     5E 91 02 F6 | 	mov	arg01, local12
03e9c     5B 95 02 F6 | 	mov	arg03, local09
03ea0     24 23 B0 FD | 	call	#__system__emitsign_0095
03ea4     3B EF 02 F6 | 	mov	local37, result1
03ea8     00 EE 56 F2 | 	cmps	local37, #0 wc
03eac     77 77 02 C6 |  if_b	mov	result1, local37
03eb0     C8 01 90 CD |  if_b	jmp	#LR__0540
03eb4     77 DD 02 F6 | 	mov	local28, local37
03eb8     77 BD 02 F1 | 	add	local12, local37
03ebc                 | LR__0516
03ebc     74 F1 02 F6 | 	mov	local38, local34
03ec0     D7 42 48 FB | 	callpa	#(@LR__0521-@LR__0517)>>2,fcache_load_ptr_
03ec4                 | LR__0517
03ec4     75 F1 52 F2 | 	cmps	local38, local35 wc
03ec8     7C 00 90 3D |  if_ae	jmp	#LR__0522
03ecc     00 F0 56 F2 | 	cmps	local38, #0 wc
03ed0     2C 00 90 CD |  if_b	jmp	#LR__0518
03ed4     6F F1 52 F2 | 	cmps	local38, local29 wc
03ed8     24 00 90 3D |  if_ae	jmp	#LR__0518
03edc     5E CD 02 F6 | 	mov	local20, local12
03ee0     78 D9 02 F6 | 	mov	local26, local38
03ee4     E7 E0 02 F6 | 	mov	local30, fp
03ee8     70 E0 06 F1 | 	add	local30, #112
03eec     70 D9 02 F1 | 	add	local26, local30
03ef0     6C E3 C2 FA | 	rdbyte	local31, local26
03ef4     66 E3 42 FC | 	wrbyte	local31, local20
03ef8     01 BC 06 F1 | 	add	local12, #1
03efc     10 00 90 FD | 	jmp	#LR__0519
03f00                 | LR__0518
03f00     5E CD 02 F6 | 	mov	local20, local12
03f04     30 D8 06 F6 | 	mov	local26, #48
03f08     66 61 48 FC | 	wrbyte	#48, local20
03f0c     01 BC 06 F1 | 	add	local12, #1
03f10                 | LR__0519
03f10     73 F1 0A F2 | 	cmp	local38, local33 wz
03f14     20 00 90 5D |  if_ne	jmp	#LR__0520
03f18     00 C2 0E F2 | 	cmp	local15, #0 wz
03f1c     75 CD 02 A6 |  if_e	mov	local20, local35
03f20     01 CC 86 A1 |  if_e	sub	local20, #1
03f24     66 F1 52 A2 |  if_e	cmps	local38, local20 wc
03f28     5E CD 02 D6 |  if_c_or_nz	mov	local20, local12
03f2c     2E D8 06 D6 |  if_c_or_nz	mov	local26, #46
03f30     66 5D 48 DC |  if_c_or_nz	wrbyte	#46, local20
03f34     01 BC 06 D1 |  if_c_or_nz	add	local12, #1
03f38                 | LR__0520
03f38     78 DD 02 F6 | 	mov	local28, local38
03f3c     01 DC 06 F1 | 	add	local28, #1
03f40     6E F1 02 F6 | 	mov	local38, local28
03f44     7C FF 9F FD | 	jmp	#LR__0517
03f48                 | LR__0521
03f48                 | LR__0522
03f48     00 B2 0E F2 | 	cmp	local07, #0 wz
03f4c     30 00 90 AD |  if_e	jmp	#LR__0526
03f50     01 BC 86 F1 | 	sub	local12, #1
03f54     D7 0C 48 FB | 	callpa	#(@LR__0524-@LR__0523)>>2,fcache_load_ptr_
03f58                 | LR__0523
03f58     5F BD 5A F2 | 	cmps	local12, local13 wcz
03f5c     10 00 90 ED |  if_be	jmp	#LR__0525
03f60     5E CD C2 FA | 	rdbyte	local20, local12
03f64     30 CC 0E F2 | 	cmp	local20, #48 wz
03f68     01 BC 86 A1 |  if_e	sub	local12, #1
03f6c     E8 FF 9F AD |  if_e	jmp	#LR__0523
03f70                 | LR__0524
03f70                 | LR__0525
03f70     5E CD C2 FA | 	rdbyte	local20, local12
03f74     2E CC 0E F2 | 	cmp	local20, #46 wz
03f78     01 BC 86 A1 |  if_e	sub	local12, #1
03f7c     01 BC 06 F1 | 	add	local12, #1
03f80                 | LR__0526
03f80     00 CE 0E F2 | 	cmp	local21, #0 wz
03f84     40 00 90 AD |  if_e	jmp	#LR__0529
03f88     5E D1 42 FC | 	wrbyte	local22, local12
03f8c     01 BC 06 F1 | 	add	local12, #1
03f90     5E BB 42 FC | 	wrbyte	local11, local12
03f94     00 F0 06 F6 | 	mov	local38, #0
03f98     01 BC 06 F1 | 	add	local12, #1
03f9c                 | LR__0527
03f9c     72 F1 52 F2 | 	cmps	local38, local32 wc
03fa0     24 00 90 3D |  if_ae	jmp	#LR__0528
03fa4     78 D9 02 F6 | 	mov	local26, local38
03fa8     E7 E0 02 F6 | 	mov	local30, fp
03fac     B0 E0 06 F1 | 	add	local30, #176
03fb0     70 D9 02 F1 | 	add	local26, local30
03fb4     6C E3 C2 FA | 	rdbyte	local31, local26
03fb8     5E E3 42 FC | 	wrbyte	local31, local12
03fbc     01 F0 06 F1 | 	add	local38, #1
03fc0     01 BC 06 F1 | 	add	local12, #1
03fc4     D4 FF 9F FD | 	jmp	#LR__0527
03fc8                 | LR__0528
03fc8                 | LR__0529
03fc8     5E 01 48 FC | 	wrbyte	#0, local12
03fcc                 | LR__0530
03fcc     00 CA 0E F2 | 	cmp	local19, #0 wz
03fd0     00 B8 0E 52 |  if_ne	cmp	local10, #0 wz
03fd4     94 00 90 AD |  if_e	jmp	#LR__0539
03fd8     5F 91 02 F6 | 	mov	arg01, local13
03fdc     48 F3 02 F6 | 	mov	local39, arg01
03fe0     D7 06 48 FB | 	callpa	#(@LR__0532-@LR__0531)>>2,fcache_load_ptr_
03fe4                 | LR__0531
03fe4     79 77 CA FA | 	rdbyte	result1, local39 wz
03fe8     01 F2 06 51 |  if_ne	add	local39, #1
03fec     F4 FF 9F 5D |  if_ne	jmp	#LR__0531
03ff0                 | LR__0532
03ff0     48 F3 82 F1 | 	sub	local39, arg01
03ff4     65 F3 5A F2 | 	cmps	local39, local19 wcz
03ff8     70 00 90 ED |  if_be	jmp	#LR__0539
03ffc     5F F5 02 F6 | 	mov	local40, local13
04000     00 CE 0E F2 | 	cmp	local21, #0 wz
04004     00 C0 06 56 |  if_ne	mov	local14, #0
04008     65 F7 02 56 |  if_ne	mov	local41, local19
0400c     01 CA 86 A1 |  if_e	sub	local19, #1
04010     60 CB 82 A1 |  if_e	sub	local19, local14
04014     65 F7 02 A6 |  if_e	mov	local41, local19
04018     00 F6 0E F2 | 	cmp	local41, #0 wz
0401c     14 00 90 AD |  if_e	jmp	#LR__0535
04020     D7 08 48 FB | 	callpa	#(@LR__0534-@LR__0533)>>2,fcache_load_ptr_
04024                 | LR__0533
04024     7A 55 48 FC | 	wrbyte	#42, local40
04028     01 F6 8E F1 | 	sub	local41, #1 wz
0402c     01 F4 06 F1 | 	add	local40, #1
04030     F0 FF 9F 5D |  if_ne	jmp	#LR__0533
04034                 | LR__0534
04034                 | LR__0535
04034     00 C0 0E F2 | 	cmp	local14, #0 wz
04038     2C 00 90 AD |  if_e	jmp	#LR__0538
0403c     7A CD 02 F6 | 	mov	local20, local40
04040     66 5D 48 FC | 	wrbyte	#46, local20
04044     00 F6 06 F6 | 	mov	local41, #0
04048     01 F4 06 F1 | 	add	local40, #1
0404c     D7 0C 48 FB | 	callpa	#(@LR__0537-@LR__0536)>>2,fcache_load_ptr_
04050                 | LR__0536
04050     60 F7 52 F2 | 	cmps	local41, local14 wc
04054     7A CD 02 C6 |  if_b	mov	local20, local40
04058     01 F4 06 C1 |  if_b	add	local40, #1
0405c     66 55 48 CC |  if_b	wrbyte	#42, local20
04060     01 F6 06 C1 |  if_b	add	local41, #1
04064     E8 FF 9F CD |  if_b	jmp	#LR__0536
04068                 | LR__0537
04068                 | LR__0538
04068     7A 01 48 FC | 	wrbyte	#0, local40
0406c                 | LR__0539
0406c     53 91 02 F6 | 	mov	arg01, local01
04070     54 93 02 F6 | 	mov	arg02, local02
04074     5F 95 02 F6 | 	mov	arg03, local13
04078     C0 F7 BF FD | 	call	#__system___fmtstr
0407c                 | LR__0540
0407c     E7 F0 03 F6 | 	mov	ptra, fp
04080     F2 00 A0 FD | 	call	#popregs_
04084                 | __system___fmtfloat_ret
04084     2D 00 64 FD | 	ret
04088                 | 
04088                 | __system__str_S
04088     02 CA 05 F6 | 	mov	COUNT_, #2
0408c     E8 00 A0 FD | 	call	#pushregs_
04090     48 A7 02 F6 | 	mov	local01, arg01
04094     10 90 06 F6 | 	mov	arg01, #16
04098     3C 0E B0 FD | 	call	#__system___gc_alloc_managed
0409c     3B A9 0A F6 | 	mov	local02, result1 wz
040a0     2C 00 90 AD |  if_e	jmp	#LR__0550
040a4     F8 91 02 F6 | 	mov	arg01, ptra
040a8     08 F0 07 F1 | 	add	ptra, #8
040ac     48 A9 62 FC | 	wrlong	local02, arg01
040b0     04 90 06 F1 | 	add	arg01, #4
040b4     48 01 68 FC | 	wrlong	#0, arg01
040b8     04 90 86 F1 | 	sub	arg01, #4
040bc     54 90 26 F4 | 	bith	arg01, #84
040c0     00 92 06 F6 | 	mov	arg02, #0
040c4     53 95 02 F6 | 	mov	arg03, local01
040c8     67 96 06 F6 | 	mov	arg04, #103
040cc     58 F8 BF FD | 	call	#__system___fmtfloat
040d0                 | LR__0550
040d0     54 77 02 F6 | 	mov	result1, local02
040d4     E7 F0 03 F6 | 	mov	ptra, fp
040d8     F2 00 A0 FD | 	call	#popregs_
040dc                 | __system__str_S_ret
040dc     2D 00 64 FD | 	ret
040e0                 | 
040e0                 | __system___int64_shl
040e0     20 94 CE F7 | 	test	arg03, #32 wz
040e4     48 93 02 56 |  if_ne	mov	arg02, arg01
040e8     00 90 06 56 |  if_ne	mov	arg01, #0
040ec     1F 94 CE F7 | 	test	arg03, #31 wz
040f0     18 00 90 AD |  if_e	jmp	#LR__0560
040f4     4A 93 62 F0 | 	shl	arg02, arg03
040f8     48 77 02 F6 | 	mov	result1, arg01
040fc     4A 79 62 F6 | 	neg	result2, arg03
04100     3C 77 42 F0 | 	shr	result1, result2
04104     3B 93 42 F5 | 	or	arg02, result1
04108     4A 91 62 F0 | 	shl	arg01, arg03
0410c                 | LR__0560
0410c     49 79 02 F6 | 	mov	result2, arg02
04110     48 77 02 F6 | 	mov	result1, arg01
04114                 | __system___int64_shl_ret
04114     2D 00 64 FD | 	ret
04118                 | 
04118                 | __system___int64_sar
04118     20 94 CE F7 | 	test	arg03, #32 wz
0411c     49 91 02 56 |  if_ne	mov	arg01, arg02
04120     1F 92 C6 50 |  if_ne	sar	arg02, #31
04124     1F 94 CE F7 | 	test	arg03, #31 wz
04128     18 00 90 AD |  if_e	jmp	#LR__0570
0412c     4A 91 42 F0 | 	shr	arg01, arg03
04130     49 77 02 F6 | 	mov	result1, arg02
04134     4A 79 62 F6 | 	neg	result2, arg03
04138     3C 77 62 F0 | 	shl	result1, result2
0413c     3B 91 42 F5 | 	or	arg01, result1
04140     4A 93 C2 F0 | 	sar	arg02, arg03
04144                 | LR__0570
04144     49 79 02 F6 | 	mov	result2, arg02
04148     48 77 02 F6 | 	mov	result1, arg01
0414c                 | __system___int64_sar_ret
0414c     2D 00 64 FD | 	ret
04150                 | 
04150                 | __system___usepins
04150     14 66 06 F1 | 	add	ptr___system__dat__, #20
04154     33 7D 02 FB | 	rdlong	_var01, ptr___system__dat__
04158     14 66 86 F1 | 	sub	ptr___system__dat__, #20
0415c     3E 91 CA F7 | 	test	arg01, _var01 wz
04160     18 66 06 A1 |  if_e	add	ptr___system__dat__, #24
04164     33 7F 02 AB |  if_e	rdlong	_var02, ptr___system__dat__
04168     18 66 86 A1 |  if_e	sub	ptr___system__dat__, #24
0416c     3F 93 CA A7 |  if_e	test	arg02, _var02 wz
04170     00 76 06 56 |  if_ne	mov	result1, #0
04174     28 00 90 5D |  if_ne	jmp	#__system___usepins_ret
04178     14 66 06 F1 | 	add	ptr___system__dat__, #20
0417c     33 7F 02 FB | 	rdlong	_var02, ptr___system__dat__
04180     48 7F 42 F5 | 	or	_var02, arg01
04184     33 7F 62 FC | 	wrlong	_var02, ptr___system__dat__
04188     04 66 06 F1 | 	add	ptr___system__dat__, #4
0418c     33 7F 02 FB | 	rdlong	_var02, ptr___system__dat__
04190     49 7F 42 F5 | 	or	_var02, arg02
04194     33 7F 62 FC | 	wrlong	_var02, ptr___system__dat__
04198     18 66 86 F1 | 	sub	ptr___system__dat__, #24
0419c     01 76 66 F6 | 	neg	result1, #1
041a0                 | __system___usepins_ret
041a0     2D 00 64 FD | 	ret
041a4                 | 
041a4                 | __system___freepins
041a4     14 66 06 F1 | 	add	ptr___system__dat__, #20
041a8     33 7D 02 FB | 	rdlong	_var01, ptr___system__dat__
041ac     48 7D 22 F5 | 	andn	_var01, arg01
041b0     33 7D 62 FC | 	wrlong	_var01, ptr___system__dat__
041b4     04 66 06 F1 | 	add	ptr___system__dat__, #4
041b8     33 7D 02 FB | 	rdlong	_var01, ptr___system__dat__
041bc     49 7D 22 F5 | 	andn	_var01, arg02
041c0     33 7D 62 FC | 	wrlong	_var01, ptr___system__dat__
041c4     18 66 86 F1 | 	sub	ptr___system__dat__, #24
041c8                 | __system___freepins_ret
041c8     2D 00 64 FD | 	ret
041cc                 | 
041cc                 | __system___float_fromuns
041cc     48 95 0A F6 | 	mov	arg03, arg01 wz
041d0     4A 77 02 A6 |  if_e	mov	result1, arg03
041d4     24 00 90 AD |  if_e	jmp	#LR__0580
041d8     4A 93 92 F7 | 	encod	arg02, arg03 wc
041dc     01 92 06 C1 |  if_b	add	arg02, #1
041e0     01 92 86 F1 | 	sub	arg02, #1
041e4     1F 90 06 F6 | 	mov	arg01, #31
041e8     49 91 82 F1 | 	sub	arg01, arg02
041ec     48 95 62 F0 | 	shl	arg03, arg01
041f0     02 94 46 F0 | 	shr	arg03, #2
041f4     00 90 06 F6 | 	mov	arg01, #0
041f8     80 08 B0 FD | 	call	#__system___float_Pack
041fc                 | LR__0580
041fc                 | __system___float_fromuns_ret
041fc     2D 00 64 FD | 	ret
04200                 | 
04200                 | __system___float_add
04200     0F CA 05 F6 | 	mov	COUNT_, #15
04204     E8 00 A0 FD | 	call	#pushregs_
04208     48 A7 02 F6 | 	mov	local01, arg01
0420c     49 A9 02 F6 | 	mov	local02, arg02
04210     00 AA 06 F6 | 	mov	local03, #0
04214     53 AD 02 F6 | 	mov	local04, local01
04218     56 AF 02 F6 | 	mov	local05, local04
0421c     16 AE 46 F7 | 	zerox	local05, #22
04220     56 B1 02 F6 | 	mov	local06, local04
04224     01 B0 66 F0 | 	shl	local06, #1
04228     18 B0 46 F0 | 	shr	local06, #24
0422c     1F AC 46 F0 | 	shr	local04, #31
04230     54 91 02 F6 | 	mov	arg01, local02
04234     48 77 02 F6 | 	mov	result1, arg01
04238     3B B3 02 F6 | 	mov	local07, result1
0423c     59 B5 02 F6 | 	mov	local08, local07
04240     16 B4 46 F7 | 	zerox	local08, #22
04244     59 B7 02 F6 | 	mov	local09, local07
04248     01 B6 66 F0 | 	shl	local09, #1
0424c     18 B6 46 F0 | 	shr	local09, #24
04250     5B B9 02 F6 | 	mov	local10, local09
04254     1F B2 46 F0 | 	shr	local07, #31
04258     00 BA 06 F6 | 	mov	local11, #0
0425c     00 BC 06 F6 | 	mov	local12, #0
04260     5C B1 12 F2 | 	cmp	local06, local10 wc
04264     5C B1 0A 32 |  if_ae	cmp	local06, local10 wz
04268     2C 00 90 1D |  if_a	jmp	#LR__0590
0426c     5A AF 12 32 |  if_ae	cmp	local05, local08 wc
04270     24 00 90 3D |  if_ae	jmp	#LR__0590
04274     57 BF 02 F6 | 	mov	local13, local05
04278     5A AF 02 F6 | 	mov	local05, local08
0427c     5F B5 02 F6 | 	mov	local08, local13
04280     58 BF 02 F6 | 	mov	local13, local06
04284     5C B1 02 F6 | 	mov	local06, local10
04288     5F B9 02 F6 | 	mov	local10, local13
0428c     56 BF 02 F6 | 	mov	local13, local04
04290     59 AD 02 F6 | 	mov	local04, local07
04294     5F B3 02 F6 | 	mov	local07, local13
04298                 | LR__0590
04298     FF B0 0E F2 | 	cmp	local06, #255 wz
0429c     70 01 90 AD |  if_e	jmp	#LR__0605
042a0     00 B0 0E F2 | 	cmp	local06, #0 wz
042a4     AC 01 90 AD |  if_e	jmp	#LR__0607
042a8     17 AE 26 F4 | 	bith	local05, #23
042ac                 | LR__0591
042ac     00 B8 0E F2 | 	cmp	local10, #0 wz
042b0     F0 01 90 AD |  if_e	jmp	#LR__0611
042b4     17 B4 26 F4 | 	bith	local08, #23
042b8                 | LR__0592
042b8     7F B0 86 F1 | 	sub	local06, #127
042bc     7F B8 86 F1 | 	sub	local10, #127
042c0     58 C1 02 F6 | 	mov	local14, local06
042c4     5C C1 82 F1 | 	sub	local14, local10
042c8     D7 14 48 FB | 	callpa	#(@LR__0594-@LR__0593)>>2,fcache_load_ptr_
042cc                 | LR__0593
042cc     20 C0 56 F2 | 	cmps	local14, #32 wc
042d0     20 00 90 CD |  if_b	jmp	#LR__0595
042d4     5A B7 02 F6 | 	mov	local09, local08
042d8     00 BA 0E F2 | 	cmp	local11, #0 wz
042dc     6F BA 62 FD | 	wrnz	local11
042e0     5D B7 42 F5 | 	or	local09, local11
042e4     5B BB 02 F6 | 	mov	local11, local09
042e8     00 B4 06 F6 | 	mov	local08, #0
042ec     20 C0 86 F1 | 	sub	local14, #32
042f0     D8 FF 9F FD | 	jmp	#LR__0593
042f4                 | LR__0594
042f4                 | LR__0595
042f4     00 C0 0E F2 | 	cmp	local14, #0 wz
042f8     38 00 90 AD |  if_e	jmp	#LR__0596
042fc     5A BF 02 F6 | 	mov	local13, local08
04300     20 B8 06 F6 | 	mov	local10, #32
04304     60 B9 82 F1 | 	sub	local10, local14
04308     5C BF 62 F0 | 	shl	local13, local10
0430c     5D B9 02 F6 | 	mov	local10, local11
04310     20 B6 06 F6 | 	mov	local09, #32
04314     60 B7 82 F1 | 	sub	local09, local14
04318     5B B9 6A F0 | 	shl	local10, local09 wz
0431c     60 BB 42 F0 | 	shr	local11, local14
04320     60 B5 42 F0 | 	shr	local08, local14
04324     5F BB 42 F5 | 	or	local11, local13
04328     00 C2 06 F6 | 	mov	local15, #0
0432c     01 C2 06 56 |  if_ne	mov	local15, #1
04330     61 BB 42 F5 | 	or	local11, local15
04334                 | LR__0596
04334     56 C3 02 F6 | 	mov	local15, local04
04338     59 C3 62 F5 | 	xor	local15, local07
0433c     01 C2 CE F7 | 	test	local15, #1 wz
04340     18 00 90 AD |  if_e	jmp	#LR__0597
04344     5A B5 22 F6 | 	not	local08, local08
04348     5D BB 22 F6 | 	not	local11, local11
0434c     01 BA 0E F1 | 	add	local11, #1 wz
04350     00 C2 06 F6 | 	mov	local15, #0
04354     01 C2 06 A6 |  if_e	mov	local15, #1
04358     61 B5 02 F1 | 	add	local08, local15
0435c                 | LR__0597
0435c     5D BD 12 F1 | 	add	local12, local11 wc
04360     5A AF 22 F1 | 	addx	local05, local08
04364     00 AE 56 F2 | 	cmps	local05, #0 wc
04368     1C 00 90 3D |  if_ae	jmp	#LR__0598
0436c     01 AC 66 F5 | 	xor	local04, #1
04370     57 AF 22 F6 | 	not	local05, local05
04374     5E BD 22 F6 | 	not	local12, local12
04378     01 BC 0E F1 | 	add	local12, #1 wz
0437c     00 C2 06 F6 | 	mov	local15, #0
04380     01 C2 06 A6 |  if_e	mov	local15, #1
04384     61 AF 02 F1 | 	add	local05, local15
04388                 | LR__0598
04388     00 80 00 FF 
0438c     00 AE 16 F2 | 	cmp	local05, ##16777216 wc
04390     28 00 90 CD |  if_b	jmp	#LR__0599
04394     01 B0 06 F1 | 	add	local06, #1
04398     5E C1 02 F6 | 	mov	local14, local12
0439c     01 C0 06 F5 | 	and	local14, #1
043a0     01 BC 46 F0 | 	shr	local12, #1
043a4     57 C3 02 F6 | 	mov	local15, local05
043a8     1F C2 66 F0 | 	shl	local15, #31
043ac     61 BD 42 F5 | 	or	local12, local15
043b0     60 BD 42 F5 | 	or	local12, local14
043b4     01 AE 46 F0 | 	shr	local05, #1
043b8     3C 00 90 FD | 	jmp	#LR__0604
043bc                 | LR__0599
043bc     00 40 00 FF 
043c0     00 AE 16 F2 | 	cmp	local05, ##8388608 wc
043c4     30 00 90 3D |  if_ae	jmp	#LR__0603
043c8     00 AE 0E F2 | 	cmp	local05, #0 wz
043cc     00 BC 0E A2 |  if_e	cmp	local12, #0 wz
043d0     08 AC 46 A5 |  if_e	or	local04, #8
043d4     01 AC 26 A5 |  if_e	andn	local04, #1
043d8     1C 00 90 AD |  if_e	jmp	#LR__0602
043dc                 | LR__0600
043dc     00 40 00 FF 
043e0     00 AE 16 F2 | 	cmp	local05, ##8388608 wc
043e4     10 00 90 3D |  if_ae	jmp	#LR__0601
043e8     5E BD 12 F1 | 	add	local12, local12 wc
043ec     57 AF 22 F1 | 	addx	local05, local05
043f0     01 B0 86 F1 | 	sub	local06, #1
043f4     E4 FF 9F FD | 	jmp	#LR__0600
043f8                 | LR__0601
043f8                 | LR__0602
043f8                 | LR__0603
043f8                 | LR__0604
043f8     57 91 02 F6 | 	mov	arg01, local05
043fc     5E 93 02 F6 | 	mov	arg02, local12
04400     58 95 02 F6 | 	mov	arg03, local06
04404     56 97 02 F6 | 	mov	arg04, local04
04408     78 1E B0 FD | 	call	#__system__pack_0176
0440c     DC 00 90 FD | 	jmp	#LR__0615
04410                 | LR__0605
04410     FF B8 0E F2 | 	cmp	local10, #255 wz
04414     10 00 90 5D |  if_ne	jmp	#LR__0606
04418     56 B3 0A F2 | 	cmp	local07, local04 wz
0441c     00 F8 3F 5F 
04420     00 76 06 56 |  if_ne	mov	result1, ##2146435072
04424     C4 00 90 5D |  if_ne	jmp	#LR__0615
04428                 | LR__0606
04428     00 AE 0E F2 | 	cmp	local05, #0 wz
0442c     00 F8 3F 5F 
04430     00 76 06 56 |  if_ne	mov	result1, ##2146435072
04434     B4 00 90 5D |  if_ne	jmp	#LR__0615
04438     5E 93 02 F6 | 	mov	arg02, local12
0443c     58 95 02 F6 | 	mov	arg03, local06
04440     56 97 02 F6 | 	mov	arg04, local04
04444     02 96 46 F5 | 	or	arg04, #2
04448     57 91 02 F6 | 	mov	arg01, local05
0444c     34 1E B0 FD | 	call	#__system__pack_0176
04450     98 00 90 FD | 	jmp	#LR__0615
04454                 | LR__0607
04454     00 AE 0E F2 | 	cmp	local05, #0 wz
04458     28 00 90 AD |  if_e	jmp	#LR__0610
0445c     01 AE 66 F0 | 	shl	local05, #1
04460     D7 0E 48 FB | 	callpa	#(@LR__0609-@LR__0608)>>2,fcache_load_ptr_
04464                 | LR__0608
04464     00 40 00 FF 
04468     00 AE 16 F2 | 	cmp	local05, ##8388608 wc
0446c     58 C3 02 C6 |  if_b	mov	local15, local06
04470     01 C2 86 C1 |  if_b	sub	local15, #1
04474     61 B1 02 C6 |  if_b	mov	local06, local15
04478     01 AE 66 C0 |  if_b	shl	local05, #1
0447c     E4 FF 9F CD |  if_b	jmp	#LR__0608
04480                 | LR__0609
04480     28 FE 9F FD | 	jmp	#LR__0591
04484                 | LR__0610
04484     59 AD 02 F5 | 	and	local04, local07
04488     56 97 02 F6 | 	mov	arg04, local04
0448c     08 96 46 F5 | 	or	arg04, #8
04490     00 90 06 F6 | 	mov	arg01, #0
04494     00 92 06 F6 | 	mov	arg02, #0
04498     00 94 06 F6 | 	mov	arg03, #0
0449c     E4 1D B0 FD | 	call	#__system__pack_0176
044a0     48 00 90 FD | 	jmp	#LR__0615
044a4                 | LR__0611
044a4     00 B4 0E F2 | 	cmp	local08, #0 wz
044a8     28 00 90 AD |  if_e	jmp	#LR__0614
044ac     01 B4 66 F0 | 	shl	local08, #1
044b0     D7 0E 48 FB | 	callpa	#(@LR__0613-@LR__0612)>>2,fcache_load_ptr_
044b4                 | LR__0612
044b4     00 40 00 FF 
044b8     00 B4 16 F2 | 	cmp	local08, ##8388608 wc
044bc     5C C3 02 C6 |  if_b	mov	local15, local10
044c0     01 C2 86 C1 |  if_b	sub	local15, #1
044c4     61 B9 02 C6 |  if_b	mov	local10, local15
044c8     01 B4 66 C0 |  if_b	shl	local08, #1
044cc     E4 FF 9F CD |  if_b	jmp	#LR__0612
044d0                 | LR__0613
044d0     E4 FD 9F FD | 	jmp	#LR__0592
044d4                 | LR__0614
044d4     7F B0 86 F1 | 	sub	local06, #127
044d8     57 91 02 F6 | 	mov	arg01, local05
044dc     5E 93 02 F6 | 	mov	arg02, local12
044e0     58 95 02 F6 | 	mov	arg03, local06
044e4     56 97 02 F6 | 	mov	arg04, local04
044e8     98 1D B0 FD | 	call	#__system__pack_0176
044ec                 | LR__0615
044ec     E7 F0 03 F6 | 	mov	ptra, fp
044f0     F2 00 A0 FD | 	call	#popregs_
044f4                 | __system___float_add_ret
044f4     2D 00 64 FD | 	ret
044f8                 | 
044f8                 | __system___float_mul
044f8     0B CA 05 F6 | 	mov	COUNT_, #11
044fc     E8 00 A0 FD | 	call	#pushregs_
04500     48 A7 02 F6 | 	mov	local01, arg01
04504     49 A9 02 F6 | 	mov	local02, arg02
04508     53 AB 02 F6 | 	mov	local03, local01
0450c     55 AD 02 F6 | 	mov	local04, local03
04510     16 AC 46 F7 | 	zerox	local04, #22
04514     55 AF 02 F6 | 	mov	local05, local03
04518     01 AE 66 F0 | 	shl	local05, #1
0451c     18 AE 46 F0 | 	shr	local05, #24
04520     1F AA 46 F0 | 	shr	local03, #31
04524     54 77 02 F6 | 	mov	result1, local02
04528     3B B1 02 F6 | 	mov	local06, result1
0452c     58 B3 02 F6 | 	mov	local07, local06
04530     16 B2 46 F7 | 	zerox	local07, #22
04534     58 B5 02 F6 | 	mov	local08, local06
04538     01 B4 66 F0 | 	shl	local08, #1
0453c     18 B4 46 F0 | 	shr	local08, #24
04540     1F B0 46 F0 | 	shr	local06, #31
04544     58 AB 62 F5 | 	xor	local03, local06
04548     FF AE 0E F2 | 	cmp	local05, #255 wz
0454c     90 00 90 AD |  if_e	jmp	#LR__0623
04550     FF B4 0E F2 | 	cmp	local08, #255 wz
04554     D8 00 90 AD |  if_e	jmp	#LR__0625
04558     00 AE 0E F2 | 	cmp	local05, #0 wz
0455c     0C 01 90 AD |  if_e	jmp	#LR__0626
04560     17 AC 26 F4 | 	bith	local04, #23
04564                 | LR__0620
04564     00 B4 0E F2 | 	cmp	local08, #0 wz
04568     44 01 90 AD |  if_e	jmp	#LR__0630
0456c     17 B2 26 F4 | 	bith	local07, #23
04570                 | LR__0621
04570     56 A9 02 F6 | 	mov	local02, local04
04574     04 A8 66 F0 | 	shl	local02, #4
04578     59 B1 02 F6 | 	mov	local06, local07
0457c     05 B0 66 F0 | 	shl	local06, #5
04580     58 A9 02 FD | 	qmul	local02, local06
04584     5A AF 02 F1 | 	add	local05, local08
04588     FE AE 86 F1 | 	sub	local05, #254
0458c     57 B7 02 F6 | 	mov	local09, local05
04590     04 AC 66 F0 | 	shl	local04, #4
04594     05 B2 66 F0 | 	shl	local07, #5
04598     18 B8 62 FD | 	getqx	local10
0459c     59 AD 02 FD | 	qmul	local04, local07
045a0     19 BA 62 FD | 	getqy	local11
045a4     00 80 00 FF 
045a8     00 BA 16 F2 | 	cmp	local11, ##16777216 wc
045ac     18 00 90 CD |  if_b	jmp	#LR__0622
045b0     01 B6 06 F1 | 	add	local09, #1
045b4     01 B8 46 F0 | 	shr	local10, #1
045b8     5D B5 02 F6 | 	mov	local08, local11
045bc     1F B4 66 F0 | 	shl	local08, #31
045c0     5A B9 42 F5 | 	or	local10, local08
045c4     01 BA 46 F0 | 	shr	local11, #1
045c8                 | LR__0622
045c8     5D 91 02 F6 | 	mov	arg01, local11
045cc     5C 93 02 F6 | 	mov	arg02, local10
045d0     5B 95 02 F6 | 	mov	arg03, local09
045d4     55 97 02 F6 | 	mov	arg04, local03
045d8     A8 1C B0 FD | 	call	#__system__pack_0176
045dc     10 01 90 FD | 	jmp	#LR__0634
045e0                 | LR__0623
045e0     00 AC 0E F2 | 	cmp	local04, #0 wz
045e4     53 77 02 56 |  if_ne	mov	result1, local01
045e8     04 01 90 5D |  if_ne	jmp	#LR__0634
045ec     FF B4 56 F2 | 	cmps	local08, #255 wc
045f0     00 B4 0E C2 |  if_b	cmp	local08, #0 wz
045f4     00 B2 0E 82 |  if_c_and_z	cmp	local07, #0 wz
045f8     18 00 90 4D |  if_c_and_nz	jmp	#LR__0624
045fc     00 F8 3F CF 
04600     00 76 06 C6 |  if_b	mov	result1, ##2146435072
04604     E8 00 90 CD |  if_b	jmp	#LR__0634
04608     00 B2 0E F2 | 	cmp	local07, #0 wz
0460c     54 77 02 56 |  if_ne	mov	result1, local02
04610     DC 00 90 5D |  if_ne	jmp	#LR__0634
04614                 | LR__0624
04614     02 AA 46 F5 | 	or	local03, #2
04618     00 90 06 F6 | 	mov	arg01, #0
0461c     00 92 06 F6 | 	mov	arg02, #0
04620     57 95 02 F6 | 	mov	arg03, local05
04624     55 97 02 F6 | 	mov	arg04, local03
04628     58 1C B0 FD | 	call	#__system__pack_0176
0462c     C0 00 90 FD | 	jmp	#LR__0634
04630                 | LR__0625
04630     00 AE 0E F2 | 	cmp	local05, #0 wz
04634     00 AC 0E A2 |  if_e	cmp	local04, #0 wz
04638     00 F8 3F AF 
0463c     00 76 06 A6 |  if_e	mov	result1, ##2146435072
04640     AC 00 90 AD |  if_e	jmp	#LR__0634
04644     00 B2 0E F2 | 	cmp	local07, #0 wz
04648     54 77 02 56 |  if_ne	mov	result1, local02
0464c     A0 00 90 5D |  if_ne	jmp	#LR__0634
04650     5A 95 02 F6 | 	mov	arg03, local08
04654     55 97 02 F6 | 	mov	arg04, local03
04658     02 96 46 F5 | 	or	arg04, #2
0465c     00 90 06 F6 | 	mov	arg01, #0
04660     00 92 06 F6 | 	mov	arg02, #0
04664     1C 1C B0 FD | 	call	#__system__pack_0176
04668     84 00 90 FD | 	jmp	#LR__0634
0466c                 | LR__0626
0466c     00 AC 0E F2 | 	cmp	local04, #0 wz
04670     20 00 90 AD |  if_e	jmp	#LR__0629
04674     01 AC 66 F0 | 	shl	local04, #1
04678     D7 0A 48 FB | 	callpa	#(@LR__0628-@LR__0627)>>2,fcache_load_ptr_
0467c                 | LR__0627
0467c     00 40 00 FF 
04680     00 AC 16 F2 | 	cmp	local04, ##8388608 wc
04684     01 AE 86 C1 |  if_b	sub	local05, #1
04688     01 AC 66 C0 |  if_b	shl	local04, #1
0468c     EC FF 9F CD |  if_b	jmp	#LR__0627
04690                 | LR__0628
04690     D0 FE 9F FD | 	jmp	#LR__0620
04694                 | LR__0629
04694     08 AA 46 F5 | 	or	local03, #8
04698     00 90 06 F6 | 	mov	arg01, #0
0469c     00 92 06 F6 | 	mov	arg02, #0
046a0     00 94 06 F6 | 	mov	arg03, #0
046a4     55 97 02 F6 | 	mov	arg04, local03
046a8     D8 1B B0 FD | 	call	#__system__pack_0176
046ac     40 00 90 FD | 	jmp	#LR__0634
046b0                 | LR__0630
046b0     00 B2 0E F2 | 	cmp	local07, #0 wz
046b4     20 00 90 AD |  if_e	jmp	#LR__0633
046b8     01 B2 66 F0 | 	shl	local07, #1
046bc     D7 0A 48 FB | 	callpa	#(@LR__0632-@LR__0631)>>2,fcache_load_ptr_
046c0                 | LR__0631
046c0     00 40 00 FF 
046c4     00 B2 16 F2 | 	cmp	local07, ##8388608 wc
046c8     01 B4 86 C1 |  if_b	sub	local08, #1
046cc     01 B2 66 C0 |  if_b	shl	local07, #1
046d0     EC FF 9F CD |  if_b	jmp	#LR__0631
046d4                 | LR__0632
046d4     98 FE 9F FD | 	jmp	#LR__0621
046d8                 | LR__0633
046d8     08 AA 46 F5 | 	or	local03, #8
046dc     00 90 06 F6 | 	mov	arg01, #0
046e0     00 92 06 F6 | 	mov	arg02, #0
046e4     00 94 06 F6 | 	mov	arg03, #0
046e8     55 97 02 F6 | 	mov	arg04, local03
046ec     94 1B B0 FD | 	call	#__system__pack_0176
046f0                 | LR__0634
046f0     E7 F0 03 F6 | 	mov	ptra, fp
046f4     F2 00 A0 FD | 	call	#popregs_
046f8                 | __system___float_mul_ret
046f8     2D 00 64 FD | 	ret
046fc                 | 
046fc                 | __system___float_div
046fc     0E CA 05 F6 | 	mov	COUNT_, #14
04700     E8 00 A0 FD | 	call	#pushregs_
04704     48 AB 02 F6 | 	mov	local03, arg01
04708     49 AD 02 F6 | 	mov	local04, arg02
0470c     55 AF 02 F6 | 	mov	local05, local03
04710     57 B1 02 F6 | 	mov	local06, local05
04714     16 B0 46 F7 | 	zerox	local06, #22
04718     57 B3 02 F6 | 	mov	local07, local05
0471c     01 B2 66 F0 | 	shl	local07, #1
04720     18 B2 46 F0 | 	shr	local07, #24
04724     1F AE 46 F0 | 	shr	local05, #31
04728     56 77 02 F6 | 	mov	result1, local04
0472c     3B B5 02 F6 | 	mov	local08, result1
04730     5A B7 02 F6 | 	mov	local09, local08
04734     16 B6 46 F7 | 	zerox	local09, #22
04738     5A B9 02 F6 | 	mov	local10, local08
0473c     01 B8 66 F0 | 	shl	local10, #1
04740     18 B8 46 F0 | 	shr	local10, #24
04744     1F B4 46 F0 | 	shr	local08, #31
04748     5A AF 62 F5 | 	xor	local05, local08
0474c     FF B2 0E F2 | 	cmp	local07, #255 wz
04750     D4 00 90 AD |  if_e	jmp	#LR__0645
04754     FF B8 0E F2 | 	cmp	local10, #255 wz
04758     04 01 90 AD |  if_e	jmp	#LR__0646
0475c     00 B2 0E F2 | 	cmp	local07, #0 wz
04760     24 01 90 AD |  if_e	jmp	#LR__0647
04764     17 B0 26 F4 | 	bith	local06, #23
04768                 | LR__0640
04768     00 B8 0E F2 | 	cmp	local10, #0 wz
0476c     70 01 90 AD |  if_e	jmp	#LR__0651
04770     17 B6 26 F4 | 	bith	local09, #23
04774                 | LR__0641
04774     5C B3 82 F1 | 	sub	local07, local10
04778     59 BB 02 F6 | 	mov	local11, local07
0477c     58 91 02 F6 | 	mov	arg01, local06
04780     02 90 46 F0 | 	shr	arg01, #2
04784     1E B0 66 F0 | 	shl	local06, #30
04788     58 93 02 F6 | 	mov	arg02, local06
0478c     5B 95 02 F6 | 	mov	arg03, local09
04790     28 90 62 FD | 	setq	arg01
04794     4A 93 12 FD | 	qdiv	arg02, arg03
04798     00 BC 06 F6 | 	mov	local12, #0
0479c     18 A6 62 FD | 	getqx	local01
047a0     19 78 62 FD | 	getqy	result2
047a4     3C A9 02 F6 | 	mov	local02, result2
047a8     53 BF 02 F6 | 	mov	local13, local01
047ac     00 A8 4E F2 | 	cmps	local02, #0 wz
047b0     5F C1 02 F6 | 	mov	local14, local13
047b4     19 C0 66 F0 | 	shl	local14, #25
047b8     01 BC 06 56 |  if_ne	mov	local12, #1
047bc     5E C1 42 F5 | 	or	local14, local12
047c0     07 BE 46 F0 | 	shr	local13, #7
047c4     00 80 00 FF 
047c8     00 BE 16 F2 | 	cmp	local13, ##16777216 wc
047cc     1C 00 90 CD |  if_b	jmp	#LR__0642
047d0     01 BA 06 F1 | 	add	local11, #1
047d4     01 C0 46 F0 | 	shr	local14, #1
047d8     5F BD 02 F6 | 	mov	local12, local13
047dc     1F BC 66 F0 | 	shl	local12, #31
047e0     5E C1 42 F5 | 	or	local14, local12
047e4     01 BE 46 F0 | 	shr	local13, #1
047e8     24 00 90 FD | 	jmp	#LR__0644
047ec                 | LR__0642
047ec     00 40 00 FF 
047f0     00 BE 16 F2 | 	cmp	local13, ##8388608 wc
047f4     18 00 90 3D |  if_ae	jmp	#LR__0643
047f8     01 BA 86 F1 | 	sub	local11, #1
047fc     01 BE 66 F0 | 	shl	local13, #1
04800     60 BD 02 F6 | 	mov	local12, local14
04804     1F BC 46 F0 | 	shr	local12, #31
04808     5E BF 42 F5 | 	or	local13, local12
0480c     01 C0 66 F0 | 	shl	local14, #1
04810                 | LR__0643
04810                 | LR__0644
04810     5F 91 02 F6 | 	mov	arg01, local13
04814     60 93 02 F6 | 	mov	arg02, local14
04818     5D 95 02 F6 | 	mov	arg03, local11
0481c     57 97 02 F6 | 	mov	arg04, local05
04820     60 1A B0 FD | 	call	#__system__pack_0176
04824     F8 00 90 FD | 	jmp	#LR__0655
04828                 | LR__0645
04828     00 B0 0E F2 | 	cmp	local06, #0 wz
0482c     55 77 02 56 |  if_ne	mov	result1, local03
04830     EC 00 90 5D |  if_ne	jmp	#LR__0655
04834     FF B8 0E F2 | 	cmp	local10, #255 wz
04838     00 F8 3F AF 
0483c     00 76 06 A6 |  if_e	mov	result1, ##2146435072
04840     DC 00 90 AD |  if_e	jmp	#LR__0655
04844     02 AE 46 F5 | 	or	local05, #2
04848     00 90 06 F6 | 	mov	arg01, #0
0484c     00 92 06 F6 | 	mov	arg02, #0
04850     59 95 02 F6 | 	mov	arg03, local07
04854     57 97 02 F6 | 	mov	arg04, local05
04858     28 1A B0 FD | 	call	#__system__pack_0176
0485c     C0 00 90 FD | 	jmp	#LR__0655
04860                 | LR__0646
04860     00 B6 0E F2 | 	cmp	local09, #0 wz
04864     56 77 02 56 |  if_ne	mov	result1, local04
04868     B4 00 90 5D |  if_ne	jmp	#LR__0655
0486c     57 97 02 F6 | 	mov	arg04, local05
04870     08 96 46 F5 | 	or	arg04, #8
04874     00 90 06 F6 | 	mov	arg01, #0
04878     00 92 06 F6 | 	mov	arg02, #0
0487c     00 94 06 F6 | 	mov	arg03, #0
04880     00 1A B0 FD | 	call	#__system__pack_0176
04884     98 00 90 FD | 	jmp	#LR__0655
04888                 | LR__0647
04888     00 B0 0E F2 | 	cmp	local06, #0 wz
0488c     20 00 90 AD |  if_e	jmp	#LR__0650
04890     01 B0 66 F0 | 	shl	local06, #1
04894     D7 0A 48 FB | 	callpa	#(@LR__0649-@LR__0648)>>2,fcache_load_ptr_
04898                 | LR__0648
04898     00 40 00 FF 
0489c     00 B0 16 F2 | 	cmp	local06, ##8388608 wc
048a0     01 B2 86 C1 |  if_b	sub	local07, #1
048a4     01 B0 66 C0 |  if_b	shl	local06, #1
048a8     EC FF 9F CD |  if_b	jmp	#LR__0648
048ac                 | LR__0649
048ac     B8 FE 9F FD | 	jmp	#LR__0640
048b0                 | LR__0650
048b0     00 B8 0E F2 | 	cmp	local10, #0 wz
048b4     00 B6 0E A2 |  if_e	cmp	local09, #0 wz
048b8     00 F8 3F AF 
048bc     00 76 06 A6 |  if_e	mov	result1, ##2146435072
048c0     5C 00 90 AD |  if_e	jmp	#LR__0655
048c4     57 97 02 F6 | 	mov	arg04, local05
048c8     08 96 46 F5 | 	or	arg04, #8
048cc     00 90 06 F6 | 	mov	arg01, #0
048d0     00 92 06 F6 | 	mov	arg02, #0
048d4     00 94 06 F6 | 	mov	arg03, #0
048d8     A8 19 B0 FD | 	call	#__system__pack_0176
048dc     40 00 90 FD | 	jmp	#LR__0655
048e0                 | LR__0651
048e0     00 B6 0E F2 | 	cmp	local09, #0 wz
048e4     20 00 90 AD |  if_e	jmp	#LR__0654
048e8     01 B6 66 F0 | 	shl	local09, #1
048ec     D7 0A 48 FB | 	callpa	#(@LR__0653-@LR__0652)>>2,fcache_load_ptr_
048f0                 | LR__0652
048f0     00 40 00 FF 
048f4     00 B6 16 F2 | 	cmp	local09, ##8388608 wc
048f8     01 B8 86 C1 |  if_b	sub	local10, #1
048fc     01 B6 66 C0 |  if_b	shl	local09, #1
04900     EC FF 9F CD |  if_b	jmp	#LR__0652
04904                 | LR__0653
04904     6C FE 9F FD | 	jmp	#LR__0641
04908                 | LR__0654
04908     02 AE 46 F5 | 	or	local05, #2
0490c     00 90 06 F6 | 	mov	arg01, #0
04910     00 92 06 F6 | 	mov	arg02, #0
04914     00 94 06 F6 | 	mov	arg03, #0
04918     57 97 02 F6 | 	mov	arg04, local05
0491c     64 19 B0 FD | 	call	#__system__pack_0176
04920                 | LR__0655
04920     E7 F0 03 F6 | 	mov	ptra, fp
04924     F2 00 A0 FD | 	call	#popregs_
04928                 | __system___float_div_ret
04928     2D 00 64 FD | 	ret
0492c                 | 
0492c                 | __system___float_cmp
0492c     00 C0 3F FF 
04930     01 90 56 F2 | 	cmps	arg01, ##2139095041 wc
04934     00 C0 3F CF 
04938     01 92 56 C2 |  if_b	cmps	arg02, ##2139095041 wc
0493c     4A 77 02 36 |  if_ae	mov	result1, arg03
04940     78 00 90 3D |  if_ae	jmp	#__system___float_cmp_ret
04944     00 C0 7F FF 
04948     01 90 16 F2 | 	cmp	arg01, ##-8388607 wc
0494c     00 C0 7F CF 
04950     01 90 16 C2 |  if_b	cmp	arg01, ##-8388607 wc
04954     4A 77 02 36 |  if_ae	mov	result1, arg03
04958     60 00 90 3D |  if_ae	jmp	#__system___float_cmp_ret
0495c     00 90 56 F2 | 	cmps	arg01, #0 wc
04960     2C 00 90 3D |  if_ae	jmp	#LR__0660
04964     00 92 56 F2 | 	cmps	arg02, #0 wc
04968     49 77 02 C6 |  if_b	mov	result1, arg02
0496c     48 77 82 C1 |  if_b	sub	result1, arg01
04970     48 00 90 CD |  if_b	jmp	#__system___float_cmp_ret
04974     00 92 0E F2 | 	cmp	arg02, #0 wz
04978     00 00 40 AF 
0497c     00 90 0E A2 |  if_e	cmp	arg01, ##-2147483648 wz
04980     00 76 06 A6 |  if_e	mov	result1, #0
04984     34 00 90 AD |  if_e	jmp	#__system___float_cmp_ret
04988     01 76 66 F6 | 	neg	result1, #1
0498c     2C 00 90 FD | 	jmp	#__system___float_cmp_ret
04990                 | LR__0660
04990     00 92 56 F2 | 	cmps	arg02, #0 wc
04994     1C 00 90 3D |  if_ae	jmp	#LR__0661
04998     00 90 0E F2 | 	cmp	arg01, #0 wz
0499c     00 00 40 AF 
049a0     00 92 0E A2 |  if_e	cmp	arg02, ##-2147483648 wz
049a4     00 76 06 A6 |  if_e	mov	result1, #0
049a8     10 00 90 AD |  if_e	jmp	#__system___float_cmp_ret
049ac     01 76 06 F6 | 	mov	result1, #1
049b0     08 00 90 FD | 	jmp	#__system___float_cmp_ret
049b4                 | LR__0661
049b4     49 91 82 F1 | 	sub	arg01, arg02
049b8     48 77 02 F6 | 	mov	result1, arg01
049bc                 | __system___float_cmp_ret
049bc     2D 00 64 FD | 	ret
049c0                 | 
049c0                 | __system___float_tointeger
049c0     02 CA 05 F6 | 	mov	COUNT_, #2
049c4     E8 00 A0 FD | 	call	#pushregs_
049c8     5C 00 B0 FD | 	call	#__system___float_Unpack
049cc     3B A7 02 F6 | 	mov	local01, result1
049d0     1F 78 56 F2 | 	cmps	result2, #31 wc
049d4     00 A6 0E 32 |  if_ae	cmp	local01, #0 wz
049d8     1F A8 C6 19 |  if_a	decod	local02, #31
049dc     1E A8 CE 29 |  if_nc_and_z	bmask	local02, #30
049e0     54 7B 02 36 |  if_ae	mov	result3, local02
049e4     30 00 90 3D |  if_ae	jmp	#LR__0671
049e8     FF FF 7F FF 
049ec     FF 79 56 F2 | 	cmps	result2, ##-1 wc
049f0     00 7A 06 C6 |  if_b	mov	result3, #0
049f4     20 00 90 CD |  if_b	jmp	#LR__0670
049f8     02 7A 66 F0 | 	shl	result3, #2
049fc     1E A8 06 F6 | 	mov	local02, #30
04a00     3C A9 82 F1 | 	sub	local02, result2
04a04     54 7B 42 F0 | 	shr	result3, local02
04a08     49 7B 02 F1 | 	add	result3, arg02
04a0c     01 7A 46 F0 | 	shr	result3, #1
04a10     00 A6 0E F2 | 	cmp	local01, #0 wz
04a14     3D 7B 62 56 |  if_ne	neg	result3, result3
04a18                 | LR__0670
04a18                 | LR__0671
04a18     3D 77 02 F6 | 	mov	result1, result3
04a1c     E7 F0 03 F6 | 	mov	ptra, fp
04a20     F2 00 A0 FD | 	call	#popregs_
04a24                 | __system___float_tointeger_ret
04a24     2D 00 64 FD | 	ret
04a28                 | 
04a28                 | __system___float_Unpack
04a28     48 7D 02 F6 | 	mov	_var01, arg01
04a2c     1F 7C 46 F0 | 	shr	_var01, #31
04a30     48 7F 02 F6 | 	mov	_var02, arg01
04a34     01 7E 66 F0 | 	shl	_var02, #1
04a38     18 7E 4E F0 | 	shr	_var02, #24 wz
04a3c     17 91 06 F4 | 	bitl	arg01, #279
04a40     06 90 66 50 |  if_ne	shl	arg01, #6
04a44     1D 90 26 54 |  if_ne	bith	arg01, #29
04a48     1C 00 90 5D |  if_ne	jmp	#LR__0680
04a4c     48 81 92 F7 | 	encod	_var03, arg01 wc
04a50     01 80 06 C1 |  if_b	add	_var03, #1
04a54     17 80 86 F1 | 	sub	_var03, #23
04a58     40 7F 02 F6 | 	mov	_var02, _var03
04a5c     07 78 06 F6 | 	mov	result2, #7
04a60     40 79 82 F1 | 	sub	result2, _var03
04a64     3C 91 62 F0 | 	shl	arg01, result2
04a68                 | LR__0680
04a68     7F 7E 86 F1 | 	sub	_var02, #127
04a6c     48 7B 02 F6 | 	mov	result3, arg01
04a70     3E 77 02 F6 | 	mov	result1, _var01
04a74     3F 79 02 F6 | 	mov	result2, _var02
04a78                 | __system___float_Unpack_ret
04a78     2D 00 64 FD | 	ret
04a7c                 | 
04a7c                 | __system___float_Pack
04a7c     00 7C 06 F6 | 	mov	_var01, #0
04a80     00 94 0E F2 | 	cmp	arg03, #0 wz
04a84     8C 00 90 AD |  if_e	jmp	#LR__0691
04a88     4A 7F 92 F7 | 	encod	_var02, arg03 wc
04a8c     01 7E 06 C1 |  if_b	add	_var02, #1
04a90     21 7C 06 F6 | 	mov	_var01, #33
04a94     3F 7D 82 F1 | 	sub	_var01, _var02
04a98     3E 95 62 F0 | 	shl	arg03, _var01
04a9c     03 7E 06 F6 | 	mov	_var02, #3
04aa0     3E 7F 82 F1 | 	sub	_var02, _var01
04aa4     3F 93 02 F1 | 	add	arg02, _var02
04aa8     49 81 02 F6 | 	mov	_var03, arg02
04aac     00 95 06 F1 | 	add	arg03, #256
04ab0     4A 7F 02 F6 | 	mov	_var02, arg03
04ab4     FF 7E 2E F5 | 	andn	_var02, #255 wz
04ab8     01 80 06 A1 |  if_e	add	_var03, #1
04abc     7F 80 06 F1 | 	add	_var03, #127
04ac0     FF FF 7F FF 
04ac4     E9 81 46 F3 | 	fges	_var03, ##-23
04ac8     FF 80 66 F3 | 	fles	_var03, #255
04acc     01 80 56 F2 | 	cmps	_var03, #1 wc
04ad0     1C 00 90 3D |  if_ae	jmp	#LR__0690
04ad4     01 94 46 F0 | 	shr	arg03, #1
04ad8     1F 7E C6 F9 | 	decod	_var02, #31
04adc     4A 7F 02 F1 | 	add	_var02, arg03
04ae0     40 81 62 F6 | 	neg	_var03, _var03
04ae4     40 7F 42 F0 | 	shr	_var02, _var03
04ae8     3F 95 02 F6 | 	mov	arg03, _var02
04aec     00 80 06 F6 | 	mov	_var03, #0
04af0                 | LR__0690
04af0     48 77 02 F6 | 	mov	result1, arg01
04af4     1F 76 66 F0 | 	shl	result1, #31
04af8     40 7F 02 F6 | 	mov	_var02, _var03
04afc     17 7E 66 F0 | 	shl	_var02, #23
04b00     3F 77 42 F5 | 	or	result1, _var02
04b04     4A 83 02 F6 | 	mov	_var04, arg03
04b08     09 82 46 F0 | 	shr	_var04, #9
04b0c     41 77 42 F5 | 	or	result1, _var04
04b10     04 00 90 FD | 	jmp	#__system___float_Pack_ret
04b14                 | LR__0691
04b14     3E 77 02 F6 | 	mov	result1, _var01
04b18                 | __system___float_Pack_ret
04b18     2D 00 64 FD | 	ret
04b1c                 | 
04b1c                 | __system___basic_print_float
04b1c     05 CA 05 F6 | 	mov	COUNT_, #5
04b20     E8 00 A0 FD | 	call	#pushregs_
04b24     48 A7 02 F6 | 	mov	local01, arg01
04b28     49 A9 02 F6 | 	mov	local02, arg02
04b2c     4A AB 0A F6 | 	mov	local03, arg03 wz
04b30     4B AD 02 F6 | 	mov	local04, arg04
04b34     14 00 90 5D |  if_ne	jmp	#LR__0700
04b38     23 AC 0E F2 | 	cmp	local04, #35 wz
04b3c     80 02 10 AF 
04b40     00 AE 06 A6 |  if_e	mov	local05, ##537198592
04b44     1D AE C6 59 |  if_ne	decod	local05, #29
04b48     57 AB 02 F6 | 	mov	local03, local05
04b4c                 | LR__0700
04b4c     53 91 02 F6 | 	mov	arg01, local01
04b50     EC 16 B0 FD | 	call	#__system___gettxfunc
04b54     3B AF 0A F6 | 	mov	local05, result1 wz
04b58     00 76 06 A6 |  if_e	mov	result1, #0
04b5c     57 91 02 56 |  if_ne	mov	arg01, local05
04b60     55 93 02 56 |  if_ne	mov	arg02, local03
04b64     54 95 02 56 |  if_ne	mov	arg03, local02
04b68     56 97 02 56 |  if_ne	mov	arg04, local04
04b6c     B8 ED BF 5D |  if_ne	call	#__system___fmtfloat
04b70     E7 F0 03 F6 | 	mov	ptra, fp
04b74     F2 00 A0 FD | 	call	#popregs_
04b78                 | __system___basic_print_float_ret
04b78     2D 00 64 FD | 	ret
04b7c                 | 
04b7c                 | __system____builtin_ilogb
04b7c     A8 FE BF FD | 	call	#__system___float_Unpack
04b80     00 7A 0E F2 | 	cmp	result3, #0 wz
04b84     00 00 40 AF 
04b88     01 76 06 A6 |  if_e	mov	result1, ##-2147483647
04b8c     24 00 90 AD |  if_e	jmp	#LR__0711
04b90     80 78 0E F2 | 	cmp	result2, #128 wz
04b94     18 00 90 5D |  if_ne	jmp	#LR__0710
04b98     00 00 10 FF 
04b9c     00 7A 0E F2 | 	cmp	result3, ##536870912 wz
04ba0     1E 76 CE A9 |  if_e	bmask	result1, #30
04ba4     0C 00 90 AD |  if_e	jmp	#LR__0711
04ba8     1F 76 C6 F9 | 	decod	result1, #31
04bac     04 00 90 FD | 	jmp	#LR__0711
04bb0                 | LR__0710
04bb0     3C 77 02 F6 | 	mov	result1, result2
04bb4                 | LR__0711
04bb4                 | __system____builtin_ilogb_ret
04bb4     2D 00 64 FD | 	ret
04bb8                 | 
04bb8                 | __system___float_pow_n
04bb8     05 CA 05 F6 | 	mov	COUNT_, #5
04bbc     E8 00 A0 FD | 	call	#pushregs_
04bc0     48 A7 02 F6 | 	mov	local01, arg01
04bc4     49 A9 02 F6 | 	mov	local02, arg02
04bc8     4A AB 02 F6 | 	mov	local03, arg03
04bcc     00 AA 56 F2 | 	cmps	local03, #0 wc
04bd0     18 00 90 3D |  if_ae	jmp	#LR__0720
04bd4     01 AC 06 F6 | 	mov	local04, #1
04bd8     55 AB 62 F6 | 	neg	local03, local03
04bdc     00 AA 56 F2 | 	cmps	local03, #0 wc
04be0     00 76 06 C6 |  if_b	mov	result1, #0
04be4     94 00 90 CD |  if_b	jmp	#LR__0728
04be8     04 00 90 FD | 	jmp	#LR__0721
04bec                 | LR__0720
04bec     00 AC 06 F6 | 	mov	local04, #0
04bf0                 | LR__0721
04bf0     00 C0 1F FF 
04bf4     00 AE 06 F6 | 	mov	local05, ##1065353216
04bf8                 | LR__0722
04bf8     01 AA 56 F2 | 	cmps	local03, #1 wc
04bfc     30 00 90 CD |  if_b	jmp	#LR__0724
04c00     01 AA CE F7 | 	test	local03, #1 wz
04c04     10 00 90 AD |  if_e	jmp	#LR__0723
04c08     57 91 02 F6 | 	mov	arg01, local05
04c0c     54 93 02 F6 | 	mov	arg02, local02
04c10     E4 F8 BF FD | 	call	#__system___float_mul
04c14     3B AF 02 F6 | 	mov	local05, result1
04c18                 | LR__0723
04c18     01 AA C6 F0 | 	sar	local03, #1
04c1c     54 91 02 F6 | 	mov	arg01, local02
04c20     54 93 02 F6 | 	mov	arg02, local02
04c24     D0 F8 BF FD | 	call	#__system___float_mul
04c28     3B A9 02 F6 | 	mov	local02, result1
04c2c     C8 FF 9F FD | 	jmp	#LR__0722
04c30                 | LR__0724
04c30     00 AC 0E F2 | 	cmp	local04, #0 wz
04c34     14 00 90 AD |  if_e	jmp	#LR__0725
04c38     53 91 02 F6 | 	mov	arg01, local01
04c3c     57 93 02 F6 | 	mov	arg02, local05
04c40     B8 FA BF FD | 	call	#__system___float_div
04c44     3B AF 02 F6 | 	mov	local05, result1
04c48     2C 00 90 FD | 	jmp	#LR__0727
04c4c                 | LR__0725
04c4c     53 91 02 F6 | 	mov	arg01, local01
04c50     00 C0 1F FF 
04c54     00 92 06 F6 | 	mov	arg02, ##1065353216
04c58     01 94 06 F6 | 	mov	arg03, #1
04c5c     CC FC BF FD | 	call	#__system___float_cmp
04c60     00 76 0E F2 | 	cmp	result1, #0 wz
04c64     10 00 90 AD |  if_e	jmp	#LR__0726
04c68     53 91 02 F6 | 	mov	arg01, local01
04c6c     57 93 02 F6 | 	mov	arg02, local05
04c70     84 F8 BF FD | 	call	#__system___float_mul
04c74     3B AF 02 F6 | 	mov	local05, result1
04c78                 | LR__0726
04c78                 | LR__0727
04c78     57 77 02 F6 | 	mov	result1, local05
04c7c                 | LR__0728
04c7c     E7 F0 03 F6 | 	mov	ptra, fp
04c80     F2 00 A0 FD | 	call	#popregs_
04c84                 | __system___float_pow_n_ret
04c84     2D 00 64 FD | 	ret
04c88                 | 
04c88                 | __system___gc_ptrs
04c88     2C 7D 02 F6 | 	mov	_var01, __heap_ptr
04c8c     3E 7F 02 F6 | 	mov	_var02, _var01
04c90     BB 00 00 FF 
04c94     F8 7E 06 F1 | 	add	_var02, ##95992
04c98     3E 79 0A FB | 	rdlong	result2, _var01 wz
04c9c     74 00 90 5D |  if_ne	jmp	#LR__0730
04ca0     3F 79 02 F6 | 	mov	result2, _var02
04ca4     3E 79 82 F1 | 	sub	result2, _var01
04ca8     3E 03 58 FC | 	wrword	#1, _var01
04cac     3E 77 02 F6 | 	mov	result1, _var01
04cb0     02 76 06 F1 | 	add	result1, #2
04cb4     36 00 80 FF 
04cb8     3B 21 59 FC | 	wrword	##27792, result1
04cbc     3E 77 02 F6 | 	mov	result1, _var01
04cc0     04 76 06 F1 | 	add	result1, #4
04cc4     3B 01 58 FC | 	wrword	#0, result1
04cc8     3E 77 02 F6 | 	mov	result1, _var01
04ccc     06 76 06 F1 | 	add	result1, #6
04cd0     3B 03 58 FC | 	wrword	#1, result1
04cd4     10 7C 06 F1 | 	add	_var01, #16
04cd8     3C 79 52 F6 | 	abs	result2, result2 wc
04cdc     04 78 46 F0 | 	shr	result2, #4
04ce0     3C 79 82 F6 | 	negc	result2, result2
04ce4     3E 79 52 FC | 	wrword	result2, _var01
04ce8     3E 79 02 F6 | 	mov	result2, _var01
04cec     02 78 06 F1 | 	add	result2, #2
04cf0     36 00 80 FF 
04cf4     3C 1F 59 FC | 	wrword	##27791, result2
04cf8     3E 79 02 F6 | 	mov	result2, _var01
04cfc     04 78 06 F1 | 	add	result2, #4
04d00     3C 01 58 FC | 	wrword	#0, result2
04d04     3E 79 02 F6 | 	mov	result2, _var01
04d08     06 78 06 F1 | 	add	result2, #6
04d0c     3C 01 58 FC | 	wrword	#0, result2
04d10     10 7C 86 F1 | 	sub	_var01, #16
04d14                 | LR__0730
04d14     3E 77 02 F6 | 	mov	result1, _var01
04d18     3F 79 02 F6 | 	mov	result2, _var02
04d1c                 | __system___gc_ptrs_ret
04d1c     2D 00 64 FD | 	ret
04d20                 | 
04d20                 | __system___gc_tryalloc
04d20     0B CA 05 F6 | 	mov	COUNT_, #11
04d24     E8 00 A0 FD | 	call	#pushregs_
04d28     48 A7 02 F6 | 	mov	local01, arg01
04d2c     49 A9 02 F6 | 	mov	local02, arg02
04d30     54 FF BF FD | 	call	#__system___gc_ptrs
04d34     3B AB 02 F6 | 	mov	local03, result1
04d38     3C AD 02 F6 | 	mov	local04, result2
04d3c     55 AF 02 F6 | 	mov	local05, local03
04d40     00 B0 06 F6 | 	mov	local06, #0
04d44     D7 1E 48 FB | 	callpa	#(@LR__0741-@LR__0740)>>2,fcache_load_ptr_
04d48                 | LR__0740
04d48     57 B3 02 F6 | 	mov	local07, local05
04d4c     06 AE 06 F1 | 	add	local05, #6
04d50     57 93 EA FA | 	rdword	arg02, local05 wz
04d54     55 91 02 F6 | 	mov	arg01, local03
04d58     00 76 06 A6 |  if_e	mov	result1, #0
04d5c     04 92 66 50 |  if_ne	shl	arg02, #4
04d60     49 91 02 51 |  if_ne	add	arg01, arg02
04d64     48 77 02 56 |  if_ne	mov	result1, arg01
04d68     3B AF 0A F6 | 	mov	local05, result1 wz
04d6c     57 B1 E2 5A |  if_ne	rdword	local06, local05
04d70     00 AE 0E F2 | 	cmp	local05, #0 wz
04d74     56 AF 52 52 |  if_ne	cmps	local05, local04 wc
04d78     08 00 90 1D |  if_a	jmp	#LR__0742
04d7c     58 A7 5A 52 |  if_ne	cmps	local01, local06 wcz
04d80     C4 FF 9F 1D |  if_a	jmp	#LR__0740
04d84                 | LR__0741
04d84                 | LR__0742
04d84     00 AE 0E F2 | 	cmp	local05, #0 wz
04d88     57 77 02 A6 |  if_e	mov	result1, local05
04d8c     3C 01 90 AD |  if_e	jmp	#LR__0745
04d90     57 79 02 F6 | 	mov	result2, local05
04d94     06 78 06 F1 | 	add	result2, #6
04d98     3C B5 E2 FA | 	rdword	local08, result2
04d9c     58 A7 52 F2 | 	cmps	local01, local06 wc
04da0     C0 00 90 3D |  if_ae	jmp	#LR__0744
04da4     57 A7 52 FC | 	wrword	local01, local05
04da8     57 91 02 F6 | 	mov	arg01, local05
04dac     53 B5 02 F6 | 	mov	local08, local01
04db0     04 B4 66 F0 | 	shl	local08, #4
04db4     5A 91 02 F1 | 	add	arg01, local08
04db8     53 B1 82 F1 | 	sub	local06, local01
04dbc     48 B1 52 FC | 	wrword	local06, arg01
04dc0     48 B5 02 F6 | 	mov	local08, arg01
04dc4     02 B4 06 F1 | 	add	local08, #2
04dc8     36 00 80 FF 
04dcc     5A 1F 59 FC | 	wrword	##27791, local08
04dd0     57 93 0A F6 | 	mov	arg02, local05 wz
04dd4     00 76 06 A6 |  if_e	mov	result1, #0
04dd8     55 93 82 51 |  if_ne	sub	arg02, local03
04ddc     04 92 46 50 |  if_ne	shr	arg02, #4
04de0     49 77 02 56 |  if_ne	mov	result1, arg02
04de4     48 B5 02 F6 | 	mov	local08, arg01
04de8     04 B4 06 F1 | 	add	local08, #4
04dec     5A 77 52 FC | 	wrword	result1, local08
04df0     57 B5 02 F6 | 	mov	local08, local05
04df4     06 B4 06 F1 | 	add	local08, #6
04df8     48 93 02 F6 | 	mov	arg02, arg01
04dfc     5A B5 E2 FA | 	rdword	local08, local08
04e00     06 92 06 F1 | 	add	arg02, #6
04e04     49 B5 52 FC | 	wrword	local08, arg02
04e08     48 B7 02 F6 | 	mov	local09, arg01
04e0c     5B 93 0A F6 | 	mov	arg02, local09 wz
04e10     00 76 06 A6 |  if_e	mov	result1, #0
04e14     55 93 82 51 |  if_ne	sub	arg02, local03
04e18     04 92 46 50 |  if_ne	shr	arg02, #4
04e1c     49 77 02 56 |  if_ne	mov	result1, arg02
04e20     3B B5 02 F6 | 	mov	local08, result1
04e24     48 B9 EA FA | 	rdword	local10, arg01 wz
04e28     00 76 06 A6 |  if_e	mov	result1, #0
04e2c     04 B8 66 50 |  if_ne	shl	local10, #4
04e30     5C 91 02 51 |  if_ne	add	arg01, local10
04e34     48 77 02 56 |  if_ne	mov	result1, arg01
04e38     3B BB 0A F6 | 	mov	local11, result1 wz
04e3c     24 00 90 AD |  if_e	jmp	#LR__0743
04e40     56 BB 52 F2 | 	cmps	local11, local04 wc
04e44     1C 00 90 3D |  if_ae	jmp	#LR__0743
04e48     5B 93 0A F6 | 	mov	arg02, local09 wz
04e4c     00 76 06 A6 |  if_e	mov	result1, #0
04e50     55 93 82 51 |  if_ne	sub	arg02, local03
04e54     04 92 46 50 |  if_ne	shr	arg02, #4
04e58     49 77 02 56 |  if_ne	mov	result1, arg02
04e5c     04 BA 06 F1 | 	add	local11, #4
04e60     5D 77 52 FC | 	wrword	result1, local11
04e64                 | LR__0743
04e64                 | LR__0744
04e64     06 B2 06 F1 | 	add	local07, #6
04e68     59 B5 52 FC | 	wrword	local08, local07
04e6c     36 00 00 FF 
04e70     80 B6 06 F6 | 	mov	local09, ##27776
04e74     54 B7 42 F5 | 	or	local09, local02
04e78     00 76 06 F6 | 	mov	result1, #0
04e7c     01 76 62 FD | 	cogid	result1
04e80     3B B7 42 F5 | 	or	local09, result1
04e84     57 BB 02 F6 | 	mov	local11, local05
04e88     02 BA 06 F1 | 	add	local11, #2
04e8c     5D B7 52 FC | 	wrword	local09, local11
04e90     55 B7 02 F6 | 	mov	local09, local03
04e94     08 B6 06 F1 | 	add	local09, #8
04e98     57 BB 02 F6 | 	mov	local11, local05
04e9c     5B B7 E2 FA | 	rdword	local09, local09
04ea0     06 BA 06 F1 | 	add	local11, #6
04ea4     5D B7 52 FC | 	wrword	local09, local11
04ea8     57 93 0A F6 | 	mov	arg02, local05 wz
04eac     00 76 06 A6 |  if_e	mov	result1, #0
04eb0     55 93 82 51 |  if_ne	sub	arg02, local03
04eb4     04 92 46 50 |  if_ne	shr	arg02, #4
04eb8     49 77 02 56 |  if_ne	mov	result1, arg02
04ebc     08 AA 06 F1 | 	add	local03, #8
04ec0     55 77 52 FC | 	wrword	result1, local03
04ec4     08 AE 06 F1 | 	add	local05, #8
04ec8     57 77 02 F6 | 	mov	result1, local05
04ecc                 | LR__0745
04ecc     E7 F0 03 F6 | 	mov	ptra, fp
04ed0     F2 00 A0 FD | 	call	#popregs_
04ed4                 | __system___gc_tryalloc_ret
04ed4     2D 00 64 FD | 	ret
04ed8                 | 
04ed8                 | __system___gc_alloc_managed
04ed8     01 CA 05 F6 | 	mov	COUNT_, #1
04edc     E8 00 A0 FD | 	call	#pushregs_
04ee0     48 A7 02 F6 | 	mov	local01, arg01
04ee4     00 92 06 F6 | 	mov	arg02, #0
04ee8     1C 00 B0 FD | 	call	#__system___gc_doalloc
04eec     3B 93 0A F6 | 	mov	arg02, result1 wz
04ef0     01 A6 56 A2 |  if_e	cmps	local01, #1 wc
04ef4     00 76 06 26 |  if_nc_and_z	mov	result1, #0
04ef8     49 77 02 D6 |  if_c_or_nz	mov	result1, arg02
04efc     E7 F0 03 F6 | 	mov	ptra, fp
04f00     F2 00 A0 FD | 	call	#popregs_
04f04                 | __system___gc_alloc_managed_ret
04f04     2D 00 64 FD | 	ret
04f08                 | 
04f08                 | __system___gc_doalloc
04f08     06 CA 05 F6 | 	mov	COUNT_, #6
04f0c     E8 00 A0 FD | 	call	#pushregs_
04f10     48 A7 0A F6 | 	mov	local01, arg01 wz
04f14     49 A9 02 F6 | 	mov	local02, arg02
04f18     00 76 06 A6 |  if_e	mov	result1, #0
04f1c     84 00 90 AD |  if_e	jmp	#LR__0757
04f20     17 A6 06 F1 | 	add	local01, #23
04f24     0F A6 26 F5 | 	andn	local01, #15
04f28     04 A6 46 F0 | 	shr	local01, #4
04f2c     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
04f30     1C 90 06 F1 | 	add	arg01, #28
04f34     80 DE BF FD | 	call	#__system___lockmem
04f38     53 91 02 F6 | 	mov	arg01, local01
04f3c     54 93 02 F6 | 	mov	arg02, local02
04f40     DC FD BF FD | 	call	#__system___gc_tryalloc
04f44     3B AB 0A F6 | 	mov	local03, result1 wz
04f48     14 00 90 5D |  if_ne	jmp	#LR__0750
04f4c     64 03 B0 FD | 	call	#__system___gc_docollect
04f50     53 91 02 F6 | 	mov	arg01, local01
04f54     54 93 02 F6 | 	mov	arg02, local02
04f58     C4 FD BF FD | 	call	#__system___gc_tryalloc
04f5c     3B AB 02 F6 | 	mov	local03, result1
04f60                 | LR__0750
04f60     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
04f64     1C 90 06 F1 | 	add	arg01, #28
04f68     48 01 68 FC | 	wrlong	#0, arg01
04f6c     00 AA 0E F2 | 	cmp	local03, #0 wz
04f70     2C 00 90 AD |  if_e	jmp	#LR__0756
04f74     04 A6 66 F0 | 	shl	local01, #4
04f78     08 A6 86 F1 | 	sub	local01, #8
04f7c     53 AD 52 F6 | 	abs	local04, local01 wc
04f80     02 AC 46 F0 | 	shr	local04, #2
04f84     56 AF 8A F6 | 	negc	local05, local04 wz
04f88     55 B1 02 F6 | 	mov	local06, local03
04f8c     10 00 90 AD |  if_e	jmp	#LR__0755
04f90     D7 06 48 FB | 	callpa	#(@LR__0753-@LR__0751)>>2,fcache_load_ptr_
04f94                 | LR__0751
04f94     57 05 D8 FC | 	rep	@LR__0754, local05
04f98                 | LR__0752
04f98     58 01 68 FC | 	wrlong	#0, local06
04f9c     04 B0 06 F1 | 	add	local06, #4
04fa0                 | LR__0753
04fa0                 | LR__0754
04fa0                 | LR__0755
04fa0                 | LR__0756
04fa0     55 77 02 F6 | 	mov	result1, local03
04fa4                 | LR__0757
04fa4     E7 F0 03 F6 | 	mov	ptra, fp
04fa8     F2 00 A0 FD | 	call	#popregs_
04fac                 | __system___gc_doalloc_ret
04fac     2D 00 64 FD | 	ret
04fb0                 | 
04fb0                 | __system___gc_isvalidptr
04fb0     F8 94 06 F4 | 	bitl	arg03, #248
04fb4     08 94 86 F1 | 	sub	arg03, #8
04fb8     48 95 52 F2 | 	cmps	arg03, arg01 wc
04fbc     08 00 90 CD |  if_b	jmp	#LR__0760
04fc0     49 95 52 F2 | 	cmps	arg03, arg02 wc
04fc4     08 00 90 CD |  if_b	jmp	#LR__0761
04fc8                 | LR__0760
04fc8     00 76 06 F6 | 	mov	result1, #0
04fcc     38 00 90 FD | 	jmp	#__system___gc_isvalidptr_ret
04fd0                 | LR__0761
04fd0     4A 7D 02 F6 | 	mov	_var01, arg03
04fd4     48 7D 62 F5 | 	xor	_var01, arg01
04fd8     0F 7C CE F7 | 	test	_var01, #15 wz
04fdc     00 76 06 56 |  if_ne	mov	result1, #0
04fe0     24 00 90 5D |  if_ne	jmp	#__system___gc_isvalidptr_ret
04fe4     4A 7D 02 F6 | 	mov	_var01, arg03
04fe8     02 7C 06 F1 | 	add	_var01, #2
04fec     3E 7D E2 FA | 	rdword	_var01, _var01
04ff0     7F 00 00 FF 
04ff4     C0 7D 06 F5 | 	and	_var01, ##65472
04ff8     36 00 00 FF 
04ffc     80 7C 0E F2 | 	cmp	_var01, ##27776 wz
05000     00 76 06 56 |  if_ne	mov	result1, #0
05004     4A 77 02 A6 |  if_e	mov	result1, arg03
05008                 | __system___gc_isvalidptr_ret
05008     2D 00 64 FD | 	ret
0500c                 | 
0500c                 | __system___gc_free
0500c     48 95 02 F6 | 	mov	arg03, arg01
05010     74 FC BF FD | 	call	#__system___gc_ptrs
05014     3B 91 02 F6 | 	mov	arg01, result1
05018     3C 93 02 F6 | 	mov	arg02, result2
0501c     90 FF BF FD | 	call	#__system___gc_isvalidptr
05020     3B 93 0A F6 | 	mov	arg02, result1 wz
05024     20 00 90 AD |  if_e	jmp	#LR__0770
05028     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
0502c     1C 90 06 F1 | 	add	arg01, #28
05030     84 DD BF FD | 	call	#__system___lockmem
05034     49 91 02 F6 | 	mov	arg01, arg02
05038     10 00 B0 FD | 	call	#__system___gc_dofree
0503c     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
05040     1C 90 06 F1 | 	add	arg01, #28
05044     48 01 68 FC | 	wrlong	#0, arg01
05048                 | LR__0770
05048                 | __system___gc_free_ret
05048     2D 00 64 FD | 	ret
0504c                 | 
0504c                 | __system___gc_dofree
0504c     06 CA 05 F6 | 	mov	COUNT_, #6
05050     E8 00 A0 FD | 	call	#pushregs_
05054     48 A7 02 F6 | 	mov	local01, arg01
05058     2C FC BF FD | 	call	#__system___gc_ptrs
0505c     3B A9 02 F6 | 	mov	local02, result1
05060     3C AB 02 F6 | 	mov	local03, result2
05064     53 93 02 F6 | 	mov	arg02, local01
05068     02 92 06 F1 | 	add	arg02, #2
0506c     36 00 80 FF 
05070     49 1F 59 FC | 	wrword	##27791, arg02
05074     53 AD 02 F6 | 	mov	local04, local01
05078     53 91 02 F6 | 	mov	arg01, local01
0507c     48 AF EA FA | 	rdword	local05, arg01 wz
05080     00 76 06 A6 |  if_e	mov	result1, #0
05084     04 AE 66 50 |  if_ne	shl	local05, #4
05088     57 91 02 51 |  if_ne	add	arg01, local05
0508c     48 77 02 56 |  if_ne	mov	result1, arg01
05090     3B B1 02 F6 | 	mov	local06, result1
05094     D7 24 48 FB | 	callpa	#(@LR__0781-@LR__0780)>>2,fcache_load_ptr_
05098                 | LR__0780
05098     04 AC 06 F1 | 	add	local04, #4
0509c     56 93 EA FA | 	rdword	arg02, local04 wz
050a0     54 91 02 F6 | 	mov	arg01, local02
050a4     00 76 06 A6 |  if_e	mov	result1, #0
050a8     04 92 66 50 |  if_ne	shl	arg02, #4
050ac     49 91 02 51 |  if_ne	add	arg01, arg02
050b0     48 77 02 56 |  if_ne	mov	result1, arg01
050b4     3B AD 0A F6 | 	mov	local04, result1 wz
050b8     24 00 90 AD |  if_e	jmp	#LR__0782
050bc     56 91 02 F6 | 	mov	arg01, local04
050c0     00 76 06 F6 | 	mov	result1, #0
050c4     02 90 06 F1 | 	add	arg01, #2
050c8     48 91 E2 FA | 	rdword	arg01, arg01
050cc     36 00 00 FF 
050d0     8F 90 0E F2 | 	cmp	arg01, ##27791 wz
050d4     01 76 66 A6 |  if_e	neg	result1, #1
050d8     00 76 0E F2 | 	cmp	result1, #0 wz
050dc     B8 FF 9F AD |  if_e	jmp	#LR__0780
050e0                 | LR__0781
050e0                 | LR__0782
050e0     00 AC 0E F2 | 	cmp	local04, #0 wz
050e4     54 AD 02 A6 |  if_e	mov	local04, local02
050e8     56 93 02 F6 | 	mov	arg02, local04
050ec     06 92 06 F1 | 	add	arg02, #6
050f0     53 91 02 F6 | 	mov	arg01, local01
050f4     49 93 E2 FA | 	rdword	arg02, arg02
050f8     06 90 06 F1 | 	add	arg01, #6
050fc     48 93 52 FC | 	wrword	arg02, arg01
05100     53 93 0A F6 | 	mov	arg02, local01 wz
05104     00 76 06 A6 |  if_e	mov	result1, #0
05108     54 93 82 51 |  if_ne	sub	arg02, local02
0510c     04 92 46 50 |  if_ne	shr	arg02, #4
05110     49 77 02 56 |  if_ne	mov	result1, arg02
05114     56 93 02 F6 | 	mov	arg02, local04
05118     06 92 06 F1 | 	add	arg02, #6
0511c     49 77 52 FC | 	wrword	result1, arg02
05120     54 AD 0A F2 | 	cmp	local04, local02 wz
05124     A4 00 90 AD |  if_e	jmp	#LR__0785
05128     56 91 02 F6 | 	mov	arg01, local04
0512c     48 AF EA FA | 	rdword	local05, arg01 wz
05130     00 76 06 A6 |  if_e	mov	result1, #0
05134     04 AE 66 50 |  if_ne	shl	local05, #4
05138     57 91 02 51 |  if_ne	add	arg01, local05
0513c     48 77 02 56 |  if_ne	mov	result1, arg01
05140     53 77 0A F2 | 	cmp	result1, local01 wz
05144     84 00 90 5D |  if_ne	jmp	#LR__0784
05148     56 B1 E2 FA | 	rdword	local06, local04
0514c     53 93 E2 FA | 	rdword	arg02, local01
05150     49 B1 02 F1 | 	add	local06, arg02
05154     56 B1 52 FC | 	wrword	local06, local04
05158     53 B1 02 F6 | 	mov	local06, local01
0515c     02 B0 06 F1 | 	add	local06, #2
05160     58 01 58 FC | 	wrword	#0, local06
05164     53 91 02 F6 | 	mov	arg01, local01
05168     48 AF EA FA | 	rdword	local05, arg01 wz
0516c     00 76 06 A6 |  if_e	mov	result1, #0
05170     04 AE 66 50 |  if_ne	shl	local05, #4
05174     57 91 02 51 |  if_ne	add	arg01, local05
05178     48 77 02 56 |  if_ne	mov	result1, arg01
0517c     3B B1 02 F6 | 	mov	local06, result1
05180     55 B1 52 F2 | 	cmps	local06, local03 wc
05184     20 00 90 3D |  if_ae	jmp	#LR__0783
05188     56 93 0A F6 | 	mov	arg02, local04 wz
0518c     00 76 06 A6 |  if_e	mov	result1, #0
05190     54 93 82 51 |  if_ne	sub	arg02, local02
05194     04 92 46 50 |  if_ne	shr	arg02, #4
05198     49 77 02 56 |  if_ne	mov	result1, arg02
0519c     58 93 02 F6 | 	mov	arg02, local06
051a0     04 92 06 F1 | 	add	arg02, #4
051a4     49 77 52 FC | 	wrword	result1, arg02
051a8                 | LR__0783
051a8     53 93 02 F6 | 	mov	arg02, local01
051ac     06 92 06 F1 | 	add	arg02, #6
051b0     56 79 02 F6 | 	mov	result2, local04
051b4     49 93 E2 FA | 	rdword	arg02, arg02
051b8     06 78 06 F1 | 	add	result2, #6
051bc     3C 93 52 FC | 	wrword	arg02, result2
051c0     06 A6 06 F1 | 	add	local01, #6
051c4     53 01 58 FC | 	wrword	#0, local01
051c8     56 A7 02 F6 | 	mov	local01, local04
051cc                 | LR__0784
051cc                 | LR__0785
051cc     53 91 02 F6 | 	mov	arg01, local01
051d0     48 AF EA FA | 	rdword	local05, arg01 wz
051d4     00 76 06 A6 |  if_e	mov	result1, #0
051d8     04 AE 66 50 |  if_ne	shl	local05, #4
051dc     57 91 02 51 |  if_ne	add	arg01, local05
051e0     48 77 02 56 |  if_ne	mov	result1, arg01
051e4     3B 93 0A F6 | 	mov	arg02, result1 wz
051e8     B8 00 90 AD |  if_e	jmp	#LR__0787
051ec     55 93 52 F2 | 	cmps	arg02, local03 wc
051f0     B0 00 90 3D |  if_ae	jmp	#LR__0787
051f4     49 91 02 F6 | 	mov	arg01, arg02
051f8     00 76 06 F6 | 	mov	result1, #0
051fc     02 90 06 F1 | 	add	arg01, #2
05200     48 91 E2 FA | 	rdword	arg01, arg01
05204     36 00 00 FF 
05208     8F 90 0E F2 | 	cmp	arg01, ##27791 wz
0520c     01 76 66 A6 |  if_e	neg	result1, #1
05210     00 76 0E F2 | 	cmp	result1, #0 wz
05214     8C 00 90 AD |  if_e	jmp	#LR__0787
05218     53 AD 02 F6 | 	mov	local04, local01
0521c     56 B1 E2 FA | 	rdword	local06, local04
05220     49 91 02 F6 | 	mov	arg01, arg02
05224     48 A7 E2 FA | 	rdword	local01, arg01
05228     53 B1 02 F1 | 	add	local06, local01
0522c     56 B1 52 FC | 	wrword	local06, local04
05230     48 B1 02 F6 | 	mov	local06, arg01
05234     06 B0 06 F1 | 	add	local06, #6
05238     56 A7 02 F6 | 	mov	local01, local04
0523c     58 B1 E2 FA | 	rdword	local06, local06
05240     06 A6 06 F1 | 	add	local01, #6
05244     53 B1 52 FC | 	wrword	local06, local01
05248     48 B1 02 F6 | 	mov	local06, arg01
0524c     02 B0 06 F1 | 	add	local06, #2
05250     58 55 59 FC | 	wrword	#170, local06
05254     48 B1 02 F6 | 	mov	local06, arg01
05258     06 B0 06 F1 | 	add	local06, #6
0525c     58 01 58 FC | 	wrword	#0, local06
05260     48 AF EA FA | 	rdword	local05, arg01 wz
05264     00 76 06 A6 |  if_e	mov	result1, #0
05268     04 AE 66 50 |  if_ne	shl	local05, #4
0526c     57 91 02 51 |  if_ne	add	arg01, local05
05270     48 77 02 56 |  if_ne	mov	result1, arg01
05274     3B B1 0A F6 | 	mov	local06, result1 wz
05278     28 00 90 AD |  if_e	jmp	#LR__0786
0527c     55 B1 52 F2 | 	cmps	local06, local03 wc
05280     20 00 90 3D |  if_ae	jmp	#LR__0786
05284     56 93 0A F6 | 	mov	arg02, local04 wz
05288     00 76 06 A6 |  if_e	mov	result1, #0
0528c     54 93 82 51 |  if_ne	sub	arg02, local02
05290     04 92 46 50 |  if_ne	shr	arg02, #4
05294     49 77 02 56 |  if_ne	mov	result1, arg02
05298     58 AD 02 F6 | 	mov	local04, local06
0529c     04 AC 06 F1 | 	add	local04, #4
052a0     56 77 52 FC | 	wrword	result1, local04
052a4                 | LR__0786
052a4                 | LR__0787
052a4     58 77 02 F6 | 	mov	result1, local06
052a8     E7 F0 03 F6 | 	mov	ptra, fp
052ac     F2 00 A0 FD | 	call	#popregs_
052b0                 | __system___gc_dofree_ret
052b0     2D 00 64 FD | 	ret
052b4                 | 
052b4                 | __system___gc_docollect
052b4     05 CA 05 F6 | 	mov	COUNT_, #5
052b8     E8 00 A0 FD | 	call	#pushregs_
052bc     C8 F9 BF FD | 	call	#__system___gc_ptrs
052c0     3C A7 02 F6 | 	mov	local01, result2
052c4     3B A9 02 F6 | 	mov	local02, result1
052c8     54 91 02 F6 | 	mov	arg01, local02
052cc     48 AB EA FA | 	rdword	local03, arg01 wz
052d0     00 76 06 A6 |  if_e	mov	result1, #0
052d4     04 AA 66 50 |  if_ne	shl	local03, #4
052d8     55 91 02 51 |  if_ne	add	arg01, local03
052dc     48 77 02 56 |  if_ne	mov	result1, arg01
052e0     3B AD 0A F6 | 	mov	local04, result1 wz
052e4     00 76 06 F6 | 	mov	result1, #0
052e8     01 76 62 FD | 	cogid	result1
052ec     3B AF 02 F6 | 	mov	local05, result1
052f0     48 00 90 AD |  if_e	jmp	#LR__0792
052f4     D7 22 48 FB | 	callpa	#(@LR__0791-@LR__0790)>>2,fcache_load_ptr_
052f8                 | LR__0790
052f8     53 AD 52 F2 | 	cmps	local04, local01 wc
052fc     3C 00 90 3D |  if_ae	jmp	#LR__0792
05300     56 93 02 F6 | 	mov	arg02, local04
05304     02 92 06 F1 | 	add	arg02, #2
05308     49 93 E2 FA | 	rdword	arg02, arg02
0530c     20 92 26 F5 | 	andn	arg02, #32
05310     56 91 02 F6 | 	mov	arg01, local04
05314     02 90 06 F1 | 	add	arg01, #2
05318     48 93 52 FC | 	wrword	arg02, arg01
0531c     56 91 02 F6 | 	mov	arg01, local04
05320     48 AB EA FA | 	rdword	local03, arg01 wz
05324     00 76 06 A6 |  if_e	mov	result1, #0
05328     04 AA 66 50 |  if_ne	shl	local03, #4
0532c     55 91 02 51 |  if_ne	add	arg01, local03
05330     48 77 02 56 |  if_ne	mov	result1, arg01
05334     3B AD 0A F6 | 	mov	local04, result1 wz
05338     BC FF 9F 5D |  if_ne	jmp	#LR__0790
0533c                 | LR__0791
0533c                 | LR__0792
0533c     00 AA 06 F6 | 	mov	local03, #0
05340     00 90 06 F6 | 	mov	arg01, #0
05344     48 DA BF FD | 	call	#__system____topofstack
05348     3B 93 02 F6 | 	mov	arg02, result1
0534c     55 91 02 F6 | 	mov	arg01, local03
05350     90 00 B0 FD | 	call	#__system___gc_markhub
05354     1C 01 B0 FD | 	call	#__system___gc_markcog
05358     54 91 02 F6 | 	mov	arg01, local02
0535c     48 AB EA FA | 	rdword	local03, arg01 wz
05360     00 76 06 A6 |  if_e	mov	result1, #0
05364     04 AA 66 50 |  if_ne	shl	local03, #4
05368     55 91 02 51 |  if_ne	add	arg01, local03
0536c     48 77 02 56 |  if_ne	mov	result1, arg01
05370     3B A9 0A F6 | 	mov	local02, result1 wz
05374     60 00 90 AD |  if_e	jmp	#LR__0796
05378                 | LR__0793
05378     54 AD 02 F6 | 	mov	local04, local02
0537c     56 91 02 F6 | 	mov	arg01, local04
05380     48 AB EA FA | 	rdword	local03, arg01 wz
05384     00 76 06 A6 |  if_e	mov	result1, #0
05388     04 AA 66 50 |  if_ne	shl	local03, #4
0538c     55 91 02 51 |  if_ne	add	arg01, local03
05390     48 77 02 56 |  if_ne	mov	result1, arg01
05394     3B A9 02 F6 | 	mov	local02, result1
05398     56 93 02 F6 | 	mov	arg02, local04
0539c     02 92 06 F1 | 	add	arg02, #2
053a0     49 93 E2 FA | 	rdword	arg02, arg02
053a4     20 92 CE F7 | 	test	arg02, #32 wz
053a8     10 92 CE A7 |  if_e	test	arg02, #16 wz
053ac     1C 00 90 5D |  if_ne	jmp	#LR__0795
053b0     49 93 42 F8 | 	getnib	arg02, arg02, #0
053b4     57 93 0A F2 | 	cmp	arg02, local05 wz
053b8     0E 92 0E 52 |  if_ne	cmp	arg02, #14 wz
053bc     0C 00 90 5D |  if_ne	jmp	#LR__0794
053c0     56 91 02 F6 | 	mov	arg01, local04
053c4     84 FC BF FD | 	call	#__system___gc_dofree
053c8     3B A9 02 F6 | 	mov	local02, result1
053cc                 | LR__0794
053cc                 | LR__0795
053cc     00 A8 0E F2 | 	cmp	local02, #0 wz
053d0     53 A9 52 52 |  if_ne	cmps	local02, local01 wc
053d4     A0 FF 9F 4D |  if_c_and_nz	jmp	#LR__0793
053d8                 | LR__0796
053d8     E7 F0 03 F6 | 	mov	ptra, fp
053dc     F2 00 A0 FD | 	call	#popregs_
053e0                 | __system___gc_docollect_ret
053e0     2D 00 64 FD | 	ret
053e4                 | 
053e4                 | __system___gc_markhub
053e4     04 CA 05 F6 | 	mov	COUNT_, #4
053e8     E8 00 A0 FD | 	call	#pushregs_
053ec     48 A7 02 F6 | 	mov	local01, arg01
053f0     49 A9 02 F6 | 	mov	local02, arg02
053f4     90 F8 BF FD | 	call	#__system___gc_ptrs
053f8     3B AB 02 F6 | 	mov	local03, result1
053fc     3C AD 02 F6 | 	mov	local04, result2
05400                 | LR__0800
05400     54 A7 52 F2 | 	cmps	local01, local02 wc
05404     60 00 90 3D |  if_ae	jmp	#LR__0801
05408     53 95 02 FB | 	rdlong	arg03, local01
0540c     04 A6 06 F1 | 	add	local01, #4
05410     56 93 02 F6 | 	mov	arg02, local04
05414     55 91 02 F6 | 	mov	arg01, local03
05418     94 FB BF FD | 	call	#__system___gc_isvalidptr
0541c     3B 95 0A F6 | 	mov	arg03, result1 wz
05420     DC FF 9F AD |  if_e	jmp	#LR__0800
05424     4A 91 02 F6 | 	mov	arg01, arg03
05428     00 76 06 F6 | 	mov	result1, #0
0542c     02 90 06 F1 | 	add	arg01, #2
05430     48 91 E2 FA | 	rdword	arg01, arg01
05434     36 00 00 FF 
05438     8F 90 0E F2 | 	cmp	arg01, ##27791 wz
0543c     01 76 66 A6 |  if_e	neg	result1, #1
05440     00 76 0E F2 | 	cmp	result1, #0 wz
05444     B8 FF 9F 5D |  if_ne	jmp	#LR__0800
05448     4A 79 02 F6 | 	mov	result2, arg03
0544c     02 78 06 F1 | 	add	result2, #2
05450     3C 79 E2 FA | 	rdword	result2, result2
05454     0F 78 26 F5 | 	andn	result2, #15
05458     2E 78 46 F5 | 	or	result2, #46
0545c     02 94 06 F1 | 	add	arg03, #2
05460     4A 79 52 FC | 	wrword	result2, arg03
05464     98 FF 9F FD | 	jmp	#LR__0800
05468                 | LR__0801
05468     E7 F0 03 F6 | 	mov	ptra, fp
0546c     F2 00 A0 FD | 	call	#popregs_
05470                 | __system___gc_markhub_ret
05470     2D 00 64 FD | 	ret
05474                 | 
05474                 | __system___gc_markcog
05474     04 CA 05 F6 | 	mov	COUNT_, #4
05478     E8 00 A0 FD | 	call	#pushregs_
0547c     08 F8 BF FD | 	call	#__system___gc_ptrs
05480     3B A7 02 F6 | 	mov	local01, result1
05484     3C A9 02 F6 | 	mov	local02, result2
05488     EF AB 06 F6 | 	mov	local03, #495
0548c                 | LR__0810
0548c                 | 	'.live	local03
0548c     00 AA 96 F9 | 	alts	local03, #0
05490     55 AD 02 F6 | 	mov	local04, local03
05494     53 91 02 F6 | 	mov	arg01, local01
05498     54 93 02 F6 | 	mov	arg02, local02
0549c     56 95 02 F6 | 	mov	arg03, local04
054a0     0C FB BF FD | 	call	#__system___gc_isvalidptr
054a4     00 76 0E F2 | 	cmp	result1, #0 wz
054a8     18 00 90 AD |  if_e	jmp	#LR__0811
054ac     3B AD 02 F6 | 	mov	local04, result1
054b0     02 AC 06 F1 | 	add	local04, #2
054b4     56 AD E2 FA | 	rdword	local04, local04
054b8     20 AC 46 F5 | 	or	local04, #32
054bc     02 76 06 F1 | 	add	result1, #2
054c0     3B AD 52 FC | 	wrword	local04, result1
054c4                 | LR__0811
054c4     01 AA 86 F1 | 	sub	local03, #1
054c8     00 AA 56 F2 | 	cmps	local03, #0 wc
054cc     BC FF 9F 3D |  if_ae	jmp	#LR__0810
054d0     E7 F0 03 F6 | 	mov	ptra, fp
054d4     F2 00 A0 FD | 	call	#popregs_
054d8                 | __system___gc_markcog_ret
054d8     2D 00 64 FD | 	ret
054dc                 | 
054dc                 | __system___get_vfs_file_handle
054dc     01 CA 05 F6 | 	mov	COUNT_, #1
054e0     E8 00 A0 FD | 	call	#pushregs_
054e4     64 E2 BF FD | 	call	#__system___find_free_file
054e8     3B A7 02 F6 | 	mov	local01, result1
054ec     00 A6 56 F2 | 	cmps	local01, #0 wc
054f0     34 A6 06 3D |  if_ae	qmul	local01, #52
054f4     00 76 06 C6 |  if_b	mov	result1, #0
054f8     33 A7 02 36 |  if_ae	mov	local01, ptr___system__dat__
054fc     01 00 00 3F 
05500     E0 A6 06 31 |  if_ae	add	local01, ##736
05504     18 76 62 3D |  if_ae	getqx	result1
05508     53 77 02 31 |  if_ae	add	result1, local01
0550c     E7 F0 03 F6 | 	mov	ptra, fp
05510     F2 00 A0 FD | 	call	#popregs_
05514                 | __system___get_vfs_file_handle_ret
05514     2D 00 64 FD | 	ret
05518                 | 
05518                 | __system___closeraw
05518     05 CA 05 F6 | 	mov	COUNT_, #5
0551c     E8 00 A0 FD | 	call	#pushregs_
05520     48 A7 02 F6 | 	mov	local01, arg01
05524     00 A8 06 F6 | 	mov	local02, #0
05528     08 A6 06 F1 | 	add	local01, #8
0552c     53 77 0A FB | 	rdlong	result1, local01 wz
05530     08 A6 86 F1 | 	sub	local01, #8
05534     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
05538     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
0553c     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
05540     01 76 66 A6 |  if_e	neg	result1, #1
05544     A8 00 90 AD |  if_e	jmp	#LR__0822
05548     2C A6 06 F1 | 	add	local01, #44
0554c     53 77 0A FB | 	rdlong	result1, local01 wz
05550     2C A6 86 F1 | 	sub	local01, #44
05554     38 00 90 AD |  if_e	jmp	#LR__0820
05558     2C A6 06 F1 | 	add	local01, #44
0555c     53 AB 02 FB | 	rdlong	local03, local01
05560     55 AD 02 F6 | 	mov	local04, local03
05564     2C A6 86 F1 | 	sub	local01, #44
05568     13 AC 46 F7 | 	zerox	local04, #19
0556c     14 AA 46 F0 | 	shr	local03, #20
05570     02 AA 66 F0 | 	shl	local03, #2
05574     2D AB 02 F1 | 	add	local03, __methods__
05578     55 AB 02 FB | 	rdlong	local03, local03
0557c     53 91 02 F6 | 	mov	arg01, local01
05580     31 AF 02 F6 | 	mov	local05, objptr
05584     56 63 02 F6 | 	mov	objptr, local04
05588     2D AA 62 FD | 	call	local03
0558c     57 63 02 F6 | 	mov	objptr, local05
05590                 | LR__0820
05590     24 A6 06 F1 | 	add	local01, #36
05594     53 AF 0A FB | 	rdlong	local05, local01 wz
05598     24 A6 86 F1 | 	sub	local01, #36
0559c     3C 00 90 AD |  if_e	jmp	#LR__0821
055a0     24 A6 06 F1 | 	add	local01, #36
055a4     53 AB 02 FB | 	rdlong	local03, local01
055a8     55 AD 02 F6 | 	mov	local04, local03
055ac     24 A6 86 F1 | 	sub	local01, #36
055b0     13 AC 46 F7 | 	zerox	local04, #19
055b4     14 AA 46 F0 | 	shr	local03, #20
055b8     02 AA 66 F0 | 	shl	local03, #2
055bc     2D AB 02 F1 | 	add	local03, __methods__
055c0     55 AB 02 FB | 	rdlong	local03, local03
055c4     53 91 02 F6 | 	mov	arg01, local01
055c8     31 AF 02 F6 | 	mov	local05, objptr
055cc     56 63 02 F6 | 	mov	objptr, local04
055d0     2D AA 62 FD | 	call	local03
055d4     57 63 02 F6 | 	mov	objptr, local05
055d8     3B A9 02 F6 | 	mov	local02, result1
055dc                 | LR__0821
055dc     53 91 02 F6 | 	mov	arg01, local01
055e0     00 92 06 F6 | 	mov	arg02, #0
055e4     34 94 06 F6 | 	mov	arg03, #52
055e8     D8 00 A0 FD | 	call	#\builtin_bytefill_
055ec     54 77 02 F6 | 	mov	result1, local02
055f0                 | LR__0822
055f0     E7 F0 03 F6 | 	mov	ptra, fp
055f4     F2 00 A0 FD | 	call	#popregs_
055f8                 | __system___closeraw_ret
055f8     2D 00 64 FD | 	ret
055fc                 | 
055fc                 | __system___vfs_open_fat_handle
055fc     03 CA 05 F6 | 	mov	COUNT_, #3
05600     E8 00 A0 FD | 	call	#pushregs_
05604     48 A7 0A F6 | 	mov	local01, arg01 wz
05608     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0560c     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
05610     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
05614     00 76 06 A6 |  if_e	mov	result1, #0
05618     80 00 90 AD |  if_e	jmp	#LR__0831
0561c     01 00 00 FF 
05620     14 90 06 F6 | 	mov	arg01, ##532
05624     B0 F8 BF FD | 	call	#__system___gc_alloc_managed
05628     3B A9 02 F6 | 	mov	local02, result1
0562c     01 00 00 FF 
05630     34 90 06 F6 | 	mov	arg01, ##564
05634     A0 F8 BF FD | 	call	#__system___gc_alloc_managed
05638     31 AB 02 F6 | 	mov	local03, objptr
0563c     54 63 02 F6 | 	mov	objptr, local02
05640     01 00 00 FF 
05644     10 62 06 F1 | 	add	objptr, ##528
05648     31 A7 62 FC | 	wrlong	local01, objptr
0564c                 | ' #line 4 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/diskio.cc"
0564c                 | ' 
0564c                 | ' 
0564c                 | ' vfs_file_t *fh;
0564c                 | ' 
0564c                 | ' DRESULT disk_sethandle(BYTE pdrv, vfs_file_t *fhandle) {
0564c                 | '     fh = fhandle;
0564c                 | '     return RES_OK;
0564c     6F 00 00 FF 
05650     3C 93 06 F6 | 	mov	arg02, ##@LR__2146
05654     3B 91 02 F6 | 	mov	arg01, result1
05658     00 94 06 F6 | 	mov	arg03, #0
0565c     54 63 02 F6 | 	mov	objptr, local02
05660     CC 59 B0 FD | 	call	#_fatfs_cc_f_mount
05664     55 63 02 F6 | 	mov	objptr, local03
05668     3B 91 0A F6 | 	mov	arg01, result1 wz
0566c     18 00 90 AD |  if_e	jmp	#LR__0830
05670     48 91 6A F6 | 	neg	arg01, arg01 wz
05674     20 66 06 F1 | 	add	ptr___system__dat__, #32
05678     33 91 62 FC | 	wrlong	arg01, ptr___system__dat__
0567c     20 66 86 F1 | 	sub	ptr___system__dat__, #32
05680     00 76 06 F6 | 	mov	result1, #0
05684     14 00 90 FD | 	jmp	#LR__0831
05688                 | LR__0830
05688     54 91 02 F6 | 	mov	arg01, local02
0568c     31 AB 02 F6 | 	mov	local03, objptr
05690     54 63 02 F6 | 	mov	objptr, local02
05694     08 80 B0 FD | 	call	#_fatfs_cc_get_vfs
05698     55 63 02 F6 | 	mov	objptr, local03
0569c                 | LR__0831
0569c     E7 F0 03 F6 | 	mov	ptra, fp
056a0     F2 00 A0 FD | 	call	#popregs_
056a4                 | __system___vfs_open_fat_handle_ret
056a4     2D 00 64 FD | 	ret
056a8                 | 
056a8                 | __system___vfs_open_sdcardx
056a8     04 CA 05 F6 | 	mov	COUNT_, #4
056ac     E8 00 A0 FD | 	call	#pushregs_
056b0     38 0D B0 FD | 	call	#__system___sdmm_open
056b4     3B A7 0A F6 | 	mov	local01, result1 wz
056b8     00 76 06 A6 |  if_e	mov	result1, #0
056bc     4C 00 90 AD |  if_e	jmp	#LR__0841
056c0     53 91 02 F6 | 	mov	arg01, local01
056c4     34 FF BF FD | 	call	#__system___vfs_open_fat_handle
056c8     3B A9 0A F6 | 	mov	local02, result1 wz
056cc     38 00 90 5D |  if_ne	jmp	#LR__0840
056d0     24 A6 06 F1 | 	add	local01, #36
056d4     53 AB 02 FB | 	rdlong	local03, local01
056d8     55 AD 02 F6 | 	mov	local04, local03
056dc     24 A6 86 F1 | 	sub	local01, #36
056e0     13 AC 46 F7 | 	zerox	local04, #19
056e4     14 AA 46 F0 | 	shr	local03, #20
056e8     02 AA 66 F0 | 	shl	local03, #2
056ec     2D AB 02 F1 | 	add	local03, __methods__
056f0     55 AB 02 FB | 	rdlong	local03, local03
056f4     53 91 02 F6 | 	mov	arg01, local01
056f8     31 A7 02 F6 | 	mov	local01, objptr
056fc     56 63 02 F6 | 	mov	objptr, local04
05700     2D AA 62 FD | 	call	local03
05704     53 63 02 F6 | 	mov	objptr, local01
05708                 | LR__0840
05708     54 77 02 F6 | 	mov	result1, local02
0570c                 | LR__0841
0570c     E7 F0 03 F6 | 	mov	ptra, fp
05710     F2 00 A0 FD | 	call	#popregs_
05714                 | __system___vfs_open_sdcardx_ret
05714     2D 00 64 FD | 	ret
05718                 | 
05718                 | __system____default_getc
05718     03 CA 05 F6 | 	mov	COUNT_, #3
0571c     E8 00 A0 FD | 	call	#pushregs_
05720     48 A7 02 F6 | 	mov	local01, arg01
05724     53 A9 02 FB | 	rdlong	local02, local01
05728     08 A6 06 F1 | 	add	local01, #8
0572c     53 AB 02 FB | 	rdlong	local03, local01
05730     08 A6 86 F1 | 	sub	local01, #8
05734     08 AA CE F7 | 	test	local03, #8 wz
05738     53 91 02 56 |  if_ne	mov	arg01, local01
0573c     08 01 B0 5D |  if_ne	call	#__system____default_flush
05740     08 A6 06 F1 | 	add	local01, #8
05744     53 AB 02 FB | 	rdlong	local03, local01
05748     04 AA 46 F5 | 	or	local03, #4
0574c     53 AB 62 FC | 	wrlong	local03, local01
05750     08 A6 86 F1 | 	sub	local01, #8
05754     54 AB 0A FB | 	rdlong	local03, local02 wz
05758     0C 00 90 5D |  if_ne	jmp	#LR__0850
0575c     53 91 02 F6 | 	mov	arg01, local01
05760     CC 0E B0 FD | 	call	#__system____default_filbuf
05764     3B AB 02 F6 | 	mov	local03, result1
05768                 | LR__0850
05768     01 AA 56 F2 | 	cmps	local03, #1 wc
0576c     01 76 66 C6 |  if_b	neg	result1, #1
05770     1C 00 90 CD |  if_b	jmp	#LR__0851
05774     01 AA 86 F1 | 	sub	local03, #1
05778     54 AB 62 FC | 	wrlong	local03, local02
0577c     04 A8 06 F1 | 	add	local02, #4
05780     54 AB 02 FB | 	rdlong	local03, local02
05784     55 77 C2 FA | 	rdbyte	result1, local03
05788     01 AA 06 F1 | 	add	local03, #1
0578c     54 AB 62 FC | 	wrlong	local03, local02
05790                 | LR__0851
05790     E7 F0 03 F6 | 	mov	ptra, fp
05794     F2 00 A0 FD | 	call	#popregs_
05798                 | __system____default_getc_ret
05798     2D 00 64 FD | 	ret
0579c                 | 
0579c                 | __system____default_putc
0579c     06 CA 05 F6 | 	mov	COUNT_, #6
057a0     E8 00 A0 FD | 	call	#pushregs_
057a4     48 A7 02 F6 | 	mov	local01, arg01
057a8     49 A9 02 F6 | 	mov	local02, arg02
057ac     54 AB 02 FB | 	rdlong	local03, local02
057b0     08 A8 06 F1 | 	add	local02, #8
057b4     54 93 02 FB | 	rdlong	arg02, local02
057b8     08 A8 86 F1 | 	sub	local02, #8
057bc     04 92 CE F7 | 	test	arg02, #4 wz
057c0     54 91 02 56 |  if_ne	mov	arg01, local02
057c4     80 00 B0 5D |  if_ne	call	#__system____default_flush
057c8     08 A8 06 F1 | 	add	local02, #8
057cc     54 AD 02 FB | 	rdlong	local04, local02
057d0     08 AC 46 F5 | 	or	local04, #8
057d4     54 AD 62 FC | 	wrlong	local04, local02
057d8     55 AF 02 FB | 	rdlong	local05, local03
057dc     0C AA 06 F1 | 	add	local03, #12
057e0     55 93 02 FB | 	rdlong	arg02, local03
057e4     0C AA 86 F1 | 	sub	local03, #12
057e8     57 77 02 F6 | 	mov	result1, local05
057ec     49 77 02 F1 | 	add	result1, arg02
057f0     3B A7 42 FC | 	wrbyte	local01, result1
057f4     53 A7 E2 F8 | 	getbyte	local01, local01, #0
057f8     01 AE 06 F1 | 	add	local05, #1
057fc     55 AF 62 FC | 	wrlong	local05, local03
05800     02 A8 86 F1 | 	sub	local02, #2
05804     54 B1 EA FA | 	rdword	local06, local02 wz
05808     06 A8 86 F1 | 	sub	local02, #6
0580c     08 AA 06 51 |  if_ne	add	local03, #8
05810     55 AD 02 5B |  if_ne	rdlong	local04, local03
05814     56 AF 0A 52 |  if_ne	cmp	local05, local04 wz
05818     0C 00 90 AD |  if_e	jmp	#LR__0860
0581c     0A A6 0E F2 | 	cmp	local01, #10 wz
05820     01 B0 0E A2 |  if_e	cmp	local06, #1 wz
05824     10 00 90 5D |  if_ne	jmp	#LR__0861
05828                 | LR__0860
05828     54 91 02 F6 | 	mov	arg01, local02
0582c     18 00 B0 FD | 	call	#__system____default_flush
05830     00 76 0E F2 | 	cmp	result1, #0 wz
05834     01 A6 66 56 |  if_ne	neg	local01, #1
05838                 | LR__0861
05838     53 77 02 F6 | 	mov	result1, local01
0583c     E7 F0 03 F6 | 	mov	ptra, fp
05840     F2 00 A0 FD | 	call	#popregs_
05844                 | __system____default_putc_ret
05844     2D 00 64 FD | 	ret
05848                 | 
05848                 | __system____default_flush
05848     07 CA 05 F6 | 	mov	COUNT_, #7
0584c     E8 00 A0 FD | 	call	#pushregs_
05850     48 A7 02 F6 | 	mov	local01, arg01
05854     53 A9 02 FB | 	rdlong	local02, local01
05858     54 AB 02 FB | 	rdlong	local03, local02
0585c     08 A6 06 F1 | 	add	local01, #8
05860     53 79 02 FB | 	rdlong	result2, local01
05864     08 A6 86 F1 | 	sub	local01, #8
05868     08 78 CE F7 | 	test	result2, #8 wz
0586c     D4 00 90 AD |  if_e	jmp	#LR__0872
05870     01 AA 56 F2 | 	cmps	local03, #1 wc
05874     2C 01 90 CD |  if_b	jmp	#LR__0874
05878     08 A6 06 F1 | 	add	local01, #8
0587c     53 79 02 FB | 	rdlong	result2, local01
05880     08 A6 86 F1 | 	sub	local01, #8
05884     80 78 CE F7 | 	test	result2, #128 wz
05888     6C 00 90 AD |  if_e	jmp	#LR__0871
0588c     08 A6 06 F1 | 	add	local01, #8
05890     53 95 02 FB | 	rdlong	arg03, local01
05894     08 A6 86 F1 | 	sub	local01, #8
05898     00 95 CE F7 | 	test	arg03, #256 wz
0589c     58 00 90 AD |  if_e	jmp	#LR__0870
058a0     30 A6 06 F1 | 	add	local01, #48
058a4     53 AD 02 FB | 	rdlong	local04, local01
058a8     56 AF 02 F6 | 	mov	local05, local04
058ac     30 A6 86 F1 | 	sub	local01, #48
058b0     13 AE 46 F7 | 	zerox	local05, #19
058b4     14 AC 46 F0 | 	shr	local04, #20
058b8     02 AC 66 F0 | 	shl	local04, #2
058bc     2D AD 02 F1 | 	add	local04, __methods__
058c0     56 AD 02 FB | 	rdlong	local04, local04
058c4     53 91 02 F6 | 	mov	arg01, local01
058c8     00 92 06 F6 | 	mov	arg02, #0
058cc     00 94 06 F6 | 	mov	arg03, #0
058d0     02 96 06 F6 | 	mov	arg04, #2
058d4     31 B1 02 F6 | 	mov	local06, objptr
058d8     57 63 02 F6 | 	mov	objptr, local05
058dc     2D AC 62 FD | 	call	local04
058e0     58 63 02 F6 | 	mov	objptr, local06
058e4     08 A6 06 F1 | 	add	local01, #8
058e8     53 B1 02 FB | 	rdlong	local06, local01
058ec     00 B1 26 F5 | 	andn	local06, #256
058f0     53 B1 62 FC | 	wrlong	local06, local01
058f4     08 A6 86 F1 | 	sub	local01, #8
058f8                 | LR__0870
058f8                 | LR__0871
058f8     18 A6 06 F1 | 	add	local01, #24
058fc     53 AD 02 FB | 	rdlong	local04, local01
05900     56 AF 02 F6 | 	mov	local05, local04
05904     18 A6 86 F1 | 	sub	local01, #24
05908     13 AE 46 F7 | 	zerox	local05, #19
0590c     14 AC 46 F0 | 	shr	local04, #20
05910     02 AC 66 F0 | 	shl	local04, #2
05914     2D AD 02 F1 | 	add	local04, __methods__
05918     56 AD 02 FB | 	rdlong	local04, local04
0591c     0C A8 06 F1 | 	add	local02, #12
05920     54 93 02 FB | 	rdlong	arg02, local02
05924     0C A8 86 F1 | 	sub	local02, #12
05928     53 91 02 F6 | 	mov	arg01, local01
0592c     55 95 02 F6 | 	mov	arg03, local03
05930     31 B1 02 F6 | 	mov	local06, objptr
05934     57 63 02 F6 | 	mov	objptr, local05
05938     2D AC 62 FD | 	call	local04
0593c     58 63 02 F6 | 	mov	objptr, local06
05940     60 00 90 FD | 	jmp	#LR__0874
05944                 | LR__0872
05944     08 A6 06 F1 | 	add	local01, #8
05948     53 B1 02 FB | 	rdlong	local06, local01
0594c     08 A6 86 F1 | 	sub	local01, #8
05950     04 B0 CE F7 | 	test	local06, #4 wz
05954     00 AA 0E 52 |  if_ne	cmp	local03, #0 wz
05958     48 00 90 AD |  if_e	jmp	#LR__0873
0595c     55 93 62 F6 | 	neg	arg02, local03
05960     49 95 02 F6 | 	mov	arg03, arg02
05964     1F 94 C6 F0 | 	sar	arg03, #31
05968     30 A6 06 F1 | 	add	local01, #48
0596c     53 AD 02 FB | 	rdlong	local04, local01
05970     56 AF 02 F6 | 	mov	local05, local04
05974     30 A6 86 F1 | 	sub	local01, #48
05978     13 AE 46 F7 | 	zerox	local05, #19
0597c     14 AC 46 F0 | 	shr	local04, #20
05980     02 AC 66 F0 | 	shl	local04, #2
05984     2D AD 02 F1 | 	add	local04, __methods__
05988     56 AD 02 FB | 	rdlong	local04, local04
0598c     53 91 02 F6 | 	mov	arg01, local01
05990     01 96 06 F6 | 	mov	arg04, #1
05994     31 B1 02 F6 | 	mov	local06, objptr
05998     57 63 02 F6 | 	mov	objptr, local05
0599c     2D AC 62 FD | 	call	local04
059a0     58 63 02 F6 | 	mov	objptr, local06
059a4                 | LR__0873
059a4                 | LR__0874
059a4     54 01 68 FC | 	wrlong	#0, local02
059a8     04 A8 06 F1 | 	add	local02, #4
059ac     54 01 68 FC | 	wrlong	#0, local02
059b0     08 A6 06 F1 | 	add	local01, #8
059b4     53 B3 02 FB | 	rdlong	local07, local01
059b8     0C B2 26 F5 | 	andn	local07, #12
059bc     53 B3 62 FC | 	wrlong	local07, local01
059c0     00 76 06 F6 | 	mov	result1, #0
059c4     E7 F0 03 F6 | 	mov	ptra, fp
059c8     F2 00 A0 FD | 	call	#popregs_
059cc                 | __system____default_flush_ret
059cc     2D 00 64 FD | 	ret
059d0                 | 
059d0                 | __system__stat
059d0     04 CA 05 F6 | 	mov	COUNT_, #4
059d4     E8 00 A0 FD | 	call	#pushregs_
059d8     49 A7 02 F6 | 	mov	local01, arg02
059dc     33 A9 02 F6 | 	mov	local02, ptr___system__dat__
059e0     84 A9 06 F1 | 	add	local02, #388
059e4     48 93 02 F6 | 	mov	arg02, arg01
059e8     54 91 02 F6 | 	mov	arg01, local02
059ec     00 94 06 F6 | 	mov	arg03, #0
059f0     00 D9 BF FD | 	call	#__system____getvfsforfile
059f4     3B AB 0A F6 | 	mov	local03, result1 wz
059f8     10 00 90 AD |  if_e	jmp	#LR__0880
059fc     34 AA 06 F1 | 	add	local03, #52
05a00     55 95 0A FB | 	rdlong	arg03, local03 wz
05a04     34 AA 86 F1 | 	sub	local03, #52
05a08     14 00 90 5D |  if_ne	jmp	#LR__0881
05a0c                 | LR__0880
05a0c     20 66 06 F1 | 	add	ptr___system__dat__, #32
05a10     33 21 68 FC | 	wrlong	#16, ptr___system__dat__
05a14     20 66 86 F1 | 	sub	ptr___system__dat__, #32
05a18     01 76 66 F6 | 	neg	result1, #1
05a1c     68 00 90 FD | 	jmp	#LR__0882
05a20                 | LR__0881
05a20     53 91 02 F6 | 	mov	arg01, local01
05a24     00 92 06 F6 | 	mov	arg02, #0
05a28     34 94 06 F6 | 	mov	arg03, #52
05a2c     48 AD 02 F6 | 	mov	local04, arg01
05a30     D8 00 A0 FD | 	call	#\builtin_bytefill_
05a34     56 77 02 F6 | 	mov	result1, local04
05a38     54 91 CA FA | 	rdbyte	arg01, local02 wz
05a3c     08 A6 06 A1 |  if_e	add	local01, #8
05a40     08 00 80 AF 
05a44     53 FF 6B AC |  if_e	wrlong	##4607, local01
05a48     00 76 06 A6 |  if_e	mov	result1, #0
05a4c     38 00 90 AD |  if_e	jmp	#LR__0882
05a50     34 AA 06 F1 | 	add	local03, #52
05a54     55 AB 02 FB | 	rdlong	local03, local03
05a58     55 AD 02 F6 | 	mov	local04, local03
05a5c     13 AA 46 F7 | 	zerox	local03, #19
05a60     14 AC 46 F0 | 	shr	local04, #20
05a64     02 AC 66 F0 | 	shl	local04, #2
05a68     2D AD 02 F1 | 	add	local04, __methods__
05a6c     56 AD 02 FB | 	rdlong	local04, local04
05a70     54 91 02 F6 | 	mov	arg01, local02
05a74     53 93 02 F6 | 	mov	arg02, local01
05a78     31 A9 02 F6 | 	mov	local02, objptr
05a7c     55 63 02 F6 | 	mov	objptr, local03
05a80     2D AC 62 FD | 	call	local04
05a84     54 63 02 F6 | 	mov	objptr, local02
05a88                 | LR__0882
05a88     E7 F0 03 F6 | 	mov	ptra, fp
05a8c     F2 00 A0 FD | 	call	#popregs_
05a90                 | __system__stat_ret
05a90     2D 00 64 FD | 	ret
05a94                 | 
05a94                 | __system____getftab
05a94     0A 90 16 F2 | 	cmp	arg01, #10 wc
05a98     34 90 06 CD |  if_b	qmul	arg01, #52
05a9c     00 76 06 36 |  if_ae	mov	result1, #0
05aa0     33 91 02 C6 |  if_b	mov	arg01, ptr___system__dat__
05aa4     01 00 00 CF 
05aa8     E0 90 06 C1 |  if_b	add	arg01, ##736
05aac     18 76 62 CD |  if_b	getqx	result1
05ab0     48 77 02 C1 |  if_b	add	result1, arg01
05ab4                 | __system____getftab_ret
05ab4     2D 00 64 FD | 	ret
05ab8                 | 
05ab8                 | __system__strncpy
05ab8     48 7D 02 F6 | 	mov	_var01, arg01
05abc                 | LR__0890
05abc     01 94 86 F1 | 	sub	arg03, #1
05ac0     00 94 56 F2 | 	cmps	arg03, #0 wc
05ac4     24 00 90 CD |  if_b	jmp	#LR__0891
05ac8     49 77 02 F6 | 	mov	result1, arg02
05acc     01 76 06 F1 | 	add	result1, #1
05ad0     49 7F C2 FA | 	rdbyte	_var02, arg02
05ad4     3B 93 02 F6 | 	mov	arg02, result1
05ad8     3E 7F 42 FC | 	wrbyte	_var02, _var01
05adc     3F 7F E2 F8 | 	getbyte	_var02, _var02, #0
05ae0     07 7E 4E F7 | 	zerox	_var02, #7 wz
05ae4     01 7C 06 F1 | 	add	_var01, #1
05ae8     D0 FF 9F 5D |  if_ne	jmp	#LR__0890
05aec                 | LR__0891
05aec     D7 0C 48 FB | 	callpa	#(@LR__0893-@LR__0892)>>2,fcache_load_ptr_
05af0                 | LR__0892
05af0     01 94 86 F1 | 	sub	arg03, #1
05af4     00 94 56 F2 | 	cmps	arg03, #0 wc
05af8     3E 81 02 36 |  if_ae	mov	_var03, _var01
05afc     01 7C 06 31 |  if_ae	add	_var01, #1
05b00     40 01 48 3C |  if_ae	wrbyte	#0, _var03
05b04     E8 FF 9F 3D |  if_ae	jmp	#LR__0892
05b08                 | LR__0893
05b08     48 77 02 F6 | 	mov	result1, arg01
05b0c                 | __system__strncpy_ret
05b0c     2D 00 64 FD | 	ret
05b10                 | 
05b10                 | __system__strncat
05b10     00 92 4E F2 | 	cmps	arg02, #0 wz
05b14     54 00 90 AD |  if_e	jmp	#LR__0905
05b18     01 94 16 F2 | 	cmp	arg03, #1 wc
05b1c     4C 00 90 CD |  if_b	jmp	#LR__0905
05b20     48 7D 02 F6 | 	mov	_var01, arg01
05b24     D7 06 48 FB | 	callpa	#(@LR__0901-@LR__0900)>>2,fcache_load_ptr_
05b28                 | LR__0900
05b28     3E 77 CA FA | 	rdbyte	result1, _var01 wz
05b2c     01 7C 06 51 |  if_ne	add	_var01, #1
05b30     F4 FF 9F 5D |  if_ne	jmp	#LR__0900
05b34                 | LR__0901
05b34     4A 7F 02 F6 | 	mov	_var02, arg03
05b38     D7 16 48 FB | 	callpa	#(@LR__0903-@LR__0902)>>2,fcache_load_ptr_
05b3c                 | LR__0902
05b3c     49 81 C2 FA | 	rdbyte	_var03, arg02
05b40     40 83 02 F6 | 	mov	_var04, _var03
05b44     07 82 4E F7 | 	zerox	_var04, #7 wz
05b48     01 92 06 F1 | 	add	arg02, #1
05b4c     18 00 90 AD |  if_e	jmp	#LR__0904
05b50     01 7E 86 F1 | 	sub	_var02, #1
05b54     00 7E 56 F2 | 	cmps	_var02, #0 wc
05b58     3E 83 02 36 |  if_ae	mov	_var04, _var01
05b5c     01 7C 06 31 |  if_ae	add	_var01, #1
05b60     41 81 42 3C |  if_ae	wrbyte	_var03, _var04
05b64     D4 FF 9F 3D |  if_ae	jmp	#LR__0902
05b68                 | LR__0903
05b68                 | LR__0904
05b68     3E 01 48 FC | 	wrbyte	#0, _var01
05b6c                 | LR__0905
05b6c     48 77 02 F6 | 	mov	result1, arg01
05b70                 | __system__strncat_ret
05b70     2D 00 64 FD | 	ret
05b74                 | 
05b74                 | __system__strncmp
05b74     48 7D 0A F6 | 	mov	_var01, arg01 wz
05b78     14 00 90 5D |  if_ne	jmp	#LR__0910
05b7c     00 92 0E F2 | 	cmp	arg02, #0 wz
05b80     01 7E 66 56 |  if_ne	neg	_var02, #1
05b84     00 7E 06 A6 |  if_e	mov	_var02, #0
05b88     3F 77 02 F6 | 	mov	result1, _var02
05b8c     74 00 90 FD | 	jmp	#__system__strncmp_ret
05b90                 | LR__0910
05b90     00 92 0E F2 | 	cmp	arg02, #0 wz
05b94     01 76 06 A6 |  if_e	mov	result1, #1
05b98     68 00 90 AD |  if_e	jmp	#__system__strncmp_ret
05b9c     4A 81 02 F6 | 	mov	_var03, arg03
05ba0     D7 16 48 FB | 	callpa	#(@LR__0912-@LR__0911)>>2,fcache_load_ptr_
05ba4                 | LR__0911
05ba4     3E 83 C2 FA | 	rdbyte	_var04, _var01
05ba8     49 85 02 F6 | 	mov	_var05, arg02
05bac     42 87 C2 FA | 	rdbyte	_var06, _var05
05bb0     01 80 86 F1 | 	sub	_var03, #1
05bb4     00 80 56 F2 | 	cmps	_var03, #0 wc
05bb8     01 7C 06 F1 | 	add	_var01, #1
05bbc     01 92 06 F1 | 	add	arg02, #1
05bc0     00 82 0E 32 |  if_ae	cmp	_var04, #0 wz
05bc4     08 00 90 2D |  if_nc_and_z	jmp	#LR__0913
05bc8     43 83 0A 32 |  if_ae	cmp	_var04, _var06 wz
05bcc     D4 FF 9F 2D |  if_nc_and_z	jmp	#LR__0911
05bd0                 | LR__0912
05bd0                 | LR__0913
05bd0     00 80 56 F2 | 	cmps	_var03, #0 wc
05bd4     00 76 06 C6 |  if_b	mov	result1, #0
05bd8     28 00 90 CD |  if_b	jmp	#__system__strncmp_ret
05bdc     43 83 0A F2 | 	cmp	_var04, _var06 wz
05be0     00 76 06 A6 |  if_e	mov	result1, #0
05be4     1C 00 90 AD |  if_e	jmp	#__system__strncmp_ret
05be8     00 82 0E F2 | 	cmp	_var04, #0 wz
05bec     01 76 66 A6 |  if_e	neg	result1, #1
05bf0     10 00 90 AD |  if_e	jmp	#__system__strncmp_ret
05bf4     00 86 0E F2 | 	cmp	_var06, #0 wz
05bf8     01 76 06 A6 |  if_e	mov	result1, #1
05bfc     41 77 02 56 |  if_ne	mov	result1, _var04
05c00     43 77 82 51 |  if_ne	sub	result1, _var06
05c04                 | __system__strncmp_ret
05c04     2D 00 64 FD | 	ret
05c08                 | 
05c08                 | __system____root_opendir
05c08     33 77 02 F6 | 	mov	result1, ptr___system__dat__
05c0c     64 76 06 F1 | 	add	result1, #100
05c10     04 90 06 F1 | 	add	arg01, #4
05c14     48 77 62 FC | 	wrlong	result1, arg01
05c18     00 76 06 F6 | 	mov	result1, #0
05c1c                 | __system____root_opendir_ret
05c1c     2D 00 64 FD | 	ret
05c20                 | 
05c20                 | __system____root_readdir
05c20     03 CA 05 F6 | 	mov	COUNT_, #3
05c24     E8 00 A0 FD | 	call	#pushregs_
05c28     48 A7 02 F6 | 	mov	local01, arg01
05c2c     49 A9 02 F6 | 	mov	local02, arg02
05c30     04 A6 06 F1 | 	add	local01, #4
05c34     53 AB 02 FB | 	rdlong	local03, local01
05c38     04 A6 86 F1 | 	sub	local01, #4
05c3c                 | LR__0920
05c3c     33 95 02 F6 | 	mov	arg03, ptr___system__dat__
05c40     74 94 06 F1 | 	add	arg03, #116
05c44     4A AB 0A F2 | 	cmp	local03, arg03 wz
05c48     01 76 66 A6 |  if_e	neg	result1, #1
05c4c     48 00 90 AD |  if_e	jmp	#LR__0921
05c50     55 95 0A FB | 	rdlong	arg03, local03 wz
05c54     04 AA 06 A1 |  if_e	add	local03, #4
05c58     E0 FF 9F AD |  if_e	jmp	#LR__0920
05c5c     55 93 02 FB | 	rdlong	arg02, local03
05c60     01 92 06 F1 | 	add	arg02, #1
05c64     54 91 02 F6 | 	mov	arg01, local02
05c68     40 94 06 F6 | 	mov	arg03, #64
05c6c     48 FE BF FD | 	call	#__system__strncpy
05c70     50 A8 06 F1 | 	add	local02, #80
05c74     54 03 48 FC | 	wrbyte	#1, local02
05c78     08 A8 86 F1 | 	sub	local02, #8
05c7c     54 01 68 FC | 	wrlong	#0, local02
05c80     04 A8 06 F1 | 	add	local02, #4
05c84     54 01 68 FC | 	wrlong	#0, local02
05c88     04 AA 06 F1 | 	add	local03, #4
05c8c     04 A6 06 F1 | 	add	local01, #4
05c90     53 AB 62 FC | 	wrlong	local03, local01
05c94     00 76 06 F6 | 	mov	result1, #0
05c98                 | LR__0921
05c98     E7 F0 03 F6 | 	mov	ptra, fp
05c9c     F2 00 A0 FD | 	call	#popregs_
05ca0                 | __system____root_readdir_ret
05ca0     2D 00 64 FD | 	ret
05ca4                 | 
05ca4                 | __system____root_closedir
05ca4     00 76 06 F6 | 	mov	result1, #0
05ca8                 | __system____root_closedir_ret
05ca8     2D 00 64 FD | 	ret
05cac                 | 
05cac                 | __system____root_stat
05cac     49 7D 02 F6 | 	mov	_var01, arg02
05cb0     3E 91 02 F6 | 	mov	arg01, _var01
05cb4     00 92 06 F6 | 	mov	arg02, #0
05cb8     34 94 06 F6 | 	mov	arg03, #52
05cbc     D8 00 A0 FD | 	call	#\builtin_bytefill_
05cc0     08 7C 06 F1 | 	add	_var01, #8
05cc4     08 00 80 FF 
05cc8     3E FF 6B FC | 	wrlong	##4607, _var01
05ccc     00 76 06 F6 | 	mov	result1, #0
05cd0                 | __system____root_stat_ret
05cd0     2D 00 64 FD | 	ret
05cd4                 | 
05cd4                 | __system___normalizeName
05cd4     00 7C 06 F6 | 	mov	_var01, #0
05cd8     48 7F 02 F6 | 	mov	_var02, arg01
05cdc     3F 81 02 F6 | 	mov	_var03, _var02
05ce0                 | LR__0930
05ce0     3F 83 CA FA | 	rdbyte	_var04, _var02 wz
05ce4     5C 01 90 AD |  if_e	jmp	#LR__0949
05ce8     00 7C 0E F2 | 	cmp	_var01, #0 wz
05cec     40 83 02 56 |  if_ne	mov	_var04, _var03
05cf0     01 80 06 51 |  if_ne	add	_var03, #1
05cf4     41 5F 48 5C |  if_ne	wrbyte	#47, _var04
05cf8     00 7C 06 56 |  if_ne	mov	_var01, #0
05cfc     3F 83 C2 FA | 	rdbyte	_var04, _var02
05d00     2E 82 0E F2 | 	cmp	_var04, #46 wz
05d04     D8 00 90 5D |  if_ne	jmp	#LR__0942
05d08     01 7E 06 F1 | 	add	_var02, #1
05d0c     3F 83 C2 FA | 	rdbyte	_var04, _var02
05d10     01 7E 86 F1 | 	sub	_var02, #1
05d14     2F 82 0E F2 | 	cmp	_var04, #47 wz
05d18     18 00 90 AD |  if_e	jmp	#LR__0931
05d1c     01 7E 06 F1 | 	add	_var02, #1
05d20     3F 85 C2 FA | 	rdbyte	_var05, _var02
05d24     01 7E 86 F1 | 	sub	_var02, #1
05d28     42 87 02 F6 | 	mov	_var06, _var05
05d2c     07 86 4E F7 | 	zerox	_var06, #7 wz
05d30     10 00 90 5D |  if_ne	jmp	#LR__0932
05d34                 | LR__0931
05d34     3F 89 02 F6 | 	mov	_var07, _var02
05d38     01 88 06 F1 | 	add	_var07, #1
05d3c     44 7F 02 F6 | 	mov	_var02, _var07
05d40     E0 00 90 FD | 	jmp	#LR__0946
05d44                 | LR__0932
05d44     01 7E 06 F1 | 	add	_var02, #1
05d48     3F 89 C2 FA | 	rdbyte	_var07, _var02
05d4c     01 7E 86 F1 | 	sub	_var02, #1
05d50     44 83 E2 F8 | 	getbyte	_var04, _var07, #0
05d54     2E 82 0E F2 | 	cmp	_var04, #46 wz
05d58     84 00 90 5D |  if_ne	jmp	#LR__0941
05d5c     02 7E 06 F1 | 	add	_var02, #2
05d60     3F 89 C2 FA | 	rdbyte	_var07, _var02
05d64     02 7E 86 F1 | 	sub	_var02, #2
05d68     44 83 E2 F8 | 	getbyte	_var04, _var07, #0
05d6c     2F 82 0E F2 | 	cmp	_var04, #47 wz
05d70     18 00 90 AD |  if_e	jmp	#LR__0933
05d74     02 7E 06 F1 | 	add	_var02, #2
05d78     3F 85 C2 FA | 	rdbyte	_var05, _var02
05d7c     02 7E 86 F1 | 	sub	_var02, #2
05d80     42 87 02 F6 | 	mov	_var06, _var05
05d84     07 86 4E F7 | 	zerox	_var06, #7 wz
05d88     54 00 90 5D |  if_ne	jmp	#LR__0940
05d8c                 | LR__0933
05d8c     02 7E 06 F1 | 	add	_var02, #2
05d90     48 81 5A F2 | 	cmps	_var03, arg01 wcz
05d94     40 00 90 ED |  if_be	jmp	#LR__0939
05d98     40 8B 02 F6 | 	mov	_var08, _var03
05d9c     01 8A 86 F1 | 	sub	_var08, #1
05da0                 | LR__0934
05da0     45 83 C2 FA | 	rdbyte	_var04, _var08
05da4     2F 82 0E F2 | 	cmp	_var04, #47 wz
05da8     0C 00 90 5D |  if_ne	jmp	#LR__0935
05dac     48 8B 5A F2 | 	cmps	_var08, arg01 wcz
05db0     01 8A 86 11 |  if_a	sub	_var08, #1
05db4     E8 FF 9F 1D |  if_a	jmp	#LR__0934
05db8                 | LR__0935
05db8     D7 0C 48 FB | 	callpa	#(@LR__0937-@LR__0936)>>2,fcache_load_ptr_
05dbc                 | LR__0936
05dbc     48 8B 5A F2 | 	cmps	_var08, arg01 wcz
05dc0     10 00 90 ED |  if_be	jmp	#LR__0938
05dc4     45 83 C2 FA | 	rdbyte	_var04, _var08
05dc8     2F 82 0E F2 | 	cmp	_var04, #47 wz
05dcc     01 8A 86 51 |  if_ne	sub	_var08, #1
05dd0     E8 FF 9F 5D |  if_ne	jmp	#LR__0936
05dd4                 | LR__0937
05dd4                 | LR__0938
05dd4     45 81 02 F6 | 	mov	_var03, _var08
05dd8                 | LR__0939
05dd8     01 7C 06 F6 | 	mov	_var01, #1
05ddc     44 00 90 FD | 	jmp	#LR__0946
05de0                 | LR__0940
05de0                 | LR__0941
05de0                 | LR__0942
05de0     D7 18 48 FB | 	callpa	#(@LR__0944-@LR__0943)>>2,fcache_load_ptr_
05de4                 | LR__0943
05de4     3F 83 CA FA | 	rdbyte	_var04, _var02 wz
05de8     41 89 02 56 |  if_ne	mov	_var07, _var04
05dec     2F 88 0E 52 |  if_ne	cmp	_var07, #47 wz
05df0     20 00 90 AD |  if_e	jmp	#LR__0945
05df4     3F 87 02 F6 | 	mov	_var06, _var02
05df8     3F 85 02 F6 | 	mov	_var05, _var02
05dfc     01 84 06 F1 | 	add	_var05, #1
05e00     43 8D C2 FA | 	rdbyte	_var09, _var06
05e04     42 7F 02 F6 | 	mov	_var02, _var05
05e08     40 8D 42 FC | 	wrbyte	_var09, _var03
05e0c     01 80 06 F1 | 	add	_var03, #1
05e10     D0 FF 9F FD | 	jmp	#LR__0943
05e14                 | LR__0944
05e14                 | LR__0945
05e14     3F 83 C2 FA | 	rdbyte	_var04, _var02
05e18     2F 82 0E F2 | 	cmp	_var04, #47 wz
05e1c     C0 FE 9F 5D |  if_ne	jmp	#LR__0930
05e20     01 7C 06 F6 | 	mov	_var01, #1
05e24                 | LR__0946
05e24     D7 0C 48 FB | 	callpa	#(@LR__0948-@LR__0947)>>2,fcache_load_ptr_
05e28                 | LR__0947
05e28     3F 83 C2 FA | 	rdbyte	_var04, _var02
05e2c     2F 82 0E F2 | 	cmp	_var04, #47 wz
05e30     3F 89 02 A6 |  if_e	mov	_var07, _var02
05e34     01 88 06 A1 |  if_e	add	_var07, #1
05e38     44 7F 02 A6 |  if_e	mov	_var02, _var07
05e3c     E8 FF 9F AD |  if_e	jmp	#LR__0947
05e40                 | LR__0948
05e40     9C FE 9F FD | 	jmp	#LR__0930
05e44                 | LR__0949
05e44     40 01 48 FC | 	wrbyte	#0, _var03
05e48                 | __system___normalizeName_ret
05e48     2D 00 64 FD | 	ret
05e4c                 | 
05e4c                 | __system___strrev
05e4c     48 7D CA FA | 	rdbyte	_var01, arg01 wz
05e50     40 00 90 AD |  if_e	jmp	#__system___strrev_ret
05e54     48 7F 02 F6 | 	mov	_var02, arg01
05e58     D7 06 48 FB | 	callpa	#(@LR__0951-@LR__0950)>>2,fcache_load_ptr_
05e5c                 | LR__0950
05e5c     3F 7D CA FA | 	rdbyte	_var01, _var02 wz
05e60     01 7E 06 51 |  if_ne	add	_var02, #1
05e64     F4 FF 9F 5D |  if_ne	jmp	#LR__0950
05e68                 | LR__0951
05e68     01 7E 86 F1 | 	sub	_var02, #1
05e6c     D7 12 48 FB | 	callpa	#(@LR__0953-@LR__0952)>>2,fcache_load_ptr_
05e70                 | LR__0952
05e70     48 7F 5A F2 | 	cmps	_var02, arg01 wcz
05e74     1C 00 90 ED |  if_be	jmp	#LR__0954
05e78     48 7D C2 FA | 	rdbyte	_var01, arg01
05e7c     3F 81 C2 FA | 	rdbyte	_var03, _var02
05e80     48 81 42 FC | 	wrbyte	_var03, arg01
05e84     3F 7D 42 FC | 	wrbyte	_var01, _var02
05e88     01 90 06 F1 | 	add	arg01, #1
05e8c     01 7E 86 F1 | 	sub	_var02, #1
05e90     DC FF 9F FD | 	jmp	#LR__0952
05e94                 | LR__0953
05e94                 | LR__0954
05e94                 | __system___strrev_ret
05e94     2D 00 64 FD | 	ret
05e98                 | 
05e98                 | __system___fmtpad
05e98     06 CA 05 F6 | 	mov	COUNT_, #6
05e9c     E8 00 A0 FD | 	call	#pushregs_
05ea0     48 A7 02 F6 | 	mov	local01, arg01
05ea4     49 A9 02 F6 | 	mov	local02, arg02
05ea8     4A AB 02 F6 | 	mov	local03, arg03
05eac     54 91 EA F8 | 	getbyte	arg01, local02, #1
05eb0     16 A8 46 F0 | 	shr	local02, #22
05eb4     03 A8 0E F5 | 	and	local02, #3 wz
05eb8     00 AC 06 F6 | 	mov	local04, #0
05ebc     01 A8 06 A6 |  if_e	mov	local02, #1
05ec0     4B A9 CA F7 | 	test	local02, arg04 wz
05ec4     00 76 06 A6 |  if_e	mov	result1, #0
05ec8     88 00 90 AD |  if_e	jmp	#LR__0963
05ecc     48 AB C2 F2 | 	subr	local03, arg01
05ed0     01 AA 56 F2 | 	cmps	local03, #1 wc
05ed4     00 76 06 C6 |  if_b	mov	result1, #0
05ed8     78 00 90 CD |  if_b	jmp	#LR__0963
05edc     03 A8 0E F2 | 	cmp	local02, #3 wz
05ee0     18 00 90 5D |  if_ne	jmp	#LR__0960
05ee4     01 96 0E F2 | 	cmp	arg04, #1 wz
05ee8     6E A8 62 FD | 	wrz	local02
05eec     54 AB 02 F1 | 	add	local03, local02
05ef0     55 AB 52 F6 | 	abs	local03, local03 wc
05ef4     01 AA 46 F0 | 	shr	local03, #1
05ef8     55 AB 82 F6 | 	negc	local03, local03
05efc                 | LR__0960
05efc     01 AA 56 F2 | 	cmps	local03, #1 wc
05f00     4C 00 90 CD |  if_b	jmp	#LR__0962
05f04     55 AF 02 F6 | 	mov	local05, local03
05f08                 | LR__0961
05f08     53 A9 02 F6 | 	mov	local02, local01
05f0c     53 B1 02 F6 | 	mov	local06, local01
05f10     13 A8 46 F7 | 	zerox	local02, #19
05f14     14 B0 46 F0 | 	shr	local06, #20
05f18     02 B0 66 F0 | 	shl	local06, #2
05f1c     2D B1 02 F1 | 	add	local06, __methods__
05f20     58 B1 02 FB | 	rdlong	local06, local06
05f24     20 90 06 F6 | 	mov	arg01, #32
05f28     31 AB 02 F6 | 	mov	local03, objptr
05f2c     54 63 02 F6 | 	mov	objptr, local02
05f30     2D B0 62 FD | 	call	local06
05f34     55 63 02 F6 | 	mov	objptr, local03
05f38     3B B1 02 F6 | 	mov	local06, result1
05f3c     00 B0 56 F2 | 	cmps	local06, #0 wc
05f40     58 77 02 C6 |  if_b	mov	result1, local06
05f44     0C 00 90 CD |  if_b	jmp	#LR__0963
05f48     58 AD 02 F1 | 	add	local04, local06
05f4c     EE AF 6E FB | 	djnz	local05, #LR__0961
05f50                 | LR__0962
05f50     56 77 02 F6 | 	mov	result1, local04
05f54                 | LR__0963
05f54     E7 F0 03 F6 | 	mov	ptra, fp
05f58     F2 00 A0 FD | 	call	#popregs_
05f5c                 | __system___fmtpad_ret
05f5c     2D 00 64 FD | 	ret
05f60                 | 
05f60                 | __system___uitoa
05f60     04 CA 05 F6 | 	mov	COUNT_, #4
05f64     E8 00 A0 FD | 	call	#pushregs_
05f68     48 A7 02 F6 | 	mov	local01, arg01
05f6c     00 98 4E F2 | 	cmps	arg05, #0 wz
05f70     53 99 02 F6 | 	mov	arg05, local01
05f74     00 A8 06 F6 | 	mov	local02, #0
05f78     37 AA 06 56 |  if_ne	mov	local03, #55
05f7c     57 AA 06 A6 |  if_e	mov	local03, #87
05f80                 | LR__0970
05f80     4A 93 12 FD | 	qdiv	arg02, arg03
05f84     19 AC 62 FD | 	getqy	local04
05f88     4A 93 12 FD | 	qdiv	arg02, arg03
05f8c     0A AC 16 F2 | 	cmp	local04, #10 wc
05f90     30 AC 06 C1 |  if_b	add	local04, #48
05f94     55 AD 02 31 |  if_ae	add	local04, local03
05f98     4C AD 42 FC | 	wrbyte	local04, arg05
05f9c     01 98 06 F1 | 	add	arg05, #1
05fa0     01 A8 06 F1 | 	add	local02, #1
05fa4     18 92 62 FD | 	getqx	arg02
05fa8     00 92 0E F2 | 	cmp	arg02, #0 wz
05fac     D0 FF 9F 5D |  if_ne	jmp	#LR__0970
05fb0     4B A9 12 F2 | 	cmp	local02, arg04 wc
05fb4     C8 FF 9F CD |  if_b	jmp	#LR__0970
05fb8     4C 01 48 FC | 	wrbyte	#0, arg05
05fbc     53 91 02 F6 | 	mov	arg01, local01
05fc0     88 FE BF FD | 	call	#__system___strrev
05fc4     54 77 02 F6 | 	mov	result1, local02
05fc8     E7 F0 03 F6 | 	mov	ptra, fp
05fcc     F2 00 A0 FD | 	call	#popregs_
05fd0                 | __system___uitoa_ret
05fd0     2D 00 64 FD | 	ret
05fd4                 | 
05fd4                 | __system__disassemble_0093
05fd4     10 CA 05 F6 | 	mov	COUNT_, #16
05fd8     E8 00 A0 FD | 	call	#pushregs_
05fdc     48 A7 02 F6 | 	mov	local01, arg01
05fe0     49 A9 02 F6 | 	mov	local02, arg02
05fe4     4A AB 02 F6 | 	mov	local03, arg03
05fe8     4B AD 02 F6 | 	mov	local04, arg04
05fec     4C AF 02 F6 | 	mov	local05, arg05
05ff0     57 91 52 F6 | 	abs	arg01, local05 wc
05ff4     1F B0 C6 C9 |  if_b	decod	local06, #31
05ff8     00 B0 06 36 |  if_ae	mov	local06, #0
05ffc     CC E1 BF FD | 	call	#__system___float_fromuns
06000     58 77 62 F5 | 	xor	result1, local06
06004     3B B3 02 F6 | 	mov	local07, result1
06008     00 B4 06 F6 | 	mov	local08, #0
0600c     53 91 02 F6 | 	mov	arg01, local01
06010     00 92 06 F6 | 	mov	arg02, #0
06014     01 94 06 F6 | 	mov	arg03, #1
06018     10 E9 BF FD | 	call	#__system___float_cmp
0601c     00 76 0E F2 | 	cmp	result1, #0 wz
06020     00 B6 06 A6 |  if_e	mov	local09, #0
06024     54 01 68 AC |  if_e	wrlong	#0, local02
06028     55 B7 62 AC |  if_e	wrlong	local09, local03
0602c     8C 01 90 AD |  if_e	jmp	#LR__0992
06030     53 91 02 F6 | 	mov	arg01, local01
06034     44 EB BF FD | 	call	#__system____builtin_ilogb
06038     3B B9 02 F6 | 	mov	local10, result1
0603c     0A AE 0E F2 | 	cmp	local05, #10 wz
06040     24 00 90 5D |  if_ne	jmp	#LR__0980
06044     5C B7 02 F6 | 	mov	local09, local10
06048     01 B6 66 F0 | 	shl	local09, #1
0604c     5C B7 02 F1 | 	add	local09, local10
06050     5B B9 52 F6 | 	abs	local10, local09 wc
06054     0A B8 16 FD | 	qdiv	local10, #10
06058     09 BA 06 F6 | 	mov	local11, #9
0605c     18 B8 62 FD | 	getqx	local10
06060     5C B9 82 F6 | 	negc	local10, local10
06064     04 00 90 FD | 	jmp	#LR__0981
06068                 | LR__0980
06068     18 BA 06 F6 | 	mov	local11, #24
0606c                 | LR__0981
0606c                 | LR__0982
0606c     08 B4 56 F2 | 	cmps	local08, #8 wc
06070     01 B4 06 F1 | 	add	local08, #1
06074     60 00 90 3D |  if_ae	jmp	#LR__0983
06078     00 C0 1F FF 
0607c     00 90 06 F6 | 	mov	arg01, ##1065353216
06080     59 93 02 F6 | 	mov	arg02, local07
06084     5C 95 02 F6 | 	mov	arg03, local10
06088     2C EB BF FD | 	call	#__system___float_pow_n
0608c     3B 93 02 F6 | 	mov	arg02, result1
06090     53 91 02 F6 | 	mov	arg01, local01
06094     64 E6 BF FD | 	call	#__system___float_div
06098     3B BD 02 F6 | 	mov	local12, result1
0609c     5E 91 02 F6 | 	mov	arg01, local12
060a0     00 C0 1F FF 
060a4     00 92 06 F6 | 	mov	arg02, ##1065353216
060a8     01 94 06 F6 | 	mov	arg03, #1
060ac     7C E8 BF FD | 	call	#__system___float_cmp
060b0     00 76 56 F2 | 	cmps	result1, #0 wc
060b4     01 B8 86 C1 |  if_b	sub	local10, #1
060b8     B0 FF 9F CD |  if_b	jmp	#LR__0982
060bc     59 93 02 F6 | 	mov	arg02, local07
060c0     5E 91 02 F6 | 	mov	arg01, local12
060c4     01 94 66 F6 | 	neg	arg03, #1
060c8     60 E8 BF FD | 	call	#__system___float_cmp
060cc     00 76 56 F2 | 	cmps	result1, #0 wc
060d0     01 B8 06 31 |  if_ae	add	local10, #1
060d4     94 FF 9F 3D |  if_ae	jmp	#LR__0982
060d8                 | LR__0983
060d8     5E 91 02 F6 | 	mov	arg01, local12
060dc     9C EA BF FD | 	call	#__system____builtin_ilogb
060e0     3B BF 02 F6 | 	mov	local13, result1
060e4     5E C1 02 F6 | 	mov	local14, local12
060e8     17 C1 06 F4 | 	bitl	local14, #279
060ec     17 C0 26 F4 | 	bith	local14, #23
060f0     5F C1 62 F0 | 	shl	local14, local13
060f4     02 AE 0E F2 | 	cmp	local05, #2 wz
060f8     02 AC 66 A0 |  if_e	shl	local04, #2
060fc     00 C2 06 F6 | 	mov	local15, #0
06100     00 AC 56 F2 | 	cmps	local04, #0 wc
06104     10 00 90 3D |  if_ae	jmp	#LR__0984
06108     5C AD C2 F2 | 	subr	local04, local10
0610c     00 AC 56 F2 | 	cmps	local04, #0 wc
06110     A0 00 90 CD |  if_b	jmp	#LR__0991
06114     04 00 90 FD | 	jmp	#LR__0985
06118                 | LR__0984
06118     01 AC 06 F1 | 	add	local04, #1
0611c                 | LR__0985
0611c     5D AD 7A F3 | 	fles	local04, local11 wcz
06120     01 C4 06 F6 | 	mov	local16, #1
06124     D7 22 48 FB | 	callpa	#(@LR__0987-@LR__0986)>>2,fcache_load_ptr_
06128                 | LR__0986
06128     00 40 00 FF 
0612c     00 C2 16 F2 | 	cmp	local15, ##8388608 wc
06130     38 00 90 3D |  if_ae	jmp	#LR__0988
06134     01 AC 56 F2 | 	cmps	local04, #1 wc
06138     01 AC 86 F1 | 	sub	local04, #1
0613c     2C 00 90 CD |  if_b	jmp	#LR__0988
06140     57 C3 02 FD | 	qmul	local15, local05
06144     60 BF 02 F6 | 	mov	local13, local14
06148     17 BE 46 F0 | 	shr	local13, #23
0614c     17 C1 06 F4 | 	bitl	local14, #279
06150     18 C2 62 FD | 	getqx	local15
06154     57 C5 02 FD | 	qmul	local16, local05
06158     18 C4 62 FD | 	getqx	local16
0615c     57 C1 02 FD | 	qmul	local14, local05
06160     5F C3 02 F1 | 	add	local15, local13
06164     18 C0 62 FD | 	getqx	local14
06168     BC FF 9F FD | 	jmp	#LR__0986
0616c                 | LR__0987
0616c                 | LR__0988
0616c     57 B7 02 F6 | 	mov	local09, local05
06170     17 B6 66 F0 | 	shl	local09, #23
06174     5B BF 52 F6 | 	abs	local13, local09 wc
06178     01 BE 46 F0 | 	shr	local13, #1
0617c     5F BF 82 F6 | 	negc	local13, local13
06180     5F C1 1A F2 | 	cmp	local14, local13 wcz
06184     20 00 90 1D |  if_a	jmp	#LR__0989
06188     17 AE 66 F0 | 	shl	local05, #23
0618c     57 BF 52 F6 | 	abs	local13, local05 wc
06190     01 BE 46 F0 | 	shr	local13, #1
06194     5F BF 82 F6 | 	negc	local13, local13
06198     5F C1 0A F2 | 	cmp	local14, local13 wz
0619c     14 00 90 5D |  if_ne	jmp	#LR__0990
061a0     01 C2 CE F7 | 	test	local15, #1 wz
061a4     0C 00 90 AD |  if_e	jmp	#LR__0990
061a8                 | LR__0989
061a8     01 C2 06 F1 | 	add	local15, #1
061ac     62 C3 0A F2 | 	cmp	local15, local16 wz
061b0     01 B8 06 A1 |  if_e	add	local10, #1
061b4                 | LR__0990
061b4                 | LR__0991
061b4     54 C3 62 FC | 	wrlong	local15, local02
061b8     55 B9 62 FC | 	wrlong	local10, local03
061bc                 | LR__0992
061bc     E7 F0 03 F6 | 	mov	ptra, fp
061c0     F2 00 A0 FD | 	call	#popregs_
061c4                 | __system__disassemble_0093_ret
061c4     2D 00 64 FD | 	ret
061c8                 | 
061c8                 | __system__emitsign_0095
061c8     00 76 06 F6 | 	mov	result1, #0
061cc     00 92 0E F2 | 	cmp	arg02, #0 wz
061d0     48 7D 02 56 |  if_ne	mov	_var01, arg01
061d4     01 90 06 51 |  if_ne	add	arg01, #1
061d8     3E 93 42 5C |  if_ne	wrbyte	arg02, _var01
061dc     01 76 06 56 |  if_ne	mov	result1, #1
061e0     00 94 0E F2 | 	cmp	arg03, #0 wz
061e4     48 61 48 5C |  if_ne	wrbyte	#48, arg01
061e8     01 90 06 51 |  if_ne	add	arg01, #1
061ec     48 95 42 5C |  if_ne	wrbyte	arg03, arg01
061f0     02 76 06 51 |  if_ne	add	result1, #2
061f4                 | __system__emitsign_0095_ret
061f4     2D 00 64 FD | 	ret
061f8                 | 
061f8                 | __system___getiolock_0133
061f8     01 CA 05 F6 | 	mov	COUNT_, #1
061fc     E8 00 A0 FD | 	call	#pushregs_
06200     90 F8 BF FD | 	call	#__system____getftab
06204     3B A7 0A F6 | 	mov	local01, result1 wz
06208     10 00 90 AD |  if_e	jmp	#LR__1000
0620c     08 A6 06 F1 | 	add	local01, #8
06210     53 77 0A FB | 	rdlong	result1, local01 wz
06214     08 A6 86 F1 | 	sub	local01, #8
06218     10 00 90 5D |  if_ne	jmp	#LR__1001
0621c                 | LR__1000
0621c     33 77 02 F6 | 	mov	result1, ptr___system__dat__
06220     01 00 00 FF 
06224     DC 76 06 F1 | 	add	result1, ##732
06228     08 00 90 FD | 	jmp	#LR__1002
0622c                 | LR__1001
0622c     0C A6 06 F1 | 	add	local01, #12
06230     53 77 02 F6 | 	mov	result1, local01
06234                 | LR__1002
06234     E7 F0 03 F6 | 	mov	ptra, fp
06238     F2 00 A0 FD | 	call	#popregs_
0623c                 | __system___getiolock_0133_ret
0623c     2D 00 64 FD | 	ret
06240                 | 
06240                 | __system___gettxfunc
06240     01 CA 05 F6 | 	mov	COUNT_, #1
06244     E8 00 A0 FD | 	call	#pushregs_
06248     48 F8 BF FD | 	call	#__system____getftab
0624c     3B A7 0A F6 | 	mov	local01, result1 wz
06250     10 00 90 AD |  if_e	jmp	#LR__1010
06254     08 A6 06 F1 | 	add	local01, #8
06258     53 93 0A FB | 	rdlong	arg02, local01 wz
0625c     08 A6 86 F1 | 	sub	local01, #8
06260     08 00 90 5D |  if_ne	jmp	#LR__1011
06264                 | LR__1010
06264     00 76 06 F6 | 	mov	result1, #0
06268     0C 00 90 FD | 	jmp	#LR__1012
0626c                 | LR__1011
0626c     00 28 00 FF 
06270     00 A6 46 F5 | 	or	local01, ##5242880
06274     53 77 02 F6 | 	mov	result1, local01
06278                 | LR__1012
06278     E7 F0 03 F6 | 	mov	ptra, fp
0627c     F2 00 A0 FD | 	call	#popregs_
06280                 | __system___gettxfunc_ret
06280     2D 00 64 FD | 	ret
06284                 | 
06284                 | __system__pack_0176
06284     48 7D 02 F6 | 	mov	_var01, arg01
06288     7F 94 06 F1 | 	add	arg03, #127
0628c     04 96 CE F7 | 	test	arg04, #4 wz
06290     10 00 90 AD |  if_e	jmp	#LR__1020
06294     00 7C 0E F2 | 	cmp	_var01, #0 wz
06298     16 7C C6 A9 |  if_e	decod	_var01, #22
0629c     F7 7C 26 F4 | 	bith	_var01, #247
062a0     B4 00 90 FD | 	jmp	#LR__1029
062a4                 | LR__1020
062a4     02 96 CE F7 | 	test	arg04, #2 wz
062a8     00 C0 3F 5F 
062ac     00 7C 06 56 |  if_ne	mov	_var01, ##2139095040
062b0     00 92 06 56 |  if_ne	mov	arg02, #0
062b4     A0 00 90 5D |  if_ne	jmp	#LR__1028
062b8     08 96 CE F7 | 	test	arg04, #8 wz
062bc     00 7C 06 56 |  if_ne	mov	_var01, #0
062c0     94 00 90 5D |  if_ne	jmp	#LR__1027
062c4     FF 94 56 F2 | 	cmps	arg03, #255 wc
062c8     00 C0 3F 3F 
062cc     00 7C 06 36 |  if_ae	mov	_var01, ##2139095040
062d0     00 92 06 36 |  if_ae	mov	arg02, #0
062d4     80 00 90 3D |  if_ae	jmp	#LR__1026
062d8     01 94 56 F2 | 	cmps	arg03, #1 wc
062dc     6C 00 90 3D |  if_ae	jmp	#LR__1024
062e0     01 92 46 F0 | 	shr	arg02, #1
062e4     3E 7F 02 F6 | 	mov	_var02, _var01
062e8     01 7E 06 F5 | 	and	_var02, #1
062ec     1F 7E 66 F0 | 	shl	_var02, #31
062f0     3F 93 42 F5 | 	or	arg02, _var02
062f4     01 7C 46 F0 | 	shr	_var01, #1
062f8     D7 1E 48 FB | 	callpa	#(@LR__1022-@LR__1021)>>2,fcache_load_ptr_
062fc                 | LR__1021
062fc     00 94 56 F2 | 	cmps	arg03, #0 wc
06300     34 00 90 3D |  if_ae	jmp	#LR__1023
06304     00 7C 0E F2 | 	cmp	_var01, #0 wz
06308     2C 00 90 AD |  if_e	jmp	#LR__1023
0630c     49 91 02 F6 | 	mov	arg01, arg02
06310     01 90 06 F5 | 	and	arg01, #1
06314     01 94 06 F1 | 	add	arg03, #1
06318     01 92 46 F0 | 	shr	arg02, #1
0631c     3E 7F 02 F6 | 	mov	_var02, _var01
06320     01 7E 06 F5 | 	and	_var02, #1
06324     1F 7E 66 F0 | 	shl	_var02, #31
06328     3F 93 42 F5 | 	or	arg02, _var02
0632c     48 93 42 F5 | 	or	arg02, arg01
06330     01 7C 46 F0 | 	shr	_var01, #1
06334     C4 FF 9F FD | 	jmp	#LR__1021
06338                 | LR__1022
06338                 | LR__1023
06338     00 94 56 F2 | 	cmps	arg03, #0 wc
0633c     18 00 90 3D |  if_ae	jmp	#LR__1025
06340     00 92 0E F2 | 	cmp	arg02, #0 wz
06344     6F 92 62 FD | 	wrnz	arg02
06348     0C 00 90 FD | 	jmp	#LR__1025
0634c                 | LR__1024
0634c     17 7D 06 F4 | 	bitl	_var01, #279
06350     17 94 66 F0 | 	shl	arg03, #23
06354     4A 7D 42 F5 | 	or	_var01, arg03
06358                 | LR__1025
06358                 | LR__1026
06358                 | LR__1027
06358                 | LR__1028
06358                 | LR__1029
06358     01 7C CE F7 | 	test	_var01, #1 wz
0635c     01 92 46 55 |  if_ne	or	arg02, #1
06360     49 95 02 F6 | 	mov	arg03, arg02
06364     00 7E 06 F6 | 	mov	_var02, #0
06368     FF FF 3F FF 
0636c     FF 93 06 F1 | 	add	arg02, ##2147483647
06370     4A 93 12 F2 | 	cmp	arg02, arg03 wc
06374     01 7E 06 C6 |  if_b	mov	_var02, #1
06378     3F 7D 02 F1 | 	add	_var01, _var02
0637c     01 96 CE F7 | 	test	arg04, #1 wz
06380     1F 7C 26 54 |  if_ne	bith	_var01, #31
06384     3E 77 02 F6 | 	mov	result1, _var01
06388                 | __system__pack_0176_ret
06388     2D 00 64 FD | 	ret
0638c                 | 
0638c                 | __system___rxtxioctl_0227
0638c     00 93 0E F2 | 	cmp	arg02, #256 wz
06390     0C 00 90 AD |  if_e	jmp	#LR__1030
06394     01 93 0E F2 | 	cmp	arg02, #257 wz
06398     1C 00 90 AD |  if_e	jmp	#LR__1031
0639c     30 00 90 FD | 	jmp	#LR__1032
063a0                 | LR__1030
063a0     08 66 06 F1 | 	add	ptr___system__dat__, #8
063a4     33 77 02 FB | 	rdlong	result1, ptr___system__dat__
063a8     08 66 86 F1 | 	sub	ptr___system__dat__, #8
063ac     4A 77 62 FC | 	wrlong	result1, arg03
063b0     00 76 06 F6 | 	mov	result1, #0
063b4     28 00 90 FD | 	jmp	#LR__1033
063b8                 | LR__1031
063b8     4A 91 02 FB | 	rdlong	arg01, arg03
063bc     08 66 06 F1 | 	add	ptr___system__dat__, #8
063c0     33 91 62 FC | 	wrlong	arg01, ptr___system__dat__
063c4     08 66 86 F1 | 	sub	ptr___system__dat__, #8
063c8     00 76 06 F6 | 	mov	result1, #0
063cc     10 00 90 FD | 	jmp	#LR__1033
063d0                 | LR__1032
063d0     20 66 06 F1 | 	add	ptr___system__dat__, #32
063d4     33 15 68 FC | 	wrlong	#10, ptr___system__dat__
063d8     20 66 86 F1 | 	sub	ptr___system__dat__, #32
063dc     01 76 66 F6 | 	neg	result1, #1
063e0                 | LR__1033
063e0                 | __system___rxtxioctl_0227_ret
063e0     2D 00 64 FD | 	ret
063e4                 | 
063e4                 | __system____dummy_flush_0228
063e4     00 76 06 F6 | 	mov	result1, #0
063e8                 | __system____dummy_flush_0228_ret
063e8     2D 00 64 FD | 	ret
063ec                 | 
063ec                 | __system___sdmm_open
063ec     0B CA 05 F6 | 	mov	COUNT_, #11
063f0     E8 00 A0 FD | 	call	#pushregs_
063f4     48 AB 02 F6 | 	mov	local03, arg01
063f8     49 AD 02 F6 | 	mov	local04, arg02
063fc     4A AF 02 F6 | 	mov	local05, arg03
06400     4B B1 02 F6 | 	mov	local06, arg04
06404     28 90 06 F6 | 	mov	arg01, #40
06408     CC EA BF FD | 	call	#__system___gc_alloc_managed
0640c     3B B3 02 F6 | 	mov	local07, result1
06410     55 97 02 F6 | 	mov	arg04, local03
06414     1F 96 C6 F0 | 	sar	arg04, #31
06418     55 95 02 F6 | 	mov	arg03, local03
0641c     01 90 06 F6 | 	mov	arg01, #1
06420     00 92 06 F6 | 	mov	arg02, #0
06424     B8 DC BF FD | 	call	#__system___int64_shl
06428     3B A7 02 F6 | 	mov	local01, result1
0642c     3C B5 02 F6 | 	mov	local08, result2
06430     56 97 02 F6 | 	mov	arg04, local04
06434     1F 96 C6 F0 | 	sar	arg04, #31
06438     56 95 02 F6 | 	mov	arg03, local04
0643c     01 90 06 F6 | 	mov	arg01, #1
06440     00 92 06 F6 | 	mov	arg02, #0
06444     98 DC BF FD | 	call	#__system___int64_shl
06448     3B A7 42 F5 | 	or	local01, result1
0644c     3C B5 42 F5 | 	or	local08, result2
06450     57 97 02 F6 | 	mov	arg04, local05
06454     1F 96 C6 F0 | 	sar	arg04, #31
06458     57 95 02 F6 | 	mov	arg03, local05
0645c     01 90 06 F6 | 	mov	arg01, #1
06460     00 92 06 F6 | 	mov	arg02, #0
06464     78 DC BF FD | 	call	#__system___int64_shl
06468     3B A7 42 F5 | 	or	local01, result1
0646c     3C B5 42 F5 | 	or	local08, result2
06470     58 97 02 F6 | 	mov	arg04, local06
06474     1F 96 C6 F0 | 	sar	arg04, #31
06478     58 95 02 F6 | 	mov	arg03, local06
0647c     01 90 06 F6 | 	mov	arg01, #1
06480     00 92 06 F6 | 	mov	arg02, #0
06484     58 DC BF FD | 	call	#__system___int64_shl
06488     5A 93 02 F6 | 	mov	arg02, local08
0648c     3B A7 42 F5 | 	or	local01, result1
06490     49 79 42 F5 | 	or	result2, arg02
06494     3C A9 02 F6 | 	mov	local02, result2
06498     53 91 02 F6 | 	mov	arg01, local01
0649c     54 93 02 F6 | 	mov	arg02, local02
064a0     AC DC BF FD | 	call	#__system___usepins
064a4     00 76 0E F2 | 	cmp	result1, #0 wz
064a8     1C 00 90 5D |  if_ne	jmp	#LR__1040
064ac     59 91 02 F6 | 	mov	arg01, local07
064b0     58 EB BF FD | 	call	#__system___gc_free
064b4     20 66 06 F1 | 	add	ptr___system__dat__, #32
064b8     33 2D 68 FC | 	wrlong	#22, ptr___system__dat__
064bc     20 66 86 F1 | 	sub	ptr___system__dat__, #32
064c0     00 76 06 F6 | 	mov	result1, #0
064c4     5C 01 90 FD | 	jmp	#LR__1043
064c8                 | LR__1040
064c8     53 B7 02 F6 | 	mov	local09, local01
064cc     54 99 02 F6 | 	mov	arg05, local02
064d0     20 B2 06 F1 | 	add	local07, #32
064d4     59 B7 62 FC | 	wrlong	local09, local07
064d8     04 B2 06 F1 | 	add	local07, #4
064dc     59 99 62 FC | 	wrlong	arg05, local07
064e0     24 B2 86 F1 | 	sub	local07, #36
064e4     57 97 02 F6 | 	mov	arg04, local05
064e8     58 99 02 F6 | 	mov	arg05, local06
064ec     00 90 06 F6 | 	mov	arg01, #0
064f0     55 93 02 F6 | 	mov	arg02, local03
064f4     56 95 02 F6 | 	mov	arg03, local04
064f8     31 B9 02 F6 | 	mov	local10, objptr
064fc     59 63 02 F6 | 	mov	objptr, local07
06500     C8 0D B0 FD | 	call	#_sdmm_cc_disk_setpins
06504     5C 63 02 F6 | 	mov	objptr, local10
06508     3B BB 0A F6 | 	mov	local11, result1 wz
0650c     18 00 90 5D |  if_ne	jmp	#LR__1041
06510     00 90 06 F6 | 	mov	arg01, #0
06514     31 BB 02 F6 | 	mov	local11, objptr
06518     59 63 02 F6 | 	mov	objptr, local07
0651c     E0 01 B0 FD | 	call	#_sdmm_cc_disk_initialize
06520     5D 63 02 F6 | 	mov	objptr, local11
06524     3B BB E2 F8 | 	getbyte	local11, result1, #0
06528                 | LR__1041
06528     00 BA 0E F2 | 	cmp	local11, #0 wz
0652c     D0 00 90 5D |  if_ne	jmp	#LR__1042
06530     A8 EF BF FD | 	call	#__system___get_vfs_file_handle
06534     3B BB 0A F6 | 	mov	local11, result1 wz
06538     C4 00 90 AD |  if_e	jmp	#LR__1042
0653c     04 BA 06 F1 | 	add	local11, #4
06540     5D 05 58 FC | 	wrword	#2, local11
06544     02 BA 06 F1 | 	add	local11, #2
06548     5D 01 58 FC | 	wrword	#0, local11
0654c     02 BA 06 F1 | 	add	local11, #2
06550     40 00 80 FF 
06554     5D 07 68 FC | 	wrlong	##32771, local11
06558     59 77 02 F6 | 	mov	result1, local07
0655c     00 08 01 FF 
06560     00 76 46 F5 | 	or	result1, ##34603008
06564     0C BA 06 F1 | 	add	local11, #12
06568     5D 77 62 FC | 	wrlong	result1, local11
0656c     59 77 02 F6 | 	mov	result1, local07
06570     00 10 01 FF 
06574     00 76 46 F5 | 	or	result1, ##35651584
06578     04 BA 06 F1 | 	add	local11, #4
0657c     5D 77 62 FC | 	wrlong	result1, local11
06580     59 77 02 F6 | 	mov	result1, local07
06584     00 18 01 FF 
06588     00 76 46 F5 | 	or	result1, ##36700160
0658c     0C BA 06 F1 | 	add	local11, #12
06590     5D 77 62 FC | 	wrlong	result1, local11
06594     59 77 02 F6 | 	mov	result1, local07
06598     00 20 01 FF 
0659c     00 76 46 F5 | 	or	result1, ##37748736
065a0     04 BA 06 F1 | 	add	local11, #4
065a4     5D 77 62 FC | 	wrlong	result1, local11
065a8     59 77 02 F6 | 	mov	result1, local07
065ac     00 28 01 FF 
065b0     00 76 46 F5 | 	or	result1, ##38797312
065b4     04 BA 06 F1 | 	add	local11, #4
065b8     5D 77 62 FC | 	wrlong	result1, local11
065bc     59 77 02 F6 | 	mov	result1, local07
065c0     00 30 01 FF 
065c4     00 76 46 F5 | 	or	result1, ##39845888
065c8     04 BA 06 F1 | 	add	local11, #4
065cc     5D 77 62 FC | 	wrlong	result1, local11
065d0     59 77 02 F6 | 	mov	result1, local07
065d4     00 38 01 FF 
065d8     00 76 46 F5 | 	or	result1, ##40894464
065dc     14 BA 86 F1 | 	sub	local11, #20
065e0     5D 77 62 FC | 	wrlong	result1, local11
065e4     00 40 01 FF 
065e8     00 B2 46 F5 | 	or	local07, ##41943040
065ec     04 BA 06 F1 | 	add	local11, #4
065f0     5D B3 62 FC | 	wrlong	local07, local11
065f4     20 BA 86 F1 | 	sub	local11, #32
065f8     5D 77 02 F6 | 	mov	result1, local11
065fc     24 00 90 FD | 	jmp	#LR__1043
06600                 | LR__1042
06600     53 91 02 F6 | 	mov	arg01, local01
06604     54 93 02 F6 | 	mov	arg02, local02
06608     98 DB BF FD | 	call	#__system___freepins
0660c     59 91 02 F6 | 	mov	arg01, local07
06610     F8 E9 BF FD | 	call	#__system___gc_free
06614     20 66 06 F1 | 	add	ptr___system__dat__, #32
06618     33 19 68 FC | 	wrlong	#12, ptr___system__dat__
0661c     20 66 86 F1 | 	sub	ptr___system__dat__, #32
06620     00 76 06 F6 | 	mov	result1, #0
06624                 | LR__1043
06624     E7 F0 03 F6 | 	mov	ptra, fp
06628     F2 00 A0 FD | 	call	#popregs_
0662c                 | __system___sdmm_open_ret
0662c     2D 00 64 FD | 	ret
06630                 | 
06630                 | __system____default_filbuf
06630     05 CA 05 F6 | 	mov	COUNT_, #5
06634     E8 00 A0 FD | 	call	#pushregs_
06638     48 A7 02 F6 | 	mov	local01, arg01
0663c     53 A9 02 FB | 	rdlong	local02, local01
06640     08 A8 06 F1 | 	add	local02, #8
06644     54 77 0A FB | 	rdlong	result1, local02 wz
06648     08 A8 86 F1 | 	sub	local02, #8
0664c     20 00 90 5D |  if_ne	jmp	#LR__1050
06650     10 A8 06 F1 | 	add	local02, #16
06654     54 77 02 F6 | 	mov	result1, local02
06658     04 A8 86 F1 | 	sub	local02, #4
0665c     54 77 62 FC | 	wrlong	result1, local02
06660     04 A8 86 F1 | 	sub	local02, #4
06664     02 00 80 FF 
06668     54 01 68 FC | 	wrlong	##1024, local02
0666c     08 A8 86 F1 | 	sub	local02, #8
06670                 | LR__1050
06670     14 A6 06 F1 | 	add	local01, #20
06674     53 AB 02 FB | 	rdlong	local03, local01
06678     55 AD 02 F6 | 	mov	local04, local03
0667c     14 A6 86 F1 | 	sub	local01, #20
06680     13 AC 46 F7 | 	zerox	local04, #19
06684     14 AA 46 F0 | 	shr	local03, #20
06688     02 AA 66 F0 | 	shl	local03, #2
0668c     2D AB 02 F1 | 	add	local03, __methods__
06690     55 AB 02 FB | 	rdlong	local03, local03
06694     53 91 02 F6 | 	mov	arg01, local01
06698     0C A8 06 F1 | 	add	local02, #12
0669c     54 93 02 FB | 	rdlong	arg02, local02
066a0     04 A8 86 F1 | 	sub	local02, #4
066a4     54 95 02 FB | 	rdlong	arg03, local02
066a8     08 A8 86 F1 | 	sub	local02, #8
066ac     31 AF 02 F6 | 	mov	local05, objptr
066b0     56 63 02 F6 | 	mov	objptr, local04
066b4     2D AA 62 FD | 	call	local03
066b8     57 63 02 F6 | 	mov	objptr, local05
066bc     3B AF 02 F6 | 	mov	local05, result1
066c0     00 AE 56 F2 | 	cmps	local05, #0 wc
066c4     01 76 66 C6 |  if_b	neg	result1, #1
066c8     28 00 90 CD |  if_b	jmp	#LR__1051
066cc     54 AF 62 FC | 	wrlong	local05, local02
066d0     0C A8 06 F1 | 	add	local02, #12
066d4     54 AB 02 FB | 	rdlong	local03, local02
066d8     08 A8 86 F1 | 	sub	local02, #8
066dc     54 AB 62 FC | 	wrlong	local03, local02
066e0     08 A6 06 F1 | 	add	local01, #8
066e4     53 AD 02 FB | 	rdlong	local04, local01
066e8     04 AC 46 F5 | 	or	local04, #4
066ec     53 AD 62 FC | 	wrlong	local04, local01
066f0     57 77 02 F6 | 	mov	result1, local05
066f4                 | LR__1051
066f4     E7 F0 03 F6 | 	mov	ptra, fp
066f8     F2 00 A0 FD | 	call	#popregs_
066fc                 | __system____default_filbuf_ret
066fc     2D 00 64 FD | 	ret
06700                 | 
06700                 | _sdmm_cc_disk_initialize
06700     0F CA 05 F6 | 	mov	COUNT_, #15
06704     E8 00 A0 FD | 	call	#pushregs_
06708     48 A7 0A F6 | 	mov	local01, arg01 wz
0670c     F8 A9 02 F6 | 	mov	local02, ptra
06710     31 AB 02 FB | 	rdlong	local03, objptr
06714     04 62 06 F1 | 	add	objptr, #4
06718     31 AD 02 FB | 	rdlong	local04, objptr
0671c     04 62 06 F1 | 	add	objptr, #4
06720     31 AF 02 FB | 	rdlong	local05, objptr
06724     04 62 06 F1 | 	add	objptr, #4
06728     31 B1 02 FB | 	rdlong	local06, objptr
0672c     08 62 06 F1 | 	add	objptr, #8
06730     31 03 48 FC | 	wrbyte	#1, objptr
06734     14 62 86 F1 | 	sub	objptr, #20
06738                 | ' #line 539 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
06738                 | ' 		return RES_NOTRDY;
06738     0C F0 07 F1 | 	add	ptra, #12
0673c     03 76 06 56 |  if_ne	mov	result1, #3
06740     68 04 90 5D |  if_ne	jmp	#LR__1080
06744     13 00 00 FF 
06748     10 91 06 F6 | 	mov	arg01, ##10000
0674c     B8 C7 BF FD | 	call	#__system___waitus
06750     55 97 02 F6 | 	mov	arg04, local03
06754     57 97 82 F1 | 	sub	arg04, local05
06758     4B 97 42 F6 | 	abs	arg04, arg04
0675c     04 96 56 F2 | 	cmps	arg04, #4 wc
06760     04 76 06 36 |  if_ae	mov	result1, #4
06764     44 04 90 3D |  if_ae	jmp	#LR__1080
06768     55 B3 02 F6 | 	mov	local07, local03
0676c     58 B3 82 F1 | 	sub	local07, local06
06770     59 B3 42 F6 | 	abs	local07, local07
06774     04 B2 56 F2 | 	cmps	local07, #4 wc
06778     34 00 90 3D |  if_ae	jmp	#LR__1060
0677c     55 B5 02 F6 | 	mov	local08, local03
06780     58 B5 82 F1 | 	sub	local08, local06
06784     07 B4 06 F5 | 	and	local08, #7
06788     18 B4 66 F0 | 	shl	local08, #24
0678c     29 00 00 FF 
06790     7A B4 46 F5 | 	or	local08, ##21114
06794     58 B7 02 F6 | 	mov	local09, local06
06798     0C 62 06 F1 | 	add	objptr, #12
0679c     31 B7 62 FC | 	wrlong	local09, objptr
067a0     04 62 06 F1 | 	add	objptr, #4
067a4     31 B7 62 FC | 	wrlong	local09, objptr
067a8     10 62 86 F1 | 	sub	objptr, #16
067ac     A4 00 90 FD | 	jmp	#LR__1063
067b0                 | LR__1060
067b0     58 AB 5A F2 | 	cmps	local03, local06 wcz
067b4     28 00 90 ED |  if_be	jmp	#LR__1061
067b8     55 B7 02 F6 | 	mov	local09, local03
067bc     03 B6 86 F1 | 	sub	local09, #3
067c0     57 B7 0A F2 | 	cmp	local09, local05 wz
067c4     56 B7 0A 52 |  if_ne	cmp	local09, local04 wz
067c8     01 B6 06 A1 |  if_e	add	local09, #1
067cc     57 B7 0A F2 | 	cmp	local09, local05 wz
067d0     56 B7 0A 52 |  if_ne	cmp	local09, local04 wz
067d4     28 00 90 5D |  if_ne	jmp	#LR__1062
067d8     01 B6 06 F1 | 	add	local09, #1
067dc     20 00 90 FD | 	jmp	#LR__1062
067e0                 | LR__1061
067e0     55 B7 02 F6 | 	mov	local09, local03
067e4     03 B6 06 F1 | 	add	local09, #3
067e8     57 B7 0A F2 | 	cmp	local09, local05 wz
067ec     56 B7 0A 52 |  if_ne	cmp	local09, local04 wz
067f0     01 B6 86 A1 |  if_e	sub	local09, #1
067f4     57 B7 0A F2 | 	cmp	local09, local05 wz
067f8     56 B7 0A 52 |  if_ne	cmp	local09, local04 wz
067fc     01 B6 86 A1 |  if_e	sub	local09, #1
06800                 | LR__1062
06800     58 B3 02 F6 | 	mov	local07, local06
06804     5B B3 82 F1 | 	sub	local07, local09
06808     59 B3 42 F6 | 	abs	local07, local07
0680c     04 B2 56 F2 | 	cmps	local07, #4 wc
06810     04 76 06 36 |  if_ae	mov	result1, #4
06814     94 03 90 3D |  if_ae	jmp	#LR__1080
06818     58 B5 02 F6 | 	mov	local08, local06
0681c     5B B5 82 F1 | 	sub	local08, local09
06820     07 B4 06 F5 | 	and	local08, #7
06824     1C B4 66 F0 | 	shl	local08, #28
06828     55 B3 02 F6 | 	mov	local07, local03
0682c     5B B3 82 F1 | 	sub	local07, local09
06830     07 B2 06 F5 | 	and	local07, #7
06834     18 B2 66 F0 | 	shl	local07, #24
06838     59 B5 42 F5 | 	or	local08, local07
0683c     3A B4 46 F5 | 	or	local08, #58
06840     10 62 06 F1 | 	add	objptr, #16
06844     31 B1 62 FC | 	wrlong	local06, objptr
06848     04 62 86 F1 | 	sub	objptr, #4
0684c     31 B7 62 FC | 	wrlong	local09, objptr
06850     0C 62 86 F1 | 	sub	objptr, #12
06854                 | LR__1063
06854     56 01 08 FC | 	wrpin	#0, local04
06858     59 AC 62 FD | 	drvh	local04
0685c     00 08 00 FF 
06860     20 B8 06 F6 | 	mov	local10, ##1048608
06864     40 AA 62 FD | 	dirl	local03
06868     A0 03 80 FF 
0686c     55 91 08 FC | 	wrpin	##475208, local03
06870     00 08 80 FF 
06874     55 41 18 FC | 	wxpin	##1048608, local03
06878     55 01 28 FC | 	wypin	#0, local03
0687c     41 AA 62 FD | 	dirh	local03
06880     55 B3 02 F6 | 	mov	local07, local03
06884     57 B3 82 F1 | 	sub	local07, local05
06888     07 B2 06 F5 | 	and	local07, #7
0688c     18 B2 66 F0 | 	shl	local07, #24
06890     78 BA 06 F6 | 	mov	local11, #120
06894     59 BB 42 F5 | 	or	local11, local07
06898     5D 93 02 F6 | 	mov	arg02, local11
0689c     10 92 26 F4 | 	bith	arg02, #16
068a0     40 AE 62 FD | 	dirl	local05
068a4     57 93 02 FC | 	wrpin	arg02, local05
068a8     57 3F 18 FC | 	wxpin	#31, local05
068ac     FF FF FF FF 
068b0     57 FF 2B FC | 	wypin	##-1, local05
068b4     41 AE 62 FD | 	dirh	local05
068b8     29 00 80 FF 
068bc     58 01 08 FC | 	wrpin	##20992, local06
068c0     40 B6 62 FD | 	dirl	local09
068c4     5B B5 02 FC | 	wrpin	local08, local09
068c8     5B 4F 18 FC | 	wxpin	#39, local09
068cc     5B 01 28 FC | 	wypin	#0, local09
068d0     41 B6 62 FD | 	dirh	local09
068d4     54 91 02 F6 | 	mov	arg01, local02
068d8     0A 92 06 F6 | 	mov	arg02, #10
068dc     5C 06 B0 FD | 	call	#_sdmm_cc_rcvr_mmc_0287
068e0     00 90 06 F6 | 	mov	arg01, #0
068e4     00 92 06 F6 | 	mov	arg02, #0
068e8     D4 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
068ec     20 07 B0 FD | 	call	#_sdmm_cc_deselect_0297
068f0     64 90 06 F6 | 	mov	arg01, #100
068f4     10 C6 BF FD | 	call	#__system___waitus
068f8     54 91 02 F6 | 	mov	arg01, local02
068fc     0A 92 06 F6 | 	mov	arg02, #10
06900     38 06 B0 FD | 	call	#_sdmm_cc_rcvr_mmc_0287
06904     00 BC 06 F6 | 	mov	local12, #0
06908     00 90 06 F6 | 	mov	arg01, #0
0690c     00 92 06 F6 | 	mov	arg02, #0
06910     AC 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06914     3B B3 E2 F8 | 	getbyte	local07, result1, #0
06918     01 B2 0E F2 | 	cmp	local07, #1 wz
0691c     5C 02 90 5D |  if_ne	jmp	#LR__1079
06920     08 90 06 F6 | 	mov	arg01, #8
06924     AA 93 06 F6 | 	mov	arg02, #426
06928     94 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
0692c     3B 77 E2 F8 | 	getbyte	result1, result1, #0
06930     01 76 0E F2 | 	cmp	result1, #1 wz
06934     30 01 90 5D |  if_ne	jmp	#LR__1068
06938     54 91 02 F6 | 	mov	arg01, local02
0693c     04 92 06 F6 | 	mov	arg02, #4
06940     F8 05 B0 FD | 	call	#_sdmm_cc_rcvr_mmc_0287
06944     02 A8 06 F1 | 	add	local02, #2
06948     54 B3 C2 FA | 	rdbyte	local07, local02
0694c     02 A8 86 F1 | 	sub	local02, #2
06950     01 B2 0E F2 | 	cmp	local07, #1 wz
06954     03 A8 06 A1 |  if_e	add	local02, #3
06958     54 BF C2 AA |  if_e	rdbyte	local13, local02
0695c     03 A8 86 A1 |  if_e	sub	local02, #3
06960     AA BE 0E A2 |  if_e	cmp	local13, #170 wz
06964     14 02 90 5D |  if_ne	jmp	#LR__1078
06968                 | ' 				for (tmr = 1000; tmr; tmr--) {
06968     01 00 00 FF 
0696c     E8 C1 06 F6 | 	mov	local14, ##1000
06970                 | LR__1064
06970     A9 90 06 F6 | 	mov	arg01, #169
06974     1E 92 C6 F9 | 	decod	arg02, #30
06978     44 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
0697c     3B B3 02 F6 | 	mov	local07, result1
06980     07 B2 4E F7 | 	zerox	local07, #7 wz
06984     18 00 90 AD |  if_e	jmp	#LR__1065
06988     01 00 00 FF 
0698c     E8 91 06 F6 | 	mov	arg01, ##1000
06990     74 C5 BF FD | 	call	#__system___waitus
06994     60 B3 02 F6 | 	mov	local07, local14
06998     01 C0 8E F1 | 	sub	local14, #1 wz
0699c     D0 FF 9F 5D |  if_ne	jmp	#LR__1064
069a0                 | LR__1065
069a0     00 C0 0E F2 | 	cmp	local14, #0 wz
069a4     38 00 90 AD |  if_e	jmp	#LR__1066
069a8     3A 90 06 F6 | 	mov	arg01, #58
069ac     00 92 06 F6 | 	mov	arg02, #0
069b0     0C 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
069b4     3B B3 02 F6 | 	mov	local07, result1
069b8     07 B2 4E F7 | 	zerox	local07, #7 wz
069bc     20 00 90 5D |  if_ne	jmp	#LR__1066
069c0     54 91 02 F6 | 	mov	arg01, local02
069c4     04 92 06 F6 | 	mov	arg02, #4
069c8     70 05 B0 FD | 	call	#_sdmm_cc_rcvr_mmc_0287
069cc     54 C1 C2 FA | 	rdbyte	local14, local02
069d0     40 C0 CE F7 | 	test	local14, #64 wz
069d4     0C B2 06 56 |  if_ne	mov	local07, #12
069d8     04 B2 06 A6 |  if_e	mov	local07, #4
069dc     59 BD 02 F6 | 	mov	local12, local07
069e0                 | LR__1066
069e0     14 C0 06 FB | 	rdlong	local14, #20
069e4     F0 FA 02 FF 
069e8     01 C1 16 F2 | 	cmp	local14, ##100000001 wc
069ec     5D B3 02 C6 |  if_b	mov	local07, local11
069f0     1B B2 26 C4 |  if_b	bith	local07, #27
069f4     59 BB 02 C6 |  if_b	mov	local11, local07
069f8     10 00 90 CD |  if_b	jmp	#LR__1067
069fc     E1 F5 05 FF 
06a00     01 C0 16 F2 | 	cmp	local14, ##200000001 wc
06a04     80 00 04 CF 
06a08     00 BA 46 C5 |  if_b	or	local11, ##134283264
06a0c                 | LR__1067
06a0c     F0 FA 02 FF 
06a10     01 C1 16 F2 | 	cmp	local14, ##100000001 wc
06a14     00 01 00 CF 
06a18     04 B8 06 C6 |  if_b	mov	local10, ##131076
06a1c     5C 01 90 CD |  if_b	jmp	#LR__1078
06a20     68 78 04 FF 
06a24     81 C1 16 F2 | 	cmp	local14, ##150000001 wc
06a28     80 01 00 CF 
06a2c     06 B8 06 C6 |  if_b	mov	local10, ##196614
06a30     48 01 90 CD |  if_b	jmp	#LR__1078
06a34     E1 F5 05 FF 
06a38     01 C0 16 F2 | 	cmp	local14, ##200000001 wc
06a3c     00 02 00 CF 
06a40     08 B8 06 C6 |  if_b	mov	local10, ##262152
06a44     34 01 90 CD |  if_b	jmp	#LR__1078
06a48     59 73 07 FF 
06a4c     81 C0 16 F2 | 	cmp	local14, ##250000001 wc
06a50     80 02 00 CF 
06a54     0A B8 06 C6 |  if_b	mov	local10, ##327690
06a58     20 01 90 CD |  if_b	jmp	#LR__1078
06a5c     00 03 00 FF 
06a60     0C B8 06 F6 | 	mov	local10, ##393228
06a64     14 01 90 FD | 	jmp	#LR__1078
06a68                 | LR__1068
06a68     A9 90 06 F6 | 	mov	arg01, #169
06a6c     00 92 06 F6 | 	mov	arg02, #0
06a70     4C 07 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06a74     3B B3 E2 F8 | 	getbyte	local07, result1, #0
06a78     02 B2 16 F2 | 	cmp	local07, #2 wc
06a7c     02 BC 06 C6 |  if_b	mov	local12, #2
06a80     A9 C2 06 C6 |  if_b	mov	local15, #169
06a84     01 BC 06 36 |  if_ae	mov	local12, #1
06a88     01 C2 06 36 |  if_ae	mov	local15, #1
06a8c                 | ' 				ty =  0x01 ; cmd =  (1) ;
06a8c                 | ' 			}
06a8c                 | ' 			for (tmr = 1000; tmr; tmr--) {
06a8c     01 00 00 FF 
06a90     E8 C1 06 F6 | 	mov	local14, ##1000
06a94                 | LR__1069
06a94     61 91 02 F6 | 	mov	arg01, local15
06a98     00 92 06 F6 | 	mov	arg02, #0
06a9c     20 07 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06aa0     3B B3 02 F6 | 	mov	local07, result1
06aa4     07 B2 4E F7 | 	zerox	local07, #7 wz
06aa8     18 00 90 AD |  if_e	jmp	#LR__1070
06aac     01 00 00 FF 
06ab0     E8 91 06 F6 | 	mov	arg01, ##1000
06ab4     50 C4 BF FD | 	call	#__system___waitus
06ab8     60 B3 02 F6 | 	mov	local07, local14
06abc     01 C0 8E F1 | 	sub	local14, #1 wz
06ac0     D0 FF 9F 5D |  if_ne	jmp	#LR__1069
06ac4                 | LR__1070
06ac4     00 C0 0E F2 | 	cmp	local14, #0 wz
06ac8     18 00 90 AD |  if_e	jmp	#LR__1071
06acc     10 90 06 F6 | 	mov	arg01, #16
06ad0     09 92 C6 F9 | 	decod	arg02, #9
06ad4     E8 06 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06ad8     3B B3 02 F6 | 	mov	local07, result1
06adc     07 B2 4E F7 | 	zerox	local07, #7 wz
06ae0     04 00 90 AD |  if_e	jmp	#LR__1072
06ae4                 | LR__1071
06ae4     00 BC 06 F6 | 	mov	local12, #0
06ae8                 | LR__1072
06ae8     14 C0 06 FB | 	rdlong	local14, #20
06aec     F0 FA 02 FF 
06af0     01 C1 16 F2 | 	cmp	local14, ##100000001 wc
06af4     5D B3 02 C6 |  if_b	mov	local07, local11
06af8     1B B2 26 C4 |  if_b	bith	local07, #27
06afc     59 BB 02 C6 |  if_b	mov	local11, local07
06b00     10 00 90 CD |  if_b	jmp	#LR__1073
06b04     E1 F5 05 FF 
06b08     01 C0 16 F2 | 	cmp	local14, ##200000001 wc
06b0c     80 00 04 CF 
06b10     00 BA 46 C5 |  if_b	or	local11, ##134283264
06b14                 | LR__1073
06b14     F0 FA 02 FF 
06b18     01 C1 16 F2 | 	cmp	local14, ##100000001 wc
06b1c     00 01 00 CF 
06b20     04 B8 06 C6 |  if_b	mov	local10, ##131076
06b24     54 00 90 CD |  if_b	jmp	#LR__1077
06b28     68 78 04 FF 
06b2c     81 C1 16 F2 | 	cmp	local14, ##150000001 wc
06b30     80 01 00 CF 
06b34     06 B8 06 C6 |  if_b	mov	local10, ##196614
06b38     40 00 90 CD |  if_b	jmp	#LR__1076
06b3c     E1 F5 05 FF 
06b40     01 C0 16 F2 | 	cmp	local14, ##200000001 wc
06b44     00 02 00 CF 
06b48     08 B8 06 C6 |  if_b	mov	local10, ##262152
06b4c     2C 00 90 CD |  if_b	jmp	#LR__1075
06b50     59 73 07 FF 
06b54     81 C0 16 F2 | 	cmp	local14, ##250000001 wc
06b58     80 02 00 CF 
06b5c     0A B8 06 C6 |  if_b	mov	local10, ##327690
06b60     18 00 90 CD |  if_b	jmp	#LR__1074
06b64     D1 F0 08 FF 
06b68     01 C1 16 F2 | 	cmp	local14, ##300000001 wc
06b6c     00 03 00 CF 
06b70     0C B8 06 C6 |  if_b	mov	local10, ##393228
06b74     80 03 00 3F 
06b78     0E B8 06 36 |  if_ae	mov	local10, ##458766
06b7c                 | LR__1074
06b7c                 | LR__1075
06b7c                 | LR__1076
06b7c                 | LR__1077
06b7c                 | LR__1078
06b7c                 | LR__1079
06b7c     15 62 06 F1 | 	add	objptr, #21
06b80     31 BD 42 FC | 	wrbyte	local12, objptr
06b84     00 BC 0E F2 | 	cmp	local12, #0 wz
06b88     00 B2 06 56 |  if_ne	mov	local07, #0
06b8c     01 B2 06 A6 |  if_e	mov	local07, #1
06b90     01 62 86 F1 | 	sub	objptr, #1
06b94     31 B3 42 FC | 	wrbyte	local07, objptr
06b98     14 62 86 F1 | 	sub	objptr, #20
06b9c     70 04 B0 FD | 	call	#_sdmm_cc_deselect_0297
06ba0     55 B9 12 FC | 	wxpin	local10, local03
06ba4     57 BB 02 FC | 	wrpin	local11, local05
06ba8                 | ' #line 682 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
06ba8                 | ' 		}
06ba8                 | ' 	}
06ba8                 | ' #line 687 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
06ba8                 | ' 	CardType = ty;
06ba8                 | ' 	s = ty ? 0 :  0x01 ;
06ba8                 | ' 	Stat = s;
06ba8                 | ' 
06ba8                 | ' 	deselect();
06ba8                 | ' 
06ba8                 | ' 
06ba8                 | ' 	_wxpin( PIN_CLK, ck_div );
06ba8                 | ' 	_wrpin( PIN_DI, spm_tx );
06ba8                 | ' #line 700 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
06ba8                 | ' 	return s;
06ba8     59 77 02 F6 | 	mov	result1, local07
06bac                 | LR__1080
06bac     E7 F0 03 F6 | 	mov	ptra, fp
06bb0     F2 00 A0 FD | 	call	#popregs_
06bb4                 | _sdmm_cc_disk_initialize_ret
06bb4     2D 00 64 FD | 	ret
06bb8                 | 
06bb8                 | _sdmm_cc_disk_read
06bb8     05 CA 05 F6 | 	mov	COUNT_, #5
06bbc     E8 00 A0 FD | 	call	#pushregs_
06bc0     49 A7 02 F6 | 	mov	local01, arg02
06bc4     4A A9 02 F6 | 	mov	local02, arg03
06bc8     4B AB 02 F6 | 	mov	local03, arg04
06bcc     00 90 0E F2 | 	cmp	arg01, #0 wz
06bd0     01 76 06 56 |  if_ne	mov	result1, #1
06bd4                 | ' 
06bd4                 | ' 	return Stat;
06bd4     14 62 06 A1 |  if_e	add	objptr, #20
06bd8     31 77 C2 AA |  if_e	rdbyte	result1, objptr
06bdc     14 62 86 A1 |  if_e	sub	objptr, #20
06be0     3B 77 E2 F8 | 	getbyte	result1, result1, #0
06be4     01 76 CE F7 | 	test	result1, #1 wz
06be8     03 76 06 56 |  if_ne	mov	result1, #3
06bec     7C 00 90 5D |  if_ne	jmp	#LR__1092
06bf0     15 62 06 F1 | 	add	objptr, #21
06bf4     31 AD C2 FA | 	rdbyte	local04, objptr
06bf8     15 62 86 F1 | 	sub	objptr, #21
06bfc     08 AC CE F7 | 	test	local04, #8 wz
06c00     09 A8 66 A0 |  if_e	shl	local02, #9
06c04     02 AA 16 F2 | 	cmp	local03, #2 wc
06c08     12 AC 06 36 |  if_ae	mov	local04, #18
06c0c     11 AC 06 C6 |  if_b	mov	local04, #17
06c10     54 93 02 F6 | 	mov	arg02, local02
06c14     56 91 02 F6 | 	mov	arg01, local04
06c18     A4 05 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06c1c     3B AF 02 F6 | 	mov	local05, result1
06c20     07 AE 4E F7 | 	zerox	local05, #7 wz
06c24     30 00 90 5D |  if_ne	jmp	#LR__1091
06c28                 | ' 		do {
06c28                 | LR__1090
06c28     53 91 02 F6 | 	mov	arg01, local01
06c2c     09 92 C6 F9 | 	decod	arg02, #9
06c30     7C 04 B0 FD | 	call	#_sdmm_cc_rcvr_datablock_0305
06c34     00 76 0E F2 | 	cmp	result1, #0 wz
06c38     01 00 00 5F 
06c3c     00 A6 06 51 |  if_ne	add	local01, ##512
06c40     F9 AB 6E 5B |  if_ne	djnz	local03, #LR__1090
06c44     56 AD E2 F8 | 	getbyte	local04, local04, #0
06c48     12 AC 0E F2 | 	cmp	local04, #18 wz
06c4c     0C 90 06 A6 |  if_e	mov	arg01, #12
06c50     00 92 06 A6 |  if_e	mov	arg02, #0
06c54     68 05 B0 AD |  if_e	call	#_sdmm_cc_send_cmd_0310
06c58                 | LR__1091
06c58     B4 03 B0 FD | 	call	#_sdmm_cc_deselect_0297
06c5c                 | ' 	}
06c5c                 | ' 	deselect();
06c5c                 | ' 
06c5c                 | ' 	return count ? RES_ERROR : RES_OK;
06c5c     00 AA 0E F2 | 	cmp	local03, #0 wz
06c60     01 AE 06 56 |  if_ne	mov	local05, #1
06c64     00 AE 06 A6 |  if_e	mov	local05, #0
06c68     57 77 02 F6 | 	mov	result1, local05
06c6c                 | LR__1092
06c6c     E7 F0 03 F6 | 	mov	ptra, fp
06c70     F2 00 A0 FD | 	call	#popregs_
06c74                 | _sdmm_cc_disk_read_ret
06c74     2D 00 64 FD | 	ret
06c78                 | 
06c78                 | _sdmm_cc_disk_write
06c78     04 CA 05 F6 | 	mov	COUNT_, #4
06c7c     E8 00 A0 FD | 	call	#pushregs_
06c80     49 A7 02 F6 | 	mov	local01, arg02
06c84     4B A9 02 F6 | 	mov	local02, arg04
06c88     4A AB 02 F6 | 	mov	local03, arg03
06c8c     00 90 0E F2 | 	cmp	arg01, #0 wz
06c90     01 76 06 56 |  if_ne	mov	result1, #1
06c94                 | ' 
06c94                 | ' 	return Stat;
06c94     14 62 06 A1 |  if_e	add	objptr, #20
06c98     31 77 C2 AA |  if_e	rdbyte	result1, objptr
06c9c     14 62 86 A1 |  if_e	sub	objptr, #20
06ca0     3B 77 E2 F8 | 	getbyte	result1, result1, #0
06ca4     01 76 CE F7 | 	test	result1, #1 wz
06ca8     03 76 06 56 |  if_ne	mov	result1, #3
06cac     C4 00 90 5D |  if_ne	jmp	#LR__1104
06cb0     15 62 06 F1 | 	add	objptr, #21
06cb4     31 95 C2 FA | 	rdbyte	arg03, objptr
06cb8     15 62 86 F1 | 	sub	objptr, #21
06cbc     08 94 CE F7 | 	test	arg03, #8 wz
06cc0     09 AA 66 A0 |  if_e	shl	local03, #9
06cc4     01 A8 0E F2 | 	cmp	local02, #1 wz
06cc8     30 00 90 5D |  if_ne	jmp	#LR__1100
06ccc     18 90 06 F6 | 	mov	arg01, #24
06cd0     55 93 02 F6 | 	mov	arg02, local03
06cd4     E8 04 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06cd8     3B AD 02 F6 | 	mov	local04, result1
06cdc     07 AC 4E F7 | 	zerox	local04, #7 wz
06ce0     7C 00 90 5D |  if_ne	jmp	#LR__1103
06ce4     53 91 02 F6 | 	mov	arg01, local01
06ce8     FE 92 06 F6 | 	mov	arg02, #254
06cec     44 04 B0 FD | 	call	#_sdmm_cc_xmit_datablock_0307
06cf0     00 76 0E F2 | 	cmp	result1, #0 wz
06cf4     00 A8 06 56 |  if_ne	mov	local02, #0
06cf8     64 00 90 FD | 	jmp	#LR__1103
06cfc                 | LR__1100
06cfc     15 62 06 F1 | 	add	objptr, #21
06d00     31 AD C2 FA | 	rdbyte	local04, objptr
06d04     15 62 86 F1 | 	sub	objptr, #21
06d08     06 AC CE F7 | 	test	local04, #6 wz
06d0c     97 90 06 56 |  if_ne	mov	arg01, #151
06d10     54 93 02 56 |  if_ne	mov	arg02, local02
06d14     A8 04 B0 5D |  if_ne	call	#_sdmm_cc_send_cmd_0310
06d18     55 93 02 F6 | 	mov	arg02, local03
06d1c     19 90 06 F6 | 	mov	arg01, #25
06d20     9C 04 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06d24     3B AD 02 F6 | 	mov	local04, result1
06d28     07 AC 4E F7 | 	zerox	local04, #7 wz
06d2c     30 00 90 5D |  if_ne	jmp	#LR__1102
06d30                 | ' 			do {
06d30                 | LR__1101
06d30     53 91 02 F6 | 	mov	arg01, local01
06d34     FC 92 06 F6 | 	mov	arg02, #252
06d38     F8 03 B0 FD | 	call	#_sdmm_cc_xmit_datablock_0307
06d3c     00 76 0E F2 | 	cmp	result1, #0 wz
06d40     01 00 00 5F 
06d44     00 A6 06 51 |  if_ne	add	local01, ##512
06d48     F9 A9 6E 5B |  if_ne	djnz	local02, #LR__1101
06d4c     00 90 06 F6 | 	mov	arg01, #0
06d50     FD 92 06 F6 | 	mov	arg02, #253
06d54     DC 03 B0 FD | 	call	#_sdmm_cc_xmit_datablock_0307
06d58     00 76 0E F2 | 	cmp	result1, #0 wz
06d5c     01 A8 06 A6 |  if_e	mov	local02, #1
06d60                 | LR__1102
06d60                 | LR__1103
06d60     AC 02 B0 FD | 	call	#_sdmm_cc_deselect_0297
06d64                 | ' 				count = 1;
06d64                 | ' 		}
06d64                 | ' 	}
06d64                 | ' 	deselect();
06d64                 | ' 
06d64                 | ' 	return count ? RES_ERROR : RES_OK;
06d64     00 A8 0E F2 | 	cmp	local02, #0 wz
06d68     01 AC 06 56 |  if_ne	mov	local04, #1
06d6c     00 AC 06 A6 |  if_e	mov	local04, #0
06d70     56 77 02 F6 | 	mov	result1, local04
06d74                 | LR__1104
06d74     E7 F0 03 F6 | 	mov	ptra, fp
06d78     F2 00 A0 FD | 	call	#popregs_
06d7c                 | _sdmm_cc_disk_write_ret
06d7c     2D 00 64 FD | 	ret
06d80                 | 
06d80                 | _sdmm_cc_disk_ioctl
06d80     06 CA 05 F6 | 	mov	COUNT_, #6
06d84     E8 00 A0 FD | 	call	#pushregs_
06d88     30 F0 07 F1 | 	add	ptra, #48
06d8c     49 A7 02 F6 | 	mov	local01, arg02
06d90     4A A9 02 F6 | 	mov	local02, arg03
06d94     00 90 0E F2 | 	cmp	arg01, #0 wz
06d98     01 76 06 56 |  if_ne	mov	result1, #1
06d9c                 | ' 
06d9c                 | ' 	return Stat;
06d9c     14 62 06 A1 |  if_e	add	objptr, #20
06da0     31 77 C2 AA |  if_e	rdbyte	result1, objptr
06da4     14 62 86 A1 |  if_e	sub	objptr, #20
06da8     3B 77 E2 F8 | 	getbyte	result1, result1, #0
06dac     01 76 CE F7 | 	test	result1, #1 wz
06db0     03 76 06 56 |  if_ne	mov	result1, #3
06db4     F4 00 90 5D |  if_ne	jmp	#LR__1117
06db8     01 AA 06 F6 | 	mov	local03, #1
06dbc                 | ' 
06dbc                 | ' 	res = RES_ERROR;
06dbc                 | ' 	switch (ctrl) {
06dbc     53 AD E2 F8 | 	getbyte	local04, local01, #0
06dc0     04 AC 26 F3 | 	fle	local04, #4
06dc4     30 AC 62 FD | 	jmprel	local04
06dc8                 | LR__1110
06dc8     10 00 90 FD | 	jmp	#LR__1111
06dcc     1C 00 90 FD | 	jmp	#LR__1112
06dd0     CC 00 90 FD | 	jmp	#LR__1115
06dd4     BC 00 90 FD | 	jmp	#LR__1114
06dd8     C4 00 90 FD | 	jmp	#LR__1115
06ddc                 | LR__1111
06ddc     6C 02 B0 FD | 	call	#_sdmm_cc_select_0301
06de0     00 76 0E F2 | 	cmp	result1, #0 wz
06de4     00 AA 06 56 |  if_ne	mov	local03, #0
06de8                 | ' 			break;
06de8     B8 00 90 FD | 	jmp	#LR__1116
06dec                 | LR__1112
06dec     09 90 06 F6 | 	mov	arg01, #9
06df0     00 92 06 F6 | 	mov	arg02, #0
06df4     C8 03 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06df8     3B AD 02 F6 | 	mov	local04, result1
06dfc     07 AC 4E F7 | 	zerox	local04, #7 wz
06e00     A0 00 90 5D |  if_ne	jmp	#LR__1116
06e04     E7 90 02 F6 | 	mov	arg01, fp
06e08     18 90 06 F1 | 	add	arg01, #24
06e0c     10 92 06 F6 | 	mov	arg02, #16
06e10     9C 02 B0 FD | 	call	#_sdmm_cc_rcvr_datablock_0305
06e14     00 76 0E F2 | 	cmp	result1, #0 wz
06e18     88 00 90 AD |  if_e	jmp	#LR__1116
06e1c     E7 90 02 F6 | 	mov	arg01, fp
06e20     18 90 06 F1 | 	add	arg01, #24
06e24     48 77 02 F6 | 	mov	result1, arg01
06e28     06 90 06 F1 | 	add	arg01, #6
06e2c     48 AF 02 FB | 	rdlong	local05, arg01
06e30     1B AE FE F9 | 	movbyts	local05, #27
06e34     3B 91 C2 FA | 	rdbyte	arg01, result1
06e38     06 90 46 F0 | 	shr	arg01, #6
06e3c     01 90 0E F2 | 	cmp	arg01, #1 wz
06e40     36 AF 06 A4 |  if_e	bitl	local05, #310
06e44     01 AE 06 A1 |  if_e	add	local05, #1
06e48     0A B0 06 A6 |  if_e	mov	local06, #10
06e4c     34 00 90 AD |  if_e	jmp	#LR__1113
06e50     0E AE 46 F0 | 	shr	local05, #14
06e54     0B AE 46 F7 | 	zerox	local05, #11
06e58     01 AE 06 F1 | 	add	local05, #1
06e5c     05 76 06 F1 | 	add	result1, #5
06e60     3B B1 C2 FA | 	rdbyte	local06, result1
06e64     58 B1 42 F8 | 	getnib	local06, local06, #0
06e68     04 76 06 F1 | 	add	result1, #4
06e6c     3B 77 E2 FA | 	rdword	result1, result1
06e70     1B 76 FE F9 | 	movbyts	result1, #27
06e74     17 76 46 F0 | 	shr	result1, #23
06e78     07 76 06 F5 | 	and	result1, #7
06e7c     3B B1 02 F1 | 	add	local06, result1
06e80     07 B0 86 F1 | 	sub	local06, #7
06e84                 | LR__1113
06e84                 | '         cs = (LBA_t)(cs>>14 & 0xfff)+1;
06e84                 | '         n = (csd[5] & 15) + (__builtin_bswap32(*(uint16_t*)(&csd[9]))>>23 & 0x7)+(2-9);
06e84                 | '     }
06e84                 | '     return (LBA_t)cs << n;
06e84     58 AF 62 F0 | 	shl	local05, local06
06e88     54 AF 62 FC | 	wrlong	local05, local02
06e8c     00 AA 06 F6 | 	mov	local03, #0
06e90                 | '                			*(LBA_t*)buff = disc_size(csd);
06e90                 | ' 				res = RES_OK;
06e90                 | ' 			}
06e90                 | ' 			break;
06e90     10 00 90 FD | 	jmp	#LR__1116
06e94                 | LR__1114
06e94     54 01 69 FC | 	wrlong	#128, local02
06e98     00 AA 06 F6 | 	mov	local03, #0
06e9c                 | ' 			*(DWORD*)buff = 128;
06e9c                 | ' 			res = RES_OK;
06e9c                 | ' 			break;
06e9c     04 00 90 FD | 	jmp	#LR__1116
06ea0                 | LR__1115
06ea0     04 AA 06 F6 | 	mov	local03, #4
06ea4                 | LR__1116
06ea4     68 01 B0 FD | 	call	#_sdmm_cc_deselect_0297
06ea8                 | ' 			res = RES_PARERR;
06ea8                 | ' 	}
06ea8                 | ' 
06ea8                 | ' 	deselect();
06ea8                 | ' 
06ea8                 | ' 	return res;
06ea8     55 77 02 F6 | 	mov	result1, local03
06eac                 | LR__1117
06eac     E7 F0 03 F6 | 	mov	ptra, fp
06eb0     F2 00 A0 FD | 	call	#popregs_
06eb4                 | _sdmm_cc_disk_ioctl_ret
06eb4     2D 00 64 FD | 	ret
06eb8                 | 
06eb8                 | _sdmm_cc_xmit_mmc_0280
06eb8     31 7D 02 FB | 	rdlong	_var01, objptr
06ebc     08 62 06 F1 | 	add	objptr, #8
06ec0     31 7F 02 FB | 	rdlong	_var02, objptr
06ec4     08 62 86 F1 | 	sub	objptr, #8
06ec8     40 7E 62 FD | 	dirl	_var02
06ecc     28 02 64 FD | 	setq	#1
06ed0     48 81 02 FB | 	rdlong	_var03, arg01
06ed4     69 80 62 FD | 	rev	_var03
06ed8     1B 80 FE F9 | 	movbyts	_var03, #27
06edc     3F 81 22 FC | 	wypin	_var03, _var02
06ee0     49 81 02 F6 | 	mov	_var03, arg02
06ee4     02 92 4E F0 | 	shr	arg02, #2 wz
06ee8     03 80 66 F0 | 	shl	_var03, #3
06eec     3E 81 22 FC | 	wypin	_var03, _var01
06ef0     41 7E 62 FD | 	dirh	_var02
06ef4     08 90 06 F1 | 	add	arg01, #8
06ef8     69 82 62 FD | 	rev	_var04
06efc     1B 82 FE F9 | 	movbyts	_var04, #27
06f00                 | LR__1120
06f00     3F 83 22 5C |  if_ne	wypin	_var04, _var02
06f04     48 83 02 5B |  if_ne	rdlong	_var04, arg01
06f08     04 90 06 51 |  if_ne	add	arg01, #4
06f0c     69 82 62 5D |  if_ne	rev	_var04
06f10     1B 82 FE 59 |  if_ne	movbyts	_var04, #27
06f14                 | LR__1121
06f14     40 7E 72 5D |  if_ne	testp	_var02 wc
06f18     F8 FF 9F 1D |  if_a	jmp	#LR__1121
06f1c     F8 93 6E 5B |  if_ne	djnz	arg02, #LR__1120
06f20                 | LR__1122
06f20     40 7C 72 FD | 	testp	_var01 wc
06f24     F8 FF 9F 3D |  if_ae	jmp	#LR__1122
06f28     40 7E 62 FD | 	dirl	_var02
06f2c     FF FF FF FF 
06f30     3F FF 2B FC | 	wypin	##-1, _var02
06f34     41 7E 62 FD | 	dirh	_var02
06f38                 | _sdmm_cc_xmit_mmc_0280_ret
06f38     2D 00 64 FD | 	ret
06f3c                 | 
06f3c                 | _sdmm_cc_rcvr_mmc_0287
06f3c     31 7D 02 FB | 	rdlong	_var01, objptr
06f40     0C 62 06 F1 | 	add	objptr, #12
06f44     31 7F 02 FB | 	rdlong	_var02, objptr
06f48     0C 62 86 F1 | 	sub	objptr, #12
06f4c     3F 03 08 FC | 	akpin	_var02
06f50     49 81 0A F6 | 	mov	_var03, arg02 wz
06f54     02 80 4E F0 | 	shr	_var03, #2 wz
06f58     30 00 90 AD |  if_e	jmp	#LR__1132
06f5c     40 83 02 F6 | 	mov	_var04, _var03
06f60     05 82 66 F0 | 	shl	_var04, #5
06f64     3E 83 22 FC | 	wypin	_var04, _var01
06f68     3F 7F 18 FC | 	wxpin	#63, _var02
06f6c                 | LR__1130
06f6c                 | LR__1131
06f6c     40 7E 72 FD | 	testp	_var02 wc
06f70     F8 FF 9F 3D |  if_ae	jmp	#LR__1131
06f74     3F 83 8A FA | 	rdpin	_var04, _var02
06f78     69 82 62 FD | 	rev	_var04
06f7c     1B 82 FE F9 | 	movbyts	_var04, #27
06f80     48 83 62 FC | 	wrlong	_var04, arg01
06f84     04 90 06 F1 | 	add	arg01, #4
06f88     F8 81 6E FB | 	djnz	_var03, #LR__1130
06f8c                 | LR__1132
06f8c     03 92 0E F5 | 	and	arg02, #3 wz
06f90     24 00 90 AD |  if_e	jmp	#LR__1135
06f94     3F 4F 18 FC | 	wxpin	#39, _var02
06f98                 | LR__1133
06f98     3E 11 28 FC | 	wypin	#8, _var01
06f9c                 | LR__1134
06f9c     40 7E 72 FD | 	testp	_var02 wc
06fa0     F8 FF 9F 3D |  if_ae	jmp	#LR__1134
06fa4     3F 83 8A FA | 	rdpin	_var04, _var02
06fa8     69 82 62 FD | 	rev	_var04
06fac     48 83 42 FC | 	wrbyte	_var04, arg01
06fb0     01 90 06 F1 | 	add	arg01, #1
06fb4     F8 93 6E FB | 	djnz	arg02, #LR__1133
06fb8                 | LR__1135
06fb8                 | _sdmm_cc_rcvr_mmc_0287_ret
06fb8     2D 00 64 FD | 	ret
06fbc                 | 
06fbc                 | _sdmm_cc_wait_ready_0291
06fbc     03 CA 05 F6 | 	mov	COUNT_, #3
06fc0     E8 00 A0 FD | 	call	#pushregs_
06fc4     F8 A7 02 F6 | 	mov	local01, ptra
06fc8     1A A8 62 FD | 	getct	local02
06fcc     14 AA 06 FB | 	rdlong	local03, #20
06fd0     01 AA 46 F0 | 	shr	local03, #1
06fd4                 | ' 	UINT tmr, tmout;
06fd4                 | ' 
06fd4                 | ' 	tmr = _cnt();
06fd4                 | ' 	tmout =  (*(uint32_t *)0x14)  >> 1;
06fd4                 | ' 	for(;;) {
06fd4     04 F0 07 F1 | 	add	ptra, #4
06fd8                 | LR__1140
06fd8     53 91 02 F6 | 	mov	arg01, local01
06fdc     01 92 06 F6 | 	mov	arg02, #1
06fe0     58 FF BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
06fe4     53 93 C2 FA | 	rdbyte	arg02, local01
06fe8     FF 92 0E F2 | 	cmp	arg02, #255 wz
06fec     01 76 06 A6 |  if_e	mov	result1, #1
06ff0     1A 76 62 5D |  if_ne	getct	result1
06ff4     54 77 82 51 |  if_ne	sub	result1, local02
06ff8     55 77 12 52 |  if_ne	cmp	result1, local03 wc
06ffc     00 76 06 16 |  if_a	mov	result1, #0
07000     D4 FF 9F 4D |  if_c_and_nz	jmp	#LR__1140
07004     E7 F0 03 F6 | 	mov	ptra, fp
07008     F2 00 A0 FD | 	call	#popregs_
0700c                 | _sdmm_cc_wait_ready_0291_ret
0700c     2D 00 64 FD | 	ret
07010                 | 
07010                 | _sdmm_cc_deselect_0297
07010     00 CA 05 F6 | 	mov	COUNT_, #0
07014     E8 00 A0 FD | 	call	#pushregs_
07018     F8 93 02 F6 | 	mov	arg02, ptra
0701c     04 62 06 F1 | 	add	objptr, #4
07020     31 91 02 FB | 	rdlong	arg01, objptr
07024     04 62 86 F1 | 	sub	objptr, #4
07028     04 F0 07 F1 | 	add	ptra, #4
0702c     59 90 62 FD | 	drvh	arg01
07030     1F 20 64 FD | 	waitx	#16
07034     49 91 02 F6 | 	mov	arg01, arg02
07038     01 92 06 F6 | 	mov	arg02, #1
0703c     FC FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07040     E7 F0 03 F6 | 	mov	ptra, fp
07044     F2 00 A0 FD | 	call	#popregs_
07048                 | _sdmm_cc_deselect_0297_ret
07048     2D 00 64 FD | 	ret
0704c                 | 
0704c                 | _sdmm_cc_select_0301
0704c     01 CA 05 F6 | 	mov	COUNT_, #1
07050     E8 00 A0 FD | 	call	#pushregs_
07054     F8 93 02 F6 | 	mov	arg02, ptra
07058     04 62 06 F1 | 	add	objptr, #4
0705c     31 91 02 FB | 	rdlong	arg01, objptr
07060     08 62 06 F1 | 	add	objptr, #8
07064     31 A7 02 FB | 	rdlong	local01, objptr
07068     0C 62 86 F1 | 	sub	objptr, #12
0706c     04 F0 07 F1 | 	add	ptra, #4
07070     50 A6 62 FD | 	fltl	local01
07074     58 90 62 FD | 	drvl	arg01
07078     1F 20 64 FD | 	waitx	#16
0707c     41 A6 62 FD | 	dirh	local01
07080     49 91 02 F6 | 	mov	arg01, arg02
07084     01 92 06 F6 | 	mov	arg02, #1
07088     B0 FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
0708c     2C FF BF FD | 	call	#_sdmm_cc_wait_ready_0291
07090     00 76 0E F2 | 	cmp	result1, #0 wz
07094     01 76 06 56 |  if_ne	mov	result1, #1
07098     08 00 90 5D |  if_ne	jmp	#LR__1150
0709c     70 FF BF FD | 	call	#_sdmm_cc_deselect_0297
070a0                 | ' 
070a0                 | ' 	deselect();
070a0                 | ' 	return 0;
070a0     00 76 06 F6 | 	mov	result1, #0
070a4                 | LR__1150
070a4     E7 F0 03 F6 | 	mov	ptra, fp
070a8     F2 00 A0 FD | 	call	#popregs_
070ac                 | _sdmm_cc_select_0301_ret
070ac     2D 00 64 FD | 	ret
070b0                 | 
070b0                 | _sdmm_cc_rcvr_datablock_0305
070b0     05 CA 05 F6 | 	mov	COUNT_, #5
070b4     E8 00 A0 FD | 	call	#pushregs_
070b8     48 A7 02 F6 | 	mov	local01, arg01
070bc     49 A9 02 F6 | 	mov	local02, arg02
070c0     F8 AB 02 F6 | 	mov	local03, ptra
070c4     1A AC 62 FD | 	getct	local04
070c8     14 AE 06 FB | 	rdlong	local05, #20
070cc     03 AE 46 F0 | 	shr	local05, #3
070d0                 | ' 	UINT tmr, tmout;
070d0                 | ' 
070d0                 | ' 	tmr = _cnt();
070d0                 | ' 	tmout =  (*(uint32_t *)0x14)  >> 3;
070d0                 | ' 	for(;;) {
070d0     04 F0 07 F1 | 	add	ptra, #4
070d4                 | LR__1160
070d4     55 91 02 F6 | 	mov	arg01, local03
070d8     01 92 06 F6 | 	mov	arg02, #1
070dc     5C FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
070e0     55 93 C2 FA | 	rdbyte	arg02, local03
070e4     FF 92 0E F2 | 	cmp	arg02, #255 wz
070e8     1A 76 62 AD |  if_e	getct	result1
070ec     3B 93 02 A6 |  if_e	mov	arg02, result1
070f0     56 93 82 A1 |  if_e	sub	arg02, local04
070f4     57 93 12 A2 |  if_e	cmp	arg02, local05 wc
070f8     D8 FF 9F 8D |  if_c_and_z	jmp	#LR__1160
070fc     55 AF C2 FA | 	rdbyte	local05, local03
07100     FE AE 0E F2 | 	cmp	local05, #254 wz
07104     00 76 06 56 |  if_ne	mov	result1, #0
07108     1C 00 90 5D |  if_ne	jmp	#LR__1161
0710c     53 91 02 F6 | 	mov	arg01, local01
07110     54 93 02 F6 | 	mov	arg02, local02
07114     24 FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07118     55 91 02 F6 | 	mov	arg01, local03
0711c     02 92 06 F6 | 	mov	arg02, #2
07120     18 FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07124                 | ' 
07124                 | ' 	rcvr_mmc(buff, btr);
07124                 | ' 	rcvr_mmc(d, 2);
07124                 | ' 
07124                 | ' 	return 1;
07124     01 76 06 F6 | 	mov	result1, #1
07128                 | LR__1161
07128     E7 F0 03 F6 | 	mov	ptra, fp
0712c     F2 00 A0 FD | 	call	#popregs_
07130                 | _sdmm_cc_rcvr_datablock_0305_ret
07130     2D 00 64 FD | 	ret
07134                 | 
07134                 | _sdmm_cc_xmit_datablock_0307
07134     03 CA 05 F6 | 	mov	COUNT_, #3
07138     E8 00 A0 FD | 	call	#pushregs_
0713c     48 A7 02 F6 | 	mov	local01, arg01
07140     49 A9 02 F6 | 	mov	local02, arg02
07144     F8 AB 02 F6 | 	mov	local03, ptra
07148     04 F0 07 F1 | 	add	ptra, #4
0714c     6C FE BF FD | 	call	#_sdmm_cc_wait_ready_0291
07150     00 76 0E F2 | 	cmp	result1, #0 wz
07154     00 76 06 A6 |  if_e	mov	result1, #0
07158     58 00 90 AD |  if_e	jmp	#LR__1171
0715c     55 A9 42 FC | 	wrbyte	local02, local03
07160     55 91 02 F6 | 	mov	arg01, local03
07164     01 92 06 F6 | 	mov	arg02, #1
07168     4C FD BF FD | 	call	#_sdmm_cc_xmit_mmc_0280
0716c     54 A9 E2 F8 | 	getbyte	local02, local02, #0
07170     FD A8 0E F2 | 	cmp	local02, #253 wz
07174     38 00 90 AD |  if_e	jmp	#LR__1170
07178     53 91 02 F6 | 	mov	arg01, local01
0717c     09 92 C6 F9 | 	decod	arg02, #9
07180     34 FD BF FD | 	call	#_sdmm_cc_xmit_mmc_0280
07184     55 91 02 F6 | 	mov	arg01, local03
07188     02 92 06 F6 | 	mov	arg02, #2
0718c     AC FD BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07190     55 91 02 F6 | 	mov	arg01, local03
07194     01 92 06 F6 | 	mov	arg02, #1
07198     A0 FD BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
0719c     55 AB C2 FA | 	rdbyte	local03, local03
071a0     1F AA 06 F5 | 	and	local03, #31
071a4     05 AA 0E F2 | 	cmp	local03, #5 wz
071a8                 | ' 			return 0;
071a8     00 76 06 56 |  if_ne	mov	result1, #0
071ac     04 00 90 5D |  if_ne	jmp	#LR__1171
071b0                 | LR__1170
071b0                 | ' 	}
071b0                 | ' 
071b0                 | ' 	return 1;
071b0     01 76 06 F6 | 	mov	result1, #1
071b4                 | LR__1171
071b4     E7 F0 03 F6 | 	mov	ptra, fp
071b8     F2 00 A0 FD | 	call	#popregs_
071bc                 | _sdmm_cc_xmit_datablock_0307_ret
071bc     2D 00 64 FD | 	ret
071c0                 | 
071c0                 | _sdmm_cc_send_cmd_0310
071c0     04 CA 05 F6 | 	mov	COUNT_, #4
071c4     E8 00 A0 FD | 	call	#pushregs_
071c8                 | _sdmm_cc_send_cmd_0310_enter
071c8     48 A7 02 F6 | 	mov	local01, arg01
071cc     49 A9 02 F6 | 	mov	local02, arg02
071d0     F8 AB 02 F6 | 	mov	local03, ptra
071d4     53 77 E2 F8 | 	getbyte	result1, local01, #0
071d8     80 76 CE F7 | 	test	result1, #128 wz
071dc     08 F0 07 F1 | 	add	ptra, #8
071e0     20 00 90 AD |  if_e	jmp	#LR__1180
071e4     53 A7 E2 F8 | 	getbyte	local01, local01, #0
071e8     7F A6 06 F5 | 	and	local01, #127
071ec     37 90 06 F6 | 	mov	arg01, #55
071f0     00 92 06 F6 | 	mov	arg02, #0
071f4     C8 FF BF FD | 	call	#_sdmm_cc_send_cmd_0310
071f8     3B 93 E2 F8 | 	getbyte	arg02, result1, #0
071fc     02 92 16 F2 | 	cmp	arg02, #2 wc
07200     BC 00 90 3D |  if_ae	jmp	#LR__1183
07204                 | LR__1180
07204     53 77 E2 F8 | 	getbyte	result1, local01, #0
07208     0C 76 0E F2 | 	cmp	result1, #12 wz
0720c     14 00 90 AD |  if_e	jmp	#LR__1181
07210     FC FD BF FD | 	call	#_sdmm_cc_deselect_0297
07214     34 FE BF FD | 	call	#_sdmm_cc_select_0301
07218     00 76 0E F2 | 	cmp	result1, #0 wz
0721c     FF 76 06 A6 |  if_e	mov	result1, #255
07220     9C 00 90 AD |  if_e	jmp	#LR__1183
07224                 | LR__1181
07224     53 93 E2 F8 | 	getbyte	arg02, local01, #0
07228     40 76 06 F6 | 	mov	result1, #64
0722c     49 77 42 F5 | 	or	result1, arg02
07230     55 77 42 FC | 	wrbyte	result1, local03
07234     55 93 02 F6 | 	mov	arg02, local03
07238     01 92 06 F1 | 	add	arg02, #1
0723c     1B A8 FE F9 | 	movbyts	local02, #27
07240     49 A9 62 FC | 	wrlong	local02, arg02
07244     01 AC 06 F6 | 	mov	local04, #1
07248     53 A9 02 F6 | 	mov	local02, local01
0724c     07 A8 4E F7 | 	zerox	local02, #7 wz
07250     95 AC 06 A6 |  if_e	mov	local04, #149
07254     53 A9 E2 F8 | 	getbyte	local02, local01, #0
07258     08 A8 0E F2 | 	cmp	local02, #8 wz
0725c     87 AC 06 A6 |  if_e	mov	local04, #135
07260     05 AA 06 F1 | 	add	local03, #5
07264     55 AD 42 FC | 	wrbyte	local04, local03
07268     05 AA 86 F1 | 	sub	local03, #5
0726c     55 91 02 F6 | 	mov	arg01, local03
07270     06 92 06 F6 | 	mov	arg02, #6
07274     40 FC BF FD | 	call	#_sdmm_cc_xmit_mmc_0280
07278     53 A7 E2 F8 | 	getbyte	local01, local01, #0
0727c     0C A6 0E F2 | 	cmp	local01, #12 wz
07280     55 91 02 A6 |  if_e	mov	arg01, local03
07284     06 90 06 A1 |  if_e	add	arg01, #6
07288     01 92 06 A6 |  if_e	mov	arg02, #1
0728c     AC FC BF AD |  if_e	call	#_sdmm_cc_rcvr_mmc_0287
07290     0A AC 06 F6 | 	mov	local04, #10
07294                 | ' 	n = 10;
07294                 | ' 	do
07294                 | LR__1182
07294     55 91 02 F6 | 	mov	arg01, local03
07298     06 90 06 F1 | 	add	arg01, #6
0729c     01 92 06 F6 | 	mov	arg02, #1
072a0     98 FC BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
072a4     06 AA 06 F1 | 	add	local03, #6
072a8     55 A9 C2 FA | 	rdbyte	local02, local03
072ac     06 AA 86 F1 | 	sub	local03, #6
072b0     80 A8 CE F7 | 	test	local02, #128 wz
072b4     F7 AD 6E 5B |  if_ne	djnz	local04, #LR__1182
072b8                 | ' 
072b8                 | ' 	return buf[6];
072b8     06 AA 06 F1 | 	add	local03, #6
072bc     55 77 C2 FA | 	rdbyte	result1, local03
072c0                 | LR__1183
072c0     E7 F0 03 F6 | 	mov	ptra, fp
072c4     F2 00 A0 FD | 	call	#popregs_
072c8                 | _sdmm_cc_send_cmd_0310_ret
072c8     2D 00 64 FD | 	ret
072cc                 | 
072cc                 | _sdmm_cc_disk_setpins
072cc     00 90 0E F2 | 	cmp	arg01, #0 wz
072d0     01 76 66 56 |  if_ne	neg	result1, #1
072d4     24 00 90 5D |  if_ne	jmp	#_sdmm_cc_disk_setpins_ret
072d8     31 93 62 FC | 	wrlong	arg02, objptr
072dc     04 62 06 F1 | 	add	objptr, #4
072e0     31 95 62 FC | 	wrlong	arg03, objptr
072e4     04 62 06 F1 | 	add	objptr, #4
072e8     31 97 62 FC | 	wrlong	arg04, objptr
072ec     04 62 06 F1 | 	add	objptr, #4
072f0     31 99 62 FC | 	wrlong	arg05, objptr
072f4     0C 62 86 F1 | 	sub	objptr, #12
072f8                 | '     _pin_clk = pclk;
072f8                 | '     _pin_ss = pss;
072f8                 | '     _pin_di = pdi;
072f8                 | '     _pin_do = pdo;
072f8                 | ' #line 848 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
072f8                 | '     return 0;
072f8     00 76 06 F6 | 	mov	result1, #0
072fc                 | _sdmm_cc_disk_setpins_ret
072fc     2D 00 64 FD | 	ret
07300                 | 
07300                 | _sdmm_cc_disk_deinitialize
07300     04 CA 05 F6 | 	mov	COUNT_, #4
07304     E8 00 A0 FD | 	call	#pushregs_
07308     00 90 4E F2 | 	cmps	arg01, #0 wz
0730c     31 A7 02 FB | 	rdlong	local01, objptr
07310     04 62 06 F1 | 	add	objptr, #4
07314     31 A9 02 FB | 	rdlong	local02, objptr
07318     04 62 06 F1 | 	add	objptr, #4
0731c     31 AB 02 FB | 	rdlong	local03, objptr
07320     08 62 06 F1 | 	add	objptr, #8
07324     31 AD 02 FB | 	rdlong	local04, objptr
07328     04 62 86 F1 | 	sub	objptr, #4
0732c     31 91 02 FB | 	rdlong	arg01, objptr
07330     0C 62 86 F1 | 	sub	objptr, #12
07334                 | ' #line 865 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
07334                 | '         return RES_NOTRDY;
07334     03 76 06 56 |  if_ne	mov	result1, #3
07338     34 00 90 5D |  if_ne	jmp	#LR__1190
0733c     50 90 62 FD | 	fltl	arg01
07340     48 01 08 FC | 	wrpin	#0, arg01
07344     50 AC 62 FD | 	fltl	local04
07348     56 01 08 FC | 	wrpin	#0, local04
0734c     50 AA 62 FD | 	fltl	local03
07350     55 01 08 FC | 	wrpin	#0, local03
07354     50 A6 62 FD | 	fltl	local01
07358     53 01 08 FC | 	wrpin	#0, local01
0735c     50 A8 62 FD | 	fltl	local02
07360     54 01 08 FC | 	wrpin	#0, local02
07364     0A 90 06 F6 | 	mov	arg01, #10
07368     30 BB BF FD | 	call	#__system___waitms
0736c                 | '     }
0736c                 | ' #line 871 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
0736c                 | '     _pinclear(SMPIN_DO);
0736c                 | '     _pinclear(PIN_DO);
0736c                 | '     _pinclear(PIN_DI);
0736c                 | '     _pinclear(PIN_CLK);
0736c                 | '     _pinclear(PIN_SS);
0736c                 | ' 
0736c                 | '     _waitms(10);
0736c                 | ' 
0736c                 | '     return 0;
0736c     00 76 06 F6 | 	mov	result1, #0
07370                 | LR__1190
07370     E7 F0 03 F6 | 	mov	ptra, fp
07374     F2 00 A0 FD | 	call	#popregs_
07378                 | _sdmm_cc_disk_deinitialize_ret
07378     2D 00 64 FD | 	ret
0737c                 | 
0737c                 | _sdmm_cc_v_do_io
0737c     08 CA 05 F6 | 	mov	COUNT_, #8
07380     E8 00 A0 FD | 	call	#pushregs_
07384     4A A7 02 F6 | 	mov	local01, arg03
07388     4B A9 02 F6 | 	mov	local02, arg04
0738c     49 AB 02 F6 | 	mov	local03, arg02
07390     18 62 06 F1 | 	add	objptr, #24
07394     31 AD 02 FB | 	rdlong	local04, objptr
07398     00 96 06 F6 | 	mov	arg04, #0
0739c     FF AD 06 F5 | 	and	local04, #511
073a0     00 AE 06 F6 | 	mov	local05, #0
073a4     31 91 02 FB | 	rdlong	arg01, objptr
073a8     04 62 06 F1 | 	add	objptr, #4
073ac     31 93 02 FB | 	rdlong	arg02, objptr
073b0     1C 62 86 F1 | 	sub	objptr, #28
073b4     09 94 06 F6 | 	mov	arg03, #9
073b8     5C CD BF FD | 	call	#__system___int64_sar
073bc     3B B1 02 F6 | 	mov	local06, result1
073c0     00 AC 0E F2 | 	cmp	local04, #0 wz
073c4                 | ' 
073c4                 | ' 
073c4                 | '         return -1;
073c4     01 76 66 56 |  if_ne	neg	result1, #1
073c8     84 00 90 5D |  if_ne	jmp	#LR__1203
073cc     53 B3 02 F6 | 	mov	local07, local01
073d0     09 B2 46 F0 | 	shr	local07, #9
073d4     00 A8 0E F2 | 	cmp	local02, #0 wz
073d8     1C 00 90 AD |  if_e	jmp	#LR__1200
073dc     00 90 06 F6 | 	mov	arg01, #0
073e0     55 93 02 F6 | 	mov	arg02, local03
073e4     58 95 02 F6 | 	mov	arg03, local06
073e8     59 97 02 F6 | 	mov	arg04, local07
073ec     88 F8 BF FD | 	call	#_sdmm_cc_disk_write
073f0     3B B5 02 F6 | 	mov	local08, result1
073f4     18 00 90 FD | 	jmp	#LR__1201
073f8                 | LR__1200
073f8     00 90 06 F6 | 	mov	arg01, #0
073fc     55 93 02 F6 | 	mov	arg02, local03
07400     58 95 02 F6 | 	mov	arg03, local06
07404     59 97 02 F6 | 	mov	arg04, local07
07408     AC F7 BF FD | 	call	#_sdmm_cc_disk_read
0740c     3B B5 02 F6 | 	mov	local08, result1
07410                 | LR__1201
07410     00 B4 0E F2 | 	cmp	local08, #0 wz
07414     34 00 90 5D |  if_ne	jmp	#LR__1202
07418     09 B2 66 F0 | 	shl	local07, #9
0741c     59 AF 02 F1 | 	add	local05, local07
07420     18 62 06 F1 | 	add	objptr, #24
07424     31 77 02 FB | 	rdlong	result1, objptr
07428     04 62 06 F1 | 	add	objptr, #4
0742c     31 79 02 FB | 	rdlong	result2, objptr
07430     59 77 12 F1 | 	add	result1, local07 wc
07434     00 78 26 F1 | 	addx	result2, #0
07438     04 62 86 F1 | 	sub	objptr, #4
0743c     31 77 62 FC | 	wrlong	result1, objptr
07440     04 62 06 F1 | 	add	objptr, #4
07444     31 79 62 FC | 	wrlong	result2, objptr
07448     1C 62 86 F1 | 	sub	objptr, #28
0744c                 | LR__1202
0744c                 | ' 
0744c                 | ' 
0744c                 | '     }
0744c                 | '     return bytes_io;
0744c     57 77 02 F6 | 	mov	result1, local05
07450                 | LR__1203
07450     E7 F0 03 F6 | 	mov	ptra, fp
07454     F2 00 A0 FD | 	call	#popregs_
07458                 | _sdmm_cc_v_do_io_ret
07458     2D 00 64 FD | 	ret
0745c                 | 
0745c                 | _sdmm_cc_v_read
0745c                 | ' {
0745c                 | '     return v_do_io(fil, buf, count,  (0) );
0745c     00 96 06 F6 | 	mov	arg04, #0
07460     18 FF BF FD | 	call	#_sdmm_cc_v_do_io
07464                 | _sdmm_cc_v_read_ret
07464     2D 00 64 FD | 	ret
07468                 | 
07468                 | _sdmm_cc_v_write
07468                 | ' {
07468                 | '     return v_do_io(fil, buf, count,  (1) );
07468     01 96 06 F6 | 	mov	arg04, #1
0746c     0C FF BF FD | 	call	#_sdmm_cc_v_do_io
07470                 | _sdmm_cc_v_write_ret
07470     2D 00 64 FD | 	ret
07474                 | 
07474                 | _sdmm_cc_v_ioctl
07474     00 90 06 F6 | 	mov	arg01, #0
07478     04 F9 BF FD | 	call	#_sdmm_cc_disk_ioctl
0747c     00 76 0E F2 | 	cmp	result1, #0 wz
07480                 | '         return _seterror( 10 );
07480     20 66 06 51 |  if_ne	add	ptr___system__dat__, #32
07484     33 15 68 5C |  if_ne	wrlong	#10, ptr___system__dat__
07488     20 66 86 51 |  if_ne	sub	ptr___system__dat__, #32
0748c     01 76 66 56 |  if_ne	neg	result1, #1
07490                 | '     return 0;
07490     00 76 06 A6 |  if_e	mov	result1, #0
07494                 | _sdmm_cc_v_ioctl_ret
07494     2D 00 64 FD | 	ret
07498                 | 
07498                 | _sdmm_cc_v_lseek
07498     49 7D 02 F6 | 	mov	_var01, arg02
0749c     4B 81 0A F6 | 	mov	_var03, arg04 wz
074a0     1C 00 90 5D |  if_ne	jmp	#LR__1210
074a4     4A 81 02 F6 | 	mov	_var03, arg03
074a8     18 62 06 F1 | 	add	objptr, #24
074ac     31 7D 62 FC | 	wrlong	_var01, objptr
074b0     04 62 06 F1 | 	add	objptr, #4
074b4     31 81 62 FC | 	wrlong	_var03, objptr
074b8     1C 62 86 F1 | 	sub	objptr, #28
074bc     64 00 90 FD | 	jmp	#LR__1213
074c0                 | LR__1210
074c0     01 80 0E F2 | 	cmp	_var03, #1 wz
074c4     30 00 90 5D |  if_ne	jmp	#LR__1211
074c8     18 62 06 F1 | 	add	objptr, #24
074cc     31 77 02 FB | 	rdlong	result1, objptr
074d0     04 62 06 F1 | 	add	objptr, #4
074d4     31 79 02 FB | 	rdlong	result2, objptr
074d8     3E 77 12 F1 | 	add	result1, _var01 wc
074dc     4A 79 22 F1 | 	addx	result2, arg03
074e0     04 62 86 F1 | 	sub	objptr, #4
074e4     31 77 62 FC | 	wrlong	result1, objptr
074e8     04 62 06 F1 | 	add	objptr, #4
074ec     31 79 62 FC | 	wrlong	result2, objptr
074f0     1C 62 86 F1 | 	sub	objptr, #28
074f4     2C 00 90 FD | 	jmp	#LR__1212
074f8                 | LR__1211
074f8     3E 77 22 F6 | 	not	result1, _var01
074fc     01 76 0E F1 | 	add	result1, #1 wz
07500     4A 79 22 F6 | 	not	result2, arg03
07504     00 92 06 F6 | 	mov	arg02, #0
07508     01 92 66 A6 |  if_e	neg	arg02, #1
0750c     49 79 82 F1 | 	sub	result2, arg02
07510     18 62 06 F1 | 	add	objptr, #24
07514     31 77 62 FC | 	wrlong	result1, objptr
07518     04 62 06 F1 | 	add	objptr, #4
0751c     31 79 62 FC | 	wrlong	result2, objptr
07520     1C 62 86 F1 | 	sub	objptr, #28
07524                 | LR__1212
07524                 | LR__1213
07524                 | '         curpos = -off;
07524                 | '     }
07524                 | '     return curpos;
07524     18 62 06 F1 | 	add	objptr, #24
07528     31 77 02 FB | 	rdlong	result1, objptr
0752c     04 62 06 F1 | 	add	objptr, #4
07530     31 79 02 FB | 	rdlong	result2, objptr
07534     1C 62 86 F1 | 	sub	objptr, #28
07538                 | _sdmm_cc_v_lseek_ret
07538     2D 00 64 FD | 	ret
0753c                 | 
0753c                 | _sdmm_cc_v_flush
0753c                 | ' {
0753c                 | '     return 0;
0753c     00 76 06 F6 | 	mov	result1, #0
07540                 | _sdmm_cc_v_flush_ret
07540     2D 00 64 FD | 	ret
07544                 | 
07544                 | _sdmm_cc_v_close
07544     00 90 06 F6 | 	mov	arg01, #0
07548     B4 FD BF FD | 	call	#_sdmm_cc_disk_deinitialize
0754c     20 62 06 F1 | 	add	objptr, #32
07550     31 91 02 FB | 	rdlong	arg01, objptr
07554     04 62 06 F1 | 	add	objptr, #4
07558     31 93 02 FB | 	rdlong	arg02, objptr
0755c     24 62 86 F1 | 	sub	objptr, #36
07560     40 CC BF FD | 	call	#__system___freepins
07564                 | ' {
07564                 | '     disk_deinitialize(0);
07564                 | '     _freepins(f_pinmask);
07564                 | '     return 0;
07564     00 76 06 F6 | 	mov	result1, #0
07568                 | _sdmm_cc_v_close_ret
07568     2D 00 64 FD | 	ret
0756c                 | 
0756c                 | _sdmm_cc_v_putc
0756c     00 CA 05 F6 | 	mov	COUNT_, #0
07570     E8 00 A0 FD | 	call	#pushregs_
07574     0C F0 07 F1 | 	add	ptra, #12
07578     04 CE 05 F1 | 	add	fp, #4
0757c     E7 90 62 FC | 	wrlong	arg01, fp
07580     49 91 02 F6 | 	mov	arg01, arg02
07584     E7 92 02 F6 | 	mov	arg02, fp
07588     01 94 06 F6 | 	mov	arg03, #1
0758c     04 CE 85 F1 | 	sub	fp, #4
07590                 | ' {
07590                 | '     return v_do_io(fil, buf, count,  (1) );
07590     01 96 06 F6 | 	mov	arg04, #1
07594     E4 FD BF FD | 	call	#_sdmm_cc_v_do_io
07598     01 76 0E F2 | 	cmp	result1, #1 wz
0759c     04 CE 05 A1 |  if_e	add	fp, #4
075a0     E7 76 02 AB |  if_e	rdlong	result1, fp
075a4     04 CE 85 A1 |  if_e	sub	fp, #4
075a8                 | '     return -1;
075a8     01 76 66 56 |  if_ne	neg	result1, #1
075ac     E7 F0 03 F6 | 	mov	ptra, fp
075b0     F2 00 A0 FD | 	call	#popregs_
075b4                 | _sdmm_cc_v_putc_ret
075b4     2D 00 64 FD | 	ret
075b8                 | 
075b8                 | _sdmm_cc_v_getc
075b8     00 CA 05 F6 | 	mov	COUNT_, #0
075bc     E8 00 A0 FD | 	call	#pushregs_
075c0     0C F0 07 F1 | 	add	ptra, #12
075c4     08 CE 05 F1 | 	add	fp, #8
075c8     E7 00 68 FC | 	wrlong	#0, fp
075cc     E7 92 02 F6 | 	mov	arg02, fp
075d0     08 CE 85 F1 | 	sub	fp, #8
075d4     01 94 06 F6 | 	mov	arg03, #1
075d8                 | ' {
075d8                 | '     return v_do_io(fil, buf, count,  (0) );
075d8     00 96 06 F6 | 	mov	arg04, #0
075dc     9C FD BF FD | 	call	#_sdmm_cc_v_do_io
075e0     01 76 0E F2 | 	cmp	result1, #1 wz
075e4     08 CE 05 A1 |  if_e	add	fp, #8
075e8     E7 76 02 AB |  if_e	rdlong	result1, fp
075ec     08 CE 85 A1 |  if_e	sub	fp, #8
075f0                 | '     return -1;
075f0     01 76 66 56 |  if_ne	neg	result1, #1
075f4     E7 F0 03 F6 | 	mov	ptra, fp
075f8     F2 00 A0 FD | 	call	#popregs_
075fc                 | _sdmm_cc_v_getc_ret
075fc     2D 00 64 FD | 	ret
07600                 | 
07600                 | _fatfs_cc_ff_uni2oem
07600     00 7C 06 F6 | 	mov	_var01, #0
07604     80 90 16 F2 | 	cmp	arg01, #128 wc
07608     48 7D 02 C6 |  if_b	mov	_var01, arg01
0760c     58 00 90 CD |  if_b	jmp	#LR__1224
07610     80 00 00 FF 
07614     00 90 16 F2 | 	cmp	arg01, ##65536 wc
07618     4C 00 90 3D |  if_ae	jmp	#LR__1223
0761c     49 77 32 F9 | 	getword	result1, arg02, #0
07620     01 00 00 FF 
07624     52 77 0E F2 | 	cmp	result1, ##850 wz
07628     3C 00 90 5D |  if_ne	jmp	#LR__1223
0762c                 | ' 			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
0762c     00 7C 06 F6 | 	mov	_var01, #0
07630     D7 14 48 FB | 	callpa	#(@LR__1221-@LR__1220)>>2,fcache_load_ptr_
07634                 | LR__1220
07634     3E 77 32 F9 | 	getword	result1, _var01, #0
07638     80 76 16 F2 | 	cmp	result1, #128 wc
0763c     1C 00 90 3D |  if_ae	jmp	#LR__1222
07640     3E 77 32 F9 | 	getword	result1, _var01, #0
07644     01 76 66 F0 | 	shl	result1, #1
07648     35 77 02 F1 | 	add	result1, ptr__fatfs_cc_dat__
0764c     3B 77 E2 FA | 	rdword	result1, result1
07650     3B 91 0A F2 | 	cmp	arg01, result1 wz
07654     01 7C 06 51 |  if_ne	add	_var01, #1
07658     D8 FF 9F 5D |  if_ne	jmp	#LR__1220
0765c                 | LR__1221
0765c                 | LR__1222
0765c     3E 7D 32 F9 | 	getword	_var01, _var01, #0
07660     80 7C 06 F1 | 	add	_var01, #128
07664     3E 7D E2 F8 | 	getbyte	_var01, _var01, #0
07668                 | LR__1223
07668                 | LR__1224
07668                 | ' 			c = (c + 0x80) & 0xFF;
07668                 | ' 		}
07668                 | ' 	}
07668                 | ' 
07668                 | ' 	return c;
07668     3E 77 02 F6 | 	mov	result1, _var01
0766c                 | _fatfs_cc_ff_uni2oem_ret
0766c     2D 00 64 FD | 	ret
07670                 | 
07670                 | _fatfs_cc_ff_oem2uni
07670     00 7C 06 F6 | 	mov	_var01, #0
07674     48 77 32 F9 | 	getword	result1, arg01, #0
07678     80 76 16 F2 | 	cmp	result1, #128 wc
0767c     48 7D 02 C6 |  if_b	mov	_var01, arg01
07680     2C 00 90 CD |  if_b	jmp	#LR__1231
07684     49 93 32 F9 | 	getword	arg02, arg02, #0
07688     01 00 00 FF 
0768c     52 93 0E F2 | 	cmp	arg02, ##850 wz
07690     1C 00 90 5D |  if_ne	jmp	#LR__1230
07694     48 77 32 F9 | 	getword	result1, arg01, #0
07698     00 77 16 F2 | 	cmp	result1, #256 wc
0769c     48 91 32 C9 |  if_b	getword	arg01, arg01, #0
076a0     80 90 86 C1 |  if_b	sub	arg01, #128
076a4     01 90 66 C0 |  if_b	shl	arg01, #1
076a8     35 91 02 C1 |  if_b	add	arg01, ptr__fatfs_cc_dat__
076ac     48 7D E2 CA |  if_b	rdword	_var01, arg01
076b0                 | LR__1230
076b0                 | LR__1231
076b0                 | ' 		}
076b0                 | ' 	}
076b0                 | ' 
076b0                 | ' 	return c;
076b0     3E 77 02 F6 | 	mov	result1, _var01
076b4                 | _fatfs_cc_ff_oem2uni_ret
076b4     2D 00 64 FD | 	ret
076b8                 | 
076b8                 | _fatfs_cc_ff_wtoupper
076b8     48 7D 02 F6 | 	mov	_var01, arg01
076bc     80 00 00 FF 
076c0     00 7C 16 F2 | 	cmp	_var01, ##65536 wc
076c4     58 01 90 3D |  if_ae	jmp	#LR__1253
076c8     3E 7F 02 F6 | 	mov	_var02, _var01
076cc     3F 7D 32 F9 | 	getword	_var01, _var02, #0
076d0     08 00 00 FF 
076d4     00 7C 16 F2 | 	cmp	_var01, ##4096 wc
076d8     35 81 02 C6 |  if_b	mov	_var03, ptr__fatfs_cc_dat__
076dc     00 81 06 C1 |  if_b	add	_var03, #256
076e0     35 81 02 36 |  if_ae	mov	_var03, ptr__fatfs_cc_dat__
076e4     01 00 00 3F 
076e8     F2 80 06 31 |  if_ae	add	_var03, ##754
076ec     40 83 02 F6 | 	mov	_var04, _var03
076f0                 | ' 		uc = (WORD)uni;
076f0                 | ' 		p = uc < 0x1000 ? cvt1 : cvt2;
076f0                 | ' 		for (;;) {
076f0                 | LR__1240
076f0     41 85 E2 FA | 	rdword	_var05, _var04
076f4     42 81 02 F6 | 	mov	_var03, _var05
076f8     0F 80 4E F7 | 	zerox	_var03, #15 wz
076fc     02 82 06 F1 | 	add	_var04, #2
07700     18 01 90 AD |  if_e	jmp	#LR__1252
07704     3F 81 32 F9 | 	getword	_var03, _var02, #0
07708     42 7D 32 F9 | 	getword	_var01, _var05, #0
0770c     3E 81 12 F2 | 	cmp	_var03, _var01 wc
07710     08 01 90 CD |  if_b	jmp	#LR__1252
07714     41 87 E2 FA | 	rdword	_var06, _var04
07718     43 89 32 F9 | 	getword	_var07, _var06, #0
0771c     08 88 46 F0 | 	shr	_var07, #8
07720     43 87 32 F9 | 	getword	_var06, _var06, #0
07724     43 87 E2 F8 | 	getbyte	_var06, _var06, #0
07728     3F 8B 32 F9 | 	getword	_var08, _var02, #0
0772c     42 8D 32 F9 | 	getword	_var09, _var05, #0
07730     43 81 32 F9 | 	getword	_var03, _var06, #0
07734     40 8D 02 F1 | 	add	_var09, _var03
07738     46 8B 52 F2 | 	cmps	_var08, _var09 wc
0773c     02 82 06 F1 | 	add	_var04, #2
07740     C4 00 90 3D |  if_ae	jmp	#LR__1251
07744                 | ' 				switch (cmd) {
07744     44 8F 32 F9 | 	getword	_var10, _var07, #0
07748     09 8E 26 F3 | 	fle	_var10, #9
0774c     30 8E 62 FD | 	jmprel	_var10
07750                 | LR__1241
07750     24 00 90 FD | 	jmp	#LR__1242
07754     3C 00 90 FD | 	jmp	#LR__1243
07758     54 00 90 FD | 	jmp	#LR__1244
0775c     5C 00 90 FD | 	jmp	#LR__1245
07760     64 00 90 FD | 	jmp	#LR__1246
07764     6C 00 90 FD | 	jmp	#LR__1247
07768     74 00 90 FD | 	jmp	#LR__1248
0776c     7C 00 90 FD | 	jmp	#LR__1249
07770     84 00 90 FD | 	jmp	#LR__1250
07774     A4 00 90 FD | 	jmp	#LR__1252
07778                 | LR__1242
07778     3F 7F 32 F9 | 	getword	_var02, _var02, #0
0777c     42 85 32 F9 | 	getword	_var05, _var05, #0
07780     42 7F 82 F1 | 	sub	_var02, _var05
07784     01 7E 66 F0 | 	shl	_var02, #1
07788     41 7F 02 F1 | 	add	_var02, _var04
0778c     3F 7F E2 FA | 	rdword	_var02, _var02
07790     88 00 90 FD | 	jmp	#LR__1252
07794                 | LR__1243
07794     3F 8B 32 F9 | 	getword	_var08, _var02, #0
07798     3F 7F 32 F9 | 	getword	_var02, _var02, #0
0779c     42 85 32 F9 | 	getword	_var05, _var05, #0
077a0     42 7F 82 F1 | 	sub	_var02, _var05
077a4     01 7E 06 F5 | 	and	_var02, #1
077a8     45 7F C2 F2 | 	subr	_var02, _var08
077ac     6C 00 90 FD | 	jmp	#LR__1252
077b0                 | LR__1244
077b0     3F 7F 32 F9 | 	getword	_var02, _var02, #0
077b4     10 7E 86 F1 | 	sub	_var02, #16
077b8     60 00 90 FD | 	jmp	#LR__1252
077bc                 | LR__1245
077bc     3F 7F 32 F9 | 	getword	_var02, _var02, #0
077c0     20 7E 86 F1 | 	sub	_var02, #32
077c4     54 00 90 FD | 	jmp	#LR__1252
077c8                 | LR__1246
077c8     3F 7F 32 F9 | 	getword	_var02, _var02, #0
077cc     30 7E 86 F1 | 	sub	_var02, #48
077d0     48 00 90 FD | 	jmp	#LR__1252
077d4                 | LR__1247
077d4     3F 7F 32 F9 | 	getword	_var02, _var02, #0
077d8     1A 7E 86 F1 | 	sub	_var02, #26
077dc     3C 00 90 FD | 	jmp	#LR__1252
077e0                 | LR__1248
077e0     3F 7F 32 F9 | 	getword	_var02, _var02, #0
077e4     08 7E 06 F1 | 	add	_var02, #8
077e8     30 00 90 FD | 	jmp	#LR__1252
077ec                 | LR__1249
077ec     3F 7F 32 F9 | 	getword	_var02, _var02, #0
077f0     50 7E 86 F1 | 	sub	_var02, #80
077f4     24 00 90 FD | 	jmp	#LR__1252
077f8                 | LR__1250
077f8     3F 7F 32 F9 | 	getword	_var02, _var02, #0
077fc     0E 00 00 FF 
07800     60 7E 86 F1 | 	sub	_var02, ##7264
07804                 | ' 				}
07804                 | ' 				break;
07804     14 00 90 FD | 	jmp	#LR__1252
07808                 | LR__1251
07808     0F 88 4E F7 | 	zerox	_var07, #15 wz
0780c     43 87 32 A9 |  if_e	getword	_var06, _var06, #0
07810     01 86 66 A0 |  if_e	shl	_var06, #1
07814     43 83 02 A1 |  if_e	add	_var04, _var06
07818     D4 FE 9F FD | 	jmp	#LR__1240
0781c                 | LR__1252
0781c     3F 7D 32 F9 | 	getword	_var01, _var02, #0
07820                 | LR__1253
07820                 | ' 		}
07820                 | ' 		uni = uc;
07820                 | ' 	}
07820                 | ' 
07820                 | ' 	return uni;
07820     3E 77 02 F6 | 	mov	result1, _var01
07824                 | _fatfs_cc_ff_wtoupper_ret
07824     2D 00 64 FD | 	ret
07828                 | 
07828                 | _fatfs_cc_strncpy
07828     48 7D 02 F6 | 	mov	_var01, arg01
0782c     D7 18 48 FB | 	callpa	#(@LR__1261-@LR__1260)>>2,fcache_load_ptr_
07830                 | ' 
07830                 | ' 	dscan = dst;
07830                 | ' 	sscan = src;
07830                 | ' 	count = n;
07830                 | ' 	while (--count >= 0 && (*dscan++ = *sscan++) != '\0')
07830                 | LR__1260
07830     01 94 86 F1 | 	sub	arg03, #1
07834     00 94 56 F2 | 	cmps	arg03, #0 wc
07838     24 00 90 CD |  if_b	jmp	#LR__1262
0783c     49 77 02 F6 | 	mov	result1, arg02
07840     01 76 06 F1 | 	add	result1, #1
07844     49 7F C2 FA | 	rdbyte	_var02, arg02
07848     3B 93 02 F6 | 	mov	arg02, result1
0784c     3E 7F 42 FC | 	wrbyte	_var02, _var01
07850     3F 7F E2 F8 | 	getbyte	_var02, _var02, #0
07854     07 7E 4E F7 | 	zerox	_var02, #7 wz
07858                 | ' 		continue;
07858     01 7C 06 F1 | 	add	_var01, #1
0785c     D0 FF 9F 5D |  if_ne	jmp	#LR__1260
07860                 | LR__1261
07860                 | LR__1262
07860     D7 0C 48 FB | 	callpa	#(@LR__1264-@LR__1263)>>2,fcache_load_ptr_
07864                 | ' 	while (--count >= 0)
07864                 | LR__1263
07864     01 94 86 F1 | 	sub	arg03, #1
07868     00 94 56 F2 | 	cmps	arg03, #0 wc
0786c     3E 81 02 36 |  if_ae	mov	_var03, _var01
07870     01 7C 06 31 |  if_ae	add	_var01, #1
07874     40 01 48 3C |  if_ae	wrbyte	#0, _var03
07878     E8 FF 9F 3D |  if_ae	jmp	#LR__1263
0787c                 | LR__1264
0787c                 | ' 		*dscan++ = '\0';
0787c                 | ' 	return(dst);
0787c     48 77 02 F6 | 	mov	result1, arg01
07880                 | _fatfs_cc_strncpy_ret
07880     2D 00 64 FD | 	ret
07884                 | 
07884                 | _fatfs_cc_memcmp
07884                 | ' 	for (n = size; n > 0; n--)
07884     00 94 0E F2 | 	cmp	arg03, #0 wz
07888     28 00 90 AD |  if_e	jmp	#LR__1271
0788c                 | LR__1270
0788c     48 7D C2 FA | 	rdbyte	_var01, arg01
07890     49 7F C2 FA | 	rdbyte	_var02, arg02
07894     3F 7D 0A F2 | 	cmp	_var01, _var02 wz
07898     01 90 06 A1 |  if_e	add	arg01, #1
0789c     01 92 06 A1 |  if_e	add	arg02, #1
078a0                 | ' 			return( ((unsigned char)(*scan1))  -  ((unsigned char)(*scan2)) );
078a0     48 77 C2 5A |  if_ne	rdbyte	result1, arg01
078a4     49 7F C2 5A |  if_ne	rdbyte	_var02, arg02
078a8     3F 77 82 51 |  if_ne	sub	result1, _var02
078ac     08 00 90 5D |  if_ne	jmp	#_fatfs_cc_memcmp_ret
078b0     F6 95 6E FB | 	djnz	arg03, #LR__1270
078b4                 | LR__1271
078b4                 | ' 
078b4                 | ' 	return(0);
078b4     00 76 06 F6 | 	mov	result1, #0
078b8                 | _fatfs_cc_memcmp_ret
078b8     2D 00 64 FD | 	ret
078bc                 | 
078bc                 | _fatfs_cc_strncmp
078bc     48 7D 0A F6 | 	mov	_var01, arg01 wz
078c0     14 00 90 5D |  if_ne	jmp	#LR__1280
078c4                 | ' 		return scan2 ? -1 : 0;
078c4     00 92 0E F2 | 	cmp	arg02, #0 wz
078c8     01 7E 66 56 |  if_ne	neg	_var02, #1
078cc     00 7E 06 A6 |  if_e	mov	_var02, #0
078d0     3F 77 02 F6 | 	mov	result1, _var02
078d4     74 00 90 FD | 	jmp	#_fatfs_cc_strncmp_ret
078d8                 | LR__1280
078d8     00 92 0E F2 | 	cmp	arg02, #0 wz
078dc     01 76 06 A6 |  if_e	mov	result1, #1
078e0     68 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
078e4     4A 81 02 F6 | 	mov	_var03, arg03
078e8     D7 16 48 FB | 	callpa	#(@LR__1282-@LR__1281)>>2,fcache_load_ptr_
078ec                 | ' 	count = n;
078ec                 | ' 	do {
078ec                 | LR__1281
078ec     3E 83 C2 FA | 	rdbyte	_var04, _var01
078f0     49 85 02 F6 | 	mov	_var05, arg02
078f4     42 87 C2 FA | 	rdbyte	_var06, _var05
078f8     01 80 86 F1 | 	sub	_var03, #1
078fc     00 80 56 F2 | 	cmps	_var03, #0 wc
07900     01 7C 06 F1 | 	add	_var01, #1
07904     01 92 06 F1 | 	add	arg02, #1
07908     00 82 0E 32 |  if_ae	cmp	_var04, #0 wz
0790c     08 00 90 2D |  if_nc_and_z	jmp	#LR__1283
07910     43 83 0A 32 |  if_ae	cmp	_var04, _var06 wz
07914     D4 FF 9F 2D |  if_nc_and_z	jmp	#LR__1281
07918                 | LR__1282
07918                 | LR__1283
07918     00 80 56 F2 | 	cmps	_var03, #0 wc
0791c                 | ' 		return(0);
0791c     00 76 06 C6 |  if_b	mov	result1, #0
07920     28 00 90 CD |  if_b	jmp	#_fatfs_cc_strncmp_ret
07924     43 83 0A F2 | 	cmp	_var04, _var06 wz
07928                 | ' 		return(0);
07928     00 76 06 A6 |  if_e	mov	result1, #0
0792c     1C 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
07930     00 82 0E F2 | 	cmp	_var04, #0 wz
07934                 | ' 		return(-1);
07934     01 76 66 A6 |  if_e	neg	result1, #1
07938     10 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
0793c     00 86 0E F2 | 	cmp	_var06, #0 wz
07940                 | ' 		return(1);
07940     01 76 06 A6 |  if_e	mov	result1, #1
07944                 | ' 		return(c1 - c2);
07944     41 77 02 56 |  if_ne	mov	result1, _var04
07948     43 77 82 51 |  if_ne	sub	result1, _var06
0794c                 | _fatfs_cc_strncmp_ret
0794c     2D 00 64 FD | 	ret
07950                 | 
07950                 | _fatfs_cc_strchr
07950                 | ' #line 16 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/libc/string/strchr.c"
07950                 | ' 	while ((c = *s++) != (char) charwanted)
07950                 | LR__1290
07950     48 7D 02 F6 | 	mov	_var01, arg01
07954     3E 7F C2 FA | 	rdbyte	_var02, _var01
07958     3F 81 E2 F8 | 	getbyte	_var03, _var02, #0
0795c     49 83 E2 F8 | 	getbyte	_var04, arg02, #0
07960     41 81 0A F2 | 	cmp	_var03, _var04 wz
07964     01 90 06 F1 | 	add	arg01, #1
07968     14 00 90 AD |  if_e	jmp	#LR__1291
0796c     3F 81 02 F6 | 	mov	_var03, _var02
07970     07 80 4E F7 | 	zerox	_var03, #7 wz
07974     00 76 06 A6 |  if_e	mov	result1, #0
07978     0C 00 90 AD |  if_e	jmp	#_fatfs_cc_strchr_ret
0797c     D0 FF 9F FD | 	jmp	#LR__1290
07980                 | LR__1291
07980                 | ' 	return((char *)--s);
07980     01 90 86 F1 | 	sub	arg01, #1
07984     48 77 02 F6 | 	mov	result1, arg01
07988                 | _fatfs_cc_strchr_ret
07988     2D 00 64 FD | 	ret
0798c                 | 
0798c                 | _fatfs_cc_time
0798c     01 CA 05 F6 | 	mov	COUNT_, #1
07990     E8 00 A0 FD | 	call	#pushregs_
07994     14 F0 07 F1 | 	add	ptra, #20
07998     48 A7 02 F6 | 	mov	local01, arg01
0799c     E7 90 02 F6 | 	mov	arg01, fp
079a0     08 90 06 F1 | 	add	arg01, #8
079a4     00 92 06 F6 | 	mov	arg02, #0
079a8     88 5E B0 FD | 	call	#_fatfs_cc_gettimeofday
079ac     08 CE 05 F1 | 	add	fp, #8
079b0     E7 76 02 FB | 	rdlong	result1, fp
079b4     08 CE 85 F1 | 	sub	fp, #8
079b8     00 A6 0E F2 | 	cmp	local01, #0 wz
079bc     53 77 62 5C |  if_ne	wrlong	result1, local01
079c0                 | '         *tp = now;
079c0                 | '     return now;
079c0     E7 F0 03 F6 | 	mov	ptra, fp
079c4     F2 00 A0 FD | 	call	#popregs_
079c8                 | _fatfs_cc_time_ret
079c8     2D 00 64 FD | 	ret
079cc                 | 
079cc                 | _fatfs_cc_mktime
079cc     06 CA 05 F6 | 	mov	COUNT_, #6
079d0     E8 00 A0 FD | 	call	#pushregs_
079d4     48 A7 02 F6 | 	mov	local01, arg01
079d8     14 A6 06 F1 | 	add	local01, #20
079dc     53 91 02 FB | 	rdlong	arg01, local01
079e0     14 A6 86 F1 | 	sub	local01, #20
079e4     46 90 56 F2 | 	cmps	arg01, #70 wc
079e8                 | '                 return (time_t) -1;
079e8     01 76 66 C6 |  if_b	neg	result1, #1
079ec     78 01 90 CD |  if_b	jmp	#LR__1304
079f0     03 00 00 FF 
079f4     6C A9 06 F6 | 	mov	local02, ##1900
079f8     14 A6 06 F1 | 	add	local01, #20
079fc     53 77 02 FB | 	rdlong	result1, local01
07a00     3B A9 02 F1 | 	add	local02, result1
07a04     08 A6 86 F1 | 	sub	local01, #8
07a08     53 AB 02 FB | 	rdlong	local03, local01
07a0c     01 AA 86 F1 | 	sub	local03, #1
07a10     04 A6 06 F1 | 	add	local01, #4
07a14     53 91 02 FB | 	rdlong	arg01, local01
07a18     10 A6 86 F1 | 	sub	local01, #16
07a1c     02 90 66 F0 | 	shl	arg01, #2
07a20     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
07a24     02 00 00 FF 
07a28     78 76 06 F1 | 	add	result1, ##1144
07a2c     3B 91 02 F1 | 	add	arg01, result1
07a30     48 77 02 FB | 	rdlong	result1, arg01
07a34     3B AB 02 F1 | 	add	local03, result1
07a38     54 91 02 F6 | 	mov	arg01, local02
07a3c     9C 5E B0 FD | 	call	#_fatfs_cc__is_leap_year
07a40     00 76 0E F2 | 	cmp	result1, #0 wz
07a44     1C 00 90 AD |  if_e	jmp	#LR__1300
07a48     00 AC 06 F6 | 	mov	local04, #0
07a4c     10 A6 06 F1 | 	add	local01, #16
07a50     53 77 02 FB | 	rdlong	result1, local01
07a54     10 A6 86 F1 | 	sub	local01, #16
07a58     02 76 56 F2 | 	cmps	result1, #2 wc
07a5c     01 AC 06 36 |  if_ae	mov	local04, #1
07a60     04 00 90 FD | 	jmp	#LR__1301
07a64                 | LR__1300
07a64     00 AC 06 F6 | 	mov	local04, #0
07a68                 | LR__1301
07a68     04 A6 06 F1 | 	add	local01, #4
07a6c     53 91 02 FB | 	rdlong	arg01, local01
07a70     04 A6 86 F1 | 	sub	local01, #4
07a74     53 AF 02 FB | 	rdlong	local05, local01
07a78     08 A6 06 F1 | 	add	local01, #8
07a7c     53 77 02 FB | 	rdlong	result1, local01
07a80     07 00 00 FF 
07a84     10 76 06 FD | 	qmul	result1, ##3600
07a88     56 AB 02 F1 | 	add	local03, local04
07a8c     48 AD 02 F6 | 	mov	local04, arg01
07a90     04 AC 66 F0 | 	shl	local04, #4
07a94     48 AD 82 F1 | 	sub	local04, arg01
07a98     02 AC 66 F0 | 	shl	local04, #2
07a9c     56 AF 02 F1 | 	add	local05, local04
07aa0     08 A6 86 F1 | 	sub	local01, #8
07aa4     18 AC 62 FD | 	getqx	local04
07aa8     A8 00 00 FF 
07aac     80 AB 06 FD | 	qmul	local03, ##86400
07ab0     56 AF 02 F1 | 	add	local05, local04
07ab4     54 AB 02 F6 | 	mov	local03, local02
07ab8     03 00 00 FF 
07abc     B2 AB 86 F1 | 	sub	local03, ##1970
07ac0     18 AC 62 FD | 	getqx	local04
07ac4     99 F0 00 FF 
07ac8     80 AB 06 FD | 	qmul	local03, ##31536000
07acc     56 AF 02 F1 | 	add	local05, local04
07ad0     54 AB 02 F6 | 	mov	local03, local02
07ad4     03 00 00 FF 
07ad8     B1 AB 86 F1 | 	sub	local03, ##1969
07adc     55 B1 52 F6 | 	abs	local06, local03 wc
07ae0     02 B0 46 F0 | 	shr	local06, #2
07ae4     58 B1 82 F6 | 	negc	local06, local06
07ae8     03 00 00 FF 
07aec     D1 A9 56 F2 | 	cmps	local02, ##2001 wc
07af0     18 AC 62 FD | 	getqx	local04
07af4     56 AF 02 F1 | 	add	local05, local04
07af8     18 00 90 CD |  if_b	jmp	#LR__1302
07afc     03 00 00 FF 
07b00     D0 A9 86 F1 | 	sub	local02, ##2000
07b04     54 AD 52 F6 | 	abs	local04, local02 wc
07b08     64 AC 16 FD | 	qdiv	local04, #100
07b0c     18 AC 62 FD | 	getqx	local04
07b10     56 B1 A2 F3 | 	sumnc	local06, local04
07b14                 | LR__1302
07b14     A8 00 00 FF 
07b18     80 B1 06 FD | 	qmul	local06, ##86400
07b1c     18 B0 62 FD | 	getqx	local06
07b20     58 AF 02 F1 | 	add	local05, local06
07b24     E8 01 B0 FD | 	call	#_fatfs_cc__tzset
07b28     02 00 00 FF 
07b2c     44 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1092
07b30     35 B1 02 FB | 	rdlong	local06, ptr__fatfs_cc_dat__
07b34     58 AF 02 F1 | 	add	local05, local06
07b38     68 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, #104
07b3c     35 AB 02 FB | 	rdlong	local03, ptr__fatfs_cc_dat__
07b40     02 00 00 FF 
07b44     AC 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1196
07b48     01 AA 0E F2 | 	cmp	local03, #1 wz
07b4c     14 00 90 5D |  if_ne	jmp	#LR__1303
07b50     53 91 02 F6 | 	mov	arg01, local01
07b54     70 60 B0 FD | 	call	#_fatfs_cc___indst
07b58     00 76 0E F2 | 	cmp	result1, #0 wz
07b5c     07 00 00 5F 
07b60     10 AE 86 51 |  if_ne	sub	local05, ##3600
07b64                 | LR__1303
07b64                 | '                 s -=  (3600L) ;
07b64                 | ' 
07b64                 | '         return s;
07b64     57 77 02 F6 | 	mov	result1, local05
07b68                 | LR__1304
07b68     E7 F0 03 F6 | 	mov	ptra, fp
07b6c     F2 00 A0 FD | 	call	#popregs_
07b70                 | _fatfs_cc_mktime_ret
07b70     2D 00 64 FD | 	ret
07b74                 | 
07b74                 | _fatfs_cc__gmtime_r
07b74     03 CA 05 F6 | 	mov	COUNT_, #3
07b78     E8 00 A0 FD | 	call	#pushregs_
07b7c     48 A7 02 FB | 	rdlong	local01, arg01
07b80     A8 00 00 FF 
07b84     80 A7 16 FD | 	qdiv	local01, ##86400
07b88     18 76 62 FD | 	getqx	result1
07b8c     04 76 06 F1 | 	add	result1, #4
07b90     07 76 16 FD | 	qdiv	result1, #7
07b94     18 92 06 F1 | 	add	arg02, #24
07b98     D1 7F 27 FF 
07b9c     00 A6 16 F2 | 	cmp	local01, ##1325376000 wc
07ba0     D1 7F 27 3F 
07ba4     00 A6 86 31 |  if_ae	sub	local01, ##1325376000
07ba8     03 00 00 3F 
07bac     DC A9 06 36 |  if_ae	mov	local02, ##2012
07bb0     03 00 00 CF 
07bb4     B2 A9 06 C6 |  if_b	mov	local02, ##1970
07bb8                 | ' 	  year = 1970;
07bb8                 | ' 	}
07bb8                 | ' 
07bb8                 | ' 	for(;;) {
07bb8     19 76 62 FD | 	getqy	result1
07bbc     49 77 62 FC | 	wrlong	result1, arg02
07bc0     18 92 86 F1 | 	sub	arg02, #24
07bc4                 | LR__1310
07bc4     54 91 02 F6 | 	mov	arg01, local02
07bc8     10 5D B0 FD | 	call	#_fatfs_cc__is_leap_year
07bcc     00 76 0E F2 | 	cmp	result1, #0 wz
07bd0     42 F1 00 5F 
07bd4     00 AB 06 56 |  if_ne	mov	local03, ##31622400
07bd8     99 F0 00 AF 
07bdc     80 AB 06 A6 |  if_e	mov	local03, ##31536000
07be0     55 A7 12 F2 | 	cmp	local01, local03 wc
07be4                 | ' 	    break;
07be4     01 A8 06 31 |  if_ae	add	local02, #1
07be8     55 A7 82 31 |  if_ae	sub	local01, local03
07bec     D4 FF 9F 3D |  if_ae	jmp	#LR__1310
07bf0     A8 00 00 FF 
07bf4     80 A7 16 FD | 	qdiv	local01, ##86400
07bf8     54 AB 02 F6 | 	mov	local03, local02
07bfc     03 00 00 FF 
07c00     6C AB 86 F1 | 	sub	local03, ##1900
07c04     14 92 06 F1 | 	add	arg02, #20
07c08     49 AB 62 FC | 	wrlong	local03, arg02
07c0c     08 92 06 F1 | 	add	arg02, #8
07c10     54 91 02 F6 | 	mov	arg01, local02
07c14     18 A8 62 FD | 	getqx	local02
07c18     49 A9 62 FC | 	wrlong	local02, arg02
07c1c     1C 92 86 F1 | 	sub	arg02, #28
07c20     B8 5C B0 FD | 	call	#_fatfs_cc__is_leap_year
07c24     00 76 0E F2 | 	cmp	result1, #0 wz
07c28     1D AA 06 56 |  if_ne	mov	local03, #29
07c2c     1C AA 06 A6 |  if_e	mov	local03, #28
07c30     02 00 00 FF 
07c34     4C 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1100
07c38     35 AB 62 FC | 	wrlong	local03, ptr__fatfs_cc_dat__
07c3c     02 00 00 FF 
07c40     4C 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1100
07c44                 | ' 
07c44                 | '         days_per_mth[1] = _is_leap_year(year) ? 29 : 28;
07c44                 | '         for (i = 0; mday >= days_per_mth[i]; i++)
07c44     00 90 06 F6 | 	mov	arg01, #0
07c48     D7 26 48 FB | 	callpa	#(@LR__1312-@LR__1311)>>2,fcache_load_ptr_
07c4c                 | LR__1311
07c4c     48 AB 02 F6 | 	mov	local03, arg01
07c50     02 AA 66 F0 | 	shl	local03, #2
07c54     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
07c58     02 00 00 FF 
07c5c     48 76 06 F1 | 	add	result1, ##1096
07c60     3B AB 02 F1 | 	add	local03, result1
07c64     55 AB 02 FB | 	rdlong	local03, local03
07c68     55 A9 52 F2 | 	cmps	local02, local03 wc
07c6c     28 00 90 CD |  if_b	jmp	#LR__1313
07c70     48 77 02 F6 | 	mov	result1, arg01
07c74     02 76 66 F0 | 	shl	result1, #2
07c78     35 AB 02 F6 | 	mov	local03, ptr__fatfs_cc_dat__
07c7c     02 00 00 FF 
07c80     48 AA 06 F1 | 	add	local03, ##1096
07c84     55 77 02 F1 | 	add	result1, local03
07c88     3B 77 02 FB | 	rdlong	result1, result1
07c8c     3B A9 82 F1 | 	sub	local02, result1
07c90     01 90 06 F1 | 	add	arg01, #1
07c94     B4 FF 9F FD | 	jmp	#LR__1311
07c98                 | LR__1312
07c98                 | LR__1313
07c98     A8 00 00 FF 
07c9c     80 A7 16 FD | 	qdiv	local01, ##86400
07ca0     10 92 06 F1 | 	add	arg02, #16
07ca4     49 91 62 FC | 	wrlong	arg01, arg02
07ca8     01 A8 06 F1 | 	add	local02, #1
07cac     04 92 86 F1 | 	sub	arg02, #4
07cb0     49 A9 62 FC | 	wrlong	local02, arg02
07cb4     19 A6 62 FD | 	getqy	local01
07cb8     07 00 00 FF 
07cbc     10 A6 16 FD | 	qdiv	local01, ##3600
07cc0     18 AA 62 FD | 	getqx	local03
07cc4     07 00 00 FF 
07cc8     10 A6 16 FD | 	qdiv	local01, ##3600
07ccc     04 92 86 F1 | 	sub	arg02, #4
07cd0     49 AB 62 FC | 	wrlong	local03, arg02
07cd4     19 A6 62 FD | 	getqy	local01
07cd8     3C A6 16 FD | 	qdiv	local01, #60
07cdc     18 AA 62 FD | 	getqx	local03
07ce0     3C A6 16 FD | 	qdiv	local01, #60
07ce4     04 92 86 F1 | 	sub	arg02, #4
07ce8     49 AB 62 FC | 	wrlong	local03, arg02
07cec     04 92 86 F1 | 	sub	arg02, #4
07cf0                 | '         stm->tm_isdst = 0;
07cf0                 | ' 
07cf0                 | ' ;
07cf0                 | '         return stm;
07cf0     49 77 02 F6 | 	mov	result1, arg02
07cf4     19 AA 62 FD | 	getqy	local03
07cf8     49 AB 62 FC | 	wrlong	local03, arg02
07cfc     20 92 06 F1 | 	add	arg02, #32
07d00     49 01 68 FC | 	wrlong	#0, arg02
07d04     E7 F0 03 F6 | 	mov	ptra, fp
07d08     F2 00 A0 FD | 	call	#popregs_
07d0c                 | _fatfs_cc__gmtime_r_ret
07d0c     2D 00 64 FD | 	ret
07d10                 | 
07d10                 | _fatfs_cc__tzset
07d10     6F 00 00 FF 
07d14     3E 91 06 F6 | 	mov	arg01, ##@LR__2147
07d18     0C 50 B0 FD | 	call	#_fatfs_cc_getenv
07d1c     3B 91 02 F6 | 	mov	arg01, result1
07d20     35 93 02 F6 | 	mov	arg02, ptr__fatfs_cc_dat__
07d24     02 00 00 FF 
07d28     AC 92 06 F1 | 	add	arg02, ##1196
07d2c     FC 5B B0 FD | 	call	#_fatfs_cc___tzoffset
07d30     02 00 00 FF 
07d34     44 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1092
07d38     35 77 62 FC | 	wrlong	result1, ptr__fatfs_cc_dat__
07d3c     02 00 00 FF 
07d40     44 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1092
07d44                 | _fatfs_cc__tzset_ret
07d44     2D 00 64 FD | 	ret
07d48                 | 
07d48                 | _fatfs_cc_disk_read
07d48     09 CA 05 F6 | 	mov	COUNT_, #9
07d4c     E8 00 A0 FD | 	call	#pushregs_
07d50     49 AF 02 F6 | 	mov	local05, arg02
07d54     4B B1 02 F6 | 	mov	local06, arg04
07d58     4A 91 02 F6 | 	mov	arg01, arg03
07d5c     00 92 06 F6 | 	mov	arg02, #0
07d60     09 94 06 F6 | 	mov	arg03, #9
07d64     00 96 06 F6 | 	mov	arg04, #0
07d68     74 C3 BF FD | 	call	#__system___int64_shl
07d6c     3B A7 02 F6 | 	mov	local01, result1
07d70     3C A9 02 F6 | 	mov	local02, result2
07d74     01 00 00 FF 
07d78     10 62 06 F1 | 	add	objptr, ##528
07d7c     31 79 0A FB | 	rdlong	result2, objptr wz
07d80     01 00 00 FF 
07d84     10 62 86 F1 | 	sub	objptr, ##528
07d88                 | '         return RES_NOTRDY;
07d88     03 76 06 A6 |  if_e	mov	result1, #3
07d8c     E8 00 90 AD |  if_e	jmp	#LR__1320
07d90     53 93 02 F6 | 	mov	arg02, local01
07d94     54 95 02 F6 | 	mov	arg03, local02
07d98     01 00 00 FF 
07d9c     10 62 06 F1 | 	add	objptr, ##528
07da0     31 91 02 FB | 	rdlong	arg01, objptr
07da4     48 97 02 F6 | 	mov	arg04, arg01
07da8     30 96 06 F1 | 	add	arg04, #48
07dac     4B B3 02 FB | 	rdlong	local07, arg04
07db0     59 B5 02 F6 | 	mov	local08, local07
07db4     13 B2 46 F7 | 	zerox	local07, #19
07db8     14 B4 46 F0 | 	shr	local08, #20
07dbc     02 B4 66 F0 | 	shl	local08, #2
07dc0     2D B5 02 F1 | 	add	local08, __methods__
07dc4     5A B5 02 FB | 	rdlong	local08, local08
07dc8     01 00 00 FF 
07dcc     10 62 86 F1 | 	sub	objptr, ##528
07dd0     00 96 06 F6 | 	mov	arg04, #0
07dd4     31 B7 02 F6 | 	mov	local09, objptr
07dd8     59 63 02 F6 | 	mov	objptr, local07
07ddc     2D B4 62 FD | 	call	local08
07de0     5B 63 02 F6 | 	mov	objptr, local09
07de4     3B AB 02 F6 | 	mov	local03, result1
07de8     3C AD 02 F6 | 	mov	local04, result2
07dec     55 91 02 F6 | 	mov	arg01, local03
07df0     56 93 02 F6 | 	mov	arg02, local04
07df4     53 95 02 F6 | 	mov	arg03, local01
07df8     54 97 02 F6 | 	mov	arg04, local02
07dfc     00 76 06 F6 | 	mov	result1, #0
07e00     4A 91 1A F2 | 	cmp	arg01, arg03 wcz
07e04     4B 93 7A F2 | 	cmpsx	arg02, arg04 wcz
07e08     01 76 86 56 |  if_ne	negc	result1, #1
07e0c     00 76 0E F2 | 	cmp	result1, #0 wz
07e10                 | '         return RES_ERROR;
07e10     01 76 06 56 |  if_ne	mov	result1, #1
07e14     60 00 90 5D |  if_ne	jmp	#LR__1320
07e18     09 B0 66 F0 | 	shl	local06, #9
07e1c     01 00 00 FF 
07e20     10 62 06 F1 | 	add	objptr, ##528
07e24     31 91 02 FB | 	rdlong	arg01, objptr
07e28     48 AB 02 F6 | 	mov	local03, arg01
07e2c     14 AA 06 F1 | 	add	local03, #20
07e30     55 AB 02 FB | 	rdlong	local03, local03
07e34     55 B7 02 F6 | 	mov	local09, local03
07e38     13 B6 46 F7 | 	zerox	local09, #19
07e3c     14 AA 46 F0 | 	shr	local03, #20
07e40     02 AA 66 F0 | 	shl	local03, #2
07e44     2D AB 02 F1 | 	add	local03, __methods__
07e48     55 AB 02 FB | 	rdlong	local03, local03
07e4c     01 00 00 FF 
07e50     10 62 86 F1 | 	sub	objptr, ##528
07e54     57 93 02 F6 | 	mov	arg02, local05
07e58     58 95 02 F6 | 	mov	arg03, local06
07e5c     31 B5 02 F6 | 	mov	local08, objptr
07e60     5B 63 02 F6 | 	mov	objptr, local09
07e64     2D AA 62 FD | 	call	local03
07e68     5A 63 02 F6 | 	mov	objptr, local08
07e6c     58 77 0A F2 | 	cmp	result1, local06 wz
07e70                 | '         return RES_ERROR;
07e70     01 76 06 56 |  if_ne	mov	result1, #1
07e74                 | '     }
07e74                 | '     return RES_OK;
07e74     00 76 06 A6 |  if_e	mov	result1, #0
07e78                 | LR__1320
07e78     E7 F0 03 F6 | 	mov	ptra, fp
07e7c     F2 00 A0 FD | 	call	#popregs_
07e80                 | _fatfs_cc_disk_read_ret
07e80     2D 00 64 FD | 	ret
07e84                 | 
07e84                 | _fatfs_cc_disk_write
07e84     09 CA 05 F6 | 	mov	COUNT_, #9
07e88     E8 00 A0 FD | 	call	#pushregs_
07e8c     49 AF 02 F6 | 	mov	local05, arg02
07e90     4B B1 02 F6 | 	mov	local06, arg04
07e94     4A 91 02 F6 | 	mov	arg01, arg03
07e98     00 92 06 F6 | 	mov	arg02, #0
07e9c     09 94 06 F6 | 	mov	arg03, #9
07ea0     00 96 06 F6 | 	mov	arg04, #0
07ea4     38 C2 BF FD | 	call	#__system___int64_shl
07ea8     3B A7 02 F6 | 	mov	local01, result1
07eac     3C A9 02 F6 | 	mov	local02, result2
07eb0     01 00 00 FF 
07eb4     10 62 06 F1 | 	add	objptr, ##528
07eb8     31 79 0A FB | 	rdlong	result2, objptr wz
07ebc     01 00 00 FF 
07ec0     10 62 86 F1 | 	sub	objptr, ##528
07ec4                 | '         return RES_NOTRDY;
07ec4     03 76 06 A6 |  if_e	mov	result1, #3
07ec8     E8 00 90 AD |  if_e	jmp	#LR__1330
07ecc     53 93 02 F6 | 	mov	arg02, local01
07ed0     54 95 02 F6 | 	mov	arg03, local02
07ed4     01 00 00 FF 
07ed8     10 62 06 F1 | 	add	objptr, ##528
07edc     31 91 02 FB | 	rdlong	arg01, objptr
07ee0     48 97 02 F6 | 	mov	arg04, arg01
07ee4     30 96 06 F1 | 	add	arg04, #48
07ee8     4B B3 02 FB | 	rdlong	local07, arg04
07eec     59 B5 02 F6 | 	mov	local08, local07
07ef0     13 B2 46 F7 | 	zerox	local07, #19
07ef4     14 B4 46 F0 | 	shr	local08, #20
07ef8     02 B4 66 F0 | 	shl	local08, #2
07efc     2D B5 02 F1 | 	add	local08, __methods__
07f00     5A B5 02 FB | 	rdlong	local08, local08
07f04     01 00 00 FF 
07f08     10 62 86 F1 | 	sub	objptr, ##528
07f0c     00 96 06 F6 | 	mov	arg04, #0
07f10     31 B7 02 F6 | 	mov	local09, objptr
07f14     59 63 02 F6 | 	mov	objptr, local07
07f18     2D B4 62 FD | 	call	local08
07f1c     5B 63 02 F6 | 	mov	objptr, local09
07f20     3B AB 02 F6 | 	mov	local03, result1
07f24     3C AD 02 F6 | 	mov	local04, result2
07f28     55 91 02 F6 | 	mov	arg01, local03
07f2c     56 93 02 F6 | 	mov	arg02, local04
07f30     53 95 02 F6 | 	mov	arg03, local01
07f34     54 97 02 F6 | 	mov	arg04, local02
07f38     00 76 06 F6 | 	mov	result1, #0
07f3c     4A 91 1A F2 | 	cmp	arg01, arg03 wcz
07f40     4B 93 7A F2 | 	cmpsx	arg02, arg04 wcz
07f44     01 76 86 56 |  if_ne	negc	result1, #1
07f48     00 76 0E F2 | 	cmp	result1, #0 wz
07f4c                 | '         return RES_ERROR;
07f4c     01 76 06 56 |  if_ne	mov	result1, #1
07f50     60 00 90 5D |  if_ne	jmp	#LR__1330
07f54     09 B0 66 F0 | 	shl	local06, #9
07f58     01 00 00 FF 
07f5c     10 62 06 F1 | 	add	objptr, ##528
07f60     31 91 02 FB | 	rdlong	arg01, objptr
07f64     48 AB 02 F6 | 	mov	local03, arg01
07f68     18 AA 06 F1 | 	add	local03, #24
07f6c     55 AB 02 FB | 	rdlong	local03, local03
07f70     55 B7 02 F6 | 	mov	local09, local03
07f74     13 B6 46 F7 | 	zerox	local09, #19
07f78     14 AA 46 F0 | 	shr	local03, #20
07f7c     02 AA 66 F0 | 	shl	local03, #2
07f80     2D AB 02 F1 | 	add	local03, __methods__
07f84     55 AB 02 FB | 	rdlong	local03, local03
07f88     01 00 00 FF 
07f8c     10 62 86 F1 | 	sub	objptr, ##528
07f90     57 93 02 F6 | 	mov	arg02, local05
07f94     58 95 02 F6 | 	mov	arg03, local06
07f98     31 B5 02 F6 | 	mov	local08, objptr
07f9c     5B 63 02 F6 | 	mov	objptr, local09
07fa0     2D AA 62 FD | 	call	local03
07fa4     5A 63 02 F6 | 	mov	objptr, local08
07fa8     58 77 0A F2 | 	cmp	result1, local06 wz
07fac                 | '         return RES_ERROR;
07fac     01 76 06 56 |  if_ne	mov	result1, #1
07fb0                 | '     }
07fb0                 | '     return RES_OK;
07fb0     00 76 06 A6 |  if_e	mov	result1, #0
07fb4                 | LR__1330
07fb4     E7 F0 03 F6 | 	mov	ptra, fp
07fb8     F2 00 A0 FD | 	call	#popregs_
07fbc                 | _fatfs_cc_disk_write_ret
07fbc     2D 00 64 FD | 	ret
07fc0                 | 
07fc0                 | _fatfs_cc_disk_ioctl
07fc0     03 CA 05 F6 | 	mov	COUNT_, #3
07fc4     E8 00 A0 FD | 	call	#pushregs_
07fc8     01 00 00 FF 
07fcc     10 62 06 F1 | 	add	objptr, ##528
07fd0     31 91 0A FB | 	rdlong	arg01, objptr wz
07fd4     01 00 00 FF 
07fd8     10 62 86 F1 | 	sub	objptr, ##528
07fdc                 | '         return RES_NOTRDY;
07fdc     03 76 06 A6 |  if_e	mov	result1, #3
07fe0     58 00 90 AD |  if_e	jmp	#LR__1340
07fe4     01 00 00 FF 
07fe8     10 62 06 F1 | 	add	objptr, ##528
07fec     31 91 02 FB | 	rdlong	arg01, objptr
07ff0     48 A7 02 F6 | 	mov	local01, arg01
07ff4     28 A6 06 F1 | 	add	local01, #40
07ff8     53 A7 02 FB | 	rdlong	local01, local01
07ffc     53 A9 02 F6 | 	mov	local02, local01
08000     13 A8 46 F7 | 	zerox	local02, #19
08004     14 A6 46 F0 | 	shr	local01, #20
08008     02 A6 66 F0 | 	shl	local01, #2
0800c     2D A7 02 F1 | 	add	local01, __methods__
08010     53 A7 02 FB | 	rdlong	local01, local01
08014     01 00 00 FF 
08018     10 62 86 F1 | 	sub	objptr, ##528
0801c     49 93 E2 F8 | 	getbyte	arg02, arg02, #0
08020     31 AB 02 F6 | 	mov	local03, objptr
08024     54 63 02 F6 | 	mov	objptr, local02
08028     2D A6 62 FD | 	call	local01
0802c     55 63 02 F6 | 	mov	objptr, local03
08030     00 76 0E F2 | 	cmp	result1, #0 wz
08034                 | '         return RES_ERROR;
08034     01 76 06 56 |  if_ne	mov	result1, #1
08038                 | '     return RES_OK;
08038     00 76 06 A6 |  if_e	mov	result1, #0
0803c                 | LR__1340
0803c     E7 F0 03 F6 | 	mov	ptra, fp
08040     F2 00 A0 FD | 	call	#popregs_
08044                 | _fatfs_cc_disk_ioctl_ret
08044     2D 00 64 FD | 	ret
08048                 | 
08048                 | _fatfs_cc_tchar2uni
08048     48 7D 02 FB | 	rdlong	_var01, arg01
0804c     3E 7F 02 F6 | 	mov	_var02, _var01
08050     01 7C 06 F1 | 	add	_var01, #1
08054     3E 81 02 F6 | 	mov	_var03, _var01
08058     3F 83 C2 FA | 	rdbyte	_var04, _var02
0805c     80 82 CE F7 | 	test	_var04, #128 wz
08060     E8 00 90 AD |  if_e	jmp	#LR__1357
08064     41 85 02 F6 | 	mov	_var05, _var04
08068     E0 84 06 F5 | 	and	_var05, #224
0806c     C0 84 0E F2 | 	cmp	_var05, #192 wz
08070     1F 82 06 A5 |  if_e	and	_var04, #31
08074     01 86 06 A6 |  if_e	mov	_var06, #1
08078     34 00 90 AD |  if_e	jmp	#LR__1351
0807c     41 85 02 F6 | 	mov	_var05, _var04
08080     F0 84 06 F5 | 	and	_var05, #240
08084     E0 84 0E F2 | 	cmp	_var05, #224 wz
08088     41 83 42 A8 |  if_e	getnib	_var04, _var04, #0
0808c     02 86 06 A6 |  if_e	mov	_var06, #2
08090     1C 00 90 AD |  if_e	jmp	#LR__1350
08094     41 85 02 F6 | 	mov	_var05, _var04
08098     F8 84 06 F5 | 	and	_var05, #248
0809c     F0 84 0E F2 | 	cmp	_var05, #240 wz
080a0     07 82 06 A5 |  if_e	and	_var04, #7
080a4     03 86 06 A6 |  if_e	mov	_var06, #3
080a8                 | ' 			return 0xFFFFFFFF;
080a8     01 76 66 56 |  if_ne	neg	result1, #1
080ac     A4 00 90 5D |  if_ne	jmp	#_fatfs_cc_tchar2uni_ret
080b0                 | LR__1350
080b0                 | LR__1351
080b0                 | ' 		}
080b0                 | ' 		do {
080b0                 | LR__1352
080b0     40 89 C2 FA | 	rdbyte	_var07, _var03
080b4     44 85 E2 F8 | 	getbyte	_var05, _var07, #0
080b8     C0 84 06 F5 | 	and	_var05, #192
080bc     80 84 0E F2 | 	cmp	_var05, #128 wz
080c0     01 80 06 F1 | 	add	_var03, #1
080c4     01 76 66 56 |  if_ne	neg	result1, #1
080c8     88 00 90 5D |  if_ne	jmp	#_fatfs_cc_tchar2uni_ret
080cc     06 82 66 F0 | 	shl	_var04, #6
080d0     44 7F E2 F8 | 	getbyte	_var02, _var07, #0
080d4     3F 7E 06 F5 | 	and	_var02, #63
080d8     3F 83 42 F5 | 	or	_var04, _var02
080dc     F4 87 6E FB | 	djnz	_var06, #LR__1352
080e0     80 82 16 F2 | 	cmp	_var04, #128 wc
080e4     24 00 90 CD |  if_b	jmp	#LR__1354
080e8     6C 00 00 FF 
080ec     00 82 16 F2 | 	cmp	_var04, ##55296 wc
080f0     0C 00 90 CD |  if_b	jmp	#LR__1353
080f4     70 00 00 FF 
080f8     00 82 16 F2 | 	cmp	_var04, ##57344 wc
080fc     0C 00 90 CD |  if_b	jmp	#LR__1354
08100                 | LR__1353
08100     80 08 00 FF 
08104     00 82 16 F2 | 	cmp	_var04, ##1114112 wc
08108     08 00 90 CD |  if_b	jmp	#LR__1355
0810c                 | LR__1354
0810c     01 76 66 F6 | 	neg	result1, #1
08110     40 00 90 FD | 	jmp	#_fatfs_cc_tchar2uni_ret
08114                 | LR__1355
08114     80 00 00 FF 
08118     00 82 16 F2 | 	cmp	_var04, ##65536 wc
0811c     2C 00 90 CD |  if_b	jmp	#LR__1356
08120     41 7F 02 F6 | 	mov	_var02, _var04
08124     80 00 00 FF 
08128     00 7E 86 F1 | 	sub	_var02, ##65536
0812c     06 7E 66 F0 | 	shl	_var02, #6
08130     80 FF 01 FF 
08134     00 7E 06 F5 | 	and	_var02, ##67043328
08138     6E 00 6C FF 
0813c     00 84 06 F6 | 	mov	_var05, ##-671032320
08140     3F 85 42 F5 | 	or	_var05, _var02
08144     09 82 46 F7 | 	zerox	_var04, #9
08148     42 83 42 F5 | 	or	_var04, _var05
0814c                 | LR__1356
0814c                 | LR__1357
0814c     48 81 62 FC | 	wrlong	_var03, arg01
08150                 | ' 	}
08150                 | ' #line 811 "ff.c"
08150                 | ' 	*str = p;
08150                 | ' 	return uc;
08150     41 77 02 F6 | 	mov	result1, _var04
08154                 | _fatfs_cc_tchar2uni_ret
08154     2D 00 64 FD | 	ret
08158                 | 
08158                 | _fatfs_cc_put_utf
08158     80 90 16 F2 | 	cmp	arg01, #128 wc
0815c     18 00 90 3D |  if_ae	jmp	#LR__1360
08160     01 94 16 F2 | 	cmp	arg03, #1 wc
08164     00 76 06 C6 |  if_b	mov	result1, #0
08168     8C 01 90 CD |  if_b	jmp	#_fatfs_cc_put_utf_ret
0816c     49 91 42 FC | 	wrbyte	arg01, arg02
08170                 | ' 		*buf = (TCHAR)chr;
08170                 | ' 		return 1;
08170     01 76 06 F6 | 	mov	result1, #1
08174     80 01 90 FD | 	jmp	#_fatfs_cc_put_utf_ret
08178                 | LR__1360
08178     04 00 00 FF 
0817c     00 90 16 F2 | 	cmp	arg01, ##2048 wc
08180     40 00 90 3D |  if_ae	jmp	#LR__1361
08184     02 94 16 F2 | 	cmp	arg03, #2 wc
08188     00 76 06 C6 |  if_b	mov	result1, #0
0818c     68 01 90 CD |  if_b	jmp	#_fatfs_cc_put_utf_ret
08190     48 77 02 F6 | 	mov	result1, arg01
08194     06 76 46 F0 | 	shr	result1, #6
08198     1F 76 06 F5 | 	and	result1, #31
0819c     C0 94 06 F6 | 	mov	arg03, #192
081a0     3B 95 42 F5 | 	or	arg03, result1
081a4     49 95 42 FC | 	wrbyte	arg03, arg02
081a8     01 92 06 F1 | 	add	arg02, #1
081ac     3F 90 06 F5 | 	and	arg01, #63
081b0     80 76 06 F6 | 	mov	result1, #128
081b4     48 77 42 F5 | 	or	result1, arg01
081b8     49 77 42 FC | 	wrbyte	result1, arg02
081bc                 | ' 		*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
081bc                 | ' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
081bc                 | ' 		return 2;
081bc     02 76 06 F6 | 	mov	result1, #2
081c0     34 01 90 FD | 	jmp	#_fatfs_cc_put_utf_ret
081c4                 | LR__1361
081c4     80 00 00 FF 
081c8     00 90 16 F2 | 	cmp	arg01, ##65536 wc
081cc     70 00 90 3D |  if_ae	jmp	#LR__1364
081d0     03 94 16 F2 | 	cmp	arg03, #3 wc
081d4     18 00 90 CD |  if_b	jmp	#LR__1362
081d8     6C 00 00 FF 
081dc     00 90 16 F2 | 	cmp	arg01, ##55296 wc
081e0     14 00 90 CD |  if_b	jmp	#LR__1363
081e4     70 00 00 FF 
081e8     00 90 16 F2 | 	cmp	arg01, ##57344 wc
081ec     08 00 90 3D |  if_ae	jmp	#LR__1363
081f0                 | LR__1362
081f0     00 76 06 F6 | 	mov	result1, #0
081f4     00 01 90 FD | 	jmp	#_fatfs_cc_put_utf_ret
081f8                 | LR__1363
081f8     48 77 5A F8 | 	getnib	result1, arg01, #3
081fc     E0 94 06 F6 | 	mov	arg03, #224
08200     3B 95 42 F5 | 	or	arg03, result1
08204     49 95 42 FC | 	wrbyte	arg03, arg02
08208     01 92 06 F1 | 	add	arg02, #1
0820c     48 77 02 F6 | 	mov	result1, arg01
08210     06 76 46 F0 | 	shr	result1, #6
08214     3F 76 06 F5 | 	and	result1, #63
08218     80 94 06 F6 | 	mov	arg03, #128
0821c     3B 95 42 F5 | 	or	arg03, result1
08220     49 95 42 FC | 	wrbyte	arg03, arg02
08224     01 92 06 F1 | 	add	arg02, #1
08228     3F 90 06 F5 | 	and	arg01, #63
0822c     80 76 06 F6 | 	mov	result1, #128
08230     48 77 42 F5 | 	or	result1, arg01
08234     49 77 42 FC | 	wrbyte	result1, arg02
08238                 | ' 		*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
08238                 | ' 		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
08238                 | ' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
08238                 | ' 		return 3;
08238     03 76 06 F6 | 	mov	result1, #3
0823c     B8 00 90 FD | 	jmp	#_fatfs_cc_put_utf_ret
08240                 | LR__1364
08240     04 94 16 F2 | 	cmp	arg03, #4 wc
08244     00 76 06 C6 |  if_b	mov	result1, #0
08248     AC 00 90 CD |  if_b	jmp	#_fatfs_cc_put_utf_ret
0824c     48 7D 02 F6 | 	mov	_var01, arg01
08250     E0 7D 06 F4 | 	bitl	_var01, #480
08254     00 00 6C FF 
08258     00 7C 86 F1 | 	sub	_var01, ##-671088640
0825c     06 7C 46 F0 | 	shr	_var01, #6
08260     48 91 32 F9 | 	getword	arg01, arg01, #0
08264     6E 00 00 FF 
08268     00 90 86 F1 | 	sub	arg01, ##56320
0826c     00 08 00 FF 
08270     00 7C 16 F2 | 	cmp	_var01, ##1048576 wc
08274     02 00 00 CF 
08278     00 90 16 C2 |  if_b	cmp	arg01, ##1024 wc
0827c     00 76 06 36 |  if_ae	mov	result1, #0
08280     74 00 90 3D |  if_ae	jmp	#_fatfs_cc_put_utf_ret
08284     48 7D 42 F5 | 	or	_var01, arg01
08288     80 00 00 FF 
0828c     00 7C 06 F1 | 	add	_var01, ##65536
08290     3E 77 02 F6 | 	mov	result1, _var01
08294     12 76 46 F0 | 	shr	result1, #18
08298     07 76 06 F5 | 	and	result1, #7
0829c     F0 94 06 F6 | 	mov	arg03, #240
082a0     3B 95 42 F5 | 	or	arg03, result1
082a4     49 95 42 FC | 	wrbyte	arg03, arg02
082a8     01 92 06 F1 | 	add	arg02, #1
082ac     3E 77 02 F6 | 	mov	result1, _var01
082b0     0C 76 46 F0 | 	shr	result1, #12
082b4     3F 76 06 F5 | 	and	result1, #63
082b8     80 94 06 F6 | 	mov	arg03, #128
082bc     3B 95 42 F5 | 	or	arg03, result1
082c0     49 95 42 FC | 	wrbyte	arg03, arg02
082c4     01 92 06 F1 | 	add	arg02, #1
082c8     3E 77 02 F6 | 	mov	result1, _var01
082cc     06 76 46 F0 | 	shr	result1, #6
082d0     3F 76 06 F5 | 	and	result1, #63
082d4     80 94 06 F6 | 	mov	arg03, #128
082d8     3B 95 42 F5 | 	or	arg03, result1
082dc     49 95 42 FC | 	wrbyte	arg03, arg02
082e0     01 92 06 F1 | 	add	arg02, #1
082e4     3F 7C 06 F5 | 	and	_var01, #63
082e8     80 76 06 F6 | 	mov	result1, #128
082ec     3E 77 42 F5 | 	or	result1, _var01
082f0     49 77 42 FC | 	wrbyte	result1, arg02
082f4                 | ' 	chr = (hc | chr) + 0x10000;
082f4                 | ' 	*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
082f4                 | ' 	*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
082f4                 | ' 	*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
082f4                 | ' 	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
082f4                 | ' 	return 4;
082f4     04 76 06 F6 | 	mov	result1, #4
082f8                 | _fatfs_cc_put_utf_ret
082f8     2D 00 64 FD | 	ret
082fc                 | 
082fc                 | _fatfs_cc_sync_window
082fc     02 CA 05 F6 | 	mov	COUNT_, #2
08300     E8 00 A0 FD | 	call	#pushregs_
08304     48 A7 02 F6 | 	mov	local01, arg01
08308     00 A8 06 F6 | 	mov	local02, #0
0830c     03 A6 06 F1 | 	add	local01, #3
08310     53 77 CA FA | 	rdbyte	result1, local01 wz
08314     03 A6 86 F1 | 	sub	local01, #3
08318     A4 00 90 AD |  if_e	jmp	#LR__1372
0831c     01 A6 06 F1 | 	add	local01, #1
08320     53 91 C2 FA | 	rdbyte	arg01, local01
08324     33 A6 06 F1 | 	add	local01, #51
08328     53 93 02 F6 | 	mov	arg02, local01
0832c     04 A6 86 F1 | 	sub	local01, #4
08330     53 95 02 FB | 	rdlong	arg03, local01
08334     30 A6 86 F1 | 	sub	local01, #48
08338     01 96 06 F6 | 	mov	arg04, #1
0833c     44 FB BF FD | 	call	#_fatfs_cc_disk_write
08340     00 76 0E F2 | 	cmp	result1, #0 wz
08344     74 00 90 5D |  if_ne	jmp	#LR__1370
08348     03 A6 06 F1 | 	add	local01, #3
0834c     53 01 48 FC | 	wrbyte	#0, local01
08350     2D A6 06 F1 | 	add	local01, #45
08354     53 77 02 FB | 	rdlong	result1, local01
08358     0C A6 86 F1 | 	sub	local01, #12
0835c     53 97 02 FB | 	rdlong	arg04, local01
08360     4B 77 82 F1 | 	sub	result1, arg04
08364     08 A6 86 F1 | 	sub	local01, #8
08368     53 97 02 FB | 	rdlong	arg04, local01
0836c     1C A6 86 F1 | 	sub	local01, #28
08370     4B 77 12 F2 | 	cmp	result1, arg04 wc
08374     48 00 90 3D |  if_ae	jmp	#LR__1371
08378     02 A6 06 F1 | 	add	local01, #2
0837c     53 97 C2 FA | 	rdbyte	arg04, local01
08380     02 A6 86 F1 | 	sub	local01, #2
08384     02 96 0E F2 | 	cmp	arg04, #2 wz
08388     34 00 90 5D |  if_ne	jmp	#LR__1371
0838c     01 A6 06 F1 | 	add	local01, #1
08390     53 91 C2 FA | 	rdbyte	arg01, local01
08394     33 A6 06 F1 | 	add	local01, #51
08398     53 93 02 F6 | 	mov	arg02, local01
0839c     04 A6 86 F1 | 	sub	local01, #4
083a0     53 95 02 FB | 	rdlong	arg03, local01
083a4     14 A6 86 F1 | 	sub	local01, #20
083a8     53 A7 02 FB | 	rdlong	local01, local01
083ac     53 95 02 F1 | 	add	arg03, local01
083b0     01 96 06 F6 | 	mov	arg04, #1
083b4     CC FA BF FD | 	call	#_fatfs_cc_disk_write
083b8     04 00 90 FD | 	jmp	#LR__1371
083bc                 | LR__1370
083bc     01 A8 06 F6 | 	mov	local02, #1
083c0                 | LR__1371
083c0                 | LR__1372
083c0                 | ' 			res = FR_DISK_ERR;
083c0                 | ' 		}
083c0                 | ' 	}
083c0                 | ' 	return res;
083c0     54 77 02 F6 | 	mov	result1, local02
083c4     E7 F0 03 F6 | 	mov	ptra, fp
083c8     F2 00 A0 FD | 	call	#popregs_
083cc                 | _fatfs_cc_sync_window_ret
083cc     2D 00 64 FD | 	ret
083d0                 | 
083d0                 | _fatfs_cc_move_window
083d0     03 CA 05 F6 | 	mov	COUNT_, #3
083d4     E8 00 A0 FD | 	call	#pushregs_
083d8     48 A7 02 F6 | 	mov	local01, arg01
083dc     49 A9 02 F6 | 	mov	local02, arg02
083e0     00 AA 06 F6 | 	mov	local03, #0
083e4     30 A6 06 F1 | 	add	local01, #48
083e8     53 97 02 FB | 	rdlong	arg04, local01
083ec     30 A6 86 F1 | 	sub	local01, #48
083f0     4B A9 0A F2 | 	cmp	local02, arg04 wz
083f4     40 00 90 AD |  if_e	jmp	#LR__1381
083f8     53 91 02 F6 | 	mov	arg01, local01
083fc     FC FE BF FD | 	call	#_fatfs_cc_sync_window
08400     3B AB 0A F6 | 	mov	local03, result1 wz
08404     30 00 90 5D |  if_ne	jmp	#LR__1380
08408     01 A6 06 F1 | 	add	local01, #1
0840c     53 91 C2 FA | 	rdbyte	arg01, local01
08410     33 A6 06 F1 | 	add	local01, #51
08414     53 93 02 F6 | 	mov	arg02, local01
08418     54 95 02 F6 | 	mov	arg03, local02
0841c     01 96 06 F6 | 	mov	arg04, #1
08420     24 F9 BF FD | 	call	#_fatfs_cc_disk_read
08424     00 76 0E F2 | 	cmp	result1, #0 wz
08428     01 A8 66 56 |  if_ne	neg	local02, #1
0842c     01 AA 06 56 |  if_ne	mov	local03, #1
08430     04 A6 86 F1 | 	sub	local01, #4
08434     53 A9 62 FC | 	wrlong	local02, local01
08438                 | LR__1380
08438                 | LR__1381
08438                 | ' 				sect = (LBA_t)0 - 1;
08438                 | ' 				res = FR_DISK_ERR;
08438                 | ' 			}
08438                 | ' 			fs->winsect = sect;
08438                 | ' 		}
08438                 | ' 	}
08438                 | ' 	return res;
08438     55 77 02 F6 | 	mov	result1, local03
0843c     E7 F0 03 F6 | 	mov	ptra, fp
08440     F2 00 A0 FD | 	call	#popregs_
08444                 | _fatfs_cc_move_window_ret
08444     2D 00 64 FD | 	ret
08448                 | 
08448                 | _fatfs_cc_sync_fs
08448     02 CA 05 F6 | 	mov	COUNT_, #2
0844c     E8 00 A0 FD | 	call	#pushregs_
08450     48 A7 02 F6 | 	mov	local01, arg01
08454     A4 FE BF FD | 	call	#_fatfs_cc_sync_window
08458     3B A9 0A F6 | 	mov	local02, result1 wz
0845c     D8 00 90 5D |  if_ne	jmp	#LR__1391
08460     53 97 C2 FA | 	rdbyte	arg04, local01
08464     03 96 0E F2 | 	cmp	arg04, #3 wz
08468     04 A6 06 A1 |  if_e	add	local01, #4
0846c     53 97 C2 AA |  if_e	rdbyte	arg04, local01
08470     04 A6 86 A1 |  if_e	sub	local01, #4
08474     01 96 0E A2 |  if_e	cmp	arg04, #1 wz
08478     A0 00 90 5D |  if_ne	jmp	#LR__1390
0847c     34 A6 06 F1 | 	add	local01, #52
08480     53 91 02 F6 | 	mov	arg01, local01
08484     00 92 06 F6 | 	mov	arg02, #0
08488     09 94 C6 F9 | 	decod	arg03, #9
0848c     D8 00 A0 FD | 	call	#\builtin_bytefill_
08490     53 91 02 F6 | 	mov	arg01, local01
08494     FE 91 06 F1 | 	add	arg01, #510
08498     55 00 80 FF 
0849c     48 AB 58 FC | 	wrword	##43605, arg01
084a0     A9 B0 A0 FF 
084a4     53 A5 68 FC | 	wrlong	##1096897106, local01
084a8     53 91 02 F6 | 	mov	arg01, local01
084ac     E4 91 06 F1 | 	add	arg01, #484
084b0     B9 A0 B0 FF 
084b4     48 E5 68 FC | 	wrlong	##1631679090, arg01
084b8     53 91 02 F6 | 	mov	arg01, local01
084bc     E8 91 06 F1 | 	add	arg01, #488
084c0     20 A6 86 F1 | 	sub	local01, #32
084c4     53 93 02 FB | 	rdlong	arg02, local01
084c8     48 93 62 FC | 	wrlong	arg02, arg01
084cc     20 A6 06 F1 | 	add	local01, #32
084d0     53 91 02 F6 | 	mov	arg01, local01
084d4     EC 91 06 F1 | 	add	arg01, #492
084d8     24 A6 86 F1 | 	sub	local01, #36
084dc     53 93 02 FB | 	rdlong	arg02, local01
084e0     48 93 62 FC | 	wrlong	arg02, arg01
084e4     10 A6 06 F1 | 	add	local01, #16
084e8     53 95 02 FB | 	rdlong	arg03, local01
084ec     01 94 06 F1 | 	add	arg03, #1
084f0     10 A6 06 F1 | 	add	local01, #16
084f4     53 95 62 FC | 	wrlong	arg03, local01
084f8     2F A6 86 F1 | 	sub	local01, #47
084fc     53 91 C2 FA | 	rdbyte	arg01, local01
08500     33 A6 06 F1 | 	add	local01, #51
08504     53 93 02 F6 | 	mov	arg02, local01
08508     01 96 06 F6 | 	mov	arg04, #1
0850c     74 F9 BF FD | 	call	#_fatfs_cc_disk_write
08510     30 A6 86 F1 | 	sub	local01, #48
08514     53 01 48 FC | 	wrbyte	#0, local01
08518     04 A6 86 F1 | 	sub	local01, #4
0851c                 | LR__1390
0851c     01 A6 06 F1 | 	add	local01, #1
08520     53 91 C2 FA | 	rdbyte	arg01, local01
08524     00 92 06 F6 | 	mov	arg02, #0
08528     00 94 06 F6 | 	mov	arg03, #0
0852c     90 FA BF FD | 	call	#_fatfs_cc_disk_ioctl
08530     00 76 0E F2 | 	cmp	result1, #0 wz
08534     01 A8 06 56 |  if_ne	mov	local02, #1
08538                 | LR__1391
08538                 | ' 	}
08538                 | ' 
08538                 | ' 	return res;
08538     54 77 02 F6 | 	mov	result1, local02
0853c     E7 F0 03 F6 | 	mov	ptra, fp
08540     F2 00 A0 FD | 	call	#popregs_
08544                 | _fatfs_cc_sync_fs_ret
08544     2D 00 64 FD | 	ret
08548                 | 
08548                 | _fatfs_cc_clst2sect
08548     02 92 86 F1 | 	sub	arg02, #2
0854c     18 90 06 F1 | 	add	arg01, #24
08550     48 7D 02 FB | 	rdlong	_var01, arg01
08554     18 90 86 F1 | 	sub	arg01, #24
08558     02 7C 86 F1 | 	sub	_var01, #2
0855c     3E 93 12 F2 | 	cmp	arg02, _var01 wc
08560     00 76 06 36 |  if_ae	mov	result1, #0
08564     1C 00 90 3D |  if_ae	jmp	#_fatfs_cc_clst2sect_ret
08568     0A 90 06 F1 | 	add	arg01, #10
0856c     48 7D E2 FA | 	rdword	_var01, arg01
08570     49 7D 02 FD | 	qmul	_var01, arg02
08574                 | ' 	return fs->database + (LBA_t)fs->csize * clst;
08574     22 90 06 F1 | 	add	arg01, #34
08578     48 77 02 FB | 	rdlong	result1, arg01
0857c     18 7C 62 FD | 	getqx	_var01
08580     3E 77 02 F1 | 	add	result1, _var01
08584                 | _fatfs_cc_clst2sect_ret
08584     2D 00 64 FD | 	ret
08588                 | 
08588                 | _fatfs_cc_get_fat
08588     07 CA 05 F6 | 	mov	COUNT_, #7
0858c     E8 00 A0 FD | 	call	#pushregs_
08590     49 A7 02 F6 | 	mov	local01, arg02
08594     48 A9 02 FB | 	rdlong	local02, arg01
08598     02 A6 16 F2 | 	cmp	local01, #2 wc
0859c     14 00 90 CD |  if_b	jmp	#LR__1400
085a0     18 A8 06 F1 | 	add	local02, #24
085a4     54 AB 02 FB | 	rdlong	local03, local02
085a8     18 A8 86 F1 | 	sub	local02, #24
085ac     55 A7 12 F2 | 	cmp	local01, local03 wc
085b0     08 00 90 CD |  if_b	jmp	#LR__1401
085b4                 | LR__1400
085b4     01 AC 06 F6 | 	mov	local04, #1
085b8     60 01 90 FD | 	jmp	#LR__1408
085bc                 | LR__1401
085bc     01 AC 66 F6 | 	neg	local04, #1
085c0                 | ' 		val = 0xFFFFFFFF;
085c0                 | ' 
085c0                 | ' 		switch (fs->fs_type) {
085c0     54 AF C2 FA | 	rdbyte	local05, local02
085c4     01 AE 86 F1 | 	sub	local05, #1
085c8     03 AE 26 F3 | 	fle	local05, #3
085cc     30 AE 62 FD | 	jmprel	local05
085d0                 | LR__1402
085d0     0C 00 90 FD | 	jmp	#LR__1403
085d4     B8 00 90 FD | 	jmp	#LR__1404
085d8     F8 00 90 FD | 	jmp	#LR__1405
085dc     38 01 90 FD | 	jmp	#LR__1406
085e0                 | LR__1403
085e0     53 AF 02 F6 | 	mov	local05, local01
085e4     53 91 02 F6 | 	mov	arg01, local01
085e8     01 90 46 F0 | 	shr	arg01, #1
085ec     48 AF 02 F1 | 	add	local05, arg01
085f0     54 91 02 F6 | 	mov	arg01, local02
085f4     57 B1 02 F6 | 	mov	local06, local05
085f8     09 B0 46 F0 | 	shr	local06, #9
085fc     24 A8 06 F1 | 	add	local02, #36
08600     54 93 02 FB | 	rdlong	arg02, local02
08604     24 A8 86 F1 | 	sub	local02, #36
08608     58 93 02 F1 | 	add	arg02, local06
0860c     C0 FD BF FD | 	call	#_fatfs_cc_move_window
08610     00 76 0E F2 | 	cmp	result1, #0 wz
08614     04 01 90 5D |  if_ne	jmp	#LR__1407
08618     57 B1 02 F6 | 	mov	local06, local05
0861c     FF B1 06 F5 | 	and	local06, #511
08620     54 91 02 F6 | 	mov	arg01, local02
08624     34 90 06 F1 | 	add	arg01, #52
08628     48 B1 02 F1 | 	add	local06, arg01
0862c     58 B3 C2 FA | 	rdbyte	local07, local06
08630     54 91 02 F6 | 	mov	arg01, local02
08634     01 AE 06 F1 | 	add	local05, #1
08638     57 B1 02 F6 | 	mov	local06, local05
0863c     09 B0 46 F0 | 	shr	local06, #9
08640     24 A8 06 F1 | 	add	local02, #36
08644     54 93 02 FB | 	rdlong	arg02, local02
08648     24 A8 86 F1 | 	sub	local02, #36
0864c     58 93 02 F1 | 	add	arg02, local06
08650     7C FD BF FD | 	call	#_fatfs_cc_move_window
08654     00 76 0E F2 | 	cmp	result1, #0 wz
08658     C0 00 90 5D |  if_ne	jmp	#LR__1407
0865c     FF AF 06 F5 | 	and	local05, #511
08660     34 A8 06 F1 | 	add	local02, #52
08664     54 AF 02 F1 | 	add	local05, local02
08668     57 B1 C2 FA | 	rdbyte	local06, local05
0866c     08 B0 66 F0 | 	shl	local06, #8
08670     58 B3 42 F5 | 	or	local07, local06
08674     01 A6 CE F7 | 	test	local01, #1 wz
08678     04 B2 46 50 |  if_ne	shr	local07, #4
0867c     59 AB 02 56 |  if_ne	mov	local03, local07
08680     0B B2 46 A7 |  if_e	zerox	local07, #11
08684     59 AB 02 A6 |  if_e	mov	local03, local07
08688     55 AD 02 F6 | 	mov	local04, local03
0868c                 | ' 			wc |= fs->win[bc %  ((UINT) 512 ) ] << 8;
0868c                 | ' 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
0868c                 | ' 			break;
0868c     8C 00 90 FD | 	jmp	#LR__1407
08690                 | LR__1404
08690     54 91 02 F6 | 	mov	arg01, local02
08694     53 B1 02 F6 | 	mov	local06, local01
08698     08 B0 46 F0 | 	shr	local06, #8
0869c     24 A8 06 F1 | 	add	local02, #36
086a0     54 93 02 FB | 	rdlong	arg02, local02
086a4     24 A8 86 F1 | 	sub	local02, #36
086a8     58 93 02 F1 | 	add	arg02, local06
086ac     20 FD BF FD | 	call	#_fatfs_cc_move_window
086b0     00 76 0E F2 | 	cmp	result1, #0 wz
086b4     64 00 90 5D |  if_ne	jmp	#LR__1407
086b8     34 A8 06 F1 | 	add	local02, #52
086bc     01 A6 66 F0 | 	shl	local01, #1
086c0     FF A7 06 F5 | 	and	local01, #511
086c4     53 A9 02 F1 | 	add	local02, local01
086c8                 | ' {
086c8                 | ' 
086c8                 | ' 	return *((WORD*)ptr);
086c8     54 77 E2 FA | 	rdword	result1, local02
086cc     3B AD 32 F9 | 	getword	local04, result1, #0
086d0                 | ' 			val = ld_word(fs->win + clst * 2 %  ((UINT) 512 ) );
086d0                 | ' 			break;
086d0     48 00 90 FD | 	jmp	#LR__1407
086d4                 | LR__1405
086d4     54 91 02 F6 | 	mov	arg01, local02
086d8     53 B1 02 F6 | 	mov	local06, local01
086dc     07 B0 46 F0 | 	shr	local06, #7
086e0     24 A8 06 F1 | 	add	local02, #36
086e4     54 93 02 FB | 	rdlong	arg02, local02
086e8     24 A8 86 F1 | 	sub	local02, #36
086ec     58 93 02 F1 | 	add	arg02, local06
086f0     DC FC BF FD | 	call	#_fatfs_cc_move_window
086f4     00 76 0E F2 | 	cmp	result1, #0 wz
086f8     20 00 90 5D |  if_ne	jmp	#LR__1407
086fc     34 A8 06 F1 | 	add	local02, #52
08700     02 A6 66 F0 | 	shl	local01, #2
08704     FF A7 06 F5 | 	and	local01, #511
08708     53 A9 02 F1 | 	add	local02, local01
0870c                 | ' {
0870c                 | ' 
0870c                 | ' 	return *((DWORD*)ptr);
0870c     54 AD 02 FB | 	rdlong	local04, local02
08710     7C AC 06 F4 | 	bitl	local04, #124
08714                 | ' 			val = ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0x0FFFFFFF;
08714                 | ' 			break;
08714     04 00 90 FD | 	jmp	#LR__1407
08718                 | LR__1406
08718     01 AC 06 F6 | 	mov	local04, #1
0871c                 | LR__1407
0871c                 | LR__1408
0871c                 | ' 			val = 1;
0871c                 | ' 		}
0871c                 | ' 	}
0871c                 | ' 
0871c                 | ' 	return val;
0871c     56 77 02 F6 | 	mov	result1, local04
08720     E7 F0 03 F6 | 	mov	ptra, fp
08724     F2 00 A0 FD | 	call	#popregs_
08728                 | _fatfs_cc_get_fat_ret
08728     2D 00 64 FD | 	ret
0872c                 | 
0872c                 | _fatfs_cc_put_fat
0872c     08 CA 05 F6 | 	mov	COUNT_, #8
08730     E8 00 A0 FD | 	call	#pushregs_
08734     48 A7 02 F6 | 	mov	local01, arg01
08738     49 A9 02 F6 | 	mov	local02, arg02
0873c     4A AB 02 F6 | 	mov	local03, arg03
08740     02 AC 06 F6 | 	mov	local04, #2
08744     02 A8 16 F2 | 	cmp	local02, #2 wc
08748     E0 01 90 CD |  if_b	jmp	#LR__1417
0874c     18 A6 06 F1 | 	add	local01, #24
08750     53 AF 02 FB | 	rdlong	local05, local01
08754     18 A6 86 F1 | 	sub	local01, #24
08758     57 A9 12 F2 | 	cmp	local02, local05 wc
0875c     CC 01 90 3D |  if_ae	jmp	#LR__1417
08760                 | ' 		switch (fs->fs_type) {
08760     53 B1 C2 FA | 	rdbyte	local06, local01
08764     01 B0 86 F1 | 	sub	local06, #1
08768     03 B0 26 F3 | 	fle	local06, #3
0876c     30 B0 62 FD | 	jmprel	local06
08770                 | LR__1410
08770     0C 00 90 FD | 	jmp	#LR__1411
08774     F4 00 90 FD | 	jmp	#LR__1414
08778     3C 01 90 FD | 	jmp	#LR__1415
0877c     AC 01 90 FD | 	jmp	#LR__1416
08780                 | LR__1411
08780     54 B3 02 F6 | 	mov	local07, local02
08784     54 AF 02 F6 | 	mov	local05, local02
08788     01 AE 46 F0 | 	shr	local05, #1
0878c     57 B3 02 F1 | 	add	local07, local05
08790     53 91 02 F6 | 	mov	arg01, local01
08794     59 B1 02 F6 | 	mov	local06, local07
08798     09 B0 46 F0 | 	shr	local06, #9
0879c     24 A6 06 F1 | 	add	local01, #36
087a0     53 93 02 FB | 	rdlong	arg02, local01
087a4     24 A6 86 F1 | 	sub	local01, #36
087a8     58 93 02 F1 | 	add	arg02, local06
087ac     20 FC BF FD | 	call	#_fatfs_cc_move_window
087b0     3B AD 0A F6 | 	mov	local04, result1 wz
087b4     74 01 90 5D |  if_ne	jmp	#LR__1416
087b8     53 B5 02 F6 | 	mov	local08, local01
087bc     34 B4 06 F1 | 	add	local08, #52
087c0     59 AF 02 F6 | 	mov	local05, local07
087c4     FF AF 06 F5 | 	and	local05, #511
087c8     57 B5 02 F1 | 	add	local08, local05
087cc     01 A8 CE F7 | 	test	local02, #1 wz
087d0     01 B2 06 F1 | 	add	local07, #1
087d4     18 00 90 AD |  if_e	jmp	#LR__1412
087d8     5A AF C2 FA | 	rdbyte	local05, local08
087dc     57 AF 42 F8 | 	getnib	local05, local05, #0
087e0     55 B1 E2 F8 | 	getbyte	local06, local03, #0
087e4     04 B0 66 F0 | 	shl	local06, #4
087e8     58 AF 42 F5 | 	or	local05, local06
087ec     04 00 90 FD | 	jmp	#LR__1413
087f0                 | LR__1412
087f0     55 AF 02 F6 | 	mov	local05, local03
087f4                 | LR__1413
087f4     5A AF 42 FC | 	wrbyte	local05, local08
087f8     03 A6 06 F1 | 	add	local01, #3
087fc     53 03 48 FC | 	wrbyte	#1, local01
08800     03 A6 86 F1 | 	sub	local01, #3
08804     53 91 02 F6 | 	mov	arg01, local01
08808     59 B5 02 F6 | 	mov	local08, local07
0880c     09 B4 46 F0 | 	shr	local08, #9
08810     24 A6 06 F1 | 	add	local01, #36
08814     53 93 02 FB | 	rdlong	arg02, local01
08818     24 A6 86 F1 | 	sub	local01, #36
0881c     5A 93 02 F1 | 	add	arg02, local08
08820     AC FB BF FD | 	call	#_fatfs_cc_move_window
08824     3B AD 0A F6 | 	mov	local04, result1 wz
08828     00 01 90 5D |  if_ne	jmp	#LR__1416
0882c     53 B5 02 F6 | 	mov	local08, local01
08830     34 B4 06 F1 | 	add	local08, #52
08834     FF B3 06 F5 | 	and	local07, #511
08838     59 B5 02 F1 | 	add	local08, local07
0883c     01 A8 CE F7 | 	test	local02, #1 wz
08840     04 AA 46 50 |  if_ne	shr	local03, #4
08844     55 AF 02 56 |  if_ne	mov	local05, local03
08848     5A AF C2 AA |  if_e	rdbyte	local05, local08
0884c     F0 AE 06 A5 |  if_e	and	local05, #240
08850     55 AB EA A8 |  if_e	getbyte	local03, local03, #1
08854     55 AB 42 A8 |  if_e	getnib	local03, local03, #0
08858     55 AF 42 A5 |  if_e	or	local05, local03
0885c     5A AF 42 FC | 	wrbyte	local05, local08
08860     03 A6 06 F1 | 	add	local01, #3
08864     53 03 48 FC | 	wrbyte	#1, local01
08868                 | ' 			p = fs->win + bc %  ((UINT) 512 ) ;
08868                 | ' 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
08868                 | ' 			fs->wflag = 1;
08868                 | ' 			break;
08868     C0 00 90 FD | 	jmp	#LR__1416
0886c                 | LR__1414
0886c     53 91 02 F6 | 	mov	arg01, local01
08870     54 B5 02 F6 | 	mov	local08, local02
08874     08 B4 46 F0 | 	shr	local08, #8
08878     24 A6 06 F1 | 	add	local01, #36
0887c     53 93 02 FB | 	rdlong	arg02, local01
08880     24 A6 86 F1 | 	sub	local01, #36
08884     5A 93 02 F1 | 	add	arg02, local08
08888     44 FB BF FD | 	call	#_fatfs_cc_move_window
0888c     3B AD 0A F6 | 	mov	local04, result1 wz
08890     98 00 90 5D |  if_ne	jmp	#LR__1416
08894     34 A6 06 F1 | 	add	local01, #52
08898     53 91 02 F6 | 	mov	arg01, local01
0889c     01 A8 66 F0 | 	shl	local02, #1
088a0     FF A9 06 F5 | 	and	local02, #511
088a4     54 91 02 F1 | 	add	arg01, local02
088a8     48 AB 52 FC | 	wrword	local03, arg01
088ac     31 A6 86 F1 | 	sub	local01, #49
088b0     53 03 48 FC | 	wrbyte	#1, local01
088b4                 | ' 			st_word(fs->win + clst * 2 %  ((UINT) 512 ) , (WORD)val);
088b4                 | ' 			fs->wflag = 1;
088b4                 | ' 			break;
088b4     74 00 90 FD | 	jmp	#LR__1416
088b8                 | LR__1415
088b8     53 91 02 F6 | 	mov	arg01, local01
088bc     54 B5 02 F6 | 	mov	local08, local02
088c0     07 B4 46 F0 | 	shr	local08, #7
088c4     24 A6 06 F1 | 	add	local01, #36
088c8     53 93 02 FB | 	rdlong	arg02, local01
088cc     24 A6 86 F1 | 	sub	local01, #36
088d0     5A 93 02 F1 | 	add	arg02, local08
088d4     F8 FA BF FD | 	call	#_fatfs_cc_move_window
088d8     3B AD 0A F6 | 	mov	local04, result1 wz
088dc     4C 00 90 5D |  if_ne	jmp	#LR__1416
088e0     7C AA 06 F4 | 	bitl	local03, #124
088e4     53 91 02 F6 | 	mov	arg01, local01
088e8     34 90 06 F1 | 	add	arg01, #52
088ec     54 B5 02 F6 | 	mov	local08, local02
088f0     02 B4 66 F0 | 	shl	local08, #2
088f4     FF B5 06 F5 | 	and	local08, #511
088f8     5A 91 02 F1 | 	add	arg01, local08
088fc                 | ' {
088fc                 | ' 
088fc                 | ' 	return *((DWORD*)ptr);
088fc     48 B5 02 FB | 	rdlong	local08, arg01
08900     00 00 78 FF 
08904     00 B4 06 F5 | 	and	local08, ##-268435456
08908     5A AB 42 F5 | 	or	local03, local08
0890c     34 A6 06 F1 | 	add	local01, #52
08910     53 91 02 F6 | 	mov	arg01, local01
08914     02 A8 66 F0 | 	shl	local02, #2
08918     FF A9 06 F5 | 	and	local02, #511
0891c     54 91 02 F1 | 	add	arg01, local02
08920     48 AB 62 FC | 	wrlong	local03, arg01
08924     31 A6 86 F1 | 	sub	local01, #49
08928     53 03 48 FC | 	wrbyte	#1, local01
0892c                 | ' 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0xF0000000);
0892c                 | ' 			}
0892c                 | ' 			st_dword(fs->win + clst * 4 %  ((UINT) 512 ) , val);
0892c                 | ' 			fs->wflag = 1;
0892c                 | ' 			break;
0892c                 | LR__1416
0892c                 | LR__1417
0892c                 | ' 		}
0892c                 | ' 	}
0892c                 | ' 	return res;
0892c     56 77 02 F6 | 	mov	result1, local04
08930     E7 F0 03 F6 | 	mov	ptra, fp
08934     F2 00 A0 FD | 	call	#popregs_
08938                 | _fatfs_cc_put_fat_ret
08938     2D 00 64 FD | 	ret
0893c                 | 
0893c                 | _fatfs_cc_remove_chain
0893c     05 CA 05 F6 | 	mov	COUNT_, #5
08940     E8 00 A0 FD | 	call	#pushregs_
08944     48 A7 02 F6 | 	mov	local01, arg01
08948     49 A9 02 F6 | 	mov	local02, arg02
0894c     4A AB 02 F6 | 	mov	local03, arg03
08950     53 AD 02 FB | 	rdlong	local04, local01
08954     02 A8 16 F2 | 	cmp	local02, #2 wc
08958     14 00 90 CD |  if_b	jmp	#LR__1420
0895c     18 AC 06 F1 | 	add	local04, #24
08960     56 77 02 FB | 	rdlong	result1, local04
08964     18 AC 86 F1 | 	sub	local04, #24
08968     3B A9 12 F2 | 	cmp	local02, result1 wc
0896c     08 00 90 CD |  if_b	jmp	#LR__1421
08970                 | LR__1420
08970     02 76 06 F6 | 	mov	result1, #2
08974     CC 00 90 FD | 	jmp	#LR__1426
08978                 | LR__1421
08978     00 AA 0E F2 | 	cmp	local03, #0 wz
0897c     18 00 90 AD |  if_e	jmp	#LR__1422
08980     55 93 02 F6 | 	mov	arg02, local03
08984     56 91 02 F6 | 	mov	arg01, local04
08988     01 94 66 F6 | 	neg	arg03, #1
0898c     9C FD BF FD | 	call	#_fatfs_cc_put_fat
08990     00 76 0E F2 | 	cmp	result1, #0 wz
08994     AC 00 90 5D |  if_ne	jmp	#LR__1426
08998                 | LR__1422
08998                 | ' 	}
08998                 | ' 
08998                 | ' 
08998                 | ' 	do {
08998                 | LR__1423
08998     54 93 02 F6 | 	mov	arg02, local02
0899c     53 91 02 F6 | 	mov	arg01, local01
089a0     E4 FB BF FD | 	call	#_fatfs_cc_get_fat
089a4     3B AF 0A F6 | 	mov	local05, result1 wz
089a8     94 00 90 AD |  if_e	jmp	#LR__1425
089ac     01 AE 0E F2 | 	cmp	local05, #1 wz
089b0     02 76 06 A6 |  if_e	mov	result1, #2
089b4     8C 00 90 AD |  if_e	jmp	#LR__1426
089b8     FF FF 7F FF 
089bc     FF AF 0E F2 | 	cmp	local05, ##-1 wz
089c0     01 76 06 A6 |  if_e	mov	result1, #1
089c4     7C 00 90 AD |  if_e	jmp	#LR__1426
089c8     54 93 02 F6 | 	mov	arg02, local02
089cc     56 91 02 F6 | 	mov	arg01, local04
089d0     00 94 06 F6 | 	mov	arg03, #0
089d4     54 FD BF FD | 	call	#_fatfs_cc_put_fat
089d8     3B AB 0A F6 | 	mov	local03, result1 wz
089dc     55 77 02 56 |  if_ne	mov	result1, local03
089e0     60 00 90 5D |  if_ne	jmp	#LR__1426
089e4     18 AC 06 F1 | 	add	local04, #24
089e8     56 AB 02 FB | 	rdlong	local03, local04
089ec     02 AA 86 F1 | 	sub	local03, #2
089f0     04 AC 86 F1 | 	sub	local04, #4
089f4     56 A9 02 FB | 	rdlong	local02, local04
089f8     14 AC 86 F1 | 	sub	local04, #20
089fc     55 A9 12 F2 | 	cmp	local02, local03 wc
08a00     24 00 90 3D |  if_ae	jmp	#LR__1424
08a04     14 AC 06 F1 | 	add	local04, #20
08a08     56 AB 02 FB | 	rdlong	local03, local04
08a0c     01 AA 06 F1 | 	add	local03, #1
08a10     56 AB 62 FC | 	wrlong	local03, local04
08a14     10 AC 86 F1 | 	sub	local04, #16
08a18     56 AB C2 FA | 	rdbyte	local03, local04
08a1c     01 AA 46 F5 | 	or	local03, #1
08a20     56 AB 42 FC | 	wrbyte	local03, local04
08a24     04 AC 86 F1 | 	sub	local04, #4
08a28                 | LR__1424
08a28     57 A9 02 F6 | 	mov	local02, local05
08a2c     18 AC 06 F1 | 	add	local04, #24
08a30     56 AF 02 FB | 	rdlong	local05, local04
08a34     18 AC 86 F1 | 	sub	local04, #24
08a38     57 A9 12 F2 | 	cmp	local02, local05 wc
08a3c     58 FF 9F CD |  if_b	jmp	#LR__1423
08a40                 | LR__1425
08a40                 | ' #line 1500 "ff.c"
08a40                 | ' 	return FR_OK;
08a40     00 76 06 F6 | 	mov	result1, #0
08a44                 | LR__1426
08a44     E7 F0 03 F6 | 	mov	ptra, fp
08a48     F2 00 A0 FD | 	call	#popregs_
08a4c                 | _fatfs_cc_remove_chain_ret
08a4c     2D 00 64 FD | 	ret
08a50                 | 
08a50                 | _fatfs_cc_create_chain
08a50     09 CA 05 F6 | 	mov	COUNT_, #9
08a54     E8 00 A0 FD | 	call	#pushregs_
08a58     48 A7 02 F6 | 	mov	local01, arg01
08a5c     49 A9 0A F6 | 	mov	local02, arg02 wz
08a60     53 AB 02 FB | 	rdlong	local03, local01
08a64     28 00 90 5D |  if_ne	jmp	#LR__1430
08a68     10 AA 06 F1 | 	add	local03, #16
08a6c     55 AD 0A FB | 	rdlong	local04, local03 wz
08a70     10 AA 86 F1 | 	sub	local03, #16
08a74     18 AA 06 51 |  if_ne	add	local03, #24
08a78     55 AF 02 5B |  if_ne	rdlong	local05, local03
08a7c     18 AA 86 51 |  if_ne	sub	local03, #24
08a80     57 AD 12 52 |  if_ne	cmp	local04, local05 wc
08a84     50 00 90 4D |  if_c_and_nz	jmp	#LR__1431
08a88     01 AC 06 F6 | 	mov	local04, #1
08a8c     48 00 90 FD | 	jmp	#LR__1431
08a90                 | LR__1430
08a90     54 93 02 F6 | 	mov	arg02, local02
08a94     53 91 02 F6 | 	mov	arg01, local01
08a98     EC FA BF FD | 	call	#_fatfs_cc_get_fat
08a9c     3B AD 02 F6 | 	mov	local04, result1
08aa0     02 AC 16 F2 | 	cmp	local04, #2 wc
08aa4     01 76 06 C6 |  if_b	mov	result1, #1
08aa8     BC 01 90 CD |  if_b	jmp	#LR__1441
08aac     FF FF 7F FF 
08ab0     FF AD 0E F2 | 	cmp	local04, ##-1 wz
08ab4     56 77 02 A6 |  if_e	mov	result1, local04
08ab8     AC 01 90 AD |  if_e	jmp	#LR__1441
08abc     18 AA 06 F1 | 	add	local03, #24
08ac0     55 AF 02 FB | 	rdlong	local05, local03
08ac4     18 AA 86 F1 | 	sub	local03, #24
08ac8     57 AD 12 F2 | 	cmp	local04, local05 wc
08acc     56 77 02 C6 |  if_b	mov	result1, local04
08ad0     94 01 90 CD |  if_b	jmp	#LR__1441
08ad4     54 AD 02 F6 | 	mov	local04, local02
08ad8                 | LR__1431
08ad8     14 AA 06 F1 | 	add	local03, #20
08adc     55 AF 0A FB | 	rdlong	local05, local03 wz
08ae0     14 AA 86 F1 | 	sub	local03, #20
08ae4     00 76 06 A6 |  if_e	mov	result1, #0
08ae8     7C 01 90 AD |  if_e	jmp	#LR__1441
08aec     00 B0 06 F6 | 	mov	local06, #0
08af0     54 AD 0A F2 | 	cmp	local04, local02 wz
08af4     74 00 90 5D |  if_ne	jmp	#LR__1434
08af8     56 B1 02 F6 | 	mov	local06, local04
08afc     01 B0 06 F1 | 	add	local06, #1
08b00     18 AA 06 F1 | 	add	local03, #24
08b04     55 AF 02 FB | 	rdlong	local05, local03
08b08     18 AA 86 F1 | 	sub	local03, #24
08b0c     57 B1 12 F2 | 	cmp	local06, local05 wc
08b10     02 B0 06 36 |  if_ae	mov	local06, #2
08b14     58 93 02 F6 | 	mov	arg02, local06
08b18     53 91 02 F6 | 	mov	arg01, local01
08b1c     68 FA BF FD | 	call	#_fatfs_cc_get_fat
08b20     3B AF 02 F6 | 	mov	local05, result1
08b24     01 AE 0E F2 | 	cmp	local05, #1 wz
08b28     FF FF 7F 5F 
08b2c     FF AF 0E 52 |  if_ne	cmp	local05, ##-1 wz
08b30     57 77 02 A6 |  if_e	mov	result1, local05
08b34     30 01 90 AD |  if_e	jmp	#LR__1441
08b38     00 AE 0E F2 | 	cmp	local05, #0 wz
08b3c     2C 00 90 AD |  if_e	jmp	#LR__1433
08b40     10 AA 06 F1 | 	add	local03, #16
08b44     55 B3 02 FB | 	rdlong	local07, local03
08b48     10 AA 86 F1 | 	sub	local03, #16
08b4c     02 B2 16 F2 | 	cmp	local07, #2 wc
08b50     14 00 90 CD |  if_b	jmp	#LR__1432
08b54     18 AA 06 F1 | 	add	local03, #24
08b58     55 AF 02 FB | 	rdlong	local05, local03
08b5c     18 AA 86 F1 | 	sub	local03, #24
08b60     57 B3 12 F2 | 	cmp	local07, local05 wc
08b64     59 AD 02 C6 |  if_b	mov	local04, local07
08b68                 | LR__1432
08b68     00 B0 06 F6 | 	mov	local06, #0
08b6c                 | LR__1433
08b6c                 | LR__1434
08b6c     00 B0 0E F2 | 	cmp	local06, #0 wz
08b70     60 00 90 5D |  if_ne	jmp	#LR__1437
08b74     56 B1 02 F6 | 	mov	local06, local04
08b78                 | ' 			ncl = scl;
08b78                 | ' 			for (;;) {
08b78                 | LR__1435
08b78     01 B0 06 F1 | 	add	local06, #1
08b7c     18 AA 06 F1 | 	add	local03, #24
08b80     55 AF 02 FB | 	rdlong	local05, local03
08b84     18 AA 86 F1 | 	sub	local03, #24
08b88     57 B1 12 F2 | 	cmp	local06, local05 wc
08b8c     02 B0 06 36 |  if_ae	mov	local06, #2
08b90     56 B1 1A 32 |  if_ae	cmp	local06, local04 wcz
08b94     00 76 06 16 |  if_a	mov	result1, #0
08b98     CC 00 90 1D |  if_a	jmp	#LR__1441
08b9c     58 93 02 F6 | 	mov	arg02, local06
08ba0     53 91 02 F6 | 	mov	arg01, local01
08ba4     E0 F9 BF FD | 	call	#_fatfs_cc_get_fat
08ba8     3B B3 0A F6 | 	mov	local07, result1 wz
08bac     24 00 90 AD |  if_e	jmp	#LR__1436
08bb0     01 B2 0E F2 | 	cmp	local07, #1 wz
08bb4     FF FF 7F 5F 
08bb8     FF B3 0E 52 |  if_ne	cmp	local07, ##-1 wz
08bbc     59 77 02 A6 |  if_e	mov	result1, local07
08bc0     A4 00 90 AD |  if_e	jmp	#LR__1441
08bc4     56 B1 0A F2 | 	cmp	local06, local04 wz
08bc8     00 76 06 A6 |  if_e	mov	result1, #0
08bcc     98 00 90 AD |  if_e	jmp	#LR__1441
08bd0     A4 FF 9F FD | 	jmp	#LR__1435
08bd4                 | LR__1436
08bd4                 | LR__1437
08bd4     55 91 02 F6 | 	mov	arg01, local03
08bd8     58 93 02 F6 | 	mov	arg02, local06
08bdc     01 94 66 F6 | 	neg	arg03, #1
08be0     48 FB BF FD | 	call	#_fatfs_cc_put_fat
08be4     3B B5 0A F6 | 	mov	local08, result1 wz
08be8     1C 00 90 5D |  if_ne	jmp	#LR__1438
08bec     00 A8 0E F2 | 	cmp	local02, #0 wz
08bf0     14 00 90 AD |  if_e	jmp	#LR__1438
08bf4     55 91 02 F6 | 	mov	arg01, local03
08bf8     54 93 02 F6 | 	mov	arg02, local02
08bfc     58 95 02 F6 | 	mov	arg03, local06
08c00     28 FB BF FD | 	call	#_fatfs_cc_put_fat
08c04     3B B5 02 F6 | 	mov	local08, result1
08c08                 | LR__1438
08c08     00 B4 0E F2 | 	cmp	local08, #0 wz
08c0c     4C 00 90 5D |  if_ne	jmp	#LR__1439
08c10     10 AA 06 F1 | 	add	local03, #16
08c14     55 B1 62 FC | 	wrlong	local06, local03
08c18     08 AA 06 F1 | 	add	local03, #8
08c1c     55 AF 02 FB | 	rdlong	local05, local03
08c20     02 AE 86 F1 | 	sub	local05, #2
08c24     04 AA 86 F1 | 	sub	local03, #4
08c28     55 B7 02 FB | 	rdlong	local09, local03
08c2c     14 AA 86 F1 | 	sub	local03, #20
08c30     57 B7 1A F2 | 	cmp	local09, local05 wcz
08c34     14 AA 06 E1 |  if_be	add	local03, #20
08c38     55 B7 02 EB |  if_be	rdlong	local09, local03
08c3c     01 B6 86 E1 |  if_be	sub	local09, #1
08c40     55 B7 62 EC |  if_be	wrlong	local09, local03
08c44     14 AA 86 E1 |  if_be	sub	local03, #20
08c48     04 AA 06 F1 | 	add	local03, #4
08c4c     55 AF C2 FA | 	rdbyte	local05, local03
08c50     01 AE 46 F5 | 	or	local05, #1
08c54     55 AF 42 FC | 	wrbyte	local05, local03
08c58     08 00 90 FD | 	jmp	#LR__1440
08c5c                 | LR__1439
08c5c     01 B4 0E F2 | 	cmp	local08, #1 wz
08c60     01 B0 C6 F6 | 	negz	local06, #1
08c64                 | LR__1440
08c64                 | ' 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
08c64                 | ' 	}
08c64                 | ' 
08c64                 | ' 	return ncl;
08c64     58 77 02 F6 | 	mov	result1, local06
08c68                 | LR__1441
08c68     E7 F0 03 F6 | 	mov	ptra, fp
08c6c     F2 00 A0 FD | 	call	#popregs_
08c70                 | _fatfs_cc_create_chain_ret
08c70     2D 00 64 FD | 	ret
08c74                 | 
08c74                 | _fatfs_cc_dir_clear
08c74     06 CA 05 F6 | 	mov	COUNT_, #6
08c78     E8 00 A0 FD | 	call	#pushregs_
08c7c     48 A7 02 F6 | 	mov	local01, arg01
08c80     49 A9 02 F6 | 	mov	local02, arg02
08c84     53 91 02 F6 | 	mov	arg01, local01
08c88     70 F6 BF FD | 	call	#_fatfs_cc_sync_window
08c8c     00 76 0E F2 | 	cmp	result1, #0 wz
08c90     01 76 06 56 |  if_ne	mov	result1, #1
08c94     90 00 90 5D |  if_ne	jmp	#LR__1452
08c98     53 91 02 F6 | 	mov	arg01, local01
08c9c     54 93 02 F6 | 	mov	arg02, local02
08ca0     A4 F8 BF FD | 	call	#_fatfs_cc_clst2sect
08ca4     3B AB 02 F6 | 	mov	local03, result1
08ca8     30 A6 06 F1 | 	add	local01, #48
08cac     53 AB 62 FC | 	wrlong	local03, local01
08cb0     04 A6 06 F1 | 	add	local01, #4
08cb4     53 91 02 F6 | 	mov	arg01, local01
08cb8     00 92 06 F6 | 	mov	arg02, #0
08cbc     09 94 C6 F9 | 	decod	arg03, #9
08cc0     D8 00 A0 FD | 	call	#\builtin_bytefill_
08cc4     53 AD 02 F6 | 	mov	local04, local01
08cc8                 | ' #line 1667 "ff.c"
08cc8                 | ' 	{
08cc8                 | ' 		ibuf = fs->win; szb = 1;
08cc8                 | ' 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
08cc8     00 AE 06 F6 | 	mov	local05, #0
08ccc     34 A6 86 F1 | 	sub	local01, #52
08cd0                 | LR__1450
08cd0     0A A6 06 F1 | 	add	local01, #10
08cd4     53 B1 E2 FA | 	rdword	local06, local01
08cd8     0A A6 86 F1 | 	sub	local01, #10
08cdc     58 AF 12 F2 | 	cmp	local05, local06 wc
08ce0     2C 00 90 3D |  if_ae	jmp	#LR__1451
08ce4     01 A6 06 F1 | 	add	local01, #1
08ce8     53 91 C2 FA | 	rdbyte	arg01, local01
08cec     01 A6 86 F1 | 	sub	local01, #1
08cf0     56 93 02 F6 | 	mov	arg02, local04
08cf4     55 95 02 F6 | 	mov	arg03, local03
08cf8     57 95 02 F1 | 	add	arg03, local05
08cfc     01 96 06 F6 | 	mov	arg04, #1
08d00     80 F1 BF FD | 	call	#_fatfs_cc_disk_write
08d04     00 76 0E F2 | 	cmp	result1, #0 wz
08d08     01 AE 06 A1 |  if_e	add	local05, #1
08d0c     C0 FF 9F AD |  if_e	jmp	#LR__1450
08d10                 | LR__1451
08d10                 | ' 	}
08d10                 | ' 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
08d10     0A A6 06 F1 | 	add	local01, #10
08d14     53 AD E2 FA | 	rdword	local04, local01
08d18     56 AF 0A F2 | 	cmp	local05, local04 wz
08d1c     00 B0 06 A6 |  if_e	mov	local06, #0
08d20     01 B0 06 56 |  if_ne	mov	local06, #1
08d24     58 77 02 F6 | 	mov	result1, local06
08d28                 | LR__1452
08d28     E7 F0 03 F6 | 	mov	ptra, fp
08d2c     F2 00 A0 FD | 	call	#popregs_
08d30                 | _fatfs_cc_dir_clear_ret
08d30     2D 00 64 FD | 	ret
08d34                 | 
08d34                 | _fatfs_cc_dir_sdi
08d34     06 CA 05 F6 | 	mov	COUNT_, #6
08d38     E8 00 A0 FD | 	call	#pushregs_
08d3c     48 A7 02 F6 | 	mov	local01, arg01
08d40     49 A9 02 F6 | 	mov	local02, arg02
08d44     53 AB 02 FB | 	rdlong	local03, local01
08d48     00 10 00 FF 
08d4c     00 A8 16 F2 | 	cmp	local02, ##2097152 wc
08d50     1F A8 CE C7 |  if_b	test	local02, #31 wz
08d54                 | ' 		return FR_INT_ERR;
08d54     02 76 06 76 |  if_nc_or_nz	mov	result1, #2
08d58     34 01 90 7D |  if_nc_or_nz	jmp	#LR__1466
08d5c     10 A6 06 F1 | 	add	local01, #16
08d60     53 A9 62 FC | 	wrlong	local02, local01
08d64     08 A6 86 F1 | 	sub	local01, #8
08d68     53 AD 0A FB | 	rdlong	local04, local01 wz
08d6c     08 A6 86 F1 | 	sub	local01, #8
08d70     55 AF C2 AA |  if_e	rdbyte	local05, local03
08d74     03 AE 16 A2 |  if_e	cmp	local05, #3 wc
08d78     28 AA 06 21 |  if_nc_and_z	add	local03, #40
08d7c     55 AD 02 2B |  if_nc_and_z	rdlong	local04, local03
08d80     28 AA 86 21 |  if_nc_and_z	sub	local03, #40
08d84     00 AC 0E F2 | 	cmp	local04, #0 wz
08d88     3C 00 90 5D |  if_ne	jmp	#LR__1460
08d8c     54 AF 02 F6 | 	mov	local05, local02
08d90     05 AE 46 F0 | 	shr	local05, #5
08d94     08 AA 06 F1 | 	add	local03, #8
08d98     55 93 E2 FA | 	rdword	arg02, local03
08d9c     08 AA 86 F1 | 	sub	local03, #8
08da0     49 AF 12 F2 | 	cmp	local05, arg02 wc
08da4     02 76 06 36 |  if_ae	mov	result1, #2
08da8     E4 00 90 3D |  if_ae	jmp	#LR__1466
08dac     28 AA 06 F1 | 	add	local03, #40
08db0     55 AF 02 FB | 	rdlong	local05, local03
08db4     28 AA 86 F1 | 	sub	local03, #40
08db8     18 A6 06 F1 | 	add	local01, #24
08dbc     53 AF 62 FC | 	wrlong	local05, local01
08dc0     18 A6 86 F1 | 	sub	local01, #24
08dc4     7C 00 90 FD | 	jmp	#LR__1465
08dc8                 | LR__1460
08dc8     0A AA 06 F1 | 	add	local03, #10
08dcc     55 B1 E2 FA | 	rdword	local06, local03
08dd0     0A AA 86 F1 | 	sub	local03, #10
08dd4     09 B0 66 F0 | 	shl	local06, #9
08dd8                 | ' 		csz = (DWORD)fs->csize *  ((UINT) 512 ) ;
08dd8                 | ' 		while (ofs >= csz) {
08dd8                 | LR__1461
08dd8     58 A9 12 F2 | 	cmp	local02, local06 wc
08ddc     4C 00 90 CD |  if_b	jmp	#LR__1464
08de0     53 91 02 F6 | 	mov	arg01, local01
08de4     56 93 02 F6 | 	mov	arg02, local04
08de8     9C F7 BF FD | 	call	#_fatfs_cc_get_fat
08dec     3B AD 02 F6 | 	mov	local04, result1
08df0     FF FF 7F FF 
08df4     FF AD 0E F2 | 	cmp	local04, ##-1 wz
08df8     01 76 06 A6 |  if_e	mov	result1, #1
08dfc     90 00 90 AD |  if_e	jmp	#LR__1466
08e00     02 AC 16 F2 | 	cmp	local04, #2 wc
08e04     14 00 90 CD |  if_b	jmp	#LR__1462
08e08     18 AA 06 F1 | 	add	local03, #24
08e0c     55 AF 02 FB | 	rdlong	local05, local03
08e10     18 AA 86 F1 | 	sub	local03, #24
08e14     57 AD 12 F2 | 	cmp	local04, local05 wc
08e18     08 00 90 CD |  if_b	jmp	#LR__1463
08e1c                 | LR__1462
08e1c     02 76 06 F6 | 	mov	result1, #2
08e20     6C 00 90 FD | 	jmp	#LR__1466
08e24                 | LR__1463
08e24     58 A9 82 F1 | 	sub	local02, local06
08e28     AC FF 9F FD | 	jmp	#LR__1461
08e2c                 | LR__1464
08e2c     55 91 02 F6 | 	mov	arg01, local03
08e30     56 93 02 F6 | 	mov	arg02, local04
08e34     10 F7 BF FD | 	call	#_fatfs_cc_clst2sect
08e38     18 A6 06 F1 | 	add	local01, #24
08e3c     53 77 62 FC | 	wrlong	result1, local01
08e40     18 A6 86 F1 | 	sub	local01, #24
08e44                 | LR__1465
08e44     14 A6 06 F1 | 	add	local01, #20
08e48     53 AD 62 FC | 	wrlong	local04, local01
08e4c     04 A6 06 F1 | 	add	local01, #4
08e50     53 AF 0A FB | 	rdlong	local05, local01 wz
08e54     18 A6 86 F1 | 	sub	local01, #24
08e58     02 76 06 A6 |  if_e	mov	result1, #2
08e5c     30 00 90 AD |  if_e	jmp	#LR__1466
08e60     54 B1 02 F6 | 	mov	local06, local02
08e64     09 B0 46 F0 | 	shr	local06, #9
08e68     18 A6 06 F1 | 	add	local01, #24
08e6c     53 AF 02 FB | 	rdlong	local05, local01
08e70     58 AF 02 F1 | 	add	local05, local06
08e74     53 AF 62 FC | 	wrlong	local05, local01
08e78     34 AA 06 F1 | 	add	local03, #52
08e7c     FF A9 06 F5 | 	and	local02, #511
08e80     54 AB 02 F1 | 	add	local03, local02
08e84     04 A6 06 F1 | 	add	local01, #4
08e88     53 AB 62 FC | 	wrlong	local03, local01
08e8c                 | ' 	dp->sect += ofs /  ((UINT) 512 ) ;
08e8c                 | ' 	dp->dir = fs->win + (ofs %  ((UINT) 512 ) );
08e8c                 | ' 
08e8c                 | ' 	return FR_OK;
08e8c     00 76 06 F6 | 	mov	result1, #0
08e90                 | LR__1466
08e90     E7 F0 03 F6 | 	mov	ptra, fp
08e94     F2 00 A0 FD | 	call	#popregs_
08e98                 | _fatfs_cc_dir_sdi_ret
08e98     2D 00 64 FD | 	ret
08e9c                 | 
08e9c                 | _fatfs_cc_dir_next
08e9c     05 CA 05 F6 | 	mov	COUNT_, #5
08ea0     E8 00 A0 FD | 	call	#pushregs_
08ea4     48 A7 02 F6 | 	mov	local01, arg01
08ea8     49 A9 02 F6 | 	mov	local02, arg02
08eac     53 AB 02 FB | 	rdlong	local03, local01
08eb0     10 A6 06 F1 | 	add	local01, #16
08eb4     53 AD 02 FB | 	rdlong	local04, local01
08eb8     10 A6 86 F1 | 	sub	local01, #16
08ebc     20 AC 06 F1 | 	add	local04, #32
08ec0     00 10 00 FF 
08ec4     00 AC 16 F2 | 	cmp	local04, ##2097152 wc
08ec8     18 A6 06 31 |  if_ae	add	local01, #24
08ecc     53 01 68 3C |  if_ae	wrlong	#0, local01
08ed0     18 A6 86 31 |  if_ae	sub	local01, #24
08ed4     18 A6 06 F1 | 	add	local01, #24
08ed8     53 93 0A FB | 	rdlong	arg02, local01 wz
08edc     18 A6 86 F1 | 	sub	local01, #24
08ee0     04 76 06 A6 |  if_e	mov	result1, #4
08ee4     64 01 90 AD |  if_e	jmp	#LR__1475
08ee8     FF AD CE F7 | 	test	local04, #511 wz
08eec     3C 01 90 5D |  if_ne	jmp	#LR__1474
08ef0     18 A6 06 F1 | 	add	local01, #24
08ef4     53 93 02 FB | 	rdlong	arg02, local01
08ef8     01 92 06 F1 | 	add	arg02, #1
08efc     53 93 62 FC | 	wrlong	arg02, local01
08f00     04 A6 86 F1 | 	sub	local01, #4
08f04     53 93 0A FB | 	rdlong	arg02, local01 wz
08f08     14 A6 86 F1 | 	sub	local01, #20
08f0c     2C 00 90 5D |  if_ne	jmp	#LR__1470
08f10     56 93 02 F6 | 	mov	arg02, local04
08f14     05 92 46 F0 | 	shr	arg02, #5
08f18     08 AA 06 F1 | 	add	local03, #8
08f1c     55 A9 E2 FA | 	rdword	local02, local03
08f20     08 AA 86 F1 | 	sub	local03, #8
08f24     54 93 12 F2 | 	cmp	arg02, local02 wc
08f28     18 A6 06 31 |  if_ae	add	local01, #24
08f2c     53 01 68 3C |  if_ae	wrlong	#0, local01
08f30                 | ' 				dp->sect = 0; return FR_NO_FILE;
08f30     04 76 06 36 |  if_ae	mov	result1, #4
08f34     14 01 90 3D |  if_ae	jmp	#LR__1475
08f38     F0 00 90 FD | 	jmp	#LR__1473
08f3c                 | LR__1470
08f3c     56 91 02 F6 | 	mov	arg01, local04
08f40     09 90 46 F0 | 	shr	arg01, #9
08f44     0A AA 06 F1 | 	add	local03, #10
08f48     55 93 E2 FA | 	rdword	arg02, local03
08f4c     0A AA 86 F1 | 	sub	local03, #10
08f50     01 92 86 F1 | 	sub	arg02, #1
08f54     49 91 CA F7 | 	test	arg01, arg02 wz
08f58     D0 00 90 5D |  if_ne	jmp	#LR__1472
08f5c     53 91 02 F6 | 	mov	arg01, local01
08f60     14 A6 06 F1 | 	add	local01, #20
08f64     53 93 02 FB | 	rdlong	arg02, local01
08f68     14 A6 86 F1 | 	sub	local01, #20
08f6c     18 F6 BF FD | 	call	#_fatfs_cc_get_fat
08f70     3B AF 02 F6 | 	mov	local05, result1
08f74     02 AE 16 F2 | 	cmp	local05, #2 wc
08f78     02 76 06 C6 |  if_b	mov	result1, #2
08f7c     CC 00 90 CD |  if_b	jmp	#LR__1475
08f80     FF FF 7F FF 
08f84     FF AF 0E F2 | 	cmp	local05, ##-1 wz
08f88     01 76 06 A6 |  if_e	mov	result1, #1
08f8c     BC 00 90 AD |  if_e	jmp	#LR__1475
08f90     18 AA 06 F1 | 	add	local03, #24
08f94     55 93 02 FB | 	rdlong	arg02, local03
08f98     18 AA 86 F1 | 	sub	local03, #24
08f9c     49 AF 12 F2 | 	cmp	local05, arg02 wc
08fa0     68 00 90 CD |  if_b	jmp	#LR__1471
08fa4     00 A8 0E F2 | 	cmp	local02, #0 wz
08fa8     18 A6 06 A1 |  if_e	add	local01, #24
08fac     53 01 68 AC |  if_e	wrlong	#0, local01
08fb0                 | ' 						dp->sect = 0; return FR_NO_FILE;
08fb0     04 76 06 A6 |  if_e	mov	result1, #4
08fb4     94 00 90 AD |  if_e	jmp	#LR__1475
08fb8     53 91 02 F6 | 	mov	arg01, local01
08fbc     14 A6 06 F1 | 	add	local01, #20
08fc0     53 93 02 FB | 	rdlong	arg02, local01
08fc4     14 A6 86 F1 | 	sub	local01, #20
08fc8     84 FA BF FD | 	call	#_fatfs_cc_create_chain
08fcc     3B AF 0A F6 | 	mov	local05, result1 wz
08fd0     07 76 06 A6 |  if_e	mov	result1, #7
08fd4     74 00 90 AD |  if_e	jmp	#LR__1475
08fd8     01 AE 0E F2 | 	cmp	local05, #1 wz
08fdc     02 76 06 A6 |  if_e	mov	result1, #2
08fe0     68 00 90 AD |  if_e	jmp	#LR__1475
08fe4     FF FF 7F FF 
08fe8     FF AF 0E F2 | 	cmp	local05, ##-1 wz
08fec     01 76 06 A6 |  if_e	mov	result1, #1
08ff0     58 00 90 AD |  if_e	jmp	#LR__1475
08ff4     57 93 02 F6 | 	mov	arg02, local05
08ff8     55 91 02 F6 | 	mov	arg01, local03
08ffc     74 FC BF FD | 	call	#_fatfs_cc_dir_clear
09000     00 76 0E F2 | 	cmp	result1, #0 wz
09004     01 76 06 56 |  if_ne	mov	result1, #1
09008     40 00 90 5D |  if_ne	jmp	#LR__1475
0900c                 | LR__1471
0900c     14 A6 06 F1 | 	add	local01, #20
09010     53 AF 62 FC | 	wrlong	local05, local01
09014     55 91 02 F6 | 	mov	arg01, local03
09018     57 93 02 F6 | 	mov	arg02, local05
0901c     28 F5 BF FD | 	call	#_fatfs_cc_clst2sect
09020     04 A6 06 F1 | 	add	local01, #4
09024     53 77 62 FC | 	wrlong	result1, local01
09028     18 A6 86 F1 | 	sub	local01, #24
0902c                 | LR__1472
0902c                 | LR__1473
0902c                 | LR__1474
0902c     10 A6 06 F1 | 	add	local01, #16
09030     53 AD 62 FC | 	wrlong	local04, local01
09034     34 AA 06 F1 | 	add	local03, #52
09038     FF AD 06 F5 | 	and	local04, #511
0903c     56 AB 02 F1 | 	add	local03, local04
09040     0C A6 06 F1 | 	add	local01, #12
09044     53 AB 62 FC | 	wrlong	local03, local01
09048                 | ' #line 1771 "ff.c"
09048                 | ' 				}
09048                 | ' 				dp->clust = clst;
09048                 | ' 				dp->sect = clst2sect(fs, clst);
09048                 | ' 			}
09048                 | ' 		}
09048                 | ' 	}
09048                 | ' 	dp->dptr = ofs;
09048                 | ' 	dp->dir = fs->win + ofs %  ((UINT) 512 ) ;
09048                 | ' 
09048                 | ' 	return FR_OK;
09048     00 76 06 F6 | 	mov	result1, #0
0904c                 | LR__1475
0904c     E7 F0 03 F6 | 	mov	ptra, fp
09050     F2 00 A0 FD | 	call	#popregs_
09054                 | _fatfs_cc_dir_next_ret
09054     2D 00 64 FD | 	ret
09058                 | 
09058                 | _fatfs_cc_dir_alloc
09058     08 CA 05 F6 | 	mov	COUNT_, #8
0905c     E8 00 A0 FD | 	call	#pushregs_
09060     48 A7 02 F6 | 	mov	local01, arg01
09064     49 A9 02 F6 | 	mov	local02, arg02
09068     53 AB 02 FB | 	rdlong	local03, local01
0906c     53 91 02 F6 | 	mov	arg01, local01
09070     00 92 06 F6 | 	mov	arg02, #0
09074     BC FC BF FD | 	call	#_fatfs_cc_dir_sdi
09078     3B AD 0A F6 | 	mov	local04, result1 wz
0907c     70 00 90 5D |  if_ne	jmp	#LR__1484
09080     00 AE 06 F6 | 	mov	local05, #0
09084                 | ' 		n = 0;
09084                 | ' 		do {
09084                 | LR__1480
09084     18 A6 06 F1 | 	add	local01, #24
09088     53 93 02 FB | 	rdlong	arg02, local01
0908c     18 A6 86 F1 | 	sub	local01, #24
09090     55 91 02 F6 | 	mov	arg01, local03
09094     38 F3 BF FD | 	call	#_fatfs_cc_move_window
09098     3B AD 0A F6 | 	mov	local04, result1 wz
0909c     50 00 90 5D |  if_ne	jmp	#LR__1483
090a0     1C A6 06 F1 | 	add	local01, #28
090a4     53 B1 02 FB | 	rdlong	local06, local01
090a8     1C A6 86 F1 | 	sub	local01, #28
090ac     58 B1 C2 FA | 	rdbyte	local06, local06
090b0     E5 B0 0E F2 | 	cmp	local06, #229 wz
090b4     1C A6 06 51 |  if_ne	add	local01, #28
090b8     53 B3 02 5B |  if_ne	rdlong	local07, local01
090bc     1C A6 86 51 |  if_ne	sub	local01, #28
090c0     59 B5 CA 5A |  if_ne	rdbyte	local08, local07 wz
090c4     10 00 90 5D |  if_ne	jmp	#LR__1481
090c8     01 AE 06 F1 | 	add	local05, #1
090cc     54 AF 0A F2 | 	cmp	local05, local02 wz
090d0     1C 00 90 AD |  if_e	jmp	#LR__1483
090d4     04 00 90 FD | 	jmp	#LR__1482
090d8                 | LR__1481
090d8     00 AE 06 F6 | 	mov	local05, #0
090dc                 | LR__1482
090dc     53 91 02 F6 | 	mov	arg01, local01
090e0     01 92 06 F6 | 	mov	arg02, #1
090e4     B4 FD BF FD | 	call	#_fatfs_cc_dir_next
090e8     3B AD 0A F6 | 	mov	local04, result1 wz
090ec     94 FF 9F AD |  if_e	jmp	#LR__1480
090f0                 | LR__1483
090f0                 | LR__1484
090f0     04 AC 0E F2 | 	cmp	local04, #4 wz
090f4     07 AC 06 A6 |  if_e	mov	local04, #7
090f8                 | ' 	return res;
090f8     56 77 02 F6 | 	mov	result1, local04
090fc     E7 F0 03 F6 | 	mov	ptra, fp
09100     F2 00 A0 FD | 	call	#popregs_
09104                 | _fatfs_cc_dir_alloc_ret
09104     2D 00 64 FD | 	ret
09108                 | 
09108                 | _fatfs_cc_ld_clust
09108     48 7D 02 F6 | 	mov	_var01, arg01
0910c     49 91 02 F6 | 	mov	arg01, arg02
09110     1A 90 06 F1 | 	add	arg01, #26
09114                 | ' {
09114                 | ' 
09114                 | ' 	return *((WORD*)ptr);
09114     48 77 E2 FA | 	rdword	result1, arg01
09118     3B 91 32 F9 | 	getword	arg01, result1, #0
0911c     3E 7D C2 FA | 	rdbyte	_var01, _var01
09120     03 7C 0E F2 | 	cmp	_var01, #3 wz
09124     14 92 06 A1 |  if_e	add	arg02, #20
09128                 | ' {
09128                 | ' 
09128                 | ' 	return *((WORD*)ptr);
09128     49 77 E2 AA |  if_e	rdword	result1, arg02
0912c     10 76 66 A0 |  if_e	shl	result1, #16
09130     3B 91 42 A5 |  if_e	or	arg01, result1
09134                 | ' 		cl |= (DWORD)ld_word(dir +  20 ) << 16;
09134                 | ' 	}
09134                 | ' 
09134                 | ' 	return cl;
09134     48 77 02 F6 | 	mov	result1, arg01
09138                 | _fatfs_cc_ld_clust_ret
09138     2D 00 64 FD | 	ret
0913c                 | 
0913c                 | _fatfs_cc_st_clust
0913c     48 7D 02 F6 | 	mov	_var01, arg01
09140     49 91 02 F6 | 	mov	arg01, arg02
09144     1A 90 06 F1 | 	add	arg01, #26
09148     48 95 52 FC | 	wrword	arg03, arg01
0914c     3E 7D C2 FA | 	rdbyte	_var01, _var01
09150     03 7C 0E F2 | 	cmp	_var01, #3 wz
09154     14 92 06 A1 |  if_e	add	arg02, #20
09158     10 94 46 A0 |  if_e	shr	arg03, #16
0915c     49 95 52 AC |  if_e	wrword	arg03, arg02
09160                 | _fatfs_cc_st_clust_ret
09160     2D 00 64 FD | 	ret
09164                 | 
09164                 | _fatfs_cc_cmp_lfn
09164     07 CA 05 F6 | 	mov	COUNT_, #7
09168     E8 00 A0 FD | 	call	#pushregs_
0916c     48 A7 02 F6 | 	mov	local01, arg01
09170     49 91 02 F6 | 	mov	arg01, arg02
09174     1A 90 06 F1 | 	add	arg01, #26
09178                 | ' {
09178                 | ' 
09178                 | ' 	return *((WORD*)ptr);
09178     48 77 EA FA | 	rdword	result1, arg01 wz
0917c     00 76 06 56 |  if_ne	mov	result1, #0
09180     D8 00 90 5D |  if_ne	jmp	#LR__1496
09184     49 A9 C2 FA | 	rdbyte	local02, arg02
09188     3F A8 06 F5 | 	and	local02, #63
0918c     01 A8 86 F1 | 	sub	local02, #1
09190     0D A8 06 FD | 	qmul	local02, #13
09194                 | ' 
09194                 | ' 	i = ((dir[ 0 ] & 0x3F) - 1) * 13;
09194                 | ' 
09194                 | ' 	for (wc = 1, s = 0; s < 13; s++) {
09194     01 AA 06 F6 | 	mov	local03, #1
09198     00 AC 06 F6 | 	mov	local04, #0
0919c     18 AE 62 FD | 	getqx	local05
091a0                 | LR__1490
091a0     0D AC 16 F2 | 	cmp	local04, #13 wc
091a4     94 00 90 3D |  if_ae	jmp	#LR__1495
091a8     49 91 02 F6 | 	mov	arg01, arg02
091ac     56 A9 02 F6 | 	mov	local02, local04
091b0     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
091b4     01 00 00 FF 
091b8     AE 77 06 F1 | 	add	result1, ##942
091bc     3B A9 02 F1 | 	add	local02, result1
091c0     54 A9 C2 FA | 	rdbyte	local02, local02
091c4     54 91 02 F1 | 	add	arg01, local02
091c8                 | ' {
091c8                 | ' 
091c8                 | ' 	return *((WORD*)ptr);
091c8     48 77 E2 FA | 	rdword	result1, arg01
091cc     3B B1 02 F6 | 	mov	local06, result1
091d0     55 A9 02 F6 | 	mov	local02, local03
091d4     0F A8 4E F7 | 	zerox	local02, #15 wz
091d8     44 00 90 AD |  if_e	jmp	#LR__1493
091dc     00 AF 16 F2 | 	cmp	local05, #256 wc
091e0     2C 00 90 3D |  if_ae	jmp	#LR__1491
091e4     58 91 32 F9 | 	getword	arg01, local06, #0
091e8     CC E4 BF FD | 	call	#_fatfs_cc_ff_wtoupper
091ec     3B A9 02 F6 | 	mov	local02, result1
091f0     57 AB 02 F6 | 	mov	local03, local05
091f4     01 AA 66 F0 | 	shl	local03, #1
091f8     53 AB 02 F1 | 	add	local03, local01
091fc     55 91 E2 FA | 	rdword	arg01, local03
09200     01 AE 06 F1 | 	add	local05, #1
09204     B0 E4 BF FD | 	call	#_fatfs_cc_ff_wtoupper
09208     3B A9 0A F2 | 	cmp	local02, result1 wz
0920c     08 00 90 AD |  if_e	jmp	#LR__1492
09210                 | LR__1491
09210                 | ' 				return 0;
09210     00 76 06 F6 | 	mov	result1, #0
09214     44 00 90 FD | 	jmp	#LR__1496
09218                 | LR__1492
09218     58 AB 02 F6 | 	mov	local03, local06
0921c     14 00 90 FD | 	jmp	#LR__1494
09220                 | LR__1493
09220     58 B1 32 F9 | 	getword	local06, local06, #0
09224     7F 00 00 FF 
09228     FF B1 0E F2 | 	cmp	local06, ##65535 wz
0922c     00 76 06 56 |  if_ne	mov	result1, #0
09230     28 00 90 5D |  if_ne	jmp	#LR__1496
09234                 | LR__1494
09234     01 AC 06 F1 | 	add	local04, #1
09238     64 FF 9F FD | 	jmp	#LR__1490
0923c                 | LR__1495
0923c     49 A9 C2 FA | 	rdbyte	local02, arg02
09240     40 A8 CE F7 | 	test	local02, #64 wz
09244     00 AA 0E 52 |  if_ne	cmp	local03, #0 wz
09248     01 AE 66 50 |  if_ne	shl	local05, #1
0924c     53 AF 02 51 |  if_ne	add	local05, local01
09250     57 B3 EA 5A |  if_ne	rdword	local07, local05 wz
09254     00 76 06 56 |  if_ne	mov	result1, #0
09258                 | ' 
09258                 | ' 	return 1;
09258     01 76 06 A6 |  if_e	mov	result1, #1
0925c                 | LR__1496
0925c     E7 F0 03 F6 | 	mov	ptra, fp
09260     F2 00 A0 FD | 	call	#popregs_
09264                 | _fatfs_cc_cmp_lfn_ret
09264     2D 00 64 FD | 	ret
09268                 | 
09268                 | _fatfs_cc_pick_lfn
09268     48 7D 02 F6 | 	mov	_var01, arg01
0926c     49 91 02 F6 | 	mov	arg01, arg02
09270     1A 90 06 F1 | 	add	arg01, #26
09274                 | ' {
09274                 | ' 
09274                 | ' 	return *((WORD*)ptr);
09274     48 77 EA FA | 	rdword	result1, arg01 wz
09278     00 76 06 56 |  if_ne	mov	result1, #0
0927c     CC 00 90 5D |  if_ne	jmp	#LR__1505
09280     49 7F C2 FA | 	rdbyte	_var02, arg02
09284     40 7E 26 F5 | 	andn	_var02, #64
09288     01 7E 86 F1 | 	sub	_var02, #1
0928c     0D 7E 06 FD | 	qmul	_var02, #13
09290                 | ' 
09290                 | ' 	i = ((dir[ 0 ] & ~ 0x40 ) - 1) * 13;
09290                 | ' 
09290                 | ' 	for (wc = 1, s = 0; s < 13; s++) {
09290     01 80 06 F6 | 	mov	_var03, #1
09294     00 82 06 F6 | 	mov	_var04, #0
09298     18 84 62 FD | 	getqx	_var05
0929c                 | LR__1500
0929c     0D 82 16 F2 | 	cmp	_var04, #13 wc
092a0     78 00 90 3D |  if_ae	jmp	#LR__1503
092a4     49 91 02 F6 | 	mov	arg01, arg02
092a8     41 7F 02 F6 | 	mov	_var02, _var04
092ac     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
092b0     01 00 00 FF 
092b4     AE 77 06 F1 | 	add	result1, ##942
092b8     3B 7F 02 F1 | 	add	_var02, result1
092bc     3F 7F C2 FA | 	rdbyte	_var02, _var02
092c0     3F 91 02 F1 | 	add	arg01, _var02
092c4                 | ' {
092c4                 | ' 
092c4                 | ' 	return *((WORD*)ptr);
092c4     48 77 E2 FA | 	rdword	result1, arg01
092c8     3B 87 02 F6 | 	mov	_var06, result1
092cc     40 7F 02 F6 | 	mov	_var02, _var03
092d0     0F 7E 4E F7 | 	zerox	_var02, #15 wz
092d4     28 00 90 AD |  if_e	jmp	#LR__1501
092d8     00 85 16 F2 | 	cmp	_var05, #256 wc
092dc     00 76 06 36 |  if_ae	mov	result1, #0
092e0     68 00 90 3D |  if_ae	jmp	#LR__1505
092e4     42 7F 02 F6 | 	mov	_var02, _var05
092e8     01 7E 66 F0 | 	shl	_var02, #1
092ec     3E 7F 02 F1 | 	add	_var02, _var01
092f0     43 81 02 F6 | 	mov	_var03, _var06
092f4     3F 81 52 FC | 	wrword	_var03, _var02
092f8     01 84 06 F1 | 	add	_var05, #1
092fc     14 00 90 FD | 	jmp	#LR__1502
09300                 | LR__1501
09300     43 87 32 F9 | 	getword	_var06, _var06, #0
09304     7F 00 00 FF 
09308     FF 87 0E F2 | 	cmp	_var06, ##65535 wz
0930c     00 76 06 56 |  if_ne	mov	result1, #0
09310     38 00 90 5D |  if_ne	jmp	#LR__1505
09314                 | LR__1502
09314     01 82 06 F1 | 	add	_var04, #1
09318     80 FF 9F FD | 	jmp	#LR__1500
0931c                 | LR__1503
0931c     49 7F C2 FA | 	rdbyte	_var02, arg02
09320     40 7E CE F7 | 	test	_var02, #64 wz
09324     40 89 02 56 |  if_ne	mov	_var07, _var03
09328     0F 88 4E 57 |  if_ne	zerox	_var07, #15 wz
0932c     18 00 90 AD |  if_e	jmp	#LR__1504
09330     00 85 16 F2 | 	cmp	_var05, #256 wc
09334     00 76 06 36 |  if_ae	mov	result1, #0
09338     10 00 90 3D |  if_ae	jmp	#LR__1505
0933c     01 84 66 F0 | 	shl	_var05, #1
09340     3E 85 02 F1 | 	add	_var05, _var01
09344     42 01 58 FC | 	wrword	#0, _var05
09348                 | LR__1504
09348                 | ' 		lfnbuf[i] = 0;
09348                 | ' 	}
09348                 | ' 
09348                 | ' 	return 1;
09348     01 76 06 F6 | 	mov	result1, #1
0934c                 | LR__1505
0934c                 | _fatfs_cc_pick_lfn_ret
0934c     2D 00 64 FD | 	ret
09350                 | 
09350                 | _fatfs_cc_put_lfn
09350     49 7D 02 F6 | 	mov	_var01, arg02
09354     0D 7C 06 F1 | 	add	_var01, #13
09358     3E 97 42 FC | 	wrbyte	arg04, _var01
0935c     4A 97 E2 F8 | 	getbyte	arg04, arg03, #0
09360     01 96 86 F1 | 	sub	arg04, #1
09364     0D 96 06 FD | 	qmul	arg04, #13
09368     48 7F 02 F6 | 	mov	_var02, arg01
0936c     02 7C 86 F1 | 	sub	_var01, #2
09370     3E 1F 48 FC | 	wrbyte	#15, _var01
09374     01 7C 06 F1 | 	add	_var01, #1
09378     3E 01 48 FC | 	wrbyte	#0, _var01
0937c     0C 7C 86 F1 | 	sub	_var01, #12
09380     3E 91 02 F6 | 	mov	arg01, _var01
09384     1A 90 06 F1 | 	add	arg01, #26
09388     48 01 58 FC | 	wrword	#0, arg01
0938c     00 80 06 F6 | 	mov	_var03, #0
09390     00 82 06 F6 | 	mov	_var04, #0
09394                 | ' 	BYTE* dir,
09394                 | ' 	BYTE ord,
09394                 | ' 	BYTE sum
09394                 | ' )
09394                 | ' {
09394                 | ' 	UINT i, s;
09394                 | ' 	WCHAR wc;
09394                 | ' 
09394                 | ' 
09394                 | ' 	dir[ 13 ] = sum;
09394                 | ' 	dir[ 11 ] =  0x0F ;
09394                 | ' 	dir[ 12 ] = 0;
09394                 | ' 	st_word(dir +  26 , 0);
09394                 | ' 
09394                 | ' 	i = (ord - 1) * 13;
09394                 | ' 	s = wc = 0;
09394                 | ' 	do {
09394     18 84 62 FD | 	getqx	_var05
09398     D7 2E 48 FB | 	callpa	#(@LR__1511-@LR__1510)>>2,fcache_load_ptr_
0939c                 | LR__1510
0939c     40 97 32 F9 | 	getword	arg04, _var03, #0
093a0     7F 00 00 FF 
093a4     FF 97 0E F2 | 	cmp	arg04, ##65535 wz
093a8     42 91 02 56 |  if_ne	mov	arg01, _var05
093ac     01 84 06 51 |  if_ne	add	_var05, #1
093b0     01 90 66 50 |  if_ne	shl	arg01, #1
093b4     3F 91 02 51 |  if_ne	add	arg01, _var02
093b8     48 81 E2 5A |  if_ne	rdword	_var03, arg01
093bc     3E 91 02 F6 | 	mov	arg01, _var01
093c0     41 97 02 F6 | 	mov	arg04, _var04
093c4     35 93 02 F6 | 	mov	arg02, ptr__fatfs_cc_dat__
093c8     01 00 00 FF 
093cc     AE 93 06 F1 | 	add	arg02, ##942
093d0     49 97 02 F1 | 	add	arg04, arg02
093d4     4B 97 C2 FA | 	rdbyte	arg04, arg04
093d8     4B 91 02 F1 | 	add	arg01, arg04
093dc     48 81 52 FC | 	wrword	_var03, arg01
093e0     40 97 02 F6 | 	mov	arg04, _var03
093e4     0F 96 4E F7 | 	zerox	arg04, #15 wz
093e8     0F 80 CE A9 |  if_e	bmask	_var03, #15
093ec     01 82 06 F1 | 	add	_var04, #1
093f0     0D 82 16 F2 | 	cmp	_var04, #13 wc
093f4     A4 FF 9F CD |  if_b	jmp	#LR__1510
093f8                 | LR__1511
093f8     40 81 32 F9 | 	getword	_var03, _var03, #0
093fc     7F 00 00 FF 
09400     FF 81 0E F2 | 	cmp	_var03, ##65535 wz
09404     01 84 66 50 |  if_ne	shl	_var05, #1
09408     3F 85 02 51 |  if_ne	add	_var05, _var02
0940c     42 85 EA 5A |  if_ne	rdword	_var05, _var05 wz
09410     4A 95 E2 A8 |  if_e	getbyte	arg03, arg03, #0
09414     40 94 46 A5 |  if_e	or	arg03, #64
09418     3E 95 42 FC | 	wrbyte	arg03, _var01
0941c                 | _fatfs_cc_put_lfn_ret
0941c     2D 00 64 FD | 	ret
09420                 | 
09420                 | _fatfs_cc_gen_numname
09420     08 CA 05 F6 | 	mov	COUNT_, #8
09424     E8 00 A0 FD | 	call	#pushregs_
09428     2C F0 07 F1 | 	add	ptra, #44
0942c     48 A7 02 F6 | 	mov	local01, arg01
09430     49 A9 02 F6 | 	mov	local02, arg02
09434     4A AB 02 F6 | 	mov	local03, arg03
09438     4B AD 02 F6 | 	mov	local04, arg04
0943c     53 91 02 F6 | 	mov	arg01, local01
09440     54 93 02 F6 | 	mov	arg02, local02
09444     0B 94 06 F6 | 	mov	arg03, #11
09448     8C 98 BF FD | 	call	#__system____builtin_memmove
0944c     06 AC 16 F2 | 	cmp	local04, #6 wc
09450     48 00 90 CD |  if_b	jmp	#LR__1525
09454     56 AF 02 F6 | 	mov	local05, local04
09458     D7 1E 48 FB | 	callpa	#(@LR__1523-@LR__1520)>>2,fcache_load_ptr_
0945c                 | ' 		sreg = seq;
0945c                 | ' 		while (*lfn) {
0945c                 | LR__1520
0945c     55 B1 EA FA | 	rdword	local06, local03 wz
09460     34 00 90 AD |  if_e	jmp	#LR__1524
09464     55 B3 E2 FA | 	rdword	local07, local03
09468                 | ' 			wc = *lfn++;
09468                 | ' 			for (i = 0; i < 16; i++) {
09468     02 AA 06 F1 | 	add	local03, #2
0946c     10 12 DC FC | 	rep	@LR__1522, #16
09470                 | LR__1521
09470     01 AE 66 F0 | 	shl	local05, #1
09474     59 B1 32 F9 | 	getword	local06, local07, #0
09478     01 B0 06 F5 | 	and	local06, #1
0947c     58 AF 02 F1 | 	add	local05, local06
09480     59 B3 32 F9 | 	getword	local07, local07, #0
09484     01 B2 46 F0 | 	shr	local07, #1
09488     10 AE 2E F4 | 	testbn	local05, #16 wz
0948c     88 00 00 5F 
09490     21 AE 66 55 |  if_ne	xor	local05, ##69665
09494                 | LR__1522
09494     C4 FF 9F FD | 	jmp	#LR__1520
09498                 | LR__1523
09498                 | LR__1524
09498     57 AD 02 F6 | 	mov	local04, local05
0949c                 | LR__1525
0949c     07 B2 06 F6 | 	mov	local07, #7
094a0     D7 1E 48 FB | 	callpa	#(@LR__1527-@LR__1526)>>2,fcache_load_ptr_
094a4                 | ' 			}
094a4                 | ' 		}
094a4                 | ' 		seq = (UINT)sreg;
094a4                 | ' 	}
094a4                 | ' 
094a4                 | ' 
094a4                 | ' 	i = 7;
094a4                 | ' 	do {
094a4                 | LR__1526
094a4     56 AF 42 F8 | 	getnib	local05, local04, #0
094a8     30 AE 06 F1 | 	add	local05, #48
094ac     04 AC 46 F0 | 	shr	local04, #4
094b0     57 B1 E2 F8 | 	getbyte	local06, local05, #0
094b4     3A B0 16 F2 | 	cmp	local06, #58 wc
094b8     57 AF E2 38 |  if_ae	getbyte	local05, local05, #0
094bc     07 AE 06 31 |  if_ae	add	local05, #7
094c0     59 B1 02 F6 | 	mov	local06, local07
094c4     01 B2 8E F1 | 	sub	local07, #1 wz
094c8     E7 AA 02 F6 | 	mov	local03, fp
094cc     10 AA 06 F1 | 	add	local03, #16
094d0     55 B1 02 F1 | 	add	local06, local03
094d4     58 AF 42 FC | 	wrbyte	local05, local06
094d8     00 AC 0E 52 |  if_ne	cmp	local04, #0 wz
094dc     C4 FF 9F 5D |  if_ne	jmp	#LR__1526
094e0                 | LR__1527
094e0     59 B1 02 F6 | 	mov	local06, local07
094e4     E7 AE 02 F6 | 	mov	local05, fp
094e8     10 AE 06 F1 | 	add	local05, #16
094ec     57 B1 02 F1 | 	add	local06, local05
094f0     58 FD 48 FC | 	wrbyte	#126, local06
094f4                 | ' 	ns[i] = '~';
094f4                 | ' 
094f4                 | ' 
094f4                 | ' 	for (j = 0; j < i && dst[j] != ' '; j++) {
094f4     00 AC 06 F6 | 	mov	local04, #0
094f8     D7 2A 48 FB | 	callpa	#(@LR__1530-@LR__1528)>>2,fcache_load_ptr_
094fc                 | LR__1528
094fc     59 AD 12 F2 | 	cmp	local04, local07 wc
09500     4C 00 90 3D |  if_ae	jmp	#LR__1531
09504     56 AF 02 F6 | 	mov	local05, local04
09508     53 AF 02 F1 | 	add	local05, local01
0950c     57 B1 C2 FA | 	rdbyte	local06, local05
09510     20 B0 0E F2 | 	cmp	local06, #32 wz
09514     38 00 90 AD |  if_e	jmp	#LR__1531
09518     56 AB 02 F6 | 	mov	local03, local04
0951c     53 AB 02 F1 | 	add	local03, local01
09520     55 91 CA FA | 	rdbyte	arg01, local03 wz
09524     00 76 06 56 |  if_ne	mov	result1, #0
09528                 | ' 
09528                 | ' 	return 0;
09528     00 76 06 A6 |  if_e	mov	result1, #0
0952c     00 76 0E F2 | 	cmp	result1, #0 wz
09530     14 00 90 AD |  if_e	jmp	#LR__1529
09534     59 AB 02 F6 | 	mov	local03, local07
09538     01 AA 86 F1 | 	sub	local03, #1
0953c     55 AD 0A F2 | 	cmp	local04, local03 wz
09540     0C 00 90 AD |  if_e	jmp	#LR__1531
09544     01 AC 06 F1 | 	add	local04, #1
09548                 | LR__1529
09548     01 AC 06 F1 | 	add	local04, #1
0954c     AC FF 9F FD | 	jmp	#LR__1528
09550                 | LR__1530
09550                 | LR__1531
09550     D7 20 48 FB | 	callpa	#(@LR__1535-@LR__1532)>>2,fcache_load_ptr_
09554                 | ' 			j++;
09554                 | ' 		}
09554                 | ' 	}
09554                 | ' 	do {
09554                 | LR__1532
09554     56 B1 02 F6 | 	mov	local06, local04
09558     53 B1 02 F1 | 	add	local06, local01
0955c     08 B2 16 F2 | 	cmp	local07, #8 wc
09560     01 AC 06 F1 | 	add	local04, #1
09564     1C 00 90 3D |  if_ae	jmp	#LR__1533
09568     59 AF 02 F6 | 	mov	local05, local07
0956c     E7 AA 02 F6 | 	mov	local03, fp
09570     10 AA 06 F1 | 	add	local03, #16
09574     55 AF 02 F1 | 	add	local05, local03
09578     57 B5 C2 FA | 	rdbyte	local08, local05
0957c     01 B2 06 F1 | 	add	local07, #1
09580     04 00 90 FD | 	jmp	#LR__1534
09584                 | LR__1533
09584     20 B4 06 F6 | 	mov	local08, #32
09588                 | LR__1534
09588     58 B5 42 FC | 	wrbyte	local08, local06
0958c     08 AC 16 F2 | 	cmp	local04, #8 wc
09590     C0 FF 9F CD |  if_b	jmp	#LR__1532
09594                 | LR__1535
09594     E7 F0 03 F6 | 	mov	ptra, fp
09598     F2 00 A0 FD | 	call	#popregs_
0959c                 | _fatfs_cc_gen_numname_ret
0959c     2D 00 64 FD | 	ret
095a0                 | 
095a0                 | _fatfs_cc_sum_sfn
095a0     00 7C 06 F6 | 	mov	_var01, #0
095a4                 | ' )
095a4                 | ' {
095a4                 | ' 	BYTE sum = 0;
095a4                 | ' 	UINT n = 11;
095a4                 | ' 
095a4                 | ' 	do {
095a4     D7 12 48 FB | 	callpa	#(@LR__1542-@LR__1540)>>2,fcache_load_ptr_
095a8                 | LR__1540
095a8     0B 10 DC FC | 	rep	@LR__1543, #11
095ac                 | LR__1541
095ac     3E 77 E2 F8 | 	getbyte	result1, _var01, #0
095b0     01 76 46 F0 | 	shr	result1, #1
095b4     3E 7D E2 F8 | 	getbyte	_var01, _var01, #0
095b8     07 7C 66 F0 | 	shl	_var01, #7
095bc     3E 77 02 F1 | 	add	result1, _var01
095c0     48 7D C2 FA | 	rdbyte	_var01, arg01
095c4     3B 7D 02 F1 | 	add	_var01, result1
095c8     01 90 06 F1 | 	add	arg01, #1
095cc                 | LR__1542
095cc                 | LR__1543
095cc                 | ' 	return sum;
095cc     3E 77 02 F6 | 	mov	result1, _var01
095d0                 | _fatfs_cc_sum_sfn_ret
095d0     2D 00 64 FD | 	ret
095d4                 | 
095d4                 | _fatfs_cc_dir_read
095d4     0C CA 05 F6 | 	mov	COUNT_, #12
095d8     E8 00 A0 FD | 	call	#pushregs_
095dc     48 A7 02 F6 | 	mov	local01, arg01
095e0     49 A9 02 F6 | 	mov	local02, arg02
095e4     04 AA 06 F6 | 	mov	local03, #4
095e8     53 AD 02 FB | 	rdlong	local04, local01
095ec     FF AE 06 F6 | 	mov	local05, #255
095f0     FF B0 06 F6 | 	mov	local06, #255
095f4                 | ' )
095f4                 | ' {
095f4                 | ' 	FRESULT res = FR_NO_FILE;
095f4                 | ' 	FATFS *fs = dp->obj.fs;
095f4                 | ' 	BYTE attr, b;
095f4                 | ' 
095f4                 | ' 	BYTE ord = 0xFF, sum = 0xFF;
095f4                 | ' 
095f4                 | ' 
095f4                 | ' 	while (dp->sect) {
095f4                 | LR__1550
095f4     18 A6 06 F1 | 	add	local01, #24
095f8     53 77 0A FB | 	rdlong	result1, local01 wz
095fc     18 A6 86 F1 | 	sub	local01, #24
09600     AC 01 90 AD |  if_e	jmp	#LR__1560
09604     18 A6 06 F1 | 	add	local01, #24
09608     53 93 02 FB | 	rdlong	arg02, local01
0960c     18 A6 86 F1 | 	sub	local01, #24
09610     56 91 02 F6 | 	mov	arg01, local04
09614     B8 ED BF FD | 	call	#_fatfs_cc_move_window
09618     3B AB 0A F6 | 	mov	local03, result1 wz
0961c     90 01 90 5D |  if_ne	jmp	#LR__1560
09620     1C A6 06 F1 | 	add	local01, #28
09624     53 77 02 FB | 	rdlong	result1, local01
09628     1C A6 86 F1 | 	sub	local01, #28
0962c     3B B3 C2 FA | 	rdbyte	local07, result1
09630     59 77 02 F6 | 	mov	result1, local07
09634     07 76 4E F7 | 	zerox	result1, #7 wz
09638     04 AA 06 A6 |  if_e	mov	local03, #4
0963c                 | ' 			res = FR_NO_FILE; break;
0963c     70 01 90 AD |  if_e	jmp	#LR__1560
09640     1C A6 06 F1 | 	add	local01, #28
09644     53 B5 02 FB | 	rdlong	local08, local01
09648     0B B4 06 F1 | 	add	local08, #11
0964c     5A B7 C2 FA | 	rdbyte	local09, local08
09650     3F B6 06 F5 | 	and	local09, #63
09654     16 A6 86 F1 | 	sub	local01, #22
09658     53 B7 42 FC | 	wrbyte	local09, local01
0965c     06 A6 86 F1 | 	sub	local01, #6
09660     59 77 E2 F8 | 	getbyte	result1, local07, #0
09664     E5 76 0E F2 | 	cmp	result1, #229 wz
09668     59 B5 02 56 |  if_ne	mov	local08, local07
0966c     5A B5 E2 58 |  if_ne	getbyte	local08, local08, #0
09670     2E B4 0E 52 |  if_ne	cmp	local08, #46 wz
09674     1C 00 90 AD |  if_e	jmp	#LR__1551
09678     00 B8 06 F6 | 	mov	local10, #0
0967c     5B B5 E2 F8 | 	getbyte	local08, local09, #0
09680     20 B4 26 F5 | 	andn	local08, #32
09684     08 B4 0E F2 | 	cmp	local08, #8 wz
09688     01 B8 06 A6 |  if_e	mov	local10, #1
0968c     54 B9 0A F2 | 	cmp	local10, local02 wz
09690     08 00 90 AD |  if_e	jmp	#LR__1552
09694                 | LR__1551
09694     FF AE 06 F6 | 	mov	local05, #255
09698     00 01 90 FD | 	jmp	#LR__1559
0969c                 | LR__1552
0969c     5B B7 E2 F8 | 	getbyte	local09, local09, #0
096a0     0F B6 0E F2 | 	cmp	local09, #15 wz
096a4     B4 00 90 5D |  if_ne	jmp	#LR__1556
096a8     59 BB E2 F8 | 	getbyte	local11, local07, #0
096ac     40 BA CE F7 | 	test	local11, #64 wz
096b0     30 00 90 AD |  if_e	jmp	#LR__1553
096b4     1C A6 06 F1 | 	add	local01, #28
096b8     53 BB 02 FB | 	rdlong	local11, local01
096bc     0D BA 06 F1 | 	add	local11, #13
096c0     5D B1 C2 FA | 	rdbyte	local06, local11
096c4     59 B3 E2 F8 | 	getbyte	local07, local07, #0
096c8     BF B2 06 F5 | 	and	local07, #191
096cc     59 AF 02 F6 | 	mov	local05, local07
096d0     0C A6 86 F1 | 	sub	local01, #12
096d4     53 BB 02 FB | 	rdlong	local11, local01
096d8     1C A6 06 F1 | 	add	local01, #28
096dc     53 BB 62 FC | 	wrlong	local11, local01
096e0     2C A6 86 F1 | 	sub	local01, #44
096e4                 | LR__1553
096e4     59 B5 E2 F8 | 	getbyte	local08, local07, #0
096e8     57 B9 E2 F8 | 	getbyte	local10, local05, #0
096ec     5C B5 0A F2 | 	cmp	local08, local10 wz
096f0     5C 00 90 5D |  if_ne	jmp	#LR__1554
096f4     58 B9 E2 F8 | 	getbyte	local10, local06, #0
096f8     1C A6 06 F1 | 	add	local01, #28
096fc     53 B7 02 FB | 	rdlong	local09, local01
09700     1C A6 86 F1 | 	sub	local01, #28
09704     0D B6 06 F1 | 	add	local09, #13
09708     5B B5 C2 FA | 	rdbyte	local08, local09
0970c     5A B7 E2 F8 | 	getbyte	local09, local08, #0
09710     5B B9 0A F2 | 	cmp	local10, local09 wz
09714     38 00 90 5D |  if_ne	jmp	#LR__1554
09718     0C AC 06 F1 | 	add	local04, #12
0971c     56 91 02 FB | 	rdlong	arg01, local04
09720     0C AC 86 F1 | 	sub	local04, #12
09724     1C A6 06 F1 | 	add	local01, #28
09728     53 BD 02 FB | 	rdlong	local12, local01
0972c     1C A6 86 F1 | 	sub	local01, #28
09730     5E 93 02 F6 | 	mov	arg02, local12
09734     30 FB BF FD | 	call	#_fatfs_cc_pick_lfn
09738     00 76 4E F2 | 	cmps	result1, #0 wz
0973c     57 BD 02 56 |  if_ne	mov	local12, local05
09740     5E BD E2 58 |  if_ne	getbyte	local12, local12, #0
09744     01 BC 86 51 |  if_ne	sub	local12, #1
09748     5E BB 02 56 |  if_ne	mov	local11, local12
0974c     04 00 90 5D |  if_ne	jmp	#LR__1555
09750                 | LR__1554
09750     FF BA 06 F6 | 	mov	local11, #255
09754                 | LR__1555
09754     5D AF 02 F6 | 	mov	local05, local11
09758     40 00 90 FD | 	jmp	#LR__1558
0975c                 | LR__1556
0975c     57 BB 02 F6 | 	mov	local11, local05
09760     07 BA 4E F7 | 	zerox	local11, #7 wz
09764     20 00 90 5D |  if_ne	jmp	#LR__1557
09768     58 B1 E2 F8 | 	getbyte	local06, local06, #0
0976c     1C A6 06 F1 | 	add	local01, #28
09770     53 91 02 FB | 	rdlong	arg01, local01
09774     1C A6 86 F1 | 	sub	local01, #28
09778     24 FE BF FD | 	call	#_fatfs_cc_sum_sfn
0977c     3B 77 E2 F8 | 	getbyte	result1, result1, #0
09780     3B B1 0A F2 | 	cmp	local06, result1 wz
09784     28 00 90 AD |  if_e	jmp	#LR__1560
09788                 | LR__1557
09788     2C A6 06 F1 | 	add	local01, #44
0978c     FF FF FF FF 
09790     53 FF 6B FC | 	wrlong	##-1, local01
09794     2C A6 86 F1 | 	sub	local01, #44
09798                 | ' 						dp->blk_ofs = 0xFFFFFFFF;
09798                 | ' 					}
09798                 | ' 					break;
09798     14 00 90 FD | 	jmp	#LR__1560
0979c                 | LR__1558
0979c                 | LR__1559
0979c     53 91 02 F6 | 	mov	arg01, local01
097a0     00 92 06 F6 | 	mov	arg02, #0
097a4     F4 F6 BF FD | 	call	#_fatfs_cc_dir_next
097a8     3B AB 0A F6 | 	mov	local03, result1 wz
097ac     44 FE 9F AD |  if_e	jmp	#LR__1550
097b0                 | LR__1560
097b0     00 AA 0E F2 | 	cmp	local03, #0 wz
097b4     18 A6 06 51 |  if_ne	add	local01, #24
097b8     53 01 68 5C |  if_ne	wrlong	#0, local01
097bc                 | ' 	return res;
097bc     55 77 02 F6 | 	mov	result1, local03
097c0     E7 F0 03 F6 | 	mov	ptra, fp
097c4     F2 00 A0 FD | 	call	#popregs_
097c8                 | _fatfs_cc_dir_read_ret
097c8     2D 00 64 FD | 	ret
097cc                 | 
097cc                 | _fatfs_cc_dir_find
097cc     0B CA 05 F6 | 	mov	COUNT_, #11
097d0     E8 00 A0 FD | 	call	#pushregs_
097d4     48 A7 02 F6 | 	mov	local01, arg01
097d8     53 A9 02 FB | 	rdlong	local02, local01
097dc     53 91 02 F6 | 	mov	arg01, local01
097e0     00 92 06 F6 | 	mov	arg02, #0
097e4     4C F5 BF FD | 	call	#_fatfs_cc_dir_sdi
097e8     00 76 0E F2 | 	cmp	result1, #0 wz
097ec     18 02 90 5D |  if_ne	jmp	#LR__1582
097f0     FF AA 06 F6 | 	mov	local03, #255
097f4     FF AC 06 F6 | 	mov	local04, #255
097f8     2C A6 06 F1 | 	add	local01, #44
097fc     FF FF FF FF 
09800     53 FF 6B FC | 	wrlong	##-1, local01
09804     2C A6 86 F1 | 	sub	local01, #44
09808                 | ' #line 2404 "ff.c"
09808                 | ' 	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;
09808                 | ' 
09808                 | ' 	do {
09808                 | LR__1570
09808     18 A6 06 F1 | 	add	local01, #24
0980c     53 93 02 FB | 	rdlong	arg02, local01
09810     18 A6 86 F1 | 	sub	local01, #24
09814     54 91 02 F6 | 	mov	arg01, local02
09818     B4 EB BF FD | 	call	#_fatfs_cc_move_window
0981c     3B AF 0A F6 | 	mov	local05, result1 wz
09820     E0 01 90 5D |  if_ne	jmp	#LR__1581
09824     1C A6 06 F1 | 	add	local01, #28
09828     53 95 02 FB | 	rdlong	arg03, local01
0982c     1C A6 86 F1 | 	sub	local01, #28
09830     4A B1 C2 FA | 	rdbyte	local06, arg03
09834     58 95 02 F6 | 	mov	arg03, local06
09838     07 94 4E F7 | 	zerox	arg03, #7 wz
0983c     04 AE 06 A6 |  if_e	mov	local05, #4
09840     C0 01 90 AD |  if_e	jmp	#LR__1581
09844     1C A6 06 F1 | 	add	local01, #28
09848     53 B3 02 FB | 	rdlong	local07, local01
0984c     59 95 02 F6 | 	mov	arg03, local07
09850     0B 94 06 F1 | 	add	arg03, #11
09854     4A B5 C2 FA | 	rdbyte	local08, arg03
09858     3F B4 06 F5 | 	and	local08, #63
0985c     16 A6 86 F1 | 	sub	local01, #22
09860     53 B5 42 FC | 	wrbyte	local08, local01
09864     06 A6 86 F1 | 	sub	local01, #6
09868     58 95 E2 F8 | 	getbyte	arg03, local06, #0
0986c     E5 94 0E F2 | 	cmp	arg03, #229 wz
09870     18 00 90 AD |  if_e	jmp	#LR__1571
09874     5A 95 E2 F8 | 	getbyte	arg03, local08, #0
09878     08 94 CE F7 | 	test	arg03, #8 wz
0987c     5A B3 02 56 |  if_ne	mov	local07, local08
09880     59 B3 E2 58 |  if_ne	getbyte	local07, local07, #0
09884     0F B2 0E 52 |  if_ne	cmp	local07, #15 wz
09888     18 00 90 AD |  if_e	jmp	#LR__1572
0988c                 | LR__1571
0988c     FF AC 06 F6 | 	mov	local04, #255
09890     2C A6 06 F1 | 	add	local01, #44
09894     FF FF FF FF 
09898     53 FF 6B FC | 	wrlong	##-1, local01
0989c     2C A6 86 F1 | 	sub	local01, #44
098a0     4C 01 90 FD | 	jmp	#LR__1580
098a4                 | LR__1572
098a4     5A B5 E2 F8 | 	getbyte	local08, local08, #0
098a8     0F B4 0E F2 | 	cmp	local08, #15 wz
098ac     C8 00 90 5D |  if_ne	jmp	#LR__1576
098b0     2B A6 06 F1 | 	add	local01, #43
098b4     53 B5 C2 FA | 	rdbyte	local08, local01
098b8     2B A6 86 F1 | 	sub	local01, #43
098bc     40 B4 CE F7 | 	test	local08, #64 wz
098c0     2C 01 90 5D |  if_ne	jmp	#LR__1579
098c4     58 B7 E2 F8 | 	getbyte	local09, local06, #0
098c8     40 B6 CE F7 | 	test	local09, #64 wz
098cc     30 00 90 AD |  if_e	jmp	#LR__1573
098d0     1C A6 06 F1 | 	add	local01, #28
098d4     53 B7 02 FB | 	rdlong	local09, local01
098d8     0D B6 06 F1 | 	add	local09, #13
098dc     5B AB C2 FA | 	rdbyte	local03, local09
098e0     58 B1 E2 F8 | 	getbyte	local06, local06, #0
098e4     BF B0 06 F5 | 	and	local06, #191
098e8     58 AD 02 F6 | 	mov	local04, local06
098ec     0C A6 86 F1 | 	sub	local01, #12
098f0     53 B7 02 FB | 	rdlong	local09, local01
098f4     1C A6 06 F1 | 	add	local01, #28
098f8     53 B7 62 FC | 	wrlong	local09, local01
098fc     2C A6 86 F1 | 	sub	local01, #44
09900                 | LR__1573
09900     58 B9 E2 F8 | 	getbyte	local10, local06, #0
09904     56 B3 E2 F8 | 	getbyte	local07, local04, #0
09908     59 B9 0A F2 | 	cmp	local10, local07 wz
0990c     5C 00 90 5D |  if_ne	jmp	#LR__1574
09910     55 B5 E2 F8 | 	getbyte	local08, local03, #0
09914     1C A6 06 F1 | 	add	local01, #28
09918     53 B3 02 FB | 	rdlong	local07, local01
0991c     1C A6 86 F1 | 	sub	local01, #28
09920     0D B2 06 F1 | 	add	local07, #13
09924     59 B1 C2 FA | 	rdbyte	local06, local07
09928     58 B3 E2 F8 | 	getbyte	local07, local06, #0
0992c     59 B5 0A F2 | 	cmp	local08, local07 wz
09930     38 00 90 5D |  if_ne	jmp	#LR__1574
09934     0C A8 06 F1 | 	add	local02, #12
09938     54 91 02 FB | 	rdlong	arg01, local02
0993c     0C A8 86 F1 | 	sub	local02, #12
09940     1C A6 06 F1 | 	add	local01, #28
09944     53 BB 02 FB | 	rdlong	local11, local01
09948     1C A6 86 F1 | 	sub	local01, #28
0994c     5D 93 02 F6 | 	mov	arg02, local11
09950     10 F8 BF FD | 	call	#_fatfs_cc_cmp_lfn
09954     00 76 4E F2 | 	cmps	result1, #0 wz
09958     56 BB 02 56 |  if_ne	mov	local11, local04
0995c     5D BB E2 58 |  if_ne	getbyte	local11, local11, #0
09960     01 BA 86 51 |  if_ne	sub	local11, #1
09964     5D B7 02 56 |  if_ne	mov	local09, local11
09968     04 00 90 5D |  if_ne	jmp	#LR__1575
0996c                 | LR__1574
0996c     FF B6 06 F6 | 	mov	local09, #255
09970                 | LR__1575
09970     5B AD 02 F6 | 	mov	local04, local09
09974     78 00 90 FD | 	jmp	#LR__1579
09978                 | LR__1576
09978     56 B7 02 F6 | 	mov	local09, local04
0997c     07 B6 4E F7 | 	zerox	local09, #7 wz
09980     20 00 90 5D |  if_ne	jmp	#LR__1577
09984     55 B9 E2 F8 | 	getbyte	local10, local03, #0
09988     1C A6 06 F1 | 	add	local01, #28
0998c     53 91 02 FB | 	rdlong	arg01, local01
09990     1C A6 86 F1 | 	sub	local01, #28
09994     08 FC BF FD | 	call	#_fatfs_cc_sum_sfn
09998     3B 77 E2 F8 | 	getbyte	result1, result1, #0
0999c     3B B9 0A F2 | 	cmp	local10, result1 wz
099a0     60 00 90 AD |  if_e	jmp	#LR__1581
099a4                 | LR__1577
099a4     2B A6 06 F1 | 	add	local01, #43
099a8     53 B7 C2 FA | 	rdbyte	local09, local01
099ac     2B A6 86 F1 | 	sub	local01, #43
099b0     01 B6 CE F7 | 	test	local09, #1 wz
099b4     24 00 90 5D |  if_ne	jmp	#LR__1578
099b8     1C A6 06 F1 | 	add	local01, #28
099bc     53 91 02 FB | 	rdlong	arg01, local01
099c0     04 A6 06 F1 | 	add	local01, #4
099c4     53 93 02 F6 | 	mov	arg02, local01
099c8     20 A6 86 F1 | 	sub	local01, #32
099cc     0B 94 06 F6 | 	mov	arg03, #11
099d0     B0 DE BF FD | 	call	#_fatfs_cc_memcmp
099d4     00 76 0E F2 | 	cmp	result1, #0 wz
099d8     28 00 90 AD |  if_e	jmp	#LR__1581
099dc                 | LR__1578
099dc     FF AC 06 F6 | 	mov	local04, #255
099e0     2C A6 06 F1 | 	add	local01, #44
099e4     FF FF FF FF 
099e8     53 FF 6B FC | 	wrlong	##-1, local01
099ec     2C A6 86 F1 | 	sub	local01, #44
099f0                 | LR__1579
099f0                 | LR__1580
099f0     53 91 02 F6 | 	mov	arg01, local01
099f4     00 92 06 F6 | 	mov	arg02, #0
099f8     A0 F4 BF FD | 	call	#_fatfs_cc_dir_next
099fc     3B AF 0A F6 | 	mov	local05, result1 wz
09a00     04 FE 9F AD |  if_e	jmp	#LR__1570
09a04                 | LR__1581
09a04                 | ' 
09a04                 | ' 	return res;
09a04     57 77 02 F6 | 	mov	result1, local05
09a08                 | LR__1582
09a08     E7 F0 03 F6 | 	mov	ptra, fp
09a0c     F2 00 A0 FD | 	call	#popregs_
09a10                 | _fatfs_cc_dir_find_ret
09a10     2D 00 64 FD | 	ret
09a14                 | 
09a14                 | _fatfs_cc_dir_register
09a14     09 CA 05 F6 | 	mov	COUNT_, #9
09a18     E8 00 A0 FD | 	call	#pushregs_
09a1c     2C F0 07 F1 | 	add	ptra, #44
09a20     48 A7 02 F6 | 	mov	local01, arg01
09a24     53 A9 02 FB | 	rdlong	local02, local01
09a28     2B A6 06 F1 | 	add	local01, #43
09a2c     53 AB C2 FA | 	rdbyte	local03, local01
09a30     2B A6 86 F1 | 	sub	local01, #43
09a34     A0 AA CE F7 | 	test	local03, #160 wz
09a38     06 76 06 56 |  if_ne	mov	result1, #6
09a3c     2C 02 90 5D |  if_ne	jmp	#LR__1601
09a40                 | ' 	for (len = 0; fs->lfnbuf[len]; len++) ;
09a40     00 AC 06 F6 | 	mov	local04, #0
09a44     0C A8 06 F1 | 	add	local02, #12
09a48     D7 12 48 FB | 	callpa	#(@LR__1591-@LR__1590)>>2,fcache_load_ptr_
09a4c                 | LR__1590
09a4c     54 AB 02 FB | 	rdlong	local03, local02
09a50     56 97 02 F6 | 	mov	arg04, local04
09a54     01 96 66 F0 | 	shl	arg04, #1
09a58     55 97 02 F1 | 	add	arg04, local03
09a5c     4B AB EA FA | 	rdword	local03, arg04 wz
09a60     56 AF 02 56 |  if_ne	mov	local05, local04
09a64     01 AE 06 51 |  if_ne	add	local05, #1
09a68     57 AD 02 56 |  if_ne	mov	local04, local05
09a6c     DC FF 9F 5D |  if_ne	jmp	#LR__1590
09a70                 | LR__1591
09a70     0C A8 86 F1 | 	sub	local02, #12
09a74     E7 90 02 F6 | 	mov	arg01, fp
09a78     1C 90 06 F1 | 	add	arg01, #28
09a7c     53 93 02 F6 | 	mov	arg02, local01
09a80     20 92 06 F1 | 	add	arg02, #32
09a84     0C 94 06 F6 | 	mov	arg03, #12
09a88     4C 92 BF FD | 	call	#__system____builtin_memmove
09a8c     27 CE 05 F1 | 	add	fp, #39
09a90     E7 AA C2 FA | 	rdbyte	local03, fp
09a94     27 CE 85 F1 | 	sub	fp, #39
09a98     01 AA CE F7 | 	test	local03, #1 wz
09a9c     80 00 90 AD |  if_e	jmp	#LR__1594
09aa0     2B A6 06 F1 | 	add	local01, #43
09aa4     53 81 48 FC | 	wrbyte	#64, local01
09aa8     2B A6 86 F1 | 	sub	local01, #43
09aac                 | ' 		dp->fn[ 11 ] =  0x40 ;
09aac                 | ' 		for (n = 1; n < 100; n++) {
09aac     01 B0 06 F6 | 	mov	local06, #1
09ab0                 | LR__1592
09ab0     64 B0 16 F2 | 	cmp	local06, #100 wc
09ab4     38 00 90 3D |  if_ae	jmp	#LR__1593
09ab8     53 91 02 F6 | 	mov	arg01, local01
09abc     20 90 06 F1 | 	add	arg01, #32
09ac0     E7 92 02 F6 | 	mov	arg02, fp
09ac4     1C 92 06 F1 | 	add	arg02, #28
09ac8     0C A8 06 F1 | 	add	local02, #12
09acc     54 95 02 FB | 	rdlong	arg03, local02
09ad0     0C A8 86 F1 | 	sub	local02, #12
09ad4     58 97 02 F6 | 	mov	arg04, local06
09ad8     44 F9 BF FD | 	call	#_fatfs_cc_gen_numname
09adc     53 91 02 F6 | 	mov	arg01, local01
09ae0     E8 FC BF FD | 	call	#_fatfs_cc_dir_find
09ae4     3B B3 0A F6 | 	mov	local07, result1 wz
09ae8     01 B0 06 A1 |  if_e	add	local06, #1
09aec     C0 FF 9F AD |  if_e	jmp	#LR__1592
09af0                 | LR__1593
09af0     64 B0 0E F2 | 	cmp	local06, #100 wz
09af4     07 76 06 A6 |  if_e	mov	result1, #7
09af8     70 01 90 AD |  if_e	jmp	#LR__1601
09afc     04 B2 0E F2 | 	cmp	local07, #4 wz
09b00     59 77 02 56 |  if_ne	mov	result1, local07
09b04     64 01 90 5D |  if_ne	jmp	#LR__1601
09b08     27 CE 05 F1 | 	add	fp, #39
09b0c     E7 AA C2 FA | 	rdbyte	local03, fp
09b10     27 CE 85 F1 | 	sub	fp, #39
09b14     2B A6 06 F1 | 	add	local01, #43
09b18     53 AB 42 FC | 	wrbyte	local03, local01
09b1c     2B A6 86 F1 | 	sub	local01, #43
09b20                 | LR__1594
09b20     27 CE 05 F1 | 	add	fp, #39
09b24     E7 B2 C2 FA | 	rdbyte	local07, fp
09b28     02 B2 CE F7 | 	test	local07, #2 wz
09b2c     0C AC 06 51 |  if_ne	add	local04, #12
09b30     0D AC 16 5D |  if_ne	qdiv	local04, #13
09b34     27 CE 85 F1 | 	sub	fp, #39
09b38     53 91 02 F6 | 	mov	arg01, local01
09b3c     18 AA 62 5D |  if_ne	getqx	local03
09b40     01 AA 06 51 |  if_ne	add	local03, #1
09b44     01 AA 06 A6 |  if_e	mov	local03, #1
09b48     55 B5 02 F6 | 	mov	local08, local03
09b4c     5A 93 02 F6 | 	mov	arg02, local08
09b50     04 F5 BF FD | 	call	#_fatfs_cc_dir_alloc
09b54     3B B3 0A F6 | 	mov	local07, result1 wz
09b58     9C 00 90 5D |  if_ne	jmp	#LR__1598
09b5c     01 B4 8E F1 | 	sub	local08, #1 wz
09b60     94 00 90 AD |  if_e	jmp	#LR__1598
09b64     53 91 02 F6 | 	mov	arg01, local01
09b68     5A B3 02 F6 | 	mov	local07, local08
09b6c     05 B2 66 F0 | 	shl	local07, #5
09b70     10 A6 06 F1 | 	add	local01, #16
09b74     53 93 02 FB | 	rdlong	arg02, local01
09b78     10 A6 86 F1 | 	sub	local01, #16
09b7c     59 93 82 F1 | 	sub	arg02, local07
09b80     B0 F1 BF FD | 	call	#_fatfs_cc_dir_sdi
09b84     3B B3 0A F6 | 	mov	local07, result1 wz
09b88     6C 00 90 5D |  if_ne	jmp	#LR__1597
09b8c     53 91 02 F6 | 	mov	arg01, local01
09b90     20 90 06 F1 | 	add	arg01, #32
09b94     08 FA BF FD | 	call	#_fatfs_cc_sum_sfn
09b98     3B B7 02 F6 | 	mov	local09, result1
09b9c                 | ' 			sum = sum_sfn(dp->fn);
09b9c                 | ' 			do {
09b9c                 | LR__1595
09b9c     18 A6 06 F1 | 	add	local01, #24
09ba0     53 93 02 FB | 	rdlong	arg02, local01
09ba4     18 A6 86 F1 | 	sub	local01, #24
09ba8     54 91 02 F6 | 	mov	arg01, local02
09bac     20 E8 BF FD | 	call	#_fatfs_cc_move_window
09bb0     3B B3 0A F6 | 	mov	local07, result1 wz
09bb4     40 00 90 5D |  if_ne	jmp	#LR__1596
09bb8     0C A8 06 F1 | 	add	local02, #12
09bbc     54 91 02 FB | 	rdlong	arg01, local02
09bc0     1C A6 06 F1 | 	add	local01, #28
09bc4     53 93 02 FB | 	rdlong	arg02, local01
09bc8     1C A6 86 F1 | 	sub	local01, #28
09bcc     5B 97 02 F6 | 	mov	arg04, local09
09bd0     5A 95 02 F6 | 	mov	arg03, local08
09bd4     78 F7 BF FD | 	call	#_fatfs_cc_put_lfn
09bd8     09 A8 86 F1 | 	sub	local02, #9
09bdc     54 03 48 FC | 	wrbyte	#1, local02
09be0     03 A8 86 F1 | 	sub	local02, #3
09be4     53 91 02 F6 | 	mov	arg01, local01
09be8     00 92 06 F6 | 	mov	arg02, #0
09bec     AC F2 BF FD | 	call	#_fatfs_cc_dir_next
09bf0     3B B3 0A F6 | 	mov	local07, result1 wz
09bf4     E9 B5 6E AB |  if_e	djnz	local08, #LR__1595
09bf8                 | LR__1596
09bf8                 | LR__1597
09bf8                 | LR__1598
09bf8     00 B2 0E F2 | 	cmp	local07, #0 wz
09bfc     68 00 90 5D |  if_ne	jmp	#LR__1600
09c00     18 A6 06 F1 | 	add	local01, #24
09c04     53 93 02 FB | 	rdlong	arg02, local01
09c08     18 A6 86 F1 | 	sub	local01, #24
09c0c     54 91 02 F6 | 	mov	arg01, local02
09c10     BC E7 BF FD | 	call	#_fatfs_cc_move_window
09c14     3B B3 0A F6 | 	mov	local07, result1 wz
09c18     4C 00 90 5D |  if_ne	jmp	#LR__1599
09c1c     1C A6 06 F1 | 	add	local01, #28
09c20     53 91 02 FB | 	rdlong	arg01, local01
09c24     00 92 06 F6 | 	mov	arg02, #0
09c28     20 94 06 F6 | 	mov	arg03, #32
09c2c     D8 00 A0 FD | 	call	#\builtin_bytefill_
09c30     53 91 02 FB | 	rdlong	arg01, local01
09c34     04 A6 06 F1 | 	add	local01, #4
09c38     53 93 02 F6 | 	mov	arg02, local01
09c3c     0B 94 06 F6 | 	mov	arg03, #11
09c40     94 90 BF FD | 	call	#__system____builtin_memmove
09c44     04 A6 86 F1 | 	sub	local01, #4
09c48     53 AB 02 FB | 	rdlong	local03, local01
09c4c     0F A6 06 F1 | 	add	local01, #15
09c50     53 B7 C2 FA | 	rdbyte	local09, local01
09c54     18 B6 06 F5 | 	and	local09, #24
09c58     0C AA 06 F1 | 	add	local03, #12
09c5c     55 B7 42 FC | 	wrbyte	local09, local03
09c60     03 A8 06 F1 | 	add	local02, #3
09c64     54 03 48 FC | 	wrbyte	#1, local02
09c68                 | LR__1599
09c68                 | LR__1600
09c68                 | ' 			__builtin_memset(dp->dir, 0, 32 ) ;
09c68                 | ' 			__builtin_memcpy(dp->dir + 0 , dp->fn, 11) ;
09c68                 | ' 
09c68                 | ' 			dp->dir[ 12 ] = dp->fn[ 11 ] & ( 0x08  |  0x10 );
09c68                 | ' 
09c68                 | ' 			fs->wflag = 1;
09c68                 | ' 		}
09c68                 | ' 	}
09c68                 | ' 
09c68                 | ' 	return res;
09c68     59 77 02 F6 | 	mov	result1, local07
09c6c                 | LR__1601
09c6c     E7 F0 03 F6 | 	mov	ptra, fp
09c70     F2 00 A0 FD | 	call	#popregs_
09c74                 | _fatfs_cc_dir_register_ret
09c74     2D 00 64 FD | 	ret
09c78                 | 
09c78                 | _fatfs_cc_dir_remove
09c78     05 CA 05 F6 | 	mov	COUNT_, #5
09c7c     E8 00 A0 FD | 	call	#pushregs_
09c80     48 A7 02 F6 | 	mov	local01, arg01
09c84     53 A9 02 FB | 	rdlong	local02, local01
09c88     10 A6 06 F1 | 	add	local01, #16
09c8c     53 AB 02 FB | 	rdlong	local03, local01
09c90     1C A6 06 F1 | 	add	local01, #28
09c94     53 93 02 FB | 	rdlong	arg02, local01
09c98     2C A6 86 F1 | 	sub	local01, #44
09c9c     FF FF 7F FF 
09ca0     FF 93 0E F2 | 	cmp	arg02, ##-1 wz
09ca4     00 AC 06 A6 |  if_e	mov	local04, #0
09ca8     18 00 90 AD |  if_e	jmp	#LR__1610
09cac     53 91 02 F6 | 	mov	arg01, local01
09cb0     2C A6 06 F1 | 	add	local01, #44
09cb4     53 93 02 FB | 	rdlong	arg02, local01
09cb8     2C A6 86 F1 | 	sub	local01, #44
09cbc     74 F0 BF FD | 	call	#_fatfs_cc_dir_sdi
09cc0     3B AD 02 F6 | 	mov	local04, result1
09cc4                 | LR__1610
09cc4     56 AF 0A F6 | 	mov	local05, local04 wz
09cc8     64 00 90 5D |  if_ne	jmp	#LR__1613
09ccc                 | ' 		do {
09ccc                 | LR__1611
09ccc     18 A6 06 F1 | 	add	local01, #24
09cd0     53 93 02 FB | 	rdlong	arg02, local01
09cd4     18 A6 86 F1 | 	sub	local01, #24
09cd8     54 91 02 F6 | 	mov	arg01, local02
09cdc     F0 E6 BF FD | 	call	#_fatfs_cc_move_window
09ce0     3B AF 0A F6 | 	mov	local05, result1 wz
09ce4     40 00 90 5D |  if_ne	jmp	#LR__1612
09ce8     1C A6 06 F1 | 	add	local01, #28
09cec     53 AD 02 FB | 	rdlong	local04, local01
09cf0     56 CB 49 FC | 	wrbyte	#229, local04
09cf4     03 A8 06 F1 | 	add	local02, #3
09cf8     54 03 48 FC | 	wrbyte	#1, local02
09cfc     03 A8 86 F1 | 	sub	local02, #3
09d00     0C A6 86 F1 | 	sub	local01, #12
09d04     53 AD 02 FB | 	rdlong	local04, local01
09d08     10 A6 86 F1 | 	sub	local01, #16
09d0c     55 AD 12 F2 | 	cmp	local04, local03 wc
09d10     14 00 90 3D |  if_ae	jmp	#LR__1612
09d14     53 91 02 F6 | 	mov	arg01, local01
09d18     00 92 06 F6 | 	mov	arg02, #0
09d1c     7C F1 BF FD | 	call	#_fatfs_cc_dir_next
09d20     3B AF 0A F6 | 	mov	local05, result1 wz
09d24     A4 FF 9F AD |  if_e	jmp	#LR__1611
09d28                 | LR__1612
09d28     04 AE 0E F2 | 	cmp	local05, #4 wz
09d2c     02 AE 06 A6 |  if_e	mov	local05, #2
09d30                 | LR__1613
09d30                 | ' 	}
09d30                 | ' #line 2590 "ff.c"
09d30                 | ' 	return res;
09d30     57 77 02 F6 | 	mov	result1, local05
09d34     E7 F0 03 F6 | 	mov	ptra, fp
09d38     F2 00 A0 FD | 	call	#popregs_
09d3c                 | _fatfs_cc_dir_remove_ret
09d3c     2D 00 64 FD | 	ret
09d40                 | 
09d40                 | _fatfs_cc_get_fileinfo
09d40     0C CA 05 F6 | 	mov	COUNT_, #12
09d44     E8 00 A0 FD | 	call	#pushregs_
09d48     48 A7 02 F6 | 	mov	local01, arg01
09d4c     49 A9 02 F6 | 	mov	local02, arg02
09d50     53 AB 02 FB | 	rdlong	local03, local01
09d54     1C A8 06 F1 | 	add	local02, #28
09d58     54 01 48 FC | 	wrbyte	#0, local02
09d5c     1C A8 86 F1 | 	sub	local02, #28
09d60     18 A6 06 F1 | 	add	local01, #24
09d64     53 AD 0A FB | 	rdlong	local04, local01 wz
09d68     18 A6 86 F1 | 	sub	local01, #24
09d6c     90 03 90 AD |  if_e	jmp	#LR__1634
09d70     2C A6 06 F1 | 	add	local01, #44
09d74     53 AD 02 FB | 	rdlong	local04, local01
09d78     2C A6 86 F1 | 	sub	local01, #44
09d7c     FF FF 7F FF 
09d80     FF AD 0E F2 | 	cmp	local04, ##-1 wz
09d84     D8 00 90 AD |  if_e	jmp	#LR__1623
09d88     00 AE 06 F6 | 	mov	local05, #0
09d8c     00 B0 06 F6 | 	mov	local06, #0
09d90     00 B2 06 F6 | 	mov	local07, #0
09d94                 | ' 			si = di = 0;
09d94                 | ' 			hs = 0;
09d94                 | ' 			while (fs->lfnbuf[si] != 0) {
09d94                 | LR__1620
09d94     0C AA 06 F1 | 	add	local03, #12
09d98     55 AD 02 FB | 	rdlong	local04, local03
09d9c     0C AA 86 F1 | 	sub	local03, #12
09da0     58 B5 02 F6 | 	mov	local08, local06
09da4     01 B4 66 F0 | 	shl	local08, #1
09da8     56 B5 02 F1 | 	add	local08, local04
09dac     5A AD EA FA | 	rdword	local04, local08 wz
09db0     90 00 90 AD |  if_e	jmp	#LR__1622
09db4     0C AA 06 F1 | 	add	local03, #12
09db8     55 B7 02 FB | 	rdlong	local09, local03
09dbc     0C AA 86 F1 | 	sub	local03, #12
09dc0     58 AD 02 F6 | 	mov	local04, local06
09dc4     01 AC 66 F0 | 	shl	local04, #1
09dc8     5B AD 02 F1 | 	add	local04, local09
09dcc     56 B9 E2 FA | 	rdword	local10, local04
09dd0     59 AD 02 F6 | 	mov	local04, local07
09dd4     0F AC 4E F7 | 	zerox	local04, #15 wz
09dd8     01 B0 06 F1 | 	add	local06, #1
09ddc     24 00 90 5D |  if_ne	jmp	#LR__1621
09de0     5C AD 32 F9 | 	getword	local04, local10, #0
09de4     6C 00 00 FF 
09de8     00 AC 16 F2 | 	cmp	local04, ##55296 wc
09dec     14 00 90 CD |  if_b	jmp	#LR__1621
09df0     5C BB 32 F9 | 	getword	local11, local10, #0
09df4     70 00 00 FF 
09df8     00 BA 16 F2 | 	cmp	local11, ##57344 wc
09dfc     5C B3 02 C6 |  if_b	mov	local07, local10
09e00                 | ' 					hs = wc; continue;
09e00     90 FF 9F CD |  if_b	jmp	#LR__1620
09e04                 | LR__1621
09e04     59 91 32 F9 | 	getword	arg01, local07, #0
09e08     10 90 66 F0 | 	shl	arg01, #16
09e0c     5C B9 32 F9 | 	getword	local10, local10, #0
09e10     5C 91 42 F5 | 	or	arg01, local10
09e14     57 93 02 F6 | 	mov	arg02, local05
09e18     54 B9 02 F6 | 	mov	local10, local02
09e1c     1C B8 06 F1 | 	add	local10, #28
09e20     5C 93 02 F1 | 	add	arg02, local10
09e24     FF 94 06 F6 | 	mov	arg03, #255
09e28     57 95 82 F1 | 	sub	arg03, local05
09e2c     28 E3 BF FD | 	call	#_fatfs_cc_put_utf
09e30     3B B9 0A F6 | 	mov	local10, result1 wz
09e34     00 AE 06 A6 |  if_e	mov	local05, #0
09e38     5C AF 02 51 |  if_ne	add	local05, local10
09e3c     00 B2 06 56 |  if_ne	mov	local07, #0
09e40     50 FF 9F 5D |  if_ne	jmp	#LR__1620
09e44                 | LR__1622
09e44     59 AD 02 F6 | 	mov	local04, local07
09e48     0F AC 4E F7 | 	zerox	local04, #15 wz
09e4c     00 AE 06 56 |  if_ne	mov	local05, #0
09e50     54 B9 02 F6 | 	mov	local10, local02
09e54     1C B8 06 F1 | 	add	local10, #28
09e58     5C AF 02 F1 | 	add	local05, local10
09e5c     57 01 48 FC | 	wrbyte	#0, local05
09e60                 | LR__1623
09e60     00 AE 06 F6 | 	mov	local05, #0
09e64     00 B0 06 F6 | 	mov	local06, #0
09e68                 | ' 			fno->fname[di] = 0;
09e68                 | ' 		}
09e68                 | ' 	}
09e68                 | ' 
09e68                 | ' 	si = di = 0;
09e68                 | ' 	while (si < 11) {
09e68                 | LR__1624
09e68     0B B0 16 F2 | 	cmp	local06, #11 wc
09e6c     20 01 90 3D |  if_ae	jmp	#LR__1627
09e70     1C A6 06 F1 | 	add	local01, #28
09e74     53 B7 02 FB | 	rdlong	local09, local01
09e78     1C A6 86 F1 | 	sub	local01, #28
09e7c     58 B9 02 F6 | 	mov	local10, local06
09e80     5B B9 02 F1 | 	add	local10, local09
09e84     5C B9 C2 FA | 	rdbyte	local10, local10
09e88     5C AD 32 F9 | 	getword	local04, local10, #0
09e8c     20 AC 0E F2 | 	cmp	local04, #32 wz
09e90     01 B0 06 F1 | 	add	local06, #1
09e94     D0 FF 9F AD |  if_e	jmp	#LR__1624
09e98     5C AD 32 F9 | 	getword	local04, local10, #0
09e9c     05 AC 0E F2 | 	cmp	local04, #5 wz
09ea0     E5 B8 06 A6 |  if_e	mov	local10, #229
09ea4     09 B0 0E F2 | 	cmp	local06, #9 wz
09ea8     20 00 90 5D |  if_ne	jmp	#LR__1625
09eac     0C AE 16 F2 | 	cmp	local05, #12 wc
09eb0     18 00 90 3D |  if_ae	jmp	#LR__1625
09eb4     57 BB 02 F6 | 	mov	local11, local05
09eb8     54 B5 02 F6 | 	mov	local08, local02
09ebc     0C B4 06 F1 | 	add	local08, #12
09ec0     5A BB 02 F1 | 	add	local11, local08
09ec4     5D 5D 48 FC | 	wrbyte	#46, local11
09ec8     01 AE 06 F1 | 	add	local05, #1
09ecc                 | LR__1625
09ecc     5C 91 32 F9 | 	getword	arg01, local10, #0
09ed0     07 90 4E F7 | 	zerox	arg01, #7 wz
09ed4     00 76 06 56 |  if_ne	mov	result1, #0
09ed8                 | ' 
09ed8                 | ' 	return 0;
09ed8     00 76 06 A6 |  if_e	mov	result1, #0
09edc     00 76 0E F2 | 	cmp	result1, #0 wz
09ee0     08 B0 0E 52 |  if_ne	cmp	local06, #8 wz
09ee4     0B B0 0E 52 |  if_ne	cmp	local06, #11 wz
09ee8     50 00 90 AD |  if_e	jmp	#LR__1626
09eec     1C A6 06 F1 | 	add	local01, #28
09ef0     53 BB 02 FB | 	rdlong	local11, local01
09ef4     1C A6 86 F1 | 	sub	local01, #28
09ef8     58 B5 02 F6 | 	mov	local08, local06
09efc     5D B5 02 F1 | 	add	local08, local11
09f00     5A 91 CA FA | 	rdbyte	arg01, local08 wz
09f04     00 76 06 56 |  if_ne	mov	result1, #0
09f08                 | ' 
09f08                 | ' 	return 0;
09f08     00 76 06 A6 |  if_e	mov	result1, #0
09f0c     00 76 0E F2 | 	cmp	result1, #0 wz
09f10     28 00 90 AD |  if_e	jmp	#LR__1626
09f14     5C B9 32 F9 | 	getword	local10, local10, #0
09f18     08 B8 66 F0 | 	shl	local10, #8
09f1c     1C A6 06 F1 | 	add	local01, #28
09f20     53 BB 02 FB | 	rdlong	local11, local01
09f24     1C A6 86 F1 | 	sub	local01, #28
09f28     58 B7 02 F6 | 	mov	local09, local06
09f2c     5D B7 02 F1 | 	add	local09, local11
09f30     5B BB C2 FA | 	rdbyte	local11, local09
09f34     5D B9 42 F5 | 	or	local10, local11
09f38     01 B0 06 F1 | 	add	local06, #1
09f3c                 | LR__1626
09f3c     5C 91 02 F6 | 	mov	arg01, local10
09f40     01 00 00 FF 
09f44     52 93 06 F6 | 	mov	arg02, ##850
09f48     24 D7 BF FD | 	call	#_fatfs_cc_ff_oem2uni
09f4c     3B B9 02 F6 | 	mov	local10, result1
09f50     5C AD 02 F6 | 	mov	local04, local10
09f54     0F AC 4E F7 | 	zerox	local04, #15 wz
09f58     00 AE 06 A6 |  if_e	mov	local05, #0
09f5c     30 00 90 AD |  if_e	jmp	#LR__1627
09f60     5C 91 32 F9 | 	getword	arg01, local10, #0
09f64     57 93 02 F6 | 	mov	arg02, local05
09f68     54 BB 02 F6 | 	mov	local11, local02
09f6c     0C BA 06 F1 | 	add	local11, #12
09f70     5D 93 02 F1 | 	add	arg02, local11
09f74     0C 94 06 F6 | 	mov	arg03, #12
09f78     57 95 82 F1 | 	sub	arg03, local05
09f7c     D8 E1 BF FD | 	call	#_fatfs_cc_put_utf
09f80     3B BB 0A F6 | 	mov	local11, result1 wz
09f84     00 AE 06 A6 |  if_e	mov	local05, #0
09f88     5D AF 02 51 |  if_ne	add	local05, local11
09f8c     D8 FE 9F 5D |  if_ne	jmp	#LR__1624
09f90                 | LR__1627
09f90     57 AD 02 F6 | 	mov	local04, local05
09f94     0C A8 06 F1 | 	add	local02, #12
09f98     54 AD 02 F1 | 	add	local04, local02
09f9c     56 01 48 FC | 	wrbyte	#0, local04
09fa0     10 A8 06 F1 | 	add	local02, #16
09fa4     54 AD CA FA | 	rdbyte	local04, local02 wz
09fa8     1C A8 86 F1 | 	sub	local02, #28
09fac     F8 00 90 5D |  if_ne	jmp	#LR__1633
09fb0     00 AE 0E F2 | 	cmp	local05, #0 wz
09fb4     1C 00 90 5D |  if_ne	jmp	#LR__1628
09fb8     57 BB 02 F6 | 	mov	local11, local05
09fbc     54 B9 02 F6 | 	mov	local10, local02
09fc0     1C B8 06 F1 | 	add	local10, #28
09fc4     5C BB 02 F1 | 	add	local11, local10
09fc8     5D 7F 48 FC | 	wrbyte	#63, local11
09fcc     01 AE 06 F1 | 	add	local05, #1
09fd0     A4 00 90 FD | 	jmp	#LR__1632
09fd4                 | LR__1628
09fd4                 | ' 			for (si = di = 0, lcf =  0x08 ; fno->altname[si]; si++, di++) {
09fd4     00 AE 06 F6 | 	mov	local05, #0
09fd8     00 B0 06 F6 | 	mov	local06, #0
09fdc     08 BC 06 F6 | 	mov	local12, #8
09fe0                 | LR__1629
09fe0     58 AD 02 F6 | 	mov	local04, local06
09fe4     54 BB 02 F6 | 	mov	local11, local02
09fe8     0C BA 06 F1 | 	add	local11, #12
09fec     5D AD 02 F1 | 	add	local04, local11
09ff0     56 BB CA FA | 	rdbyte	local11, local04 wz
09ff4     80 00 90 AD |  if_e	jmp	#LR__1631
09ff8     58 B5 02 F6 | 	mov	local08, local06
09ffc     54 BB 02 F6 | 	mov	local11, local02
0a000     0C BA 06 F1 | 	add	local11, #12
0a004     5D B5 02 F1 | 	add	local08, local11
0a008     5A B9 C2 FA | 	rdbyte	local10, local08
0a00c     5C BB 32 F9 | 	getword	local11, local10, #0
0a010     2E BA 0E F2 | 	cmp	local11, #46 wz
0a014     10 BC 06 A6 |  if_e	mov	local12, #16
0a018     5C BB 32 F9 | 	getword	local11, local10, #0
0a01c     41 BA 16 F2 | 	cmp	local11, #65 wc
0a020     30 00 90 CD |  if_b	jmp	#LR__1630
0a024     5C B5 32 F9 | 	getword	local08, local10, #0
0a028     5B B4 16 F2 | 	cmp	local08, #91 wc
0a02c     24 00 90 3D |  if_ae	jmp	#LR__1630
0a030     1C A6 06 F1 | 	add	local01, #28
0a034     53 B7 02 FB | 	rdlong	local09, local01
0a038     1C A6 86 F1 | 	sub	local01, #28
0a03c     0C B6 06 F1 | 	add	local09, #12
0a040     5B B7 C2 FA | 	rdbyte	local09, local09
0a044     5E BB E2 F8 | 	getbyte	local11, local12, #0
0a048     5D B7 CA F7 | 	test	local09, local11 wz
0a04c     5C B9 32 59 |  if_ne	getword	local10, local10, #0
0a050     20 B8 06 51 |  if_ne	add	local10, #32
0a054                 | LR__1630
0a054     57 BB 02 F6 | 	mov	local11, local05
0a058     54 B5 02 F6 | 	mov	local08, local02
0a05c     1C B4 06 F1 | 	add	local08, #28
0a060     5A BB 02 F1 | 	add	local11, local08
0a064     5C B9 32 F9 | 	getword	local10, local10, #0
0a068     5D B9 42 FC | 	wrbyte	local10, local11
0a06c     01 B0 06 F1 | 	add	local06, #1
0a070     01 AE 06 F1 | 	add	local05, #1
0a074     68 FF 9F FD | 	jmp	#LR__1629
0a078                 | LR__1631
0a078                 | LR__1632
0a078     54 BD 02 F6 | 	mov	local12, local02
0a07c     1C BC 06 F1 | 	add	local12, #28
0a080     5E AF 02 F1 | 	add	local05, local12
0a084     57 01 48 FC | 	wrbyte	#0, local05
0a088     1C A6 06 F1 | 	add	local01, #28
0a08c     53 AD 02 FB | 	rdlong	local04, local01
0a090     1C A6 86 F1 | 	sub	local01, #28
0a094     0C AC 06 F1 | 	add	local04, #12
0a098     56 BB CA FA | 	rdbyte	local11, local04 wz
0a09c     0C A8 06 A1 |  if_e	add	local02, #12
0a0a0     54 01 48 AC |  if_e	wrbyte	#0, local02
0a0a4     0C A8 86 A1 |  if_e	sub	local02, #12
0a0a8                 | LR__1633
0a0a8     1C A6 06 F1 | 	add	local01, #28
0a0ac     53 BD 02 FB | 	rdlong	local12, local01
0a0b0     0B BC 06 F1 | 	add	local12, #11
0a0b4     5E AD C2 FA | 	rdbyte	local04, local12
0a0b8     3F AC 06 F5 | 	and	local04, #63
0a0bc     08 A8 06 F1 | 	add	local02, #8
0a0c0     54 AD 42 FC | 	wrbyte	local04, local02
0a0c4     08 A8 86 F1 | 	sub	local02, #8
0a0c8     53 91 02 FB | 	rdlong	arg01, local01
0a0cc     1C 90 06 F1 | 	add	arg01, #28
0a0d0                 | ' {
0a0d0                 | ' 
0a0d0                 | ' 	return *((DWORD*)ptr);
0a0d0     48 77 02 FB | 	rdlong	result1, arg01
0a0d4     54 77 62 FC | 	wrlong	result1, local02
0a0d8     53 91 02 FB | 	rdlong	arg01, local01
0a0dc     16 90 06 F1 | 	add	arg01, #22
0a0e0                 | ' {
0a0e0                 | ' 
0a0e0                 | ' 	return *((WORD*)ptr);
0a0e0     48 77 E2 FA | 	rdword	result1, arg01
0a0e4     06 A8 06 F1 | 	add	local02, #6
0a0e8     54 77 52 FC | 	wrword	result1, local02
0a0ec     53 91 02 FB | 	rdlong	arg01, local01
0a0f0     18 90 06 F1 | 	add	arg01, #24
0a0f4                 | ' {
0a0f4                 | ' 
0a0f4                 | ' 	return *((WORD*)ptr);
0a0f4     48 77 E2 FA | 	rdword	result1, arg01
0a0f8     02 A8 86 F1 | 	sub	local02, #2
0a0fc     54 77 52 FC | 	wrword	result1, local02
0a100                 | LR__1634
0a100     E7 F0 03 F6 | 	mov	ptra, fp
0a104     F2 00 A0 FD | 	call	#popregs_
0a108                 | _fatfs_cc_get_fileinfo_ret
0a108     2D 00 64 FD | 	ret
0a10c                 | 
0a10c                 | _fatfs_cc_create_name
0a10c     12 CA 05 F6 | 	mov	COUNT_, #18
0a110     E8 00 A0 FD | 	call	#pushregs_
0a114     34 F0 07 F1 | 	add	ptra, #52
0a118     48 A7 02 F6 | 	mov	local01, arg01
0a11c     49 A9 02 F6 | 	mov	local02, arg02
0a120     54 77 02 FB | 	rdlong	result1, local02
0a124     30 CE 05 F1 | 	add	fp, #48
0a128     E7 76 62 FC | 	wrlong	result1, fp
0a12c     30 CE 85 F1 | 	sub	fp, #48
0a130     53 AB 02 FB | 	rdlong	local03, local01
0a134     0C AA 06 F1 | 	add	local03, #12
0a138     55 AD 02 FB | 	rdlong	local04, local03
0a13c     00 AE 06 F6 | 	mov	local05, #0
0a140                 | ' 
0a140                 | ' 
0a140                 | ' 
0a140                 | ' 	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
0a140                 | ' 	for (;;) {
0a140                 | LR__1640
0a140     E7 90 02 F6 | 	mov	arg01, fp
0a144     30 90 06 F1 | 	add	arg01, #48
0a148     FC DE BF FD | 	call	#_fatfs_cc_tchar2uni
0a14c     3B B1 02 F6 | 	mov	local06, result1
0a150     FF FF 7F FF 
0a154     FF B1 0E F2 | 	cmp	local06, ##-1 wz
0a158     06 76 06 A6 |  if_e	mov	result1, #6
0a15c     84 04 90 AD |  if_e	jmp	#LR__1674
0a160     80 00 00 FF 
0a164     00 B0 16 F2 | 	cmp	local06, ##65536 wc
0a168     20 00 90 CD |  if_b	jmp	#LR__1641
0a16c     57 AB 02 F6 | 	mov	local03, local05
0a170     01 AA 66 F0 | 	shl	local03, #1
0a174     56 B3 02 F6 | 	mov	local07, local04
0a178     56 AB 02 F1 | 	add	local03, local04
0a17c     58 B5 02 F6 | 	mov	local08, local06
0a180     10 B4 46 F0 | 	shr	local08, #16
0a184     55 B5 52 FC | 	wrword	local08, local03
0a188     01 AE 06 F1 | 	add	local05, #1
0a18c                 | LR__1641
0a18c     58 B7 02 F6 | 	mov	local09, local06
0a190     5B AB 32 F9 | 	getword	local03, local09, #0
0a194     20 AA 16 F2 | 	cmp	local03, #32 wc
0a198     68 00 90 CD |  if_b	jmp	#LR__1643
0a19c     5B B9 32 F9 | 	getword	local10, local09, #0
0a1a0     2F B8 0E F2 | 	cmp	local10, #47 wz
0a1a4     5B AB 02 56 |  if_ne	mov	local03, local09
0a1a8     55 AB 32 59 |  if_ne	getword	local03, local03, #0
0a1ac     5C AA 0E 52 |  if_ne	cmp	local03, #92 wz
0a1b0     50 00 90 AD |  if_e	jmp	#LR__1643
0a1b4     5B AB 32 F9 | 	getword	local03, local09, #0
0a1b8     80 AA 16 F2 | 	cmp	local03, #128 wc
0a1bc     1C 00 90 3D |  if_ae	jmp	#LR__1642
0a1c0     6F 00 00 FF 
0a1c4     41 91 06 F6 | 	mov	arg01, ##@LR__2148
0a1c8     5B 93 32 F9 | 	getword	arg02, local09, #0
0a1cc     80 D7 BF FD | 	call	#_fatfs_cc_strchr
0a1d0     3B B9 0A F6 | 	mov	local10, result1 wz
0a1d4     06 76 06 56 |  if_ne	mov	result1, #6
0a1d8     08 04 90 5D |  if_ne	jmp	#LR__1674
0a1dc                 | LR__1642
0a1dc     FF AE 16 F2 | 	cmp	local05, #255 wc
0a1e0     06 76 06 36 |  if_ae	mov	result1, #6
0a1e4     FC 03 90 3D |  if_ae	jmp	#LR__1674
0a1e8     57 B1 02 F6 | 	mov	local06, local05
0a1ec     01 B0 66 F0 | 	shl	local06, #1
0a1f0     56 B3 02 F6 | 	mov	local07, local04
0a1f4     56 B1 02 F1 | 	add	local06, local04
0a1f8     58 B7 52 FC | 	wrword	local09, local06
0a1fc     01 AE 06 F1 | 	add	local05, #1
0a200     3C FF 9F FD | 	jmp	#LR__1640
0a204                 | LR__1643
0a204     5B AB 32 F9 | 	getword	local03, local09, #0
0a208     20 AA 16 F2 | 	cmp	local03, #32 wc
0a20c     04 BA 06 C6 |  if_b	mov	local11, #4
0a210     68 00 90 CD |  if_b	jmp	#LR__1648
0a214     D7 24 48 FB | 	callpa	#(@LR__1646-@LR__1644)>>2,fcache_load_ptr_
0a218                 | ' 		while ( ((*p) == '/' || (*p) == '\\') ) p++;
0a218                 | LR__1644
0a218     30 CE 05 F1 | 	add	fp, #48
0a21c     E7 B8 02 FB | 	rdlong	local10, fp
0a220     30 CE 85 F1 | 	sub	fp, #48
0a224     5C AB C2 FA | 	rdbyte	local03, local10
0a228     2F AA 0E F2 | 	cmp	local03, #47 wz
0a22c     18 00 90 AD |  if_e	jmp	#LR__1645
0a230     30 CE 05 F1 | 	add	fp, #48
0a234     E7 B4 02 FB | 	rdlong	local08, fp
0a238     30 CE 85 F1 | 	sub	fp, #48
0a23c     5A BB C2 FA | 	rdbyte	local11, local08
0a240     5C BA 0E F2 | 	cmp	local11, #92 wz
0a244     18 00 90 5D |  if_ne	jmp	#LR__1647
0a248                 | LR__1645
0a248     30 CE 05 F1 | 	add	fp, #48
0a24c     E7 BA 02 FB | 	rdlong	local11, fp
0a250     01 BA 06 F1 | 	add	local11, #1
0a254     E7 BA 62 FC | 	wrlong	local11, fp
0a258     30 CE 85 F1 | 	sub	fp, #48
0a25c     B8 FF 9F FD | 	jmp	#LR__1644
0a260                 | LR__1646
0a260                 | LR__1647
0a260     00 BA 06 F6 | 	mov	local11, #0
0a264     30 CE 05 F1 | 	add	fp, #48
0a268     E7 B8 02 FB | 	rdlong	local10, fp
0a26c     30 CE 85 F1 | 	sub	fp, #48
0a270     5C AB C2 FA | 	rdbyte	local03, local10
0a274     20 AA 16 F2 | 	cmp	local03, #32 wc
0a278     04 BA 06 C6 |  if_b	mov	local11, #4
0a27c                 | LR__1648
0a27c     30 CE 05 F1 | 	add	fp, #48
0a280     E7 AA 02 FB | 	rdlong	local03, fp
0a284     30 CE 85 F1 | 	sub	fp, #48
0a288     54 AB 62 FC | 	wrlong	local03, local02
0a28c                 | ' 	}
0a28c                 | ' 	*path = p;
0a28c                 | ' #line 2862 "ff.c"
0a28c                 | ' 	while (di) {
0a28c     00 AE 0E F2 | 	cmp	local05, #0 wz
0a290     30 00 90 AD |  if_e	jmp	#LR__1651
0a294     D7 16 48 FB | 	callpa	#(@LR__1650-@LR__1649)>>2,fcache_load_ptr_
0a298                 | LR__1649
0a298     57 B7 02 F6 | 	mov	local09, local05
0a29c     01 B6 86 F1 | 	sub	local09, #1
0a2a0     01 B6 66 F0 | 	shl	local09, #1
0a2a4     56 B7 02 F1 | 	add	local09, local04
0a2a8     5B B7 E2 FA | 	rdword	local09, local09
0a2ac     5B AB 32 F9 | 	getword	local03, local09, #0
0a2b0     20 AA 0E F2 | 	cmp	local03, #32 wz
0a2b4     5B B9 02 56 |  if_ne	mov	local10, local09
0a2b8     5C B9 32 59 |  if_ne	getword	local10, local10, #0
0a2bc     2E B8 0E 52 |  if_ne	cmp	local10, #46 wz
0a2c0     F5 AF 6E AB |  if_e	djnz	local05, #LR__1649
0a2c4                 | LR__1650
0a2c4                 | LR__1651
0a2c4     57 B9 02 F6 | 	mov	local10, local05
0a2c8     01 B8 66 F0 | 	shl	local10, #1
0a2cc     56 B9 02 F1 | 	add	local10, local04
0a2d0     5C 01 58 FC | 	wrword	#0, local10
0a2d4     00 AE 0E F2 | 	cmp	local05, #0 wz
0a2d8     06 76 06 A6 |  if_e	mov	result1, #6
0a2dc     04 03 90 AD |  if_e	jmp	#LR__1674
0a2e0                 | ' 
0a2e0                 | ' 
0a2e0                 | ' 	for (si = 0; lfn[si] == ' '; si++) ;
0a2e0     00 BC 06 F6 | 	mov	local12, #0
0a2e4     D7 12 48 FB | 	callpa	#(@LR__1653-@LR__1652)>>2,fcache_load_ptr_
0a2e8                 | LR__1652
0a2e8     5E B7 02 F6 | 	mov	local09, local12
0a2ec     01 B6 66 F0 | 	shl	local09, #1
0a2f0     56 B7 02 F1 | 	add	local09, local04
0a2f4     5B AB E2 FA | 	rdword	local03, local09
0a2f8     20 AA 0E F2 | 	cmp	local03, #32 wz
0a2fc     5E B5 02 A6 |  if_e	mov	local08, local12
0a300     01 B4 06 A1 |  if_e	add	local08, #1
0a304     5A BD 02 A6 |  if_e	mov	local12, local08
0a308     DC FF 9F AD |  if_e	jmp	#LR__1652
0a30c                 | LR__1653
0a30c     01 BC 16 F2 | 	cmp	local12, #1 wc
0a310     18 00 90 3D |  if_ae	jmp	#LR__1654
0a314     5E B7 02 F6 | 	mov	local09, local12
0a318     01 B6 66 F0 | 	shl	local09, #1
0a31c     56 B7 02 F1 | 	add	local09, local04
0a320     5B AB E2 FA | 	rdword	local03, local09
0a324     2E AA 0E F2 | 	cmp	local03, #46 wz
0a328     08 00 90 5D |  if_ne	jmp	#LR__1655
0a32c                 | LR__1654
0a32c     5D BB E2 F8 | 	getbyte	local11, local11, #0
0a330     03 BA 46 F5 | 	or	local11, #3
0a334                 | LR__1655
0a334     D7 14 48 FB | 	callpa	#(@LR__1657-@LR__1656)>>2,fcache_load_ptr_
0a338                 | ' 	while (di > 0 && lfn[di - 1] != '.') di--;
0a338                 | LR__1656
0a338     01 AE 16 F2 | 	cmp	local05, #1 wc
0a33c     20 00 90 CD |  if_b	jmp	#LR__1658
0a340     57 B7 02 F6 | 	mov	local09, local05
0a344     01 B6 86 F1 | 	sub	local09, #1
0a348     01 B6 66 F0 | 	shl	local09, #1
0a34c     56 B7 02 F1 | 	add	local09, local04
0a350     5B AB E2 FA | 	rdword	local03, local09
0a354     2E AA 0E F2 | 	cmp	local03, #46 wz
0a358     01 AE 86 51 |  if_ne	sub	local05, #1
0a35c     D8 FF 9F 5D |  if_ne	jmp	#LR__1656
0a360                 | LR__1657
0a360                 | LR__1658
0a360     53 91 02 F6 | 	mov	arg01, local01
0a364     20 90 06 F1 | 	add	arg01, #32
0a368     20 92 06 F6 | 	mov	arg02, #32
0a36c     0B 94 06 F6 | 	mov	arg03, #11
0a370     48 BF 02 F6 | 	mov	local13, arg01
0a374     D8 00 A0 FD | 	call	#\builtin_bytefill_
0a378     5F 77 02 F6 | 	mov	result1, local13
0a37c     00 C0 06 F6 | 	mov	local14, #0
0a380     00 C2 06 F6 | 	mov	local15, #0
0a384     08 C4 06 F6 | 	mov	local16, #8
0a388                 | ' 
0a388                 | ' 	__builtin_memset(dp->fn, ' ', 11) ;
0a388                 | ' 	i = b = 0; ni = 8;
0a388                 | ' 	for (;;) {
0a388                 | LR__1659
0a388     5E C7 02 F6 | 	mov	local17, local12
0a38c     63 C9 02 F6 | 	mov	local18, local17
0a390     01 C8 66 F0 | 	shl	local18, #1
0a394     56 B3 02 F6 | 	mov	local07, local04
0a398     56 C9 02 F1 | 	add	local18, local04
0a39c     64 B7 E2 FA | 	rdword	local09, local18
0a3a0     5B AB 02 F6 | 	mov	local03, local09
0a3a4     0F AA 4E F7 | 	zerox	local03, #15 wz
0a3a8     01 BC 06 F1 | 	add	local12, #1
0a3ac     B0 01 90 AD |  if_e	jmp	#LR__1672
0a3b0     5B AB 32 F9 | 	getword	local03, local09, #0
0a3b4     20 AA 0E F2 | 	cmp	local03, #32 wz
0a3b8     14 00 90 AD |  if_e	jmp	#LR__1660
0a3bc     5B B9 32 F9 | 	getword	local10, local09, #0
0a3c0     2E B8 0E F2 | 	cmp	local10, #46 wz
0a3c4     14 00 90 5D |  if_ne	jmp	#LR__1661
0a3c8     57 BD 0A F2 | 	cmp	local12, local05 wz
0a3cc     0C 00 90 AD |  if_e	jmp	#LR__1661
0a3d0                 | LR__1660
0a3d0     5D BB E2 F8 | 	getbyte	local11, local11, #0
0a3d4     03 BA 46 F5 | 	or	local11, #3
0a3d8                 | ' 			cf |=  0x01  |  0x02 ;
0a3d8                 | ' 			continue;
0a3d8     AC FF 9F FD | 	jmp	#LR__1659
0a3dc                 | LR__1661
0a3dc     62 C3 12 F2 | 	cmp	local15, local16 wc
0a3e0     57 BD 0A C2 |  if_b	cmp	local12, local05 wz
0a3e4     3C 00 90 4D |  if_c_and_nz	jmp	#LR__1662
0a3e8     0B C4 0E F2 | 	cmp	local16, #11 wz
0a3ec     5D BB E2 A8 |  if_e	getbyte	local11, local11, #0
0a3f0     03 BA 46 A5 |  if_e	or	local11, #3
0a3f4                 | ' 				cf |=  0x01  |  0x02 ;
0a3f4                 | ' 				break;
0a3f4     68 01 90 AD |  if_e	jmp	#LR__1672
0a3f8     57 BD 0A F2 | 	cmp	local12, local05 wz
0a3fc     5D BB E2 58 |  if_ne	getbyte	local11, local11, #0
0a400     03 BA 46 55 |  if_ne	or	local11, #3
0a404     57 BD 1A F2 | 	cmp	local12, local05 wcz
0a408     54 01 90 1D |  if_a	jmp	#LR__1672
0a40c     57 BD 02 F6 | 	mov	local12, local05
0a410     08 C2 06 F6 | 	mov	local15, #8
0a414     0B C4 06 F6 | 	mov	local16, #11
0a418     60 C1 E2 F8 | 	getbyte	local14, local14, #0
0a41c     02 C0 66 F0 | 	shl	local14, #2
0a420                 | ' 			si = di; i = 8; ni = 11; b <<= 2;
0a420                 | ' 			continue;
0a420     64 FF 9F FD | 	jmp	#LR__1659
0a424                 | LR__1662
0a424     5B AB 32 F9 | 	getword	local03, local09, #0
0a428     80 AA 16 F2 | 	cmp	local03, #128 wc
0a42c     50 00 90 CD |  if_b	jmp	#LR__1664
0a430     5D BB E2 F8 | 	getbyte	local11, local11, #0
0a434     02 BA 46 F5 | 	or	local11, #2
0a438     5B 91 32 F9 | 	getword	arg01, local09, #0
0a43c     01 00 00 FF 
0a440     52 B9 06 F6 | 	mov	local10, ##850
0a444     01 00 00 FF 
0a448     52 93 06 F6 | 	mov	arg02, ##850
0a44c     B0 D1 BF FD | 	call	#_fatfs_cc_ff_uni2oem
0a450     3B B7 02 F6 | 	mov	local09, result1
0a454     5B AB 32 F9 | 	getword	local03, local09, #0
0a458     80 AA CE F7 | 	test	local03, #128 wz
0a45c     20 00 90 AD |  if_e	jmp	#LR__1663
0a460     5B B9 32 F9 | 	getword	local10, local09, #0
0a464     7F B8 06 F5 | 	and	local10, #127
0a468     5C C7 02 F6 | 	mov	local17, local10
0a46c     35 C9 02 F6 | 	mov	local18, ptr__fatfs_cc_dat__
0a470     01 00 00 FF 
0a474     BB C9 06 F1 | 	add	local18, ##955
0a478     64 C7 02 F1 | 	add	local17, local18
0a47c     63 B7 C2 FA | 	rdbyte	local09, local17
0a480                 | LR__1663
0a480                 | LR__1664
0a480     5B AB 32 F9 | 	getword	local03, local09, #0
0a484     00 AB 16 F2 | 	cmp	local03, #256 wc
0a488     40 00 90 CD |  if_b	jmp	#LR__1665
0a48c     62 AB 02 F6 | 	mov	local03, local16
0a490     01 AA 86 F1 | 	sub	local03, #1
0a494     55 C3 12 F2 | 	cmp	local15, local03 wc
0a498     5D BB E2 38 |  if_ae	getbyte	local11, local11, #0
0a49c     03 BA 46 35 |  if_ae	or	local11, #3
0a4a0     62 C3 02 36 |  if_ae	mov	local15, local16
0a4a4                 | ' 				cf |=  0x01  |  0x02 ;
0a4a4                 | ' 				i = ni; continue;
0a4a4     E0 FE 9F 3D |  if_ae	jmp	#LR__1659
0a4a8     61 C7 02 F6 | 	mov	local17, local15
0a4ac     53 C9 02 F6 | 	mov	local18, local01
0a4b0     20 C8 06 F1 | 	add	local18, #32
0a4b4     64 C7 02 F1 | 	add	local17, local18
0a4b8     5B B3 32 F9 | 	getword	local07, local09, #0
0a4bc     08 B2 46 F0 | 	shr	local07, #8
0a4c0     63 B3 42 FC | 	wrbyte	local07, local17
0a4c4     01 C2 06 F1 | 	add	local15, #1
0a4c8     74 00 90 FD | 	jmp	#LR__1671
0a4cc                 | LR__1665
0a4cc     5B AB 02 F6 | 	mov	local03, local09
0a4d0     0F AA 4E F7 | 	zerox	local03, #15 wz
0a4d4     18 00 90 AD |  if_e	jmp	#LR__1666
0a4d8     6F 00 00 FF 
0a4dc     4A 91 06 F6 | 	mov	arg01, ##@LR__2149
0a4e0     5B 93 32 F9 | 	getword	arg02, local09, #0
0a4e4     68 D4 BF FD | 	call	#_fatfs_cc_strchr
0a4e8     00 76 0E F2 | 	cmp	result1, #0 wz
0a4ec     10 00 90 AD |  if_e	jmp	#LR__1667
0a4f0                 | LR__1666
0a4f0     5F B6 06 F6 | 	mov	local09, #95
0a4f4     5D BB E2 F8 | 	getbyte	local11, local11, #0
0a4f8     03 BA 46 F5 | 	or	local11, #3
0a4fc     40 00 90 FD | 	jmp	#LR__1670
0a500                 | LR__1667
0a500     5B AB 32 F9 | 	getword	local03, local09, #0
0a504     41 AA 16 F2 | 	cmp	local03, #65 wc
0a508     10 00 90 CD |  if_b	jmp	#LR__1668
0a50c     5B B9 32 F9 | 	getword	local10, local09, #0
0a510     5B B8 16 F2 | 	cmp	local10, #91 wc
0a514     60 C1 E2 C8 |  if_b	getbyte	local14, local14, #0
0a518     02 C0 46 C5 |  if_b	or	local14, #2
0a51c                 | LR__1668
0a51c     5B AB 32 F9 | 	getword	local03, local09, #0
0a520     61 AA 16 F2 | 	cmp	local03, #97 wc
0a524     18 00 90 CD |  if_b	jmp	#LR__1669
0a528     5B B9 32 F9 | 	getword	local10, local09, #0
0a52c     7B B8 16 F2 | 	cmp	local10, #123 wc
0a530     60 C1 E2 C8 |  if_b	getbyte	local14, local14, #0
0a534     01 C0 46 C5 |  if_b	or	local14, #1
0a538     5B B7 32 C9 |  if_b	getword	local09, local09, #0
0a53c     20 B6 86 C1 |  if_b	sub	local09, #32
0a540                 | LR__1669
0a540                 | LR__1670
0a540                 | LR__1671
0a540     61 C7 02 F6 | 	mov	local17, local15
0a544     53 C9 02 F6 | 	mov	local18, local01
0a548     20 C8 06 F1 | 	add	local18, #32
0a54c     64 C7 02 F1 | 	add	local17, local18
0a550     5B B7 32 F9 | 	getword	local09, local09, #0
0a554     63 B7 42 FC | 	wrbyte	local09, local17
0a558     01 C2 06 F1 | 	add	local15, #1
0a55c     28 FE 9F FD | 	jmp	#LR__1659
0a560                 | LR__1672
0a560     20 A6 06 F1 | 	add	local01, #32
0a564     53 AB C2 FA | 	rdbyte	local03, local01
0a568     20 A6 86 F1 | 	sub	local01, #32
0a56c     E5 AA 0E F2 | 	cmp	local03, #229 wz
0a570     20 A6 06 A1 |  if_e	add	local01, #32
0a574     53 0B 48 AC |  if_e	wrbyte	#5, local01
0a578     20 A6 86 A1 |  if_e	sub	local01, #32
0a57c     08 C4 0E F2 | 	cmp	local16, #8 wz
0a580     60 C1 E2 A8 |  if_e	getbyte	local14, local14, #0
0a584     02 C0 66 A0 |  if_e	shl	local14, #2
0a588     60 AB E2 F8 | 	getbyte	local03, local14, #0
0a58c     0C AA 06 F5 | 	and	local03, #12
0a590     0C AA 0E F2 | 	cmp	local03, #12 wz
0a594     60 B9 02 56 |  if_ne	mov	local10, local14
0a598     5C B9 E2 58 |  if_ne	getbyte	local10, local10, #0
0a59c     03 B8 06 55 |  if_ne	and	local10, #3
0a5a0     03 B8 0E 52 |  if_ne	cmp	local10, #3 wz
0a5a4     5D BB E2 A8 |  if_e	getbyte	local11, local11, #0
0a5a8     02 BA 46 A5 |  if_e	or	local11, #2
0a5ac     5D AB E2 F8 | 	getbyte	local03, local11, #0
0a5b0     02 AA CE F7 | 	test	local03, #2 wz
0a5b4     20 00 90 5D |  if_ne	jmp	#LR__1673
0a5b8     60 AB E2 F8 | 	getbyte	local03, local14, #0
0a5bc     01 AA CE F7 | 	test	local03, #1 wz
0a5c0     5D BB E2 58 |  if_ne	getbyte	local11, local11, #0
0a5c4     10 BA 46 55 |  if_ne	or	local11, #16
0a5c8     60 C1 E2 F8 | 	getbyte	local14, local14, #0
0a5cc     04 C0 CE F7 | 	test	local14, #4 wz
0a5d0     5D BB E2 58 |  if_ne	getbyte	local11, local11, #0
0a5d4     08 BA 46 55 |  if_ne	or	local11, #8
0a5d8                 | LR__1673
0a5d8     2B A6 06 F1 | 	add	local01, #43
0a5dc     53 BB 42 FC | 	wrbyte	local11, local01
0a5e0                 | ' 	}
0a5e0                 | ' 
0a5e0                 | ' 	dp->fn[ 11 ] = cf;
0a5e0                 | ' 
0a5e0                 | ' 	return FR_OK;
0a5e0     00 76 06 F6 | 	mov	result1, #0
0a5e4                 | LR__1674
0a5e4     E7 F0 03 F6 | 	mov	ptra, fp
0a5e8     F2 00 A0 FD | 	call	#popregs_
0a5ec                 | _fatfs_cc_create_name_ret
0a5ec     2D 00 64 FD | 	ret
0a5f0                 | 
0a5f0                 | _fatfs_cc_follow_path
0a5f0     04 CA 05 F6 | 	mov	COUNT_, #4
0a5f4     E8 00 A0 FD | 	call	#pushregs_
0a5f8     18 F0 07 F1 | 	add	ptra, #24
0a5fc     48 A7 02 F6 | 	mov	local01, arg01
0a600     08 CE 05 F1 | 	add	fp, #8
0a604     E7 92 62 FC | 	wrlong	arg02, fp
0a608     08 CE 85 F1 | 	sub	fp, #8
0a60c     53 A9 02 FB | 	rdlong	local02, local01
0a610     D7 24 48 FB | 	callpa	#(@LR__1682-@LR__1680)>>2,fcache_load_ptr_
0a614                 | ' )
0a614                 | ' {
0a614                 | ' 	FRESULT res;
0a614                 | ' 	BYTE ns;
0a614                 | ' 	FATFS *fs = dp->obj.fs;
0a614                 | ' #line 3034 "ff.c"
0a614                 | ' 	{
0a614                 | ' 		while ( ((*path) == '/' || (*path) == '\\') ) path++;
0a614                 | LR__1680
0a614     08 CE 05 F1 | 	add	fp, #8
0a618     E7 76 02 FB | 	rdlong	result1, fp
0a61c     08 CE 85 F1 | 	sub	fp, #8
0a620     3B 77 C2 FA | 	rdbyte	result1, result1
0a624     2F 76 0E F2 | 	cmp	result1, #47 wz
0a628     18 00 90 AD |  if_e	jmp	#LR__1681
0a62c     08 CE 05 F1 | 	add	fp, #8
0a630     E7 76 02 FB | 	rdlong	result1, fp
0a634     08 CE 85 F1 | 	sub	fp, #8
0a638     3B 77 C2 FA | 	rdbyte	result1, result1
0a63c     5C 76 0E F2 | 	cmp	result1, #92 wz
0a640     18 00 90 5D |  if_ne	jmp	#LR__1683
0a644                 | LR__1681
0a644     08 CE 05 F1 | 	add	fp, #8
0a648     E7 76 02 FB | 	rdlong	result1, fp
0a64c     01 76 06 F1 | 	add	result1, #1
0a650     E7 76 62 FC | 	wrlong	result1, fp
0a654     08 CE 85 F1 | 	sub	fp, #8
0a658     B8 FF 9F FD | 	jmp	#LR__1680
0a65c                 | LR__1682
0a65c                 | LR__1683
0a65c     08 A6 06 F1 | 	add	local01, #8
0a660     53 01 68 FC | 	wrlong	#0, local01
0a664     08 A6 86 F1 | 	sub	local01, #8
0a668     08 CE 05 F1 | 	add	fp, #8
0a66c     E7 92 02 FB | 	rdlong	arg02, fp
0a670     08 CE 85 F1 | 	sub	fp, #8
0a674     49 93 C2 FA | 	rdbyte	arg02, arg02
0a678     20 92 16 F2 | 	cmp	arg02, #32 wc
0a67c     20 00 90 3D |  if_ae	jmp	#LR__1684
0a680     2B A6 06 F1 | 	add	local01, #43
0a684     53 01 49 FC | 	wrbyte	#128, local01
0a688     2B A6 86 F1 | 	sub	local01, #43
0a68c     53 91 02 F6 | 	mov	arg01, local01
0a690     00 92 06 F6 | 	mov	arg02, #0
0a694     9C E6 BF FD | 	call	#_fatfs_cc_dir_sdi
0a698     3B AB 02 F6 | 	mov	local03, result1
0a69c     A0 00 90 FD | 	jmp	#LR__1688
0a6a0                 | LR__1684
0a6a0                 | ' 		for (;;) {
0a6a0                 | LR__1685
0a6a0     E7 92 02 F6 | 	mov	arg02, fp
0a6a4     08 92 06 F1 | 	add	arg02, #8
0a6a8     53 91 02 F6 | 	mov	arg01, local01
0a6ac     5C FA BF FD | 	call	#_fatfs_cc_create_name
0a6b0     3B AB 0A F6 | 	mov	local03, result1 wz
0a6b4     88 00 90 5D |  if_ne	jmp	#LR__1687
0a6b8     53 91 02 F6 | 	mov	arg01, local01
0a6bc     0C F1 BF FD | 	call	#_fatfs_cc_dir_find
0a6c0     3B AB 0A F6 | 	mov	local03, result1 wz
0a6c4     2B A6 06 F1 | 	add	local01, #43
0a6c8     53 AD C2 FA | 	rdbyte	local04, local01
0a6cc     2B A6 86 F1 | 	sub	local01, #43
0a6d0     18 00 90 AD |  if_e	jmp	#LR__1686
0a6d4     04 AA 0E F2 | 	cmp	local03, #4 wz
0a6d8     64 00 90 5D |  if_ne	jmp	#LR__1687
0a6dc     56 AD E2 F8 | 	getbyte	local04, local04, #0
0a6e0     04 AC CE F7 | 	test	local04, #4 wz
0a6e4     05 AA 06 A6 |  if_e	mov	local03, #5
0a6e8                 | ' 					}
0a6e8                 | ' 				}
0a6e8                 | ' 				break;
0a6e8     54 00 90 FD | 	jmp	#LR__1687
0a6ec                 | LR__1686
0a6ec     56 AD E2 F8 | 	getbyte	local04, local04, #0
0a6f0     04 AC CE F7 | 	test	local04, #4 wz
0a6f4     48 00 90 5D |  if_ne	jmp	#LR__1687
0a6f8     06 A6 06 F1 | 	add	local01, #6
0a6fc     53 AD C2 FA | 	rdbyte	local04, local01
0a700     06 A6 86 F1 | 	sub	local01, #6
0a704     10 AC CE F7 | 	test	local04, #16 wz
0a708     05 AA 06 A6 |  if_e	mov	local03, #5
0a70c                 | ' 				res = FR_NO_PATH; break;
0a70c     30 00 90 AD |  if_e	jmp	#LR__1687
0a710     54 91 02 F6 | 	mov	arg01, local02
0a714     54 93 02 F6 | 	mov	arg02, local02
0a718     34 92 06 F1 | 	add	arg02, #52
0a71c     10 A6 06 F1 | 	add	local01, #16
0a720     53 AD 02 FB | 	rdlong	local04, local01
0a724     FF AD 06 F5 | 	and	local04, #511
0a728     56 93 02 F1 | 	add	arg02, local04
0a72c     D8 E9 BF FD | 	call	#_fatfs_cc_ld_clust
0a730     08 A6 86 F1 | 	sub	local01, #8
0a734     53 77 62 FC | 	wrlong	result1, local01
0a738     08 A6 86 F1 | 	sub	local01, #8
0a73c     60 FF 9F FD | 	jmp	#LR__1685
0a740                 | LR__1687
0a740                 | LR__1688
0a740                 | ' 			}
0a740                 | ' #line 3090 "ff.c"
0a740                 | ' 			{
0a740                 | ' 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr %  ((UINT) 512 ) );
0a740                 | ' 			}
0a740                 | ' 		}
0a740                 | ' 	}
0a740                 | ' 
0a740                 | ' 	return res;
0a740     55 77 02 F6 | 	mov	result1, local03
0a744     E7 F0 03 F6 | 	mov	ptra, fp
0a748     F2 00 A0 FD | 	call	#popregs_
0a74c                 | _fatfs_cc_follow_path_ret
0a74c     2D 00 64 FD | 	ret
0a750                 | 
0a750                 | _fatfs_cc_get_ldnumber
0a750     01 7C 66 F6 | 	neg	_var01, #1
0a754     48 7F 0A FB | 	rdlong	_var02, arg01 wz
0a758     3F 81 02 F6 | 	mov	_var03, _var02
0a75c     01 76 66 A6 |  if_e	neg	result1, #1
0a760     74 00 90 AD |  if_e	jmp	#_fatfs_cc_get_ldnumber_ret
0a764     D7 10 48 FB | 	callpa	#(@LR__1691-@LR__1690)>>2,fcache_load_ptr_
0a768                 | ' 	do tc = *tt++; while (! ((UINT)(tc) < ( 1 ? ' ' : '!'))  && tc != ':');
0a768                 | LR__1690
0a768     40 83 C2 FA | 	rdbyte	_var04, _var03
0a76c     41 77 E2 F8 | 	getbyte	result1, _var04, #0
0a770     20 76 16 F2 | 	cmp	result1, #32 wc
0a774     01 80 06 F1 | 	add	_var03, #1
0a778     41 85 02 36 |  if_ae	mov	_var05, _var04
0a77c     42 85 E2 38 |  if_ae	getbyte	_var05, _var05, #0
0a780     3A 84 0E 32 |  if_ae	cmp	_var05, #58 wz
0a784     E0 FF 9F 1D |  if_a	jmp	#LR__1690
0a788                 | LR__1691
0a788     41 83 E2 F8 | 	getbyte	_var04, _var04, #0
0a78c     3A 82 0E F2 | 	cmp	_var04, #58 wz
0a790     40 00 90 5D |  if_ne	jmp	#LR__1693
0a794     01 86 06 F6 | 	mov	_var06, #1
0a798     3F 85 C2 FA | 	rdbyte	_var05, _var02
0a79c     30 84 16 F2 | 	cmp	_var05, #48 wc
0a7a0     1C 00 90 CD |  if_b	jmp	#LR__1692
0a7a4     3F 85 C2 FA | 	rdbyte	_var05, _var02
0a7a8     3A 84 16 F2 | 	cmp	_var05, #58 wc
0a7ac     3F 89 02 C6 |  if_b	mov	_var07, _var02
0a7b0     02 88 06 C1 |  if_b	add	_var07, #2
0a7b4     40 89 0A C2 |  if_b	cmp	_var07, _var03 wz
0a7b8     42 87 02 86 |  if_c_and_z	mov	_var06, _var05
0a7bc     30 86 86 81 |  if_c_and_z	sub	_var06, #48
0a7c0                 | LR__1692
0a7c0     01 86 56 F2 | 	cmps	_var06, #1 wc
0a7c4     43 7D 02 C6 |  if_b	mov	_var01, _var06
0a7c8     48 81 62 CC |  if_b	wrlong	_var03, arg01
0a7cc                 | ' 			vol = i;
0a7cc                 | ' 			*path = tt;
0a7cc                 | ' 		}
0a7cc                 | ' 		return vol;
0a7cc     3E 77 02 F6 | 	mov	result1, _var01
0a7d0     04 00 90 FD | 	jmp	#_fatfs_cc_get_ldnumber_ret
0a7d4                 | LR__1693
0a7d4                 | ' 	}
0a7d4                 | ' #line 3170 "ff.c"
0a7d4                 | ' 	vol = 0;
0a7d4                 | ' 
0a7d4                 | ' 	return vol;
0a7d4     00 76 06 F6 | 	mov	result1, #0
0a7d8                 | _fatfs_cc_get_ldnumber_ret
0a7d8     2D 00 64 FD | 	ret
0a7dc                 | 
0a7dc                 | _fatfs_cc_check_fs
0a7dc     04 CA 05 F6 | 	mov	COUNT_, #4
0a7e0     E8 00 A0 FD | 	call	#pushregs_
0a7e4     48 A7 02 F6 | 	mov	local01, arg01
0a7e8     03 A6 06 F1 | 	add	local01, #3
0a7ec     53 01 48 FC | 	wrbyte	#0, local01
0a7f0     2D A6 06 F1 | 	add	local01, #45
0a7f4     FF FF FF FF 
0a7f8     53 FF 6B FC | 	wrlong	##-1, local01
0a7fc     30 A6 86 F1 | 	sub	local01, #48
0a800     53 91 02 F6 | 	mov	arg01, local01
0a804     C8 DB BF FD | 	call	#_fatfs_cc_move_window
0a808     00 76 0E F2 | 	cmp	result1, #0 wz
0a80c     04 76 06 56 |  if_ne	mov	result1, #4
0a810     64 01 90 5D |  if_ne	jmp	#LR__1703
0a814     34 A6 06 F1 | 	add	local01, #52
0a818     53 91 02 F6 | 	mov	arg01, local01
0a81c     FE 91 06 F1 | 	add	arg01, #510
0a820                 | ' {
0a820                 | ' 
0a820                 | ' 	return *((WORD*)ptr);
0a820     48 A9 E2 FA | 	rdword	local02, arg01
0a824     53 AB C2 FA | 	rdbyte	local03, local01
0a828     34 A6 86 F1 | 	sub	local01, #52
0a82c     55 AD E2 F8 | 	getbyte	local04, local03, #0
0a830     EB AC 0E F2 | 	cmp	local04, #235 wz
0a834     55 95 02 56 |  if_ne	mov	arg03, local03
0a838     4A 95 E2 58 |  if_ne	getbyte	arg03, arg03, #0
0a83c     E9 94 0E 52 |  if_ne	cmp	arg03, #233 wz
0a840     55 AB E2 58 |  if_ne	getbyte	local03, local03, #0
0a844     E8 AA 0E 52 |  if_ne	cmp	local03, #232 wz
0a848     14 01 90 5D |  if_ne	jmp	#LR__1702
0a84c     54 AD 32 F9 | 	getword	local04, local02, #0
0a850     55 00 00 FF 
0a854     55 AC 0E F2 | 	cmp	local04, ##43605 wz
0a858     24 00 90 5D |  if_ne	jmp	#LR__1700
0a85c     53 91 02 F6 | 	mov	arg01, local01
0a860     86 90 06 F1 | 	add	arg01, #134
0a864     6F 00 00 FF 
0a868     51 93 06 F6 | 	mov	arg02, ##@LR__2150
0a86c     08 94 06 F6 | 	mov	arg03, #8
0a870     10 D0 BF FD | 	call	#_fatfs_cc_memcmp
0a874     00 76 0E F2 | 	cmp	result1, #0 wz
0a878                 | ' 			return 0;
0a878     00 76 06 A6 |  if_e	mov	result1, #0
0a87c     F8 00 90 AD |  if_e	jmp	#LR__1703
0a880                 | LR__1700
0a880     34 A6 06 F1 | 	add	local01, #52
0a884     53 91 02 F6 | 	mov	arg01, local01
0a888     0B 90 06 F1 | 	add	arg01, #11
0a88c                 | ' {
0a88c                 | ' 
0a88c                 | ' 	return *((WORD*)ptr);
0a88c     48 77 E2 FA | 	rdword	result1, arg01
0a890     0D A6 06 F1 | 	add	local01, #13
0a894     53 AB C2 FA | 	rdbyte	local03, local01
0a898     41 A6 86 F1 | 	sub	local01, #65
0a89c     3B AD 32 F9 | 	getword	local04, result1, #0
0a8a0     3B 93 32 F9 | 	getword	arg02, result1, #0
0a8a4     01 92 86 F1 | 	sub	arg02, #1
0a8a8     49 AD CA F7 | 	test	local04, arg02 wz
0a8ac     B0 00 90 5D |  if_ne	jmp	#LR__1701
0a8b0     3B 93 32 F9 | 	getword	arg02, result1, #0
0a8b4     01 00 00 FF 
0a8b8     00 92 16 F2 | 	cmp	arg02, ##512 wc
0a8bc     A0 00 90 CD |  if_b	jmp	#LR__1701
0a8c0     3B 93 32 F9 | 	getword	arg02, result1, #0
0a8c4     01 00 00 FF 
0a8c8     01 92 16 F2 | 	cmp	arg02, ##513 wc
0a8cc     90 00 90 3D |  if_ae	jmp	#LR__1701
0a8d0     55 91 02 F6 | 	mov	arg01, local03
0a8d4     07 90 4E F7 | 	zerox	arg01, #7 wz
0a8d8     84 00 90 AD |  if_e	jmp	#LR__1701
0a8dc     55 91 E2 F8 | 	getbyte	arg01, local03, #0
0a8e0     55 AB E2 F8 | 	getbyte	local03, local03, #0
0a8e4     01 AA 86 F1 | 	sub	local03, #1
0a8e8     55 91 CA F7 | 	test	arg01, local03 wz
0a8ec     70 00 90 5D |  if_ne	jmp	#LR__1701
0a8f0     53 91 02 F6 | 	mov	arg01, local01
0a8f4     42 90 06 F1 | 	add	arg01, #66
0a8f8                 | ' {
0a8f8                 | ' 
0a8f8                 | ' 	return *((WORD*)ptr);
0a8f8     48 77 EA FA | 	rdword	result1, arg01 wz
0a8fc     60 00 90 AD |  if_e	jmp	#LR__1701
0a900     44 A6 06 F1 | 	add	local01, #68
0a904     53 91 C2 FA | 	rdbyte	arg01, local01
0a908     44 A6 86 F1 | 	sub	local01, #68
0a90c     01 90 86 F1 | 	sub	arg01, #1
0a910     02 90 16 F2 | 	cmp	arg01, #2 wc
0a914     48 00 90 3D |  if_ae	jmp	#LR__1701
0a918     53 91 02 F6 | 	mov	arg01, local01
0a91c     45 90 06 F1 | 	add	arg01, #69
0a920                 | ' {
0a920                 | ' 
0a920                 | ' 	return *((WORD*)ptr);
0a920     48 77 EA FA | 	rdword	result1, arg01 wz
0a924     38 00 90 AD |  if_e	jmp	#LR__1701
0a928     53 91 02 F6 | 	mov	arg01, local01
0a92c     47 90 06 F1 | 	add	arg01, #71
0a930                 | ' {
0a930                 | ' 
0a930                 | ' 	return *((WORD*)ptr);
0a930     48 77 E2 FA | 	rdword	result1, arg01
0a934     3B AB 32 F9 | 	getword	local03, result1, #0
0a938     80 AA 16 F2 | 	cmp	local03, #128 wc
0a93c     53 91 02 C6 |  if_b	mov	arg01, local01
0a940     54 90 06 C1 |  if_b	add	arg01, #84
0a944                 | ' {
0a944                 | ' 
0a944                 | ' 	return *((DWORD*)ptr);
0a944     48 77 02 CB |  if_b	rdlong	result1, arg01
0a948     80 00 00 CF 
0a94c     00 76 16 C2 |  if_b	cmp	result1, ##65536 wc
0a950     4A A6 06 31 |  if_ae	add	local01, #74
0a954                 | ' {
0a954                 | ' 
0a954                 | ' 	return *((WORD*)ptr);
0a954     53 77 EA 3A |  if_ae	rdword	result1, local01 wz
0a958                 | ' 			&& b != 0 && (b & (b - 1)) == 0
0a958                 | ' 			&& ld_word(fs->win +  14 ) != 0
0a958                 | ' 			&& (UINT)fs->win[ 16 ] - 1 <= 1
0a958                 | ' 			&& ld_word(fs->win +  17 ) != 0
0a958                 | ' 			&& (ld_word(fs->win +  19 ) >= 128 || ld_dword(fs->win +  32 ) >= 0x10000)
0a958                 | ' 			&& ld_word(fs->win +  22 ) != 0) {
0a958                 | ' 				return 0;
0a958     00 76 06 16 |  if_a	mov	result1, #0
0a95c     18 00 90 1D |  if_a	jmp	#LR__1703
0a960                 | LR__1701
0a960                 | LR__1702
0a960                 | ' 		}
0a960                 | ' 	}
0a960                 | ' 	return sign == 0xAA55 ? 2 : 3;
0a960     54 AB 32 F9 | 	getword	local03, local02, #0
0a964     55 00 00 FF 
0a968     55 AA 0E F2 | 	cmp	local03, ##43605 wz
0a96c     02 AC 06 A6 |  if_e	mov	local04, #2
0a970     03 AC 06 56 |  if_ne	mov	local04, #3
0a974     56 77 02 F6 | 	mov	result1, local04
0a978                 | LR__1703
0a978     E7 F0 03 F6 | 	mov	ptra, fp
0a97c     F2 00 A0 FD | 	call	#popregs_
0a980                 | _fatfs_cc_check_fs_ret
0a980     2D 00 64 FD | 	ret
0a984                 | 
0a984                 | _fatfs_cc_find_volume
0a984     05 CA 05 F6 | 	mov	COUNT_, #5
0a988     E8 00 A0 FD | 	call	#pushregs_
0a98c     24 F0 07 F1 | 	add	ptra, #36
0a990     48 A7 02 F6 | 	mov	local01, arg01
0a994     49 A9 02 F6 | 	mov	local02, arg02
0a998     53 91 02 F6 | 	mov	arg01, local01
0a99c     00 92 06 F6 | 	mov	arg02, #0
0a9a0     38 FE BF FD | 	call	#_fatfs_cc_check_fs
0a9a4     02 76 0E F2 | 	cmp	result1, #2 wz
0a9a8     0C 00 90 AD |  if_e	jmp	#LR__1710
0a9ac     03 76 16 F2 | 	cmp	result1, #3 wc
0a9b0     00 A8 0E C2 |  if_b	cmp	local02, #0 wz
0a9b4     C8 00 90 BD |  if_nc_or_z	jmp	#LR__1718
0a9b8                 | LR__1710
0a9b8                 | ' 	for (i = 0; i < 4; i++) {
0a9b8     00 AA 06 F6 | 	mov	local03, #0
0a9bc     D7 22 48 FB | 	callpa	#(@LR__1712-@LR__1711)>>2,fcache_load_ptr_
0a9c0                 | LR__1711
0a9c0     04 AA 16 F2 | 	cmp	local03, #4 wc
0a9c4     3C 00 90 3D |  if_ae	jmp	#LR__1713
0a9c8     55 AD 02 F6 | 	mov	local04, local03
0a9cc     02 AC 66 F0 | 	shl	local04, #2
0a9d0     E7 92 02 F6 | 	mov	arg02, fp
0a9d4     14 92 06 F1 | 	add	arg02, #20
0a9d8     49 AD 02 F1 | 	add	local04, arg02
0a9dc     53 91 02 F6 | 	mov	arg01, local01
0a9e0     F2 91 06 F1 | 	add	arg01, #498
0a9e4     55 93 02 F6 | 	mov	arg02, local03
0a9e8     04 92 66 F0 | 	shl	arg02, #4
0a9ec     49 91 02 F1 | 	add	arg01, arg02
0a9f0     08 90 06 F1 | 	add	arg01, #8
0a9f4                 | ' {
0a9f4                 | ' 
0a9f4                 | ' 	return *((DWORD*)ptr);
0a9f4     48 77 02 FB | 	rdlong	result1, arg01
0a9f8     56 77 62 FC | 	wrlong	result1, local04
0a9fc     01 AA 06 F1 | 	add	local03, #1
0aa00     BC FF 9F FD | 	jmp	#LR__1711
0aa04                 | LR__1712
0aa04                 | LR__1713
0aa04     00 A8 0E F2 | 	cmp	local02, #0 wz
0aa08     54 AD 02 56 |  if_ne	mov	local04, local02
0aa0c     01 AC 86 51 |  if_ne	sub	local04, #1
0aa10     00 AC 06 A6 |  if_e	mov	local04, #0
0aa14     56 AB 02 F6 | 	mov	local03, local04
0aa18                 | ' 		mbr_pt[i] = ld_dword(fs->win +  446  + i *  16  +  8 );
0aa18                 | ' 	}
0aa18                 | ' 	i = part ? part - 1 : 0;
0aa18                 | ' 	do {
0aa18                 | LR__1714
0aa18     55 AD 02 F6 | 	mov	local04, local03
0aa1c     02 AC 66 F0 | 	shl	local04, #2
0aa20     E7 92 02 F6 | 	mov	arg02, fp
0aa24     14 92 06 F1 | 	add	arg02, #20
0aa28     49 AD 02 F1 | 	add	local04, arg02
0aa2c     56 AD 0A FB | 	rdlong	local04, local04 wz
0aa30     28 00 90 AD |  if_e	jmp	#LR__1715
0aa34     55 AD 02 F6 | 	mov	local04, local03
0aa38     02 AC 66 F0 | 	shl	local04, #2
0aa3c     E7 92 02 F6 | 	mov	arg02, fp
0aa40     14 92 06 F1 | 	add	arg02, #20
0aa44     49 AD 02 F1 | 	add	local04, arg02
0aa48     56 93 02 FB | 	rdlong	arg02, local04
0aa4c     53 91 02 F6 | 	mov	arg01, local01
0aa50     88 FD BF FD | 	call	#_fatfs_cc_check_fs
0aa54     3B AD 02 F6 | 	mov	local04, result1
0aa58     04 00 90 FD | 	jmp	#LR__1716
0aa5c                 | LR__1715
0aa5c     03 AC 06 F6 | 	mov	local04, #3
0aa60                 | LR__1716
0aa60     56 AF 02 F6 | 	mov	local05, local04
0aa64     00 A8 0E F2 | 	cmp	local02, #0 wz
0aa68     02 AE 16 A2 |  if_e	cmp	local05, #2 wc
0aa6c     0C 00 90 8D |  if_c_and_z	jmp	#LR__1717
0aa70     01 AA 06 A1 |  if_e	add	local03, #1
0aa74     04 AA 16 A2 |  if_e	cmp	local03, #4 wc
0aa78     9C FF 9F 8D |  if_c_and_z	jmp	#LR__1714
0aa7c                 | LR__1717
0aa7c                 | ' 	return fmt;
0aa7c     57 77 02 F6 | 	mov	result1, local05
0aa80                 | LR__1718
0aa80     E7 F0 03 F6 | 	mov	ptra, fp
0aa84     F2 00 A0 FD | 	call	#popregs_
0aa88                 | _fatfs_cc_find_volume_ret
0aa88     2D 00 64 FD | 	ret
0aa8c                 | 
0aa8c                 | _fatfs_cc_mount_volume
0aa8c     0A CA 05 F6 | 	mov	COUNT_, #10
0aa90     E8 00 A0 FD | 	call	#pushregs_
0aa94     4A A7 02 F6 | 	mov	local01, arg03
0aa98     49 01 68 FC | 	wrlong	#0, arg02
0aa9c     B0 FC BF FD | 	call	#_fatfs_cc_get_ldnumber
0aaa0     3B A9 02 F6 | 	mov	local02, result1
0aaa4     00 A8 56 F2 | 	cmps	local02, #0 wc
0aaa8     0B 76 06 C6 |  if_b	mov	result1, #11
0aaac     00 05 90 CD |  if_b	jmp	#LR__1729
0aab0     54 95 02 F6 | 	mov	arg03, local02
0aab4     02 94 66 F0 | 	shl	arg03, #2
0aab8     31 95 02 F1 | 	add	arg03, objptr
0aabc     4A AB 0A FB | 	rdlong	local03, arg03 wz
0aac0     0C 76 06 A6 |  if_e	mov	result1, #12
0aac4     E8 04 90 AD |  if_e	jmp	#LR__1729
0aac8     49 AB 62 FC | 	wrlong	local03, arg02
0aacc     53 A7 E2 F8 | 	getbyte	local01, local01, #0
0aad0     FE A6 06 F5 | 	and	local01, #254
0aad4     55 95 CA FA | 	rdbyte	arg03, local03 wz
0aad8     44 00 90 AD |  if_e	jmp	#LR__1721
0aadc     01 00 00 FF 
0aae0     10 62 06 F1 | 	add	objptr, ##528
0aae4     31 91 0A FB | 	rdlong	arg01, objptr wz
0aae8     01 00 00 FF 
0aaec     10 62 86 F1 | 	sub	objptr, ##528
0aaf0                 | '         return RES_NOTRDY;
0aaf0     03 76 06 A6 |  if_e	mov	result1, #3
0aaf4                 | '     }
0aaf4                 | '     return RES_OK;
0aaf4     00 76 06 56 |  if_ne	mov	result1, #0
0aaf8     3B 95 E2 F8 | 	getbyte	arg03, result1, #0
0aafc     01 94 CE F7 | 	test	arg03, #1 wz
0ab00     1C 00 90 5D |  if_ne	jmp	#LR__1720
0ab04     00 A6 0E F2 | 	cmp	local01, #0 wz
0ab08     3B 77 E2 58 |  if_ne	getbyte	result1, result1, #0
0ab0c     04 76 CE 57 |  if_ne	test	result1, #4 wz
0ab10                 | ' 				return FR_WRITE_PROTECTED;
0ab10     0A 76 06 56 |  if_ne	mov	result1, #10
0ab14     98 04 90 5D |  if_ne	jmp	#LR__1729
0ab18                 | ' 			}
0ab18                 | ' 			return FR_OK;
0ab18     00 76 06 F6 | 	mov	result1, #0
0ab1c     90 04 90 FD | 	jmp	#LR__1729
0ab20                 | LR__1720
0ab20                 | LR__1721
0ab20     55 01 48 FC | 	wrbyte	#0, local03
0ab24     01 AA 06 F1 | 	add	local03, #1
0ab28     55 A9 42 FC | 	wrbyte	local02, local03
0ab2c     01 AA 86 F1 | 	sub	local03, #1
0ab30     01 00 00 FF 
0ab34     10 62 06 F1 | 	add	objptr, ##528
0ab38     31 A9 0A FB | 	rdlong	local02, objptr wz
0ab3c     01 00 00 FF 
0ab40     10 62 86 F1 | 	sub	objptr, ##528
0ab44                 | ' 
0ab44                 | '         return RES_NOTRDY;
0ab44     03 76 06 A6 |  if_e	mov	result1, #3
0ab48                 | '     }
0ab48                 | '     return RES_OK;
0ab48     00 76 06 56 |  if_ne	mov	result1, #0
0ab4c     3B 95 02 F6 | 	mov	arg03, result1
0ab50     4A AD E2 F8 | 	getbyte	local04, arg03, #0
0ab54     01 AC CE F7 | 	test	local04, #1 wz
0ab58                 | ' 		return FR_NOT_READY;
0ab58     03 76 06 56 |  if_ne	mov	result1, #3
0ab5c     50 04 90 5D |  if_ne	jmp	#LR__1729
0ab60     00 A6 0E F2 | 	cmp	local01, #0 wz
0ab64     4A AD 02 56 |  if_ne	mov	local04, arg03
0ab68     56 AD E2 58 |  if_ne	getbyte	local04, local04, #0
0ab6c     04 AC CE 57 |  if_ne	test	local04, #4 wz
0ab70                 | ' 		return FR_WRITE_PROTECTED;
0ab70     0A 76 06 56 |  if_ne	mov	result1, #10
0ab74     38 04 90 5D |  if_ne	jmp	#LR__1729
0ab78     55 91 02 F6 | 	mov	arg01, local03
0ab7c     00 92 06 F6 | 	mov	arg02, #0
0ab80     00 FE BF FD | 	call	#_fatfs_cc_find_volume
0ab84     3B 91 02 F6 | 	mov	arg01, result1
0ab88     04 90 0E F2 | 	cmp	arg01, #4 wz
0ab8c     01 76 06 A6 |  if_e	mov	result1, #1
0ab90     1C 04 90 AD |  if_e	jmp	#LR__1729
0ab94     02 90 16 F2 | 	cmp	arg01, #2 wc
0ab98     0D 76 06 36 |  if_ae	mov	result1, #13
0ab9c     10 04 90 3D |  if_ae	jmp	#LR__1729
0aba0     30 AA 06 F1 | 	add	local03, #48
0aba4     55 AF 02 FB | 	rdlong	local05, local03
0aba8     04 AA 06 F1 | 	add	local03, #4
0abac     55 91 02 F6 | 	mov	arg01, local03
0abb0     34 AA 86 F1 | 	sub	local03, #52
0abb4     0B 90 06 F1 | 	add	arg01, #11
0abb8                 | ' {
0abb8                 | ' 
0abb8                 | ' 	return *((WORD*)ptr);
0abb8     48 77 E2 FA | 	rdword	result1, arg01
0abbc     01 00 00 FF 
0abc0     00 76 0E F2 | 	cmp	result1, ##512 wz
0abc4     0D 76 06 56 |  if_ne	mov	result1, #13
0abc8     E4 03 90 5D |  if_ne	jmp	#LR__1729
0abcc     55 91 02 F6 | 	mov	arg01, local03
0abd0     4A 90 06 F1 | 	add	arg01, #74
0abd4                 | ' {
0abd4                 | ' 
0abd4                 | ' 	return *((WORD*)ptr);
0abd4     48 77 E2 FA | 	rdword	result1, arg01
0abd8     3B B1 0A F6 | 	mov	local06, result1 wz
0abdc     55 91 02 A6 |  if_e	mov	arg01, local03
0abe0     58 90 06 A1 |  if_e	add	arg01, #88
0abe4                 | ' {
0abe4                 | ' 
0abe4                 | ' 	return *((DWORD*)ptr);
0abe4     48 77 02 AB |  if_e	rdlong	result1, arg01
0abe8     3B B1 02 A6 |  if_e	mov	local06, result1
0abec     1C AA 06 F1 | 	add	local03, #28
0abf0     55 B1 62 FC | 	wrlong	local06, local03
0abf4     28 AA 06 F1 | 	add	local03, #40
0abf8     55 AD C2 FA | 	rdbyte	local04, local03
0abfc     42 AA 86 F1 | 	sub	local03, #66
0ac00     55 AD 42 FC | 	wrbyte	local04, local03
0ac04     56 AD E2 F8 | 	getbyte	local04, local04, #0
0ac08     02 AA 86 F1 | 	sub	local03, #2
0ac0c     01 AC 0E F2 | 	cmp	local04, #1 wz
0ac10     02 AA 06 51 |  if_ne	add	local03, #2
0ac14     55 AD C2 5A |  if_ne	rdbyte	local04, local03
0ac18     02 AA 86 51 |  if_ne	sub	local03, #2
0ac1c     02 AC 0E 52 |  if_ne	cmp	local04, #2 wz
0ac20     0D 76 06 56 |  if_ne	mov	result1, #13
0ac24     88 03 90 5D |  if_ne	jmp	#LR__1729
0ac28     02 AA 06 F1 | 	add	local03, #2
0ac2c     55 AD C2 FA | 	rdbyte	local04, local03
0ac30     56 B1 02 FD | 	qmul	local06, local04
0ac34     3F AA 06 F1 | 	add	local03, #63
0ac38     55 AD C2 FA | 	rdbyte	local04, local03
0ac3c     37 AA 86 F1 | 	sub	local03, #55
0ac40     55 AD 52 FC | 	wrword	local04, local03
0ac44     56 AD 32 F9 | 	getword	local04, local04, #0
0ac48     0A AA 86 F1 | 	sub	local03, #10
0ac4c     0F AC 4E F7 | 	zerox	local04, #15 wz
0ac50     18 B0 62 FD | 	getqx	local06
0ac54     20 00 90 AD |  if_e	jmp	#LR__1722
0ac58     0A AA 06 F1 | 	add	local03, #10
0ac5c     55 AD E2 FA | 	rdword	local04, local03
0ac60     56 A9 32 F9 | 	getword	local02, local04, #0
0ac64     0A AA 86 F1 | 	sub	local03, #10
0ac68     56 AD 32 F9 | 	getword	local04, local04, #0
0ac6c     01 AC 86 F1 | 	sub	local04, #1
0ac70     56 A9 CA F7 | 	test	local02, local04 wz
0ac74     08 00 90 AD |  if_e	jmp	#LR__1723
0ac78                 | LR__1722
0ac78     0D 76 06 F6 | 	mov	result1, #13
0ac7c     30 03 90 FD | 	jmp	#LR__1729
0ac80                 | LR__1723
0ac80     34 AA 06 F1 | 	add	local03, #52
0ac84     55 91 02 F6 | 	mov	arg01, local03
0ac88     11 90 06 F1 | 	add	arg01, #17
0ac8c                 | ' {
0ac8c                 | ' 
0ac8c                 | ' 	return *((WORD*)ptr);
0ac8c     48 77 E2 FA | 	rdword	result1, arg01
0ac90     2C AA 86 F1 | 	sub	local03, #44
0ac94     55 77 52 FC | 	wrword	result1, local03
0ac98     3B AD 32 F9 | 	getword	local04, result1, #0
0ac9c     08 AA 86 F1 | 	sub	local03, #8
0aca0     56 91 52 F6 | 	abs	arg01, local04 wc
0aca4     48 91 42 F8 | 	getnib	arg01, arg01, #0
0aca8     48 91 8A F6 | 	negc	arg01, arg01 wz
0acac     0D 76 06 56 |  if_ne	mov	result1, #13
0acb0     FC 02 90 5D |  if_ne	jmp	#LR__1729
0acb4     55 91 02 F6 | 	mov	arg01, local03
0acb8     47 90 06 F1 | 	add	arg01, #71
0acbc                 | ' {
0acbc                 | ' 
0acbc                 | ' 	return *((WORD*)ptr);
0acbc     48 77 E2 FA | 	rdword	result1, arg01
0acc0     3B B3 0A F6 | 	mov	local07, result1 wz
0acc4     55 91 02 A6 |  if_e	mov	arg01, local03
0acc8     54 90 06 A1 |  if_e	add	arg01, #84
0accc                 | ' {
0accc                 | ' 
0accc                 | ' 	return *((DWORD*)ptr);
0accc     48 B3 02 AB |  if_e	rdlong	local07, arg01
0acd0     55 91 02 F6 | 	mov	arg01, local03
0acd4     42 90 06 F1 | 	add	arg01, #66
0acd8                 | ' {
0acd8                 | ' 
0acd8                 | ' 	return *((WORD*)ptr);
0acd8     48 77 E2 FA | 	rdword	result1, arg01
0acdc     3B 91 02 F6 | 	mov	arg01, result1
0ace0     48 AD 02 F6 | 	mov	local04, arg01
0ace4     0F AC 4E F7 | 	zerox	local04, #15 wz
0ace8     0D 76 06 A6 |  if_e	mov	result1, #13
0acec     C0 02 90 AD |  if_e	jmp	#LR__1729
0acf0     48 B5 32 F9 | 	getword	local08, arg01, #0
0acf4     58 B5 02 F1 | 	add	local08, local06
0acf8     08 AA 06 F1 | 	add	local03, #8
0acfc     55 AD E2 FA | 	rdword	local04, local03
0ad00     08 AA 86 F1 | 	sub	local03, #8
0ad04     56 AD 52 F6 | 	abs	local04, local04 wc
0ad08     04 AC 46 F0 | 	shr	local04, #4
0ad0c     56 B5 82 F3 | 	sumc	local08, local04
0ad10     5A B3 12 F2 | 	cmp	local07, local08 wc
0ad14     0D 76 06 C6 |  if_b	mov	result1, #13
0ad18     94 02 90 CD |  if_b	jmp	#LR__1729
0ad1c     5A B3 82 F1 | 	sub	local07, local08
0ad20     0A AA 06 F1 | 	add	local03, #10
0ad24     55 AD E2 FA | 	rdword	local04, local03
0ad28     56 B3 12 FD | 	qdiv	local07, local04
0ad2c     0A AA 86 F1 | 	sub	local03, #10
0ad30     18 AC 62 FD | 	getqx	local04
0ad34     00 AC 0E F2 | 	cmp	local04, #0 wz
0ad38     0D 76 06 A6 |  if_e	mov	result1, #13
0ad3c     70 02 90 AD |  if_e	jmp	#LR__1729
0ad40     00 B6 06 F6 | 	mov	local09, #0
0ad44     FF FF 07 FF 
0ad48     F6 AD 16 F2 | 	cmp	local04, ##268435446 wc
0ad4c     03 B6 06 C6 |  if_b	mov	local09, #3
0ad50     7F 00 00 FF 
0ad54     F6 AD 16 F2 | 	cmp	local04, ##65526 wc
0ad58     02 B6 06 C6 |  if_b	mov	local09, #2
0ad5c     07 00 00 FF 
0ad60     F6 AD 16 F2 | 	cmp	local04, ##4086 wc
0ad64     01 B6 06 C6 |  if_b	mov	local09, #1
0ad68     00 B6 0E F2 | 	cmp	local09, #0 wz
0ad6c     0D 76 06 A6 |  if_e	mov	result1, #13
0ad70     3C 02 90 AD |  if_e	jmp	#LR__1729
0ad74     02 AC 06 F1 | 	add	local04, #2
0ad78     18 AA 06 F1 | 	add	local03, #24
0ad7c     55 AD 62 FC | 	wrlong	local04, local03
0ad80     08 AA 06 F1 | 	add	local03, #8
0ad84     55 AF 62 FC | 	wrlong	local05, local03
0ad88     57 AD 02 F6 | 	mov	local04, local05
0ad8c     48 91 32 F9 | 	getword	arg01, arg01, #0
0ad90     48 AD 02 F1 | 	add	local04, arg01
0ad94     04 AA 06 F1 | 	add	local03, #4
0ad98     55 AD 62 FC | 	wrlong	local04, local03
0ad9c     57 AD 02 F6 | 	mov	local04, local05
0ada0     5A AD 02 F1 | 	add	local04, local08
0ada4     08 AA 06 F1 | 	add	local03, #8
0ada8     55 AD 62 FC | 	wrlong	local04, local03
0adac     2C AA 86 F1 | 	sub	local03, #44
0adb0     03 B6 0E F2 | 	cmp	local09, #3 wz
0adb4     54 00 90 5D |  if_ne	jmp	#LR__1724
0adb8     55 91 02 F6 | 	mov	arg01, local03
0adbc     5E 90 06 F1 | 	add	arg01, #94
0adc0                 | ' {
0adc0                 | ' 
0adc0                 | ' 	return *((WORD*)ptr);
0adc0     48 77 EA FA | 	rdword	result1, arg01 wz
0adc4     0D 76 06 56 |  if_ne	mov	result1, #13
0adc8     E4 01 90 5D |  if_ne	jmp	#LR__1729
0adcc     08 AA 06 F1 | 	add	local03, #8
0add0     55 AD EA FA | 	rdword	local04, local03 wz
0add4     08 AA 86 F1 | 	sub	local03, #8
0add8     0D 76 06 56 |  if_ne	mov	result1, #13
0addc     D0 01 90 5D |  if_ne	jmp	#LR__1729
0ade0     34 AA 06 F1 | 	add	local03, #52
0ade4     55 91 02 F6 | 	mov	arg01, local03
0ade8     2C 90 06 F1 | 	add	arg01, #44
0adec                 | ' {
0adec                 | ' 
0adec                 | ' 	return *((DWORD*)ptr);
0adec     48 77 02 FB | 	rdlong	result1, arg01
0adf0     0C AA 86 F1 | 	sub	local03, #12
0adf4     55 77 62 FC | 	wrlong	result1, local03
0adf8     10 AA 86 F1 | 	sub	local03, #16
0adfc     55 B9 02 FB | 	rdlong	local10, local03
0ae00     18 AA 86 F1 | 	sub	local03, #24
0ae04     02 B8 66 F0 | 	shl	local10, #2
0ae08     6C 00 90 FD | 	jmp	#LR__1726
0ae0c                 | LR__1724
0ae0c     08 AA 06 F1 | 	add	local03, #8
0ae10     55 AD EA FA | 	rdword	local04, local03 wz
0ae14     08 AA 86 F1 | 	sub	local03, #8
0ae18     0D 76 06 A6 |  if_e	mov	result1, #13
0ae1c     90 01 90 AD |  if_e	jmp	#LR__1729
0ae20     24 AA 06 F1 | 	add	local03, #36
0ae24     55 AD 02 FB | 	rdlong	local04, local03
0ae28     58 AD 02 F1 | 	add	local04, local06
0ae2c     04 AA 06 F1 | 	add	local03, #4
0ae30     55 AD 62 FC | 	wrlong	local04, local03
0ae34     28 AA 86 F1 | 	sub	local03, #40
0ae38     02 B6 0E F2 | 	cmp	local09, #2 wz
0ae3c     18 AA 06 A1 |  if_e	add	local03, #24
0ae40     55 AD 02 AB |  if_e	rdlong	local04, local03
0ae44     18 AA 86 A1 |  if_e	sub	local03, #24
0ae48     01 AC 66 A0 |  if_e	shl	local04, #1
0ae4c     24 00 90 AD |  if_e	jmp	#LR__1725
0ae50     18 AA 06 F1 | 	add	local03, #24
0ae54     55 B9 02 FB | 	rdlong	local10, local03
0ae58     5C AD 02 F6 | 	mov	local04, local10
0ae5c     01 AC 66 F0 | 	shl	local04, #1
0ae60     5C AD 02 F1 | 	add	local04, local10
0ae64     01 AC 46 F0 | 	shr	local04, #1
0ae68     18 AA 86 F1 | 	sub	local03, #24
0ae6c     01 B8 06 F5 | 	and	local10, #1
0ae70     5C AD 02 F1 | 	add	local04, local10
0ae74                 | LR__1725
0ae74     56 B9 02 F6 | 	mov	local10, local04
0ae78                 | LR__1726
0ae78     FF B9 06 F1 | 	add	local10, #511
0ae7c     09 B8 46 F0 | 	shr	local10, #9
0ae80     1C AA 06 F1 | 	add	local03, #28
0ae84     55 95 02 FB | 	rdlong	arg03, local03
0ae88     1C AA 86 F1 | 	sub	local03, #28
0ae8c     5C 95 12 F2 | 	cmp	arg03, local10 wc
0ae90     0D 76 06 C6 |  if_b	mov	result1, #13
0ae94     18 01 90 CD |  if_b	jmp	#LR__1729
0ae98     14 AA 06 F1 | 	add	local03, #20
0ae9c     FF FF FF FF 
0aea0     55 FF 6B FC | 	wrlong	##-1, local03
0aea4     04 AA 86 F1 | 	sub	local03, #4
0aea8     FF FF FF FF 
0aeac     55 FF 6B FC | 	wrlong	##-1, local03
0aeb0     0C AA 86 F1 | 	sub	local03, #12
0aeb4     55 01 49 FC | 	wrbyte	#128, local03
0aeb8     04 AA 86 F1 | 	sub	local03, #4
0aebc     03 B6 0E F2 | 	cmp	local09, #3 wz
0aec0     55 91 02 A6 |  if_e	mov	arg01, local03
0aec4     64 90 06 A1 |  if_e	add	arg01, #100
0aec8                 | ' {
0aec8                 | ' 
0aec8                 | ' 	return *((WORD*)ptr);
0aec8     48 77 E2 AA |  if_e	rdword	result1, arg01
0aecc     3B AD 32 A9 |  if_e	getword	local04, result1, #0
0aed0     01 AC 0E A2 |  if_e	cmp	local04, #1 wz
0aed4     A4 00 90 5D |  if_ne	jmp	#LR__1728
0aed8     01 AE 06 F1 | 	add	local05, #1
0aedc     55 91 02 F6 | 	mov	arg01, local03
0aee0     57 93 02 F6 | 	mov	arg02, local05
0aee4     E8 D4 BF FD | 	call	#_fatfs_cc_move_window
0aee8     00 76 0E F2 | 	cmp	result1, #0 wz
0aeec     8C 00 90 5D |  if_ne	jmp	#LR__1728
0aef0     04 AA 06 F1 | 	add	local03, #4
0aef4     55 01 48 FC | 	wrbyte	#0, local03
0aef8     30 AA 06 F1 | 	add	local03, #48
0aefc     55 91 02 F6 | 	mov	arg01, local03
0af00     34 AA 86 F1 | 	sub	local03, #52
0af04     FE 91 06 F1 | 	add	arg01, #510
0af08                 | ' {
0af08                 | ' 
0af08                 | ' 	return *((WORD*)ptr);
0af08     48 77 E2 FA | 	rdword	result1, arg01
0af0c     3B AD 32 F9 | 	getword	local04, result1, #0
0af10     55 00 00 FF 
0af14     55 AC 0E F2 | 	cmp	local04, ##43605 wz
0af18     55 91 02 A6 |  if_e	mov	arg01, local03
0af1c     34 90 06 A1 |  if_e	add	arg01, #52
0af20                 | ' {
0af20                 | ' 
0af20                 | ' 	return *((DWORD*)ptr);
0af20     48 77 02 AB |  if_e	rdlong	result1, arg01
0af24     A9 B0 20 AF 
0af28     52 76 0E A2 |  if_e	cmp	result1, ##1096897106 wz
0af2c     55 91 02 A6 |  if_e	mov	arg01, local03
0af30     01 00 00 AF 
0af34     18 90 06 A1 |  if_e	add	arg01, ##536
0af38                 | ' {
0af38                 | ' 
0af38                 | ' 	return *((DWORD*)ptr);
0af38     48 77 02 AB |  if_e	rdlong	result1, arg01
0af3c     B9 A0 30 AF 
0af40     72 76 0E A2 |  if_e	cmp	result1, ##1631679090 wz
0af44     34 00 90 5D |  if_ne	jmp	#LR__1727
0af48     34 AA 06 F1 | 	add	local03, #52
0af4c     55 91 02 F6 | 	mov	arg01, local03
0af50     E8 91 06 F1 | 	add	arg01, #488
0af54                 | ' {
0af54                 | ' 
0af54                 | ' 	return *((DWORD*)ptr);
0af54     48 77 02 FB | 	rdlong	result1, arg01
0af58     20 AA 86 F1 | 	sub	local03, #32
0af5c     55 77 62 FC | 	wrlong	result1, local03
0af60     20 AA 06 F1 | 	add	local03, #32
0af64     55 91 02 F6 | 	mov	arg01, local03
0af68     EC 91 06 F1 | 	add	arg01, #492
0af6c                 | ' {
0af6c                 | ' 
0af6c                 | ' 	return *((DWORD*)ptr);
0af6c     48 77 02 FB | 	rdlong	result1, arg01
0af70     24 AA 86 F1 | 	sub	local03, #36
0af74     55 77 62 FC | 	wrlong	result1, local03
0af78     10 AA 86 F1 | 	sub	local03, #16
0af7c                 | LR__1727
0af7c                 | LR__1728
0af7c     55 B7 42 FC | 	wrbyte	local09, local03
0af80     04 62 06 F1 | 	add	objptr, #4
0af84     31 AD E2 FA | 	rdword	local04, objptr
0af88     01 AC 06 F1 | 	add	local04, #1
0af8c     31 AD 52 FC | 	wrword	local04, objptr
0af90     56 B9 32 F9 | 	getword	local10, local04, #0
0af94     06 AA 06 F1 | 	add	local03, #6
0af98     55 B9 52 FC | 	wrword	local10, local03
0af9c     04 62 06 F1 | 	add	objptr, #4
0afa0     06 AA 06 F1 | 	add	local03, #6
0afa4     55 63 62 FC | 	wrlong	objptr, local03
0afa8                 | ' 				&& ld_dword(fs->win +  0 ) == 0x41615252
0afa8                 | ' 				&& ld_dword(fs->win +  484 ) == 0x61417272)
0afa8                 | ' 			{
0afa8                 | ' 
0afa8                 | ' 				fs->free_clst = ld_dword(fs->win +  488 );
0afa8                 | ' 
0afa8                 | ' 
0afa8                 | ' 				fs->last_clst = ld_dword(fs->win +  492 );
0afa8                 | ' 
0afa8                 | ' 			}
0afa8                 | ' 		}
0afa8                 | ' 
0afa8                 | ' 
0afa8                 | ' 	}
0afa8                 | ' 
0afa8                 | ' 	fs->fs_type = (BYTE)fmt;
0afa8                 | ' 	fs->id = ++Fsid;
0afa8                 | ' 
0afa8                 | ' 	fs->lfnbuf = LfnBuf;
0afa8                 | ' #line 3567 "ff.c"
0afa8                 | ' 	return FR_OK;
0afa8     00 76 06 F6 | 	mov	result1, #0
0afac     08 62 86 F1 | 	sub	objptr, #8
0afb0                 | LR__1729
0afb0     E7 F0 03 F6 | 	mov	ptra, fp
0afb4     F2 00 A0 FD | 	call	#popregs_
0afb8                 | _fatfs_cc_mount_volume_ret
0afb8     2D 00 64 FD | 	ret
0afbc                 | 
0afbc                 | _fatfs_cc_validate
0afbc     48 7D 0A F6 | 	mov	_var01, arg01 wz
0afc0     09 7E 06 F6 | 	mov	_var02, #9
0afc4     3E 81 0A 5B |  if_ne	rdlong	_var03, _var01 wz
0afc8     40 83 CA 5A |  if_ne	rdbyte	_var04, _var03 wz
0afcc     48 00 90 AD |  if_e	jmp	#LR__1730
0afd0     04 7C 06 F1 | 	add	_var01, #4
0afd4     3E 83 E2 FA | 	rdword	_var04, _var01
0afd8     04 7C 86 F1 | 	sub	_var01, #4
0afdc     3E 91 02 FB | 	rdlong	arg01, _var01
0afe0     06 90 06 F1 | 	add	arg01, #6
0afe4     48 77 E2 FA | 	rdword	result1, arg01
0afe8     3B 83 0A F2 | 	cmp	_var04, result1 wz
0afec     28 00 90 5D |  if_ne	jmp	#LR__1730
0aff0     01 00 00 FF 
0aff4     10 62 06 F1 | 	add	objptr, ##528
0aff8     31 83 0A FB | 	rdlong	_var04, objptr wz
0affc     01 00 00 FF 
0b000     10 62 86 F1 | 	sub	objptr, ##528
0b004                 | '         return RES_NOTRDY;
0b004     03 76 06 A6 |  if_e	mov	result1, #3
0b008                 | '     }
0b008                 | '     return RES_OK;
0b008     00 76 06 56 |  if_ne	mov	result1, #0
0b00c     3B 81 E2 F8 | 	getbyte	_var03, result1, #0
0b010     01 80 CE F7 | 	test	_var03, #1 wz
0b014     00 7E 06 A6 |  if_e	mov	_var02, #0
0b018                 | LR__1730
0b018     00 7E 0E F2 | 	cmp	_var02, #0 wz
0b01c     3E 81 02 AB |  if_e	rdlong	_var03, _var01
0b020     00 80 06 56 |  if_ne	mov	_var03, #0
0b024     49 81 62 FC | 	wrlong	_var03, arg02
0b028                 | ' 			res = FR_OK;
0b028                 | ' 		}
0b028                 | ' 
0b028                 | ' 	}
0b028                 | ' 	*rfs = (res == FR_OK) ? obj->fs : 0;
0b028                 | ' 	return res;
0b028     3F 77 02 F6 | 	mov	result1, _var02
0b02c                 | _fatfs_cc_validate_ret
0b02c     2D 00 64 FD | 	ret
0b030                 | 
0b030                 | _fatfs_cc_f_mount
0b030     04 CA 05 F6 | 	mov	COUNT_, #4
0b034     E8 00 A0 FD | 	call	#pushregs_
0b038     20 F0 07 F1 | 	add	ptra, #32
0b03c     04 CE 05 F1 | 	add	fp, #4
0b040     E7 90 62 FC | 	wrlong	arg01, fp
0b044     04 CE 05 F1 | 	add	fp, #4
0b048     E7 92 62 FC | 	wrlong	arg02, fp
0b04c     4A A7 02 F6 | 	mov	local01, arg03
0b050     14 CE 05 F1 | 	add	fp, #20
0b054     E7 92 62 FC | 	wrlong	arg02, fp
0b058     E7 90 02 F6 | 	mov	arg01, fp
0b05c     1C CE 85 F1 | 	sub	fp, #28
0b060     EC F6 BF FD | 	call	#_fatfs_cc_get_ldnumber
0b064     3B A9 02 F6 | 	mov	local02, result1
0b068     00 A8 56 F2 | 	cmps	local02, #0 wc
0b06c     0B 76 06 C6 |  if_b	mov	result1, #11
0b070     84 00 90 CD |  if_b	jmp	#LR__1741
0b074     54 95 02 F6 | 	mov	arg03, local02
0b078     02 94 66 F0 | 	shl	arg03, #2
0b07c     31 95 02 F1 | 	add	arg03, objptr
0b080     4A AB 0A FB | 	rdlong	local03, arg03 wz
0b084     14 00 90 AD |  if_e	jmp	#LR__1740
0b088     01 AA 06 F1 | 	add	local03, #1
0b08c     55 91 C2 FA | 	rdbyte	arg01, local03
0b090     01 AA 86 F1 | 	sub	local03, #1
0b094     E0 2B B0 FD | 	call	#_fatfs_cc_disk_deinitialize
0b098     55 01 48 FC | 	wrbyte	#0, local03
0b09c                 | LR__1740
0b09c     04 CE 05 F1 | 	add	fp, #4
0b0a0     E7 AC 0A FB | 	rdlong	local04, fp wz
0b0a4     04 CE 85 F1 | 	sub	fp, #4
0b0a8     04 CE 05 51 |  if_ne	add	fp, #4
0b0ac     E7 AC 02 5B |  if_ne	rdlong	local04, fp
0b0b0     04 CE 85 51 |  if_ne	sub	fp, #4
0b0b4     56 01 48 5C |  if_ne	wrbyte	#0, local04
0b0b8     02 A8 66 F0 | 	shl	local02, #2
0b0bc     31 A9 02 F1 | 	add	local02, objptr
0b0c0     04 CE 05 F1 | 	add	fp, #4
0b0c4     E7 AC 02 FB | 	rdlong	local04, fp
0b0c8     04 CE 85 F1 | 	sub	fp, #4
0b0cc     54 AD 62 FC | 	wrlong	local04, local02
0b0d0     07 A6 4E F7 | 	zerox	local01, #7 wz
0b0d4     00 76 06 A6 |  if_e	mov	result1, #0
0b0d8     1C 00 90 AD |  if_e	jmp	#LR__1741
0b0dc     08 CE 05 F1 | 	add	fp, #8
0b0e0     E7 90 02 F6 | 	mov	arg01, fp
0b0e4     04 CE 85 F1 | 	sub	fp, #4
0b0e8     E7 92 02 F6 | 	mov	arg02, fp
0b0ec     04 CE 85 F1 | 	sub	fp, #4
0b0f0     00 94 06 F6 | 	mov	arg03, #0
0b0f4     94 F9 BF FD | 	call	#_fatfs_cc_mount_volume
0b0f8                 | ' 
0b0f8                 | ' 	res = mount_volume(&path, &fs, 0);
0b0f8                 | ' 	return res ;
0b0f8                 | LR__1741
0b0f8     E7 F0 03 F6 | 	mov	ptra, fp
0b0fc     F2 00 A0 FD | 	call	#popregs_
0b100                 | _fatfs_cc_f_mount_ret
0b100     2D 00 64 FD | 	ret
0b104                 | 
0b104                 | _fatfs_cc_f_open
0b104     08 CA 05 F6 | 	mov	COUNT_, #8
0b108     E8 00 A0 FD | 	call	#pushregs_
0b10c     60 F0 07 F1 | 	add	ptra, #96
0b110     48 A7 0A F6 | 	mov	local01, arg01 wz
0b114     08 CE 05 F1 | 	add	fp, #8
0b118     E7 92 62 FC | 	wrlong	arg02, fp
0b11c     08 CE 85 F1 | 	sub	fp, #8
0b120     4A A9 02 F6 | 	mov	local02, arg03
0b124     09 76 06 A6 |  if_e	mov	result1, #9
0b128     24 04 90 AD |  if_e	jmp	#LR__1767
0b12c     54 A9 E2 F8 | 	getbyte	local02, local02, #0
0b130     3F A8 06 F5 | 	and	local02, #63
0b134     08 CE 05 F1 | 	add	fp, #8
0b138     E7 90 02 F6 | 	mov	arg01, fp
0b13c     3C CE 05 F1 | 	add	fp, #60
0b140     E7 92 02 F6 | 	mov	arg02, fp
0b144     44 CE 85 F1 | 	sub	fp, #68
0b148     54 95 02 F6 | 	mov	arg03, local02
0b14c     3C F9 BF FD | 	call	#_fatfs_cc_mount_volume
0b150     3B AB 0A F6 | 	mov	local03, result1 wz
0b154     EC 03 90 5D |  if_ne	jmp	#LR__1766
0b158     44 CE 05 F1 | 	add	fp, #68
0b15c     E7 AA 02 FB | 	rdlong	local03, fp
0b160     30 CE 85 F1 | 	sub	fp, #48
0b164     E7 AA 62 FC | 	wrlong	local03, fp
0b168     E7 90 02 F6 | 	mov	arg01, fp
0b16c     0C CE 85 F1 | 	sub	fp, #12
0b170     E7 AC 02 FB | 	rdlong	local04, fp
0b174     08 CE 85 F1 | 	sub	fp, #8
0b178     56 93 02 F6 | 	mov	arg02, local04
0b17c     70 F4 BF FD | 	call	#_fatfs_cc_follow_path
0b180     3B AB 0A F6 | 	mov	local03, result1 wz
0b184     18 00 90 5D |  if_ne	jmp	#LR__1750
0b188     3F CE 05 F1 | 	add	fp, #63
0b18c     E7 AC C2 FA | 	rdbyte	local04, fp
0b190     3F CE 85 F1 | 	sub	fp, #63
0b194     56 97 E2 F8 | 	getbyte	arg04, local04, #0
0b198     80 96 CE F7 | 	test	arg04, #128 wz
0b19c     06 AA 06 56 |  if_ne	mov	local03, #6
0b1a0                 | LR__1750
0b1a0     54 97 E2 F8 | 	getbyte	arg04, local02, #0
0b1a4     1C 96 CE F7 | 	test	arg04, #28 wz
0b1a8     5C 01 90 AD |  if_e	jmp	#LR__1755
0b1ac     00 AA 0E F2 | 	cmp	local03, #0 wz
0b1b0     24 00 90 AD |  if_e	jmp	#LR__1752
0b1b4     04 AA 0E F2 | 	cmp	local03, #4 wz
0b1b8     10 00 90 5D |  if_ne	jmp	#LR__1751
0b1bc     E7 90 02 F6 | 	mov	arg01, fp
0b1c0     14 90 06 F1 | 	add	arg01, #20
0b1c4     4C E8 BF FD | 	call	#_fatfs_cc_dir_register
0b1c8     3B AB 02 F6 | 	mov	local03, result1
0b1cc                 | LR__1751
0b1cc     54 A9 E2 F8 | 	getbyte	local02, local02, #0
0b1d0     08 A8 46 F5 | 	or	local02, #8
0b1d4     24 00 90 FD | 	jmp	#LR__1754
0b1d8                 | LR__1752
0b1d8     1A CE 05 F1 | 	add	fp, #26
0b1dc     E7 AC C2 FA | 	rdbyte	local04, fp
0b1e0     1A CE 85 F1 | 	sub	fp, #26
0b1e4     11 AC CE F7 | 	test	local04, #17 wz
0b1e8     07 AA 06 56 |  if_ne	mov	local03, #7
0b1ec     0C 00 90 5D |  if_ne	jmp	#LR__1753
0b1f0     54 AD E2 F8 | 	getbyte	local04, local02, #0
0b1f4     04 AC CE F7 | 	test	local04, #4 wz
0b1f8     08 AA 06 56 |  if_ne	mov	local03, #8
0b1fc                 | LR__1753
0b1fc                 | LR__1754
0b1fc     00 AA 0E F2 | 	cmp	local03, #0 wz
0b200     40 01 90 5D |  if_ne	jmp	#LR__1758
0b204     54 AD E2 F8 | 	getbyte	local04, local02, #0
0b208     08 AC CE F7 | 	test	local04, #8 wz
0b20c     34 01 90 AD |  if_e	jmp	#LR__1758
0b210     C0 1B B0 FD | 	call	#_fatfs_cc__get_fattime
0b214     30 CE 05 F1 | 	add	fp, #48
0b218     E7 90 02 FB | 	rdlong	arg01, fp
0b21c     0E 90 06 F1 | 	add	arg01, #14
0b220     48 77 62 FC | 	wrlong	result1, arg01
0b224     E7 90 02 FB | 	rdlong	arg01, fp
0b228     16 90 06 F1 | 	add	arg01, #22
0b22c     48 77 62 FC | 	wrlong	result1, arg01
0b230     14 CE 05 F1 | 	add	fp, #20
0b234     E7 90 02 FB | 	rdlong	arg01, fp
0b238     14 CE 85 F1 | 	sub	fp, #20
0b23c     E7 92 02 FB | 	rdlong	arg02, fp
0b240     30 CE 85 F1 | 	sub	fp, #48
0b244     C0 DE BF FD | 	call	#_fatfs_cc_ld_clust
0b248     3B AD 02 F6 | 	mov	local04, result1
0b24c     30 CE 05 F1 | 	add	fp, #48
0b250     E7 96 02 FB | 	rdlong	arg04, fp
0b254     0B 96 06 F1 | 	add	arg04, #11
0b258     4B 41 48 FC | 	wrbyte	#32, arg04
0b25c     14 CE 05 F1 | 	add	fp, #20
0b260     E7 90 02 FB | 	rdlong	arg01, fp
0b264     14 CE 85 F1 | 	sub	fp, #20
0b268     E7 92 02 FB | 	rdlong	arg02, fp
0b26c     30 CE 85 F1 | 	sub	fp, #48
0b270     00 94 06 F6 | 	mov	arg03, #0
0b274     C4 DE BF FD | 	call	#_fatfs_cc_st_clust
0b278     30 CE 05 F1 | 	add	fp, #48
0b27c     E7 90 02 FB | 	rdlong	arg01, fp
0b280     1C 90 06 F1 | 	add	arg01, #28
0b284     48 01 68 FC | 	wrlong	#0, arg01
0b288     14 CE 05 F1 | 	add	fp, #20
0b28c     E7 96 02 FB | 	rdlong	arg04, fp
0b290     44 CE 85 F1 | 	sub	fp, #68
0b294     03 96 06 F1 | 	add	arg04, #3
0b298     4B 03 48 FC | 	wrbyte	#1, arg04
0b29c     00 AC 0E F2 | 	cmp	local04, #0 wz
0b2a0     A0 00 90 AD |  if_e	jmp	#LR__1758
0b2a4     44 CE 05 F1 | 	add	fp, #68
0b2a8     E7 AA 02 FB | 	rdlong	local03, fp
0b2ac     30 AA 06 F1 | 	add	local03, #48
0b2b0     55 AF 02 FB | 	rdlong	local05, local03
0b2b4     30 CE 85 F1 | 	sub	fp, #48
0b2b8     E7 90 02 F6 | 	mov	arg01, fp
0b2bc     14 CE 85 F1 | 	sub	fp, #20
0b2c0     56 93 02 F6 | 	mov	arg02, local04
0b2c4     00 94 06 F6 | 	mov	arg03, #0
0b2c8     70 D6 BF FD | 	call	#_fatfs_cc_remove_chain
0b2cc     3B AB 0A F6 | 	mov	local03, result1 wz
0b2d0     70 00 90 5D |  if_ne	jmp	#LR__1758
0b2d4     44 CE 05 F1 | 	add	fp, #68
0b2d8     E7 90 02 FB | 	rdlong	arg01, fp
0b2dc     44 CE 85 F1 | 	sub	fp, #68
0b2e0     57 93 02 F6 | 	mov	arg02, local05
0b2e4     E8 D0 BF FD | 	call	#_fatfs_cc_move_window
0b2e8     3B AB 02 F6 | 	mov	local03, result1
0b2ec     44 CE 05 F1 | 	add	fp, #68
0b2f0     E7 AE 02 FB | 	rdlong	local05, fp
0b2f4     44 CE 85 F1 | 	sub	fp, #68
0b2f8     01 AC 86 F1 | 	sub	local04, #1
0b2fc     10 AE 06 F1 | 	add	local05, #16
0b300     57 AD 62 FC | 	wrlong	local04, local05
0b304     3C 00 90 FD | 	jmp	#LR__1758
0b308                 | LR__1755
0b308     00 AA 0E F2 | 	cmp	local03, #0 wz
0b30c     34 00 90 5D |  if_ne	jmp	#LR__1757
0b310     1A CE 05 F1 | 	add	fp, #26
0b314     E7 AE C2 FA | 	rdbyte	local05, fp
0b318     1A CE 85 F1 | 	sub	fp, #26
0b31c     10 AE CE F7 | 	test	local05, #16 wz
0b320     04 AA 06 56 |  if_ne	mov	local03, #4
0b324     1C 00 90 5D |  if_ne	jmp	#LR__1756
0b328     54 AF E2 F8 | 	getbyte	local05, local02, #0
0b32c     02 AE CE F7 | 	test	local05, #2 wz
0b330     1A CE 05 51 |  if_ne	add	fp, #26
0b334     E7 AC C2 5A |  if_ne	rdbyte	local04, fp
0b338     1A CE 85 51 |  if_ne	sub	fp, #26
0b33c     01 AC CE 57 |  if_ne	test	local04, #1 wz
0b340     07 AA 06 56 |  if_ne	mov	local03, #7
0b344                 | LR__1756
0b344                 | LR__1757
0b344                 | LR__1758
0b344     00 AA 0E F2 | 	cmp	local03, #0 wz
0b348     40 00 90 5D |  if_ne	jmp	#LR__1759
0b34c     54 AF E2 F8 | 	getbyte	local05, local02, #0
0b350     08 AE CE F7 | 	test	local05, #8 wz
0b354     54 A9 E2 58 |  if_ne	getbyte	local02, local02, #0
0b358     40 A8 46 55 |  if_ne	or	local02, #64
0b35c     44 CE 05 F1 | 	add	fp, #68
0b360     E7 AE 02 FB | 	rdlong	local05, fp
0b364     30 AE 06 F1 | 	add	local05, #48
0b368     57 AF 02 FB | 	rdlong	local05, local05
0b36c     20 A6 06 F1 | 	add	local01, #32
0b370     53 AF 62 FC | 	wrlong	local05, local01
0b374     14 CE 85 F1 | 	sub	fp, #20
0b378     E7 AE 02 FB | 	rdlong	local05, fp
0b37c     30 CE 85 F1 | 	sub	fp, #48
0b380     04 A6 06 F1 | 	add	local01, #4
0b384     53 AF 62 FC | 	wrlong	local05, local01
0b388     24 A6 86 F1 | 	sub	local01, #36
0b38c                 | LR__1759
0b38c     00 AA 0E F2 | 	cmp	local03, #0 wz
0b390     B0 01 90 5D |  if_ne	jmp	#LR__1765
0b394     44 CE 05 F1 | 	add	fp, #68
0b398     E7 90 02 FB | 	rdlong	arg01, fp
0b39c     14 CE 85 F1 | 	sub	fp, #20
0b3a0     E7 92 02 FB | 	rdlong	arg02, fp
0b3a4     30 CE 85 F1 | 	sub	fp, #48
0b3a8     5C DD BF FD | 	call	#_fatfs_cc_ld_clust
0b3ac     08 A6 06 F1 | 	add	local01, #8
0b3b0     53 77 62 FC | 	wrlong	result1, local01
0b3b4     30 CE 05 F1 | 	add	fp, #48
0b3b8     E7 90 02 FB | 	rdlong	arg01, fp
0b3bc     1C 90 06 F1 | 	add	arg01, #28
0b3c0                 | ' {
0b3c0                 | ' 
0b3c0                 | ' 	return *((DWORD*)ptr);
0b3c0     48 77 02 FB | 	rdlong	result1, arg01
0b3c4     04 A6 06 F1 | 	add	local01, #4
0b3c8     53 77 62 FC | 	wrlong	result1, local01
0b3cc     0C A6 86 F1 | 	sub	local01, #12
0b3d0     14 CE 05 F1 | 	add	fp, #20
0b3d4     E7 AE 02 FB | 	rdlong	local05, fp
0b3d8     53 AF 62 FC | 	wrlong	local05, local01
0b3dc     E7 AE 02 FB | 	rdlong	local05, fp
0b3e0     44 CE 85 F1 | 	sub	fp, #68
0b3e4     06 AE 06 F1 | 	add	local05, #6
0b3e8     57 AD E2 FA | 	rdword	local04, local05
0b3ec     04 A6 06 F1 | 	add	local01, #4
0b3f0     53 AD 52 FC | 	wrword	local04, local01
0b3f4     0C A6 06 F1 | 	add	local01, #12
0b3f8     53 A9 42 FC | 	wrbyte	local02, local01
0b3fc     01 A6 06 F1 | 	add	local01, #1
0b400     53 01 48 FC | 	wrbyte	#0, local01
0b404     0B A6 06 F1 | 	add	local01, #11
0b408     53 01 68 FC | 	wrlong	#0, local01
0b40c     08 A6 86 F1 | 	sub	local01, #8
0b410     53 01 68 FC | 	wrlong	#0, local01
0b414     14 A6 06 F1 | 	add	local01, #20
0b418     53 91 02 F6 | 	mov	arg01, local01
0b41c     28 A6 86 F1 | 	sub	local01, #40
0b420     00 92 06 F6 | 	mov	arg02, #0
0b424     09 94 C6 F9 | 	decod	arg03, #9
0b428     D8 00 A0 FD | 	call	#\builtin_bytefill_
0b42c     54 A9 E2 F8 | 	getbyte	local02, local02, #0
0b430     20 A8 CE F7 | 	test	local02, #32 wz
0b434     0C 01 90 AD |  if_e	jmp	#LR__1764
0b438     0C A6 06 F1 | 	add	local01, #12
0b43c     53 AD 02 FB | 	rdlong	local04, local01
0b440     0C A6 86 F1 | 	sub	local01, #12
0b444     01 AC 16 F2 | 	cmp	local04, #1 wc
0b448     F8 00 90 CD |  if_b	jmp	#LR__1764
0b44c     0C A6 06 F1 | 	add	local01, #12
0b450     53 AD 02 FB | 	rdlong	local04, local01
0b454     08 A6 06 F1 | 	add	local01, #8
0b458     53 AD 62 FC | 	wrlong	local04, local01
0b45c     44 CE 05 F1 | 	add	fp, #68
0b460     E7 AC 02 FB | 	rdlong	local04, fp
0b464     44 CE 85 F1 | 	sub	fp, #68
0b468     0A AC 06 F1 | 	add	local04, #10
0b46c     56 B1 E2 FA | 	rdword	local06, local04
0b470     09 B0 66 F0 | 	shl	local06, #9
0b474     0C A6 86 F1 | 	sub	local01, #12
0b478     53 B3 02 FB | 	rdlong	local07, local01
0b47c                 | ' 				fp->fptr = fp->obj.objsize;
0b47c                 | ' 				bcs = (DWORD)fs->csize *  ((UINT) 512 ) ;
0b47c                 | ' 				clst = fp->obj.sclust;
0b47c                 | ' 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
0b47c     04 A6 06 F1 | 	add	local01, #4
0b480     53 B5 02 FB | 	rdlong	local08, local01
0b484     0C A6 86 F1 | 	sub	local01, #12
0b488                 | LR__1760
0b488     00 AA 0E F2 | 	cmp	local03, #0 wz
0b48c     34 00 90 5D |  if_ne	jmp	#LR__1761
0b490     58 B5 1A F2 | 	cmp	local08, local06 wcz
0b494     2C 00 90 ED |  if_be	jmp	#LR__1761
0b498     53 91 02 F6 | 	mov	arg01, local01
0b49c     59 93 02 F6 | 	mov	arg02, local07
0b4a0     E4 D0 BF FD | 	call	#_fatfs_cc_get_fat
0b4a4     3B B3 02 F6 | 	mov	local07, result1
0b4a8     02 B2 16 F2 | 	cmp	local07, #2 wc
0b4ac     02 AA 06 C6 |  if_b	mov	local03, #2
0b4b0     FF FF 7F FF 
0b4b4     FF B3 0E F2 | 	cmp	local07, ##-1 wz
0b4b8     01 AA 06 A6 |  if_e	mov	local03, #1
0b4bc     58 B5 82 F1 | 	sub	local08, local06
0b4c0     C4 FF 9F FD | 	jmp	#LR__1760
0b4c4                 | LR__1761
0b4c4     18 A6 06 F1 | 	add	local01, #24
0b4c8     53 B3 62 FC | 	wrlong	local07, local01
0b4cc     18 A6 86 F1 | 	sub	local01, #24
0b4d0     00 AA 0E F2 | 	cmp	local03, #0 wz
0b4d4     6C 00 90 5D |  if_ne	jmp	#LR__1763
0b4d8     FF B5 CE F7 | 	test	local08, #511 wz
0b4dc     64 00 90 AD |  if_e	jmp	#LR__1763
0b4e0     44 CE 05 F1 | 	add	fp, #68
0b4e4     E7 90 02 FB | 	rdlong	arg01, fp
0b4e8     44 CE 85 F1 | 	sub	fp, #68
0b4ec     59 93 02 F6 | 	mov	arg02, local07
0b4f0     54 D0 BF FD | 	call	#_fatfs_cc_clst2sect
0b4f4     3B AF 0A F6 | 	mov	local05, result1 wz
0b4f8     02 AA 06 A6 |  if_e	mov	local03, #2
0b4fc     44 00 90 AD |  if_e	jmp	#LR__1762
0b500     09 B4 46 F0 | 	shr	local08, #9
0b504     5A AF 02 F1 | 	add	local05, local08
0b508     1C A6 06 F1 | 	add	local01, #28
0b50c     53 AF 62 FC | 	wrlong	local05, local01
0b510     44 CE 05 F1 | 	add	fp, #68
0b514     E7 AC 02 FB | 	rdlong	local04, fp
0b518     44 CE 85 F1 | 	sub	fp, #68
0b51c     01 AC 06 F1 | 	add	local04, #1
0b520     56 91 C2 FA | 	rdbyte	arg01, local04
0b524     53 93 02 F6 | 	mov	arg02, local01
0b528     0C 92 06 F1 | 	add	arg02, #12
0b52c     57 95 02 F6 | 	mov	arg03, local05
0b530     1C A6 86 F1 | 	sub	local01, #28
0b534     01 96 06 F6 | 	mov	arg04, #1
0b538     0C C8 BF FD | 	call	#_fatfs_cc_disk_read
0b53c     00 76 0E F2 | 	cmp	result1, #0 wz
0b540     01 AA 06 56 |  if_ne	mov	local03, #1
0b544                 | LR__1762
0b544                 | LR__1763
0b544                 | LR__1764
0b544                 | LR__1765
0b544                 | LR__1766
0b544     00 AA 0E F2 | 	cmp	local03, #0 wz
0b548     53 01 68 5C |  if_ne	wrlong	#0, local01
0b54c                 | ' 
0b54c                 | ' 	return res ;
0b54c     55 77 02 F6 | 	mov	result1, local03
0b550                 | LR__1767
0b550     E7 F0 03 F6 | 	mov	ptra, fp
0b554     F2 00 A0 FD | 	call	#popregs_
0b558                 | _fatfs_cc_f_open_ret
0b558     2D 00 64 FD | 	ret
0b55c                 | 
0b55c                 | _fatfs_cc_f_read
0b55c     0E CA 05 F6 | 	mov	COUNT_, #14
0b560     E8 00 A0 FD | 	call	#pushregs_
0b564     38 F0 07 F1 | 	add	ptra, #56
0b568     48 A7 02 F6 | 	mov	local01, arg01
0b56c     49 A9 02 F6 | 	mov	local02, arg02
0b570     4A AB 02 F6 | 	mov	local03, arg03
0b574     4B AD 02 F6 | 	mov	local04, arg04
0b578     54 AF 02 F6 | 	mov	local05, local02
0b57c     56 01 68 FC | 	wrlong	#0, local04
0b580     E7 92 02 F6 | 	mov	arg02, fp
0b584     18 92 06 F1 | 	add	arg02, #24
0b588     53 91 02 F6 | 	mov	arg01, local01
0b58c     2C FA BF FD | 	call	#_fatfs_cc_validate
0b590     3B B1 0A F6 | 	mov	local06, result1 wz
0b594     11 A6 06 A1 |  if_e	add	local01, #17
0b598     53 B1 C2 AA |  if_e	rdbyte	local06, local01
0b59c     11 A6 86 A1 |  if_e	sub	local01, #17
0b5a0     00 B0 4E A2 |  if_e	cmps	local06, #0 wz
0b5a4     58 77 02 56 |  if_ne	mov	result1, local06
0b5a8     3C 03 90 5D |  if_ne	jmp	#LR__1781
0b5ac     10 A6 06 F1 | 	add	local01, #16
0b5b0     53 B3 C2 FA | 	rdbyte	local07, local01
0b5b4     10 A6 86 F1 | 	sub	local01, #16
0b5b8     01 B2 CE F7 | 	test	local07, #1 wz
0b5bc     07 76 06 A6 |  if_e	mov	result1, #7
0b5c0     24 03 90 AD |  if_e	jmp	#LR__1781
0b5c4     0C A6 06 F1 | 	add	local01, #12
0b5c8     53 B5 02 FB | 	rdlong	local08, local01
0b5cc     08 A6 06 F1 | 	add	local01, #8
0b5d0     53 B7 02 FB | 	rdlong	local09, local01
0b5d4     14 A6 86 F1 | 	sub	local01, #20
0b5d8     5B B5 82 F1 | 	sub	local08, local09
0b5dc     5A AB 3A F3 | 	fle	local03, local08 wcz
0b5e0                 | ' 
0b5e0                 | ' 	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
0b5e0                 | LR__1770
0b5e0     01 AA 16 F2 | 	cmp	local03, #1 wc
0b5e4     FC 02 90 CD |  if_b	jmp	#LR__1780
0b5e8     14 A6 06 F1 | 	add	local01, #20
0b5ec     53 B3 02 FB | 	rdlong	local07, local01
0b5f0     14 A6 86 F1 | 	sub	local01, #20
0b5f4     FF B3 CE F7 | 	test	local07, #511 wz
0b5f8     80 02 90 5D |  if_ne	jmp	#LR__1778
0b5fc     14 A6 06 F1 | 	add	local01, #20
0b600     53 B9 02 FB | 	rdlong	local10, local01
0b604     14 A6 86 F1 | 	sub	local01, #20
0b608     09 B8 46 F0 | 	shr	local10, #9
0b60c     18 CE 05 F1 | 	add	fp, #24
0b610     E7 B2 02 FB | 	rdlong	local07, fp
0b614     18 CE 85 F1 | 	sub	fp, #24
0b618     0A B2 06 F1 | 	add	local07, #10
0b61c     59 B3 E2 FA | 	rdword	local07, local07
0b620     01 B2 86 F1 | 	sub	local07, #1
0b624     59 B9 0A F5 | 	and	local10, local07 wz
0b628     6C 00 90 5D |  if_ne	jmp	#LR__1772
0b62c     14 A6 06 F1 | 	add	local01, #20
0b630     53 B3 0A FB | 	rdlong	local07, local01 wz
0b634     14 A6 86 F1 | 	sub	local01, #20
0b638     08 A6 06 A1 |  if_e	add	local01, #8
0b63c     53 BB 02 AB |  if_e	rdlong	local11, local01
0b640     08 A6 86 A1 |  if_e	sub	local01, #8
0b644     18 00 90 AD |  if_e	jmp	#LR__1771
0b648     53 91 02 F6 | 	mov	arg01, local01
0b64c     18 A6 06 F1 | 	add	local01, #24
0b650     53 93 02 FB | 	rdlong	arg02, local01
0b654     18 A6 86 F1 | 	sub	local01, #24
0b658     2C CF BF FD | 	call	#_fatfs_cc_get_fat
0b65c     3B BB 02 F6 | 	mov	local11, result1
0b660                 | LR__1771
0b660     02 BA 16 F2 | 	cmp	local11, #2 wc
0b664     11 A6 06 C1 |  if_b	add	local01, #17
0b668     53 05 48 CC |  if_b	wrbyte	#2, local01
0b66c     02 76 06 C6 |  if_b	mov	result1, #2
0b670     74 02 90 CD |  if_b	jmp	#LR__1781
0b674     FF FF 7F FF 
0b678     FF BB 0E F2 | 	cmp	local11, ##-1 wz
0b67c     11 A6 06 A1 |  if_e	add	local01, #17
0b680     53 03 48 AC |  if_e	wrbyte	#1, local01
0b684     01 76 06 A6 |  if_e	mov	result1, #1
0b688     5C 02 90 AD |  if_e	jmp	#LR__1781
0b68c     18 A6 06 F1 | 	add	local01, #24
0b690     53 BB 62 FC | 	wrlong	local11, local01
0b694     18 A6 86 F1 | 	sub	local01, #24
0b698                 | LR__1772
0b698     18 CE 05 F1 | 	add	fp, #24
0b69c     E7 90 02 FB | 	rdlong	arg01, fp
0b6a0     18 CE 85 F1 | 	sub	fp, #24
0b6a4     18 A6 06 F1 | 	add	local01, #24
0b6a8     53 93 02 FB | 	rdlong	arg02, local01
0b6ac     18 A6 86 F1 | 	sub	local01, #24
0b6b0     94 CE BF FD | 	call	#_fatfs_cc_clst2sect
0b6b4     3B BD 0A F6 | 	mov	local12, result1 wz
0b6b8     11 A6 06 A1 |  if_e	add	local01, #17
0b6bc     53 05 48 AC |  if_e	wrbyte	#2, local01
0b6c0     02 76 06 A6 |  if_e	mov	result1, #2
0b6c4     20 02 90 AD |  if_e	jmp	#LR__1781
0b6c8     5C BD 02 F1 | 	add	local12, local10
0b6cc     55 BF 02 F6 | 	mov	local13, local03
0b6d0     09 BE 46 F0 | 	shr	local13, #9
0b6d4     01 BE 16 F2 | 	cmp	local13, #1 wc
0b6d8     D8 00 90 CD |  if_b	jmp	#LR__1775
0b6dc     5C B3 02 F6 | 	mov	local07, local10
0b6e0     5F B3 02 F1 | 	add	local07, local13
0b6e4     18 CE 05 F1 | 	add	fp, #24
0b6e8     E7 B6 02 FB | 	rdlong	local09, fp
0b6ec     18 CE 85 F1 | 	sub	fp, #24
0b6f0     0A B6 06 F1 | 	add	local09, #10
0b6f4     5B 77 E2 FA | 	rdword	result1, local09
0b6f8     3B B3 1A F2 | 	cmp	local07, result1 wcz
0b6fc     18 00 90 ED |  if_be	jmp	#LR__1773
0b700     18 CE 05 F1 | 	add	fp, #24
0b704     E7 BE 02 FB | 	rdlong	local13, fp
0b708     18 CE 85 F1 | 	sub	fp, #24
0b70c     0A BE 06 F1 | 	add	local13, #10
0b710     5F BF E2 FA | 	rdword	local13, local13
0b714     5C BF 82 F1 | 	sub	local13, local10
0b718                 | LR__1773
0b718     18 CE 05 F1 | 	add	fp, #24
0b71c     E7 B2 02 FB | 	rdlong	local07, fp
0b720     18 CE 85 F1 | 	sub	fp, #24
0b724     01 B2 06 F1 | 	add	local07, #1
0b728     59 91 C2 FA | 	rdbyte	arg01, local07
0b72c     57 93 02 F6 | 	mov	arg02, local05
0b730     5F 97 02 F6 | 	mov	arg04, local13
0b734     5E 95 02 F6 | 	mov	arg03, local12
0b738     0C C6 BF FD | 	call	#_fatfs_cc_disk_read
0b73c     00 76 0E F2 | 	cmp	result1, #0 wz
0b740     11 A6 06 51 |  if_ne	add	local01, #17
0b744     53 03 48 5C |  if_ne	wrbyte	#1, local01
0b748     01 76 06 56 |  if_ne	mov	result1, #1
0b74c     98 01 90 5D |  if_ne	jmp	#LR__1781
0b750     10 A6 06 F1 | 	add	local01, #16
0b754     53 B3 C2 FA | 	rdbyte	local07, local01
0b758     10 A6 86 F1 | 	sub	local01, #16
0b75c     80 B2 CE F7 | 	test	local07, #128 wz
0b760     44 00 90 AD |  if_e	jmp	#LR__1774
0b764     1C A6 06 F1 | 	add	local01, #28
0b768     53 B7 02 FB | 	rdlong	local09, local01
0b76c     1C A6 86 F1 | 	sub	local01, #28
0b770     5E B7 82 F1 | 	sub	local09, local12
0b774     5F B7 12 F2 | 	cmp	local09, local13 wc
0b778     2C 00 90 3D |  if_ae	jmp	#LR__1774
0b77c     57 91 02 F6 | 	mov	arg01, local05
0b780     1C A6 06 F1 | 	add	local01, #28
0b784     53 B9 02 FB | 	rdlong	local10, local01
0b788     5E B9 82 F1 | 	sub	local10, local12
0b78c     09 B8 66 F0 | 	shl	local10, #9
0b790     5C 91 02 F1 | 	add	arg01, local10
0b794     0C A6 06 F1 | 	add	local01, #12
0b798     53 93 02 F6 | 	mov	arg02, local01
0b79c     28 A6 86 F1 | 	sub	local01, #40
0b7a0     09 94 C6 F9 | 	decod	arg03, #9
0b7a4     30 75 BF FD | 	call	#__system____builtin_memmove
0b7a8                 | LR__1774
0b7a8     09 BE 66 F0 | 	shl	local13, #9
0b7ac     5F C1 02 F6 | 	mov	local14, local13
0b7b0                 | ' 					__builtin_memcpy(rbuff + ((fp->sect - sect) * ((UINT) 512 ) ), fp->buf, ((UINT) 512 ) ) ;
0b7b0                 | ' 				}
0b7b0                 | ' 
0b7b0                 | ' 
0b7b0                 | ' 				rcnt =  ((UINT) 512 )  * cc;
0b7b0                 | ' 				continue;
0b7b0     04 01 90 FD | 	jmp	#LR__1779
0b7b4                 | LR__1775
0b7b4     1C A6 06 F1 | 	add	local01, #28
0b7b8     53 B3 02 FB | 	rdlong	local07, local01
0b7bc     1C A6 86 F1 | 	sub	local01, #28
0b7c0     5E B3 0A F2 | 	cmp	local07, local12 wz
0b7c4     A8 00 90 AD |  if_e	jmp	#LR__1777
0b7c8     10 A6 06 F1 | 	add	local01, #16
0b7cc     53 B3 C2 FA | 	rdbyte	local07, local01
0b7d0     10 A6 86 F1 | 	sub	local01, #16
0b7d4     80 B2 CE F7 | 	test	local07, #128 wz
0b7d8     58 00 90 AD |  if_e	jmp	#LR__1776
0b7dc     18 CE 05 F1 | 	add	fp, #24
0b7e0     E7 C0 02 FB | 	rdlong	local14, fp
0b7e4     18 CE 85 F1 | 	sub	fp, #24
0b7e8     01 C0 06 F1 | 	add	local14, #1
0b7ec     60 91 C2 FA | 	rdbyte	arg01, local14
0b7f0     28 A6 06 F1 | 	add	local01, #40
0b7f4     53 93 02 F6 | 	mov	arg02, local01
0b7f8     0C A6 86 F1 | 	sub	local01, #12
0b7fc     53 95 02 FB | 	rdlong	arg03, local01
0b800     1C A6 86 F1 | 	sub	local01, #28
0b804     01 96 06 F6 | 	mov	arg04, #1
0b808     78 C6 BF FD | 	call	#_fatfs_cc_disk_write
0b80c     00 76 0E F2 | 	cmp	result1, #0 wz
0b810     11 A6 06 51 |  if_ne	add	local01, #17
0b814     53 03 48 5C |  if_ne	wrbyte	#1, local01
0b818     01 76 06 56 |  if_ne	mov	result1, #1
0b81c     C8 00 90 5D |  if_ne	jmp	#LR__1781
0b820     10 A6 06 F1 | 	add	local01, #16
0b824     53 B3 C2 FA | 	rdbyte	local07, local01
0b828     7F B2 06 F5 | 	and	local07, #127
0b82c     53 B3 42 FC | 	wrbyte	local07, local01
0b830     10 A6 86 F1 | 	sub	local01, #16
0b834                 | LR__1776
0b834     18 CE 05 F1 | 	add	fp, #24
0b838     E7 C0 02 FB | 	rdlong	local14, fp
0b83c     18 CE 85 F1 | 	sub	fp, #24
0b840     01 C0 06 F1 | 	add	local14, #1
0b844     60 91 C2 FA | 	rdbyte	arg01, local14
0b848     53 93 02 F6 | 	mov	arg02, local01
0b84c     28 92 06 F1 | 	add	arg02, #40
0b850     5E 95 02 F6 | 	mov	arg03, local12
0b854     01 96 06 F6 | 	mov	arg04, #1
0b858     EC C4 BF FD | 	call	#_fatfs_cc_disk_read
0b85c     00 76 0E F2 | 	cmp	result1, #0 wz
0b860     11 A6 06 51 |  if_ne	add	local01, #17
0b864     53 03 48 5C |  if_ne	wrbyte	#1, local01
0b868     01 76 06 56 |  if_ne	mov	result1, #1
0b86c     78 00 90 5D |  if_ne	jmp	#LR__1781
0b870                 | LR__1777
0b870     1C A6 06 F1 | 	add	local01, #28
0b874     53 BD 62 FC | 	wrlong	local12, local01
0b878     1C A6 86 F1 | 	sub	local01, #28
0b87c                 | LR__1778
0b87c     14 A6 06 F1 | 	add	local01, #20
0b880     53 BF 02 FB | 	rdlong	local13, local01
0b884     FF BF 06 F5 | 	and	local13, #511
0b888     09 C0 C6 F9 | 	decod	local14, #9
0b88c     5F C1 82 F1 | 	sub	local14, local13
0b890     55 C1 3A F3 | 	fle	local14, local03 wcz
0b894     53 93 02 F6 | 	mov	arg02, local01
0b898     14 92 06 F1 | 	add	arg02, #20
0b89c     53 BF 02 FB | 	rdlong	local13, local01
0b8a0     14 A6 86 F1 | 	sub	local01, #20
0b8a4     FF BF 06 F5 | 	and	local13, #511
0b8a8     5F 93 02 F1 | 	add	arg02, local13
0b8ac     57 91 02 F6 | 	mov	arg01, local05
0b8b0     60 95 02 F6 | 	mov	arg03, local14
0b8b4     20 74 BF FD | 	call	#__system____builtin_memmove
0b8b8                 | LR__1779
0b8b8     60 AB 82 F1 | 	sub	local03, local14
0b8bc     56 B3 02 FB | 	rdlong	local07, local04
0b8c0     60 B3 02 F1 | 	add	local07, local14
0b8c4     56 B3 62 FC | 	wrlong	local07, local04
0b8c8     60 AF 02 F1 | 	add	local05, local14
0b8cc     14 A6 06 F1 | 	add	local01, #20
0b8d0     53 B3 02 FB | 	rdlong	local07, local01
0b8d4     60 B3 02 F1 | 	add	local07, local14
0b8d8     53 B3 62 FC | 	wrlong	local07, local01
0b8dc     14 A6 86 F1 | 	sub	local01, #20
0b8e0     FC FC 9F FD | 	jmp	#LR__1770
0b8e4                 | LR__1780
0b8e4                 | ' 
0b8e4                 | ' 
0b8e4                 | ' 
0b8e4                 | ' 
0b8e4                 | ' 		__builtin_memcpy(rbuff, fp->buf + fp->fptr % ((UINT) 512 ) , rcnt) ;
0b8e4                 | ' 
0b8e4                 | ' 	}
0b8e4                 | ' 
0b8e4                 | ' 	return FR_OK ;
0b8e4     00 76 06 F6 | 	mov	result1, #0
0b8e8                 | LR__1781
0b8e8     E7 F0 03 F6 | 	mov	ptra, fp
0b8ec     F2 00 A0 FD | 	call	#popregs_
0b8f0                 | _fatfs_cc_f_read_ret
0b8f0     2D 00 64 FD | 	ret
0b8f4                 | 
0b8f4                 | _fatfs_cc_f_write
0b8f4     12 CA 05 F6 | 	mov	COUNT_, #18
0b8f8     E8 00 A0 FD | 	call	#pushregs_
0b8fc     34 F0 07 F1 | 	add	ptra, #52
0b900     48 A7 02 F6 | 	mov	local01, arg01
0b904     49 A9 02 F6 | 	mov	local02, arg02
0b908     4A AB 02 F6 | 	mov	local03, arg03
0b90c     4B AD 02 F6 | 	mov	local04, arg04
0b910     54 AF 02 F6 | 	mov	local05, local02
0b914     56 01 68 FC | 	wrlong	#0, local04
0b918     E7 92 02 F6 | 	mov	arg02, fp
0b91c     18 92 06 F1 | 	add	arg02, #24
0b920     53 91 02 F6 | 	mov	arg01, local01
0b924     94 F6 BF FD | 	call	#_fatfs_cc_validate
0b928     3B B1 0A F6 | 	mov	local06, result1 wz
0b92c     11 A6 06 A1 |  if_e	add	local01, #17
0b930     53 B1 C2 AA |  if_e	rdbyte	local06, local01
0b934     11 A6 86 A1 |  if_e	sub	local01, #17
0b938     00 B0 4E A2 |  if_e	cmps	local06, #0 wz
0b93c     58 77 02 56 |  if_ne	mov	result1, local06
0b940     F4 03 90 5D |  if_ne	jmp	#LR__1802
0b944     10 A6 06 F1 | 	add	local01, #16
0b948     53 B3 C2 FA | 	rdbyte	local07, local01
0b94c     10 A6 86 F1 | 	sub	local01, #16
0b950     02 B2 CE F7 | 	test	local07, #2 wz
0b954     07 76 06 A6 |  if_e	mov	result1, #7
0b958     DC 03 90 AD |  if_e	jmp	#LR__1802
0b95c     14 A6 06 F1 | 	add	local01, #20
0b960     53 B5 02 FB | 	rdlong	local08, local01
0b964     5A B7 02 F6 | 	mov	local09, local08
0b968     55 B7 02 F1 | 	add	local09, local03
0b96c     14 A6 86 F1 | 	sub	local01, #20
0b970     5A B7 12 F2 | 	cmp	local09, local08 wc
0b974     01 AA 66 C6 |  if_b	neg	local03, #1
0b978     14 A6 06 C1 |  if_b	add	local01, #20
0b97c     53 B9 02 CB |  if_b	rdlong	local10, local01
0b980     14 A6 86 C1 |  if_b	sub	local01, #20
0b984     5C AB 82 C1 |  if_b	sub	local03, local10
0b988                 | ' 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
0b988                 | ' 	}
0b988                 | ' 
0b988                 | ' 	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
0b988                 | LR__1790
0b988     01 AA 16 F2 | 	cmp	local03, #1 wc
0b98c     94 03 90 CD |  if_b	jmp	#LR__1801
0b990     14 A6 06 F1 | 	add	local01, #20
0b994     53 B3 02 FB | 	rdlong	local07, local01
0b998     14 A6 86 F1 | 	sub	local01, #20
0b99c     FF B3 CE F7 | 	test	local07, #511 wz
0b9a0     D8 02 90 5D |  if_ne	jmp	#LR__1799
0b9a4     14 A6 06 F1 | 	add	local01, #20
0b9a8     53 BB 02 FB | 	rdlong	local11, local01
0b9ac     14 A6 86 F1 | 	sub	local01, #20
0b9b0     09 BA 46 F0 | 	shr	local11, #9
0b9b4     18 CE 05 F1 | 	add	fp, #24
0b9b8     E7 B4 02 FB | 	rdlong	local08, fp
0b9bc     18 CE 85 F1 | 	sub	fp, #24
0b9c0     5A BD 02 F6 | 	mov	local12, local08
0b9c4     0A BC 06 F1 | 	add	local12, #10
0b9c8     5E BF E2 FA | 	rdword	local13, local12
0b9cc     0A BC 86 F1 | 	sub	local12, #10
0b9d0     5F B7 32 F9 | 	getword	local09, local13, #0
0b9d4     01 B6 86 F1 | 	sub	local09, #1
0b9d8     5B BB 0A F5 | 	and	local11, local09 wz
0b9dc     A0 00 90 5D |  if_ne	jmp	#LR__1793
0b9e0     14 A6 06 F1 | 	add	local01, #20
0b9e4     53 B3 0A FB | 	rdlong	local07, local01 wz
0b9e8     14 A6 86 F1 | 	sub	local01, #20
0b9ec     24 00 90 5D |  if_ne	jmp	#LR__1791
0b9f0     08 A6 06 F1 | 	add	local01, #8
0b9f4     53 C1 0A FB | 	rdlong	local14, local01 wz
0b9f8     08 A6 86 F1 | 	sub	local01, #8
0b9fc     2C 00 90 5D |  if_ne	jmp	#LR__1792
0ba00     53 91 02 F6 | 	mov	arg01, local01
0ba04     00 92 06 F6 | 	mov	arg02, #0
0ba08     44 D0 BF FD | 	call	#_fatfs_cc_create_chain
0ba0c     3B C1 02 F6 | 	mov	local14, result1
0ba10     18 00 90 FD | 	jmp	#LR__1792
0ba14                 | LR__1791
0ba14     53 91 02 F6 | 	mov	arg01, local01
0ba18     18 A6 06 F1 | 	add	local01, #24
0ba1c     53 93 02 FB | 	rdlong	arg02, local01
0ba20     18 A6 86 F1 | 	sub	local01, #24
0ba24     28 D0 BF FD | 	call	#_fatfs_cc_create_chain
0ba28     3B C1 02 F6 | 	mov	local14, result1
0ba2c                 | LR__1792
0ba2c     00 C0 0E F2 | 	cmp	local14, #0 wz
0ba30     F0 02 90 AD |  if_e	jmp	#LR__1801
0ba34     01 C0 0E F2 | 	cmp	local14, #1 wz
0ba38     11 A6 06 A1 |  if_e	add	local01, #17
0ba3c     53 05 48 AC |  if_e	wrbyte	#2, local01
0ba40     02 76 06 A6 |  if_e	mov	result1, #2
0ba44     F0 02 90 AD |  if_e	jmp	#LR__1802
0ba48     FF FF 7F FF 
0ba4c     FF C1 0E F2 | 	cmp	local14, ##-1 wz
0ba50     11 A6 06 A1 |  if_e	add	local01, #17
0ba54     53 03 48 AC |  if_e	wrbyte	#1, local01
0ba58     01 76 06 A6 |  if_e	mov	result1, #1
0ba5c     D8 02 90 AD |  if_e	jmp	#LR__1802
0ba60     18 A6 06 F1 | 	add	local01, #24
0ba64     53 C1 62 FC | 	wrlong	local14, local01
0ba68     10 A6 86 F1 | 	sub	local01, #16
0ba6c     53 B3 0A FB | 	rdlong	local07, local01 wz
0ba70     08 A6 86 F1 | 	sub	local01, #8
0ba74     08 A6 06 A1 |  if_e	add	local01, #8
0ba78     53 C1 62 AC |  if_e	wrlong	local14, local01
0ba7c     08 A6 86 A1 |  if_e	sub	local01, #8
0ba80                 | LR__1793
0ba80     10 A6 06 F1 | 	add	local01, #16
0ba84     53 B3 C2 FA | 	rdbyte	local07, local01
0ba88     10 A6 86 F1 | 	sub	local01, #16
0ba8c     80 B2 CE F7 | 	test	local07, #128 wz
0ba90     58 00 90 AD |  if_e	jmp	#LR__1794
0ba94     18 CE 05 F1 | 	add	fp, #24
0ba98     E7 B8 02 FB | 	rdlong	local10, fp
0ba9c     18 CE 85 F1 | 	sub	fp, #24
0baa0     01 B8 06 F1 | 	add	local10, #1
0baa4     5C 91 C2 FA | 	rdbyte	arg01, local10
0baa8     28 A6 06 F1 | 	add	local01, #40
0baac     53 93 02 F6 | 	mov	arg02, local01
0bab0     0C A6 86 F1 | 	sub	local01, #12
0bab4     53 95 02 FB | 	rdlong	arg03, local01
0bab8     1C A6 86 F1 | 	sub	local01, #28
0babc     01 96 06 F6 | 	mov	arg04, #1
0bac0     C0 C3 BF FD | 	call	#_fatfs_cc_disk_write
0bac4     00 76 0E F2 | 	cmp	result1, #0 wz
0bac8     11 A6 06 51 |  if_ne	add	local01, #17
0bacc     53 03 48 5C |  if_ne	wrbyte	#1, local01
0bad0     01 76 06 56 |  if_ne	mov	result1, #1
0bad4     60 02 90 5D |  if_ne	jmp	#LR__1802
0bad8     10 A6 06 F1 | 	add	local01, #16
0badc     53 B3 C2 FA | 	rdbyte	local07, local01
0bae0     7F B2 06 F5 | 	and	local07, #127
0bae4     53 B3 42 FC | 	wrbyte	local07, local01
0bae8     10 A6 86 F1 | 	sub	local01, #16
0baec                 | LR__1794
0baec     18 CE 05 F1 | 	add	fp, #24
0baf0     E7 90 02 FB | 	rdlong	arg01, fp
0baf4     18 CE 85 F1 | 	sub	fp, #24
0baf8     18 A6 06 F1 | 	add	local01, #24
0bafc     53 93 02 FB | 	rdlong	arg02, local01
0bb00     18 A6 86 F1 | 	sub	local01, #24
0bb04     40 CA BF FD | 	call	#_fatfs_cc_clst2sect
0bb08     3B C3 0A F6 | 	mov	local15, result1 wz
0bb0c     11 A6 06 A1 |  if_e	add	local01, #17
0bb10     53 05 48 AC |  if_e	wrbyte	#2, local01
0bb14     02 76 06 A6 |  if_e	mov	result1, #2
0bb18     1C 02 90 AD |  if_e	jmp	#LR__1802
0bb1c     5D C3 02 F1 | 	add	local15, local11
0bb20     55 C5 02 F6 | 	mov	local16, local03
0bb24     09 C4 46 F0 | 	shr	local16, #9
0bb28     01 C4 16 F2 | 	cmp	local16, #1 wc
0bb2c     D4 00 90 CD |  if_b	jmp	#LR__1797
0bb30     5D B3 02 F6 | 	mov	local07, local11
0bb34     62 B3 02 F1 | 	add	local07, local16
0bb38     18 CE 05 F1 | 	add	fp, #24
0bb3c     E7 C6 02 FB | 	rdlong	local17, fp
0bb40     18 CE 85 F1 | 	sub	fp, #24
0bb44     0A C6 06 F1 | 	add	local17, #10
0bb48     63 B9 E2 FA | 	rdword	local10, local17
0bb4c     5C B3 1A F2 | 	cmp	local07, local10 wcz
0bb50     18 00 90 ED |  if_be	jmp	#LR__1795
0bb54     18 CE 05 F1 | 	add	fp, #24
0bb58     E7 B8 02 FB | 	rdlong	local10, fp
0bb5c     18 CE 85 F1 | 	sub	fp, #24
0bb60     0A B8 06 F1 | 	add	local10, #10
0bb64     5C C5 E2 FA | 	rdword	local16, local10
0bb68     5D C5 82 F1 | 	sub	local16, local11
0bb6c                 | LR__1795
0bb6c     18 CE 05 F1 | 	add	fp, #24
0bb70     E7 B8 02 FB | 	rdlong	local10, fp
0bb74     18 CE 85 F1 | 	sub	fp, #24
0bb78     01 B8 06 F1 | 	add	local10, #1
0bb7c     5C 91 C2 FA | 	rdbyte	arg01, local10
0bb80     57 93 02 F6 | 	mov	arg02, local05
0bb84     61 95 02 F6 | 	mov	arg03, local15
0bb88     62 97 02 F6 | 	mov	arg04, local16
0bb8c     F4 C2 BF FD | 	call	#_fatfs_cc_disk_write
0bb90     00 76 0E F2 | 	cmp	result1, #0 wz
0bb94     11 A6 06 51 |  if_ne	add	local01, #17
0bb98     53 03 48 5C |  if_ne	wrbyte	#1, local01
0bb9c     01 76 06 56 |  if_ne	mov	result1, #1
0bba0     94 01 90 5D |  if_ne	jmp	#LR__1802
0bba4     1C A6 06 F1 | 	add	local01, #28
0bba8     53 B3 02 FB | 	rdlong	local07, local01
0bbac     1C A6 86 F1 | 	sub	local01, #28
0bbb0     61 B3 82 F1 | 	sub	local07, local15
0bbb4     62 B3 12 F2 | 	cmp	local07, local16 wc
0bbb8     3C 00 90 3D |  if_ae	jmp	#LR__1796
0bbbc     28 A6 06 F1 | 	add	local01, #40
0bbc0     53 91 02 F6 | 	mov	arg01, local01
0bbc4     57 93 02 F6 | 	mov	arg02, local05
0bbc8     0C A6 86 F1 | 	sub	local01, #12
0bbcc     53 BF 02 FB | 	rdlong	local13, local01
0bbd0     61 BF 82 F1 | 	sub	local13, local15
0bbd4     09 BE 66 F0 | 	shl	local13, #9
0bbd8     5F 93 02 F1 | 	add	arg02, local13
0bbdc     09 94 C6 F9 | 	decod	arg03, #9
0bbe0     F4 70 BF FD | 	call	#__system____builtin_memmove
0bbe4     0C A6 86 F1 | 	sub	local01, #12
0bbe8     53 B3 C2 FA | 	rdbyte	local07, local01
0bbec     7F B2 06 F5 | 	and	local07, #127
0bbf0     53 B3 42 FC | 	wrbyte	local07, local01
0bbf4     10 A6 86 F1 | 	sub	local01, #16
0bbf8                 | LR__1796
0bbf8     62 C9 02 F6 | 	mov	local18, local16
0bbfc     09 C8 66 F0 | 	shl	local18, #9
0bc00                 | ' 					__builtin_memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT) 512 ) ), ((UINT) 512 ) ) ;
0bc00                 | ' 					fp->flag &= (BYTE)~ 0x80 ;
0bc00                 | ' 				}
0bc00                 | ' 
0bc00                 | ' 
0bc00                 | ' 				wcnt =  ((UINT) 512 )  * cc;
0bc00                 | ' 				continue;
0bc00     C4 00 90 FD | 	jmp	#LR__1800
0bc04                 | LR__1797
0bc04     1C A6 06 F1 | 	add	local01, #28
0bc08     53 B3 02 FB | 	rdlong	local07, local01
0bc0c     1C A6 86 F1 | 	sub	local01, #28
0bc10     61 B3 0A F2 | 	cmp	local07, local15 wz
0bc14     58 00 90 AD |  if_e	jmp	#LR__1798
0bc18     14 A6 06 F1 | 	add	local01, #20
0bc1c     53 C7 02 FB | 	rdlong	local17, local01
0bc20     08 A6 86 F1 | 	sub	local01, #8
0bc24     53 BD 02 FB | 	rdlong	local12, local01
0bc28     0C A6 86 F1 | 	sub	local01, #12
0bc2c     5E C7 12 F2 | 	cmp	local17, local12 wc
0bc30     3C 00 90 3D |  if_ae	jmp	#LR__1798
0bc34     18 CE 05 F1 | 	add	fp, #24
0bc38     E7 C8 02 FB | 	rdlong	local18, fp
0bc3c     18 CE 85 F1 | 	sub	fp, #24
0bc40     01 C8 06 F1 | 	add	local18, #1
0bc44     64 91 C2 FA | 	rdbyte	arg01, local18
0bc48     53 93 02 F6 | 	mov	arg02, local01
0bc4c     28 92 06 F1 | 	add	arg02, #40
0bc50     61 95 02 F6 | 	mov	arg03, local15
0bc54     01 96 06 F6 | 	mov	arg04, #1
0bc58     EC C0 BF FD | 	call	#_fatfs_cc_disk_read
0bc5c     00 76 0E F2 | 	cmp	result1, #0 wz
0bc60     11 A6 06 51 |  if_ne	add	local01, #17
0bc64     53 03 48 5C |  if_ne	wrbyte	#1, local01
0bc68                 | ' 				fp->fptr < fp->obj.objsize &&
0bc68                 | ' 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
0bc68                 | ' 					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR ; } ;
0bc68     01 76 06 56 |  if_ne	mov	result1, #1
0bc6c     C8 00 90 5D |  if_ne	jmp	#LR__1802
0bc70                 | LR__1798
0bc70     1C A6 06 F1 | 	add	local01, #28
0bc74     53 C3 62 FC | 	wrlong	local15, local01
0bc78     1C A6 86 F1 | 	sub	local01, #28
0bc7c                 | LR__1799
0bc7c     14 A6 06 F1 | 	add	local01, #20
0bc80     53 B9 02 FB | 	rdlong	local10, local01
0bc84     FF B9 06 F5 | 	and	local10, #511
0bc88     09 C8 C6 F9 | 	decod	local18, #9
0bc8c     5C C9 82 F1 | 	sub	local18, local10
0bc90     55 C9 3A F3 | 	fle	local18, local03 wcz
0bc94     53 91 02 F6 | 	mov	arg01, local01
0bc98     14 90 06 F1 | 	add	arg01, #20
0bc9c     53 BF 02 FB | 	rdlong	local13, local01
0bca0     FF BF 06 F5 | 	and	local13, #511
0bca4     5F 91 02 F1 | 	add	arg01, local13
0bca8     57 93 02 F6 | 	mov	arg02, local05
0bcac     64 95 02 F6 | 	mov	arg03, local18
0bcb0     24 70 BF FD | 	call	#__system____builtin_memmove
0bcb4     04 A6 86 F1 | 	sub	local01, #4
0bcb8     53 B3 C2 FA | 	rdbyte	local07, local01
0bcbc     80 B2 46 F5 | 	or	local07, #128
0bcc0     53 B3 42 FC | 	wrbyte	local07, local01
0bcc4     10 A6 86 F1 | 	sub	local01, #16
0bcc8                 | LR__1800
0bcc8     64 AB 82 F1 | 	sub	local03, local18
0bccc     56 B3 02 FB | 	rdlong	local07, local04
0bcd0     64 B3 02 F1 | 	add	local07, local18
0bcd4     56 B3 62 FC | 	wrlong	local07, local04
0bcd8     64 AF 02 F1 | 	add	local05, local18
0bcdc     14 A6 06 F1 | 	add	local01, #20
0bce0     53 B9 02 FB | 	rdlong	local10, local01
0bce4     64 B9 02 F1 | 	add	local10, local18
0bce8     53 B9 62 FC | 	wrlong	local10, local01
0bcec     08 A6 86 F1 | 	sub	local01, #8
0bcf0     53 B7 02 FB | 	rdlong	local09, local01
0bcf4     0C A6 86 F1 | 	sub	local01, #12
0bcf8     5B B9 1A F2 | 	cmp	local10, local09 wcz
0bcfc     14 A6 06 11 |  if_a	add	local01, #20
0bd00     53 B3 02 1B |  if_a	rdlong	local07, local01
0bd04     14 A6 86 11 |  if_a	sub	local01, #20
0bd08     0C A6 06 E1 |  if_be	add	local01, #12
0bd0c     53 B3 02 EB |  if_be	rdlong	local07, local01
0bd10     0C A6 86 E1 |  if_be	sub	local01, #12
0bd14     0C A6 06 F1 | 	add	local01, #12
0bd18     53 B3 62 FC | 	wrlong	local07, local01
0bd1c     0C A6 86 F1 | 	sub	local01, #12
0bd20     64 FC 9F FD | 	jmp	#LR__1790
0bd24                 | LR__1801
0bd24     10 A6 06 F1 | 	add	local01, #16
0bd28     53 B3 C2 FA | 	rdbyte	local07, local01
0bd2c     40 B2 46 F5 | 	or	local07, #64
0bd30     53 B3 42 FC | 	wrbyte	local07, local01
0bd34                 | ' 
0bd34                 | ' 
0bd34                 | ' 
0bd34                 | ' 
0bd34                 | ' 
0bd34                 | ' 		__builtin_memcpy(fp->buf + fp->fptr % ((UINT) 512 ) , wbuff, wcnt) ;
0bd34                 | ' 		fp->flag |=  0x80 ;
0bd34                 | ' 
0bd34                 | ' 	}
0bd34                 | ' 
0bd34                 | ' 	fp->flag |=  0x40 ;
0bd34                 | ' 
0bd34                 | ' 	return FR_OK ;
0bd34     00 76 06 F6 | 	mov	result1, #0
0bd38                 | LR__1802
0bd38     E7 F0 03 F6 | 	mov	ptra, fp
0bd3c     F2 00 A0 FD | 	call	#popregs_
0bd40                 | _fatfs_cc_f_write_ret
0bd40     2D 00 64 FD | 	ret
0bd44                 | 
0bd44                 | _fatfs_cc_f_sync
0bd44     03 CA 05 F6 | 	mov	COUNT_, #3
0bd48     E8 00 A0 FD | 	call	#pushregs_
0bd4c     18 F0 07 F1 | 	add	ptra, #24
0bd50     48 A7 02 F6 | 	mov	local01, arg01
0bd54     E7 92 02 F6 | 	mov	arg02, fp
0bd58     0C 92 06 F1 | 	add	arg02, #12
0bd5c     53 91 02 F6 | 	mov	arg01, local01
0bd60     58 F2 BF FD | 	call	#_fatfs_cc_validate
0bd64     3B A9 0A F6 | 	mov	local02, result1 wz
0bd68     30 01 90 5D |  if_ne	jmp	#LR__1813
0bd6c     10 A6 06 F1 | 	add	local01, #16
0bd70     53 97 C2 FA | 	rdbyte	arg04, local01
0bd74     10 A6 86 F1 | 	sub	local01, #16
0bd78     40 96 CE F7 | 	test	arg04, #64 wz
0bd7c     1C 01 90 AD |  if_e	jmp	#LR__1812
0bd80     10 A6 06 F1 | 	add	local01, #16
0bd84     53 A9 C2 FA | 	rdbyte	local02, local01
0bd88     10 A6 86 F1 | 	sub	local01, #16
0bd8c     80 A8 CE F7 | 	test	local02, #128 wz
0bd90     50 00 90 AD |  if_e	jmp	#LR__1810
0bd94     0C CE 05 F1 | 	add	fp, #12
0bd98     E7 A8 02 FB | 	rdlong	local02, fp
0bd9c     0C CE 85 F1 | 	sub	fp, #12
0bda0     01 A8 06 F1 | 	add	local02, #1
0bda4     54 91 C2 FA | 	rdbyte	arg01, local02
0bda8     28 A6 06 F1 | 	add	local01, #40
0bdac     53 93 02 F6 | 	mov	arg02, local01
0bdb0     0C A6 86 F1 | 	sub	local01, #12
0bdb4     53 95 02 FB | 	rdlong	arg03, local01
0bdb8     1C A6 86 F1 | 	sub	local01, #28
0bdbc     01 96 06 F6 | 	mov	arg04, #1
0bdc0     C0 C0 BF FD | 	call	#_fatfs_cc_disk_write
0bdc4     00 76 0E F2 | 	cmp	result1, #0 wz
0bdc8     01 76 06 56 |  if_ne	mov	result1, #1
0bdcc     D0 00 90 5D |  if_ne	jmp	#LR__1814
0bdd0     10 A6 06 F1 | 	add	local01, #16
0bdd4     53 A9 C2 FA | 	rdbyte	local02, local01
0bdd8     7F A8 06 F5 | 	and	local02, #127
0bddc     53 A9 42 FC | 	wrbyte	local02, local01
0bde0     10 A6 86 F1 | 	sub	local01, #16
0bde4                 | LR__1810
0bde4     EC 0F B0 FD | 	call	#_fatfs_cc__get_fattime
0bde8     3B AB 02 F6 | 	mov	local03, result1
0bdec     0C CE 05 F1 | 	add	fp, #12
0bdf0     E7 90 02 FB | 	rdlong	arg01, fp
0bdf4     0C CE 85 F1 | 	sub	fp, #12
0bdf8     20 A6 06 F1 | 	add	local01, #32
0bdfc     53 93 02 FB | 	rdlong	arg02, local01
0be00     20 A6 86 F1 | 	sub	local01, #32
0be04     C8 C5 BF FD | 	call	#_fatfs_cc_move_window
0be08     3B A9 0A F6 | 	mov	local02, result1 wz
0be0c     8C 00 90 5D |  if_ne	jmp	#LR__1811
0be10     24 A6 06 F1 | 	add	local01, #36
0be14     53 A9 02 FB | 	rdlong	local02, local01
0be18     24 A6 86 F1 | 	sub	local01, #36
0be1c     0B A8 06 F1 | 	add	local02, #11
0be20     54 97 C2 FA | 	rdbyte	arg04, local02
0be24     20 96 46 F5 | 	or	arg04, #32
0be28     54 97 42 FC | 	wrbyte	arg04, local02
0be2c     0B A8 86 F1 | 	sub	local02, #11
0be30     53 91 02 FB | 	rdlong	arg01, local01
0be34     08 A6 06 F1 | 	add	local01, #8
0be38     53 95 02 FB | 	rdlong	arg03, local01
0be3c     54 93 02 F6 | 	mov	arg02, local02
0be40     F8 D2 BF FD | 	call	#_fatfs_cc_st_clust
0be44     54 91 02 F6 | 	mov	arg01, local02
0be48     1C 90 06 F1 | 	add	arg01, #28
0be4c     04 A6 06 F1 | 	add	local01, #4
0be50     53 93 02 FB | 	rdlong	arg02, local01
0be54     48 93 62 FC | 	wrlong	arg02, arg01
0be58     54 91 02 F6 | 	mov	arg01, local02
0be5c     16 90 06 F1 | 	add	arg01, #22
0be60     48 AB 62 FC | 	wrlong	local03, arg01
0be64     12 A8 06 F1 | 	add	local02, #18
0be68     54 01 58 FC | 	wrword	#0, local02
0be6c     0C CE 05 F1 | 	add	fp, #12
0be70     E7 AA 02 FB | 	rdlong	local03, fp
0be74     03 AA 06 F1 | 	add	local03, #3
0be78     55 03 48 FC | 	wrbyte	#1, local03
0be7c     E7 90 02 FB | 	rdlong	arg01, fp
0be80     0C CE 85 F1 | 	sub	fp, #12
0be84     C0 C5 BF FD | 	call	#_fatfs_cc_sync_fs
0be88     3B A9 02 F6 | 	mov	local02, result1
0be8c     04 A6 06 F1 | 	add	local01, #4
0be90     53 AB C2 FA | 	rdbyte	local03, local01
0be94     BF AA 06 F5 | 	and	local03, #191
0be98     53 AB 42 FC | 	wrbyte	local03, local01
0be9c                 | LR__1811
0be9c                 | LR__1812
0be9c                 | LR__1813
0be9c                 | ' 					dir = fp->dir_ptr;
0be9c                 | ' 					dir[ 11 ] |=  0x20 ;
0be9c                 | ' 					st_clust(fp->obj.fs, dir, fp->obj.sclust);
0be9c                 | ' 					st_dword(dir +  28 , (DWORD)fp->obj.objsize);
0be9c                 | ' 					st_dword(dir +  22 , tm);
0be9c                 | ' 					st_word(dir +  18 , 0);
0be9c                 | ' 					fs->wflag = 1;
0be9c                 | ' 					res = sync_fs(fs);
0be9c                 | ' 					fp->flag &= (BYTE)~ 0x40 ;
0be9c                 | ' 				}
0be9c                 | ' 			}
0be9c                 | ' 		}
0be9c                 | ' 	}
0be9c                 | ' 
0be9c                 | ' 	return res ;
0be9c     54 77 02 F6 | 	mov	result1, local02
0bea0                 | LR__1814
0bea0     E7 F0 03 F6 | 	mov	ptra, fp
0bea4     F2 00 A0 FD | 	call	#popregs_
0bea8                 | _fatfs_cc_f_sync_ret
0bea8     2D 00 64 FD | 	ret
0beac                 | 
0beac                 | _fatfs_cc_f_close
0beac     02 CA 05 F6 | 	mov	COUNT_, #2
0beb0     E8 00 A0 FD | 	call	#pushregs_
0beb4     10 F0 07 F1 | 	add	ptra, #16
0beb8     48 A7 02 F6 | 	mov	local01, arg01
0bebc     84 FE BF FD | 	call	#_fatfs_cc_f_sync
0bec0     3B A9 0A F6 | 	mov	local02, result1 wz
0bec4     18 00 90 5D |  if_ne	jmp	#LR__1820
0bec8     E7 92 02 F6 | 	mov	arg02, fp
0becc     0C 92 06 F1 | 	add	arg02, #12
0bed0     53 91 02 F6 | 	mov	arg01, local01
0bed4     E4 F0 BF FD | 	call	#_fatfs_cc_validate
0bed8     3B A9 0A F6 | 	mov	local02, result1 wz
0bedc     53 01 68 AC |  if_e	wrlong	#0, local01
0bee0                 | LR__1820
0bee0                 | ' 
0bee0                 | ' 
0bee0                 | ' 
0bee0                 | ' 
0bee0                 | ' 			fp->obj.fs = 0;
0bee0                 | ' #line 4192 "ff.c"
0bee0                 | ' 		}
0bee0                 | ' 	}
0bee0                 | ' 	return res;
0bee0     54 77 02 F6 | 	mov	result1, local02
0bee4     E7 F0 03 F6 | 	mov	ptra, fp
0bee8     F2 00 A0 FD | 	call	#popregs_
0beec                 | _fatfs_cc_f_close_ret
0beec     2D 00 64 FD | 	ret
0bef0                 | 
0bef0                 | _fatfs_cc_f_lseek
0bef0     0D CA 05 F6 | 	mov	COUNT_, #13
0bef4     E8 00 A0 FD | 	call	#pushregs_
0bef8     24 F0 07 F1 | 	add	ptra, #36
0befc     48 A7 02 F6 | 	mov	local01, arg01
0bf00     49 A9 02 F6 | 	mov	local02, arg02
0bf04     E7 92 02 F6 | 	mov	arg02, fp
0bf08     10 92 06 F1 | 	add	arg02, #16
0bf0c     53 91 02 F6 | 	mov	arg01, local01
0bf10     A8 F0 BF FD | 	call	#_fatfs_cc_validate
0bf14     3B AB 0A F6 | 	mov	local03, result1 wz
0bf18     11 A6 06 A1 |  if_e	add	local01, #17
0bf1c     53 AB C2 AA |  if_e	rdbyte	local03, local01
0bf20     11 A6 86 A1 |  if_e	sub	local01, #17
0bf24     00 AA 0E F2 | 	cmp	local03, #0 wz
0bf28     55 77 02 56 |  if_ne	mov	result1, local03
0bf2c     5C 03 90 5D |  if_ne	jmp	#LR__1846
0bf30     0C A6 06 F1 | 	add	local01, #12
0bf34     53 AD 02 FB | 	rdlong	local04, local01
0bf38     0C A6 86 F1 | 	sub	local01, #12
0bf3c     56 A9 1A F2 | 	cmp	local02, local04 wcz
0bf40     20 00 90 ED |  if_be	jmp	#LR__1830
0bf44     10 A6 06 F1 | 	add	local01, #16
0bf48     53 AF C2 FA | 	rdbyte	local05, local01
0bf4c     10 A6 86 F1 | 	sub	local01, #16
0bf50     57 B1 E2 F8 | 	getbyte	local06, local05, #0
0bf54     02 B0 CE F7 | 	test	local06, #2 wz
0bf58     0C A6 06 A1 |  if_e	add	local01, #12
0bf5c     53 A9 02 AB |  if_e	rdlong	local02, local01
0bf60     0C A6 86 A1 |  if_e	sub	local01, #12
0bf64                 | LR__1830
0bf64     14 A6 06 F1 | 	add	local01, #20
0bf68     53 B3 02 FB | 	rdlong	local07, local01
0bf6c     00 B4 06 F6 | 	mov	local08, #0
0bf70     53 01 68 FC | 	wrlong	#0, local01
0bf74     14 A6 86 F1 | 	sub	local01, #20
0bf78     01 A8 16 F2 | 	cmp	local02, #1 wc
0bf7c     F4 01 90 CD |  if_b	jmp	#LR__1842
0bf80     10 CE 05 F1 | 	add	fp, #16
0bf84     E7 B6 02 FB | 	rdlong	local09, fp
0bf88     10 CE 85 F1 | 	sub	fp, #16
0bf8c     0A B6 06 F1 | 	add	local09, #10
0bf90     5B AF E2 FA | 	rdword	local05, local09
0bf94     57 B9 32 F9 | 	getword	local10, local05, #0
0bf98     09 B8 66 F0 | 	shl	local10, #9
0bf9c     5C BB 02 F6 | 	mov	local11, local10
0bfa0     01 B2 16 F2 | 	cmp	local07, #1 wc
0bfa4     5C 00 90 CD |  if_b	jmp	#LR__1831
0bfa8     54 B7 02 F6 | 	mov	local09, local02
0bfac     01 B6 86 F1 | 	sub	local09, #1
0bfb0     5D B7 12 FD | 	qdiv	local09, local11
0bfb4     59 AF 02 F6 | 	mov	local05, local07
0bfb8     01 AE 86 F1 | 	sub	local05, #1
0bfbc     5D BD 02 F6 | 	mov	local12, local11
0bfc0     18 B6 62 FD | 	getqx	local09
0bfc4     5E AF 12 FD | 	qdiv	local05, local12
0bfc8     18 B8 62 FD | 	getqx	local10
0bfcc     5C B7 12 F2 | 	cmp	local09, local10 wc
0bfd0     30 00 90 CD |  if_b	jmp	#LR__1831
0bfd4     59 B1 02 F6 | 	mov	local06, local07
0bfd8     01 B0 86 F1 | 	sub	local06, #1
0bfdc     5D B7 02 F6 | 	mov	local09, local11
0bfe0     01 B6 86 F1 | 	sub	local09, #1
0bfe4     5B B1 22 F5 | 	andn	local06, local09
0bfe8     14 A6 06 F1 | 	add	local01, #20
0bfec     53 B1 62 FC | 	wrlong	local06, local01
0bff0     58 A9 82 F1 | 	sub	local02, local06
0bff4     04 A6 06 F1 | 	add	local01, #4
0bff8     53 BF 02 FB | 	rdlong	local13, local01
0bffc     18 A6 86 F1 | 	sub	local01, #24
0c000     64 00 90 FD | 	jmp	#LR__1833
0c004                 | LR__1831
0c004     08 A6 06 F1 | 	add	local01, #8
0c008     53 BF 0A FB | 	rdlong	local13, local01 wz
0c00c     08 A6 86 F1 | 	sub	local01, #8
0c010     48 00 90 5D |  if_ne	jmp	#LR__1832
0c014     53 91 02 F6 | 	mov	arg01, local01
0c018     00 92 06 F6 | 	mov	arg02, #0
0c01c     30 CA BF FD | 	call	#_fatfs_cc_create_chain
0c020     3B BF 02 F6 | 	mov	local13, result1
0c024     01 BE 0E F2 | 	cmp	local13, #1 wz
0c028     11 A6 06 A1 |  if_e	add	local01, #17
0c02c     53 05 48 AC |  if_e	wrbyte	#2, local01
0c030     02 76 06 A6 |  if_e	mov	result1, #2
0c034     54 02 90 AD |  if_e	jmp	#LR__1846
0c038     FF FF 7F FF 
0c03c     FF BF 0E F2 | 	cmp	local13, ##-1 wz
0c040     11 A6 06 A1 |  if_e	add	local01, #17
0c044     53 03 48 AC |  if_e	wrbyte	#1, local01
0c048     01 76 06 A6 |  if_e	mov	result1, #1
0c04c     3C 02 90 AD |  if_e	jmp	#LR__1846
0c050     08 A6 06 F1 | 	add	local01, #8
0c054     53 BF 62 FC | 	wrlong	local13, local01
0c058     08 A6 86 F1 | 	sub	local01, #8
0c05c                 | LR__1832
0c05c     18 A6 06 F1 | 	add	local01, #24
0c060     53 BF 62 FC | 	wrlong	local13, local01
0c064     18 A6 86 F1 | 	sub	local01, #24
0c068                 | LR__1833
0c068     00 BE 0E F2 | 	cmp	local13, #0 wz
0c06c     04 01 90 AD |  if_e	jmp	#LR__1841
0c070                 | ' 				while (ofs > bcs) {
0c070                 | LR__1834
0c070     5D A9 1A F2 | 	cmp	local02, local11 wcz
0c074     B0 00 90 ED |  if_be	jmp	#LR__1839
0c078     5D A9 82 F1 | 	sub	local02, local11
0c07c     14 A6 06 F1 | 	add	local01, #20
0c080     53 AD 02 FB | 	rdlong	local04, local01
0c084     5D AD 02 F1 | 	add	local04, local11
0c088     53 AD 62 FC | 	wrlong	local04, local01
0c08c     04 A6 86 F1 | 	sub	local01, #4
0c090     53 AD C2 FA | 	rdbyte	local04, local01
0c094     10 A6 86 F1 | 	sub	local01, #16
0c098     02 AC CE F7 | 	test	local04, #2 wz
0c09c     1C 00 90 AD |  if_e	jmp	#LR__1835
0c0a0     53 91 02 F6 | 	mov	arg01, local01
0c0a4     5F 93 02 F6 | 	mov	arg02, local13
0c0a8     A4 C9 BF FD | 	call	#_fatfs_cc_create_chain
0c0ac     3B BF 0A F6 | 	mov	local13, result1 wz
0c0b0     00 A8 06 A6 |  if_e	mov	local02, #0
0c0b4                 | ' 							ofs = 0; break;
0c0b4     70 00 90 AD |  if_e	jmp	#LR__1839
0c0b8     10 00 90 FD | 	jmp	#LR__1836
0c0bc                 | LR__1835
0c0bc     53 91 02 F6 | 	mov	arg01, local01
0c0c0     5F 93 02 F6 | 	mov	arg02, local13
0c0c4     C0 C4 BF FD | 	call	#_fatfs_cc_get_fat
0c0c8     3B BF 02 F6 | 	mov	local13, result1
0c0cc                 | LR__1836
0c0cc     FF FF 7F FF 
0c0d0     FF BF 0E F2 | 	cmp	local13, ##-1 wz
0c0d4     11 A6 06 A1 |  if_e	add	local01, #17
0c0d8     53 03 48 AC |  if_e	wrbyte	#1, local01
0c0dc     01 76 06 A6 |  if_e	mov	result1, #1
0c0e0     A8 01 90 AD |  if_e	jmp	#LR__1846
0c0e4     02 BE 16 F2 | 	cmp	local13, #2 wc
0c0e8     1C 00 90 CD |  if_b	jmp	#LR__1837
0c0ec     10 CE 05 F1 | 	add	fp, #16
0c0f0     E7 AC 02 FB | 	rdlong	local04, fp
0c0f4     10 CE 85 F1 | 	sub	fp, #16
0c0f8     18 AC 06 F1 | 	add	local04, #24
0c0fc     56 AF 02 FB | 	rdlong	local05, local04
0c100     57 BF 12 F2 | 	cmp	local13, local05 wc
0c104     10 00 90 CD |  if_b	jmp	#LR__1838
0c108                 | LR__1837
0c108     11 A6 06 F1 | 	add	local01, #17
0c10c     53 05 48 FC | 	wrbyte	#2, local01
0c110     02 76 06 F6 | 	mov	result1, #2
0c114     74 01 90 FD | 	jmp	#LR__1846
0c118                 | LR__1838
0c118     18 A6 06 F1 | 	add	local01, #24
0c11c     53 BF 62 FC | 	wrlong	local13, local01
0c120     18 A6 86 F1 | 	sub	local01, #24
0c124     48 FF 9F FD | 	jmp	#LR__1834
0c128                 | LR__1839
0c128     14 A6 06 F1 | 	add	local01, #20
0c12c     53 AD 02 FB | 	rdlong	local04, local01
0c130     54 AD 02 F1 | 	add	local04, local02
0c134     53 AD 62 FC | 	wrlong	local04, local01
0c138     14 A6 86 F1 | 	sub	local01, #20
0c13c     FF A9 CE F7 | 	test	local02, #511 wz
0c140     30 00 90 AD |  if_e	jmp	#LR__1840
0c144     10 CE 05 F1 | 	add	fp, #16
0c148     E7 90 02 FB | 	rdlong	arg01, fp
0c14c     10 CE 85 F1 | 	sub	fp, #16
0c150     5F 93 02 F6 | 	mov	arg02, local13
0c154     F0 C3 BF FD | 	call	#_fatfs_cc_clst2sect
0c158     3B B5 0A F6 | 	mov	local08, result1 wz
0c15c     11 A6 06 A1 |  if_e	add	local01, #17
0c160     53 05 48 AC |  if_e	wrbyte	#2, local01
0c164     02 76 06 A6 |  if_e	mov	result1, #2
0c168     20 01 90 AD |  if_e	jmp	#LR__1846
0c16c     09 A8 46 F0 | 	shr	local02, #9
0c170     54 B5 02 F1 | 	add	local08, local02
0c174                 | LR__1840
0c174                 | LR__1841
0c174                 | LR__1842
0c174     14 A6 06 F1 | 	add	local01, #20
0c178     53 AD 02 FB | 	rdlong	local04, local01
0c17c     08 A6 86 F1 | 	sub	local01, #8
0c180     53 B1 02 FB | 	rdlong	local06, local01
0c184     0C A6 86 F1 | 	sub	local01, #12
0c188     58 AD 1A F2 | 	cmp	local04, local06 wcz
0c18c     24 00 90 ED |  if_be	jmp	#LR__1843
0c190     14 A6 06 F1 | 	add	local01, #20
0c194     53 AD 02 FB | 	rdlong	local04, local01
0c198     08 A6 86 F1 | 	sub	local01, #8
0c19c     53 AD 62 FC | 	wrlong	local04, local01
0c1a0     04 A6 06 F1 | 	add	local01, #4
0c1a4     53 AD C2 FA | 	rdbyte	local04, local01
0c1a8     40 AC 46 F5 | 	or	local04, #64
0c1ac     53 AD 42 FC | 	wrbyte	local04, local01
0c1b0     10 A6 86 F1 | 	sub	local01, #16
0c1b4                 | LR__1843
0c1b4     14 A6 06 F1 | 	add	local01, #20
0c1b8     53 AD 02 FB | 	rdlong	local04, local01
0c1bc     14 A6 86 F1 | 	sub	local01, #20
0c1c0     FF AD CE F7 | 	test	local04, #511 wz
0c1c4     1C A6 06 51 |  if_ne	add	local01, #28
0c1c8     53 AF 02 5B |  if_ne	rdlong	local05, local01
0c1cc     1C A6 86 51 |  if_ne	sub	local01, #28
0c1d0     57 B5 0A 52 |  if_ne	cmp	local08, local05 wz
0c1d4     B0 00 90 AD |  if_e	jmp	#LR__1845
0c1d8     10 A6 06 F1 | 	add	local01, #16
0c1dc     53 AD C2 FA | 	rdbyte	local04, local01
0c1e0     10 A6 86 F1 | 	sub	local01, #16
0c1e4     80 AC CE F7 | 	test	local04, #128 wz
0c1e8     58 00 90 AD |  if_e	jmp	#LR__1844
0c1ec     10 CE 05 F1 | 	add	fp, #16
0c1f0     E7 B6 02 FB | 	rdlong	local09, fp
0c1f4     10 CE 85 F1 | 	sub	fp, #16
0c1f8     01 B6 06 F1 | 	add	local09, #1
0c1fc     5B 91 C2 FA | 	rdbyte	arg01, local09
0c200     28 A6 06 F1 | 	add	local01, #40
0c204     53 93 02 F6 | 	mov	arg02, local01
0c208     0C A6 86 F1 | 	sub	local01, #12
0c20c     53 95 02 FB | 	rdlong	arg03, local01
0c210     1C A6 86 F1 | 	sub	local01, #28
0c214     01 96 06 F6 | 	mov	arg04, #1
0c218     68 BC BF FD | 	call	#_fatfs_cc_disk_write
0c21c     00 76 0E F2 | 	cmp	result1, #0 wz
0c220     11 A6 06 51 |  if_ne	add	local01, #17
0c224     53 03 48 5C |  if_ne	wrbyte	#1, local01
0c228     01 76 06 56 |  if_ne	mov	result1, #1
0c22c     5C 00 90 5D |  if_ne	jmp	#LR__1846
0c230     10 A6 06 F1 | 	add	local01, #16
0c234     53 AD C2 FA | 	rdbyte	local04, local01
0c238     7F AC 06 F5 | 	and	local04, #127
0c23c     53 AD 42 FC | 	wrbyte	local04, local01
0c240     10 A6 86 F1 | 	sub	local01, #16
0c244                 | LR__1844
0c244     10 CE 05 F1 | 	add	fp, #16
0c248     E7 B6 02 FB | 	rdlong	local09, fp
0c24c     10 CE 85 F1 | 	sub	fp, #16
0c250     01 B6 06 F1 | 	add	local09, #1
0c254     5B 91 C2 FA | 	rdbyte	arg01, local09
0c258     53 93 02 F6 | 	mov	arg02, local01
0c25c     28 92 06 F1 | 	add	arg02, #40
0c260     5A 95 02 F6 | 	mov	arg03, local08
0c264     01 96 06 F6 | 	mov	arg04, #1
0c268     DC BA BF FD | 	call	#_fatfs_cc_disk_read
0c26c     00 76 0E F2 | 	cmp	result1, #0 wz
0c270     11 A6 06 51 |  if_ne	add	local01, #17
0c274     53 03 48 5C |  if_ne	wrbyte	#1, local01
0c278     01 76 06 56 |  if_ne	mov	result1, #1
0c27c     0C 00 90 5D |  if_ne	jmp	#LR__1846
0c280     1C A6 06 F1 | 	add	local01, #28
0c284     53 B5 62 FC | 	wrlong	local08, local01
0c288                 | LR__1845
0c288                 | ' 
0c288                 | ' 			fp->sect = nsect;
0c288                 | ' 		}
0c288                 | ' 	}
0c288                 | ' 
0c288                 | ' 	return res ;
0c288     55 77 02 F6 | 	mov	result1, local03
0c28c                 | LR__1846
0c28c     E7 F0 03 F6 | 	mov	ptra, fp
0c290     F2 00 A0 FD | 	call	#popregs_
0c294                 | _fatfs_cc_f_lseek_ret
0c294     2D 00 64 FD | 	ret
0c298                 | 
0c298                 | _fatfs_cc_f_opendir
0c298     02 CA 05 F6 | 	mov	COUNT_, #2
0c29c     E8 00 A0 FD | 	call	#pushregs_
0c2a0     14 F0 07 F1 | 	add	ptra, #20
0c2a4     48 A7 0A F6 | 	mov	local01, arg01 wz
0c2a8     08 CE 05 F1 | 	add	fp, #8
0c2ac     E7 92 62 FC | 	wrlong	arg02, fp
0c2b0     08 CE 85 F1 | 	sub	fp, #8
0c2b4     09 76 06 A6 |  if_e	mov	result1, #9
0c2b8     EC 00 90 AD |  if_e	jmp	#LR__1856
0c2bc     08 CE 05 F1 | 	add	fp, #8
0c2c0     E7 90 02 F6 | 	mov	arg01, fp
0c2c4     08 CE 05 F1 | 	add	fp, #8
0c2c8     E7 92 02 F6 | 	mov	arg02, fp
0c2cc     10 CE 85 F1 | 	sub	fp, #16
0c2d0     00 94 06 F6 | 	mov	arg03, #0
0c2d4     B4 E7 BF FD | 	call	#_fatfs_cc_mount_volume
0c2d8     3B A9 0A F6 | 	mov	local02, result1 wz
0c2dc     BC 00 90 5D |  if_ne	jmp	#LR__1855
0c2e0     10 CE 05 F1 | 	add	fp, #16
0c2e4     E7 A8 02 FB | 	rdlong	local02, fp
0c2e8     53 A9 62 FC | 	wrlong	local02, local01
0c2ec     08 CE 85 F1 | 	sub	fp, #8
0c2f0     E7 92 02 FB | 	rdlong	arg02, fp
0c2f4     08 CE 85 F1 | 	sub	fp, #8
0c2f8     53 91 02 F6 | 	mov	arg01, local01
0c2fc     F0 E2 BF FD | 	call	#_fatfs_cc_follow_path
0c300     3B A9 0A F6 | 	mov	local02, result1 wz
0c304     8C 00 90 5D |  if_ne	jmp	#LR__1854
0c308     2B A6 06 F1 | 	add	local01, #43
0c30c     53 95 C2 FA | 	rdbyte	arg03, local01
0c310     2B A6 86 F1 | 	sub	local01, #43
0c314     80 94 CE F7 | 	test	arg03, #128 wz
0c318     40 00 90 5D |  if_ne	jmp	#LR__1852
0c31c     06 A6 06 F1 | 	add	local01, #6
0c320     53 95 C2 FA | 	rdbyte	arg03, local01
0c324     06 A6 86 F1 | 	sub	local01, #6
0c328     10 94 CE F7 | 	test	arg03, #16 wz
0c32c     28 00 90 AD |  if_e	jmp	#LR__1850
0c330     10 CE 05 F1 | 	add	fp, #16
0c334     E7 90 02 FB | 	rdlong	arg01, fp
0c338     10 CE 85 F1 | 	sub	fp, #16
0c33c     1C A6 06 F1 | 	add	local01, #28
0c340     53 93 02 FB | 	rdlong	arg02, local01
0c344     C0 CD BF FD | 	call	#_fatfs_cc_ld_clust
0c348     14 A6 86 F1 | 	sub	local01, #20
0c34c     53 77 62 FC | 	wrlong	result1, local01
0c350     08 A6 86 F1 | 	sub	local01, #8
0c354     04 00 90 FD | 	jmp	#LR__1851
0c358                 | LR__1850
0c358     05 A8 06 F6 | 	mov	local02, #5
0c35c                 | LR__1851
0c35c                 | LR__1852
0c35c     00 A8 0E F2 | 	cmp	local02, #0 wz
0c360     30 00 90 5D |  if_ne	jmp	#LR__1853
0c364     10 CE 05 F1 | 	add	fp, #16
0c368     E7 A8 02 FB | 	rdlong	local02, fp
0c36c     10 CE 85 F1 | 	sub	fp, #16
0c370     06 A8 06 F1 | 	add	local02, #6
0c374     54 A9 E2 FA | 	rdword	local02, local02
0c378     04 A6 06 F1 | 	add	local01, #4
0c37c     53 A9 52 FC | 	wrword	local02, local01
0c380     04 A6 86 F1 | 	sub	local01, #4
0c384     53 91 02 F6 | 	mov	arg01, local01
0c388     00 92 06 F6 | 	mov	arg02, #0
0c38c     A4 C9 BF FD | 	call	#_fatfs_cc_dir_sdi
0c390     3B A9 02 F6 | 	mov	local02, result1
0c394                 | LR__1853
0c394                 | LR__1854
0c394     04 A8 0E F2 | 	cmp	local02, #4 wz
0c398     05 A8 06 A6 |  if_e	mov	local02, #5
0c39c                 | LR__1855
0c39c     00 A8 0E F2 | 	cmp	local02, #0 wz
0c3a0     53 01 68 5C |  if_ne	wrlong	#0, local01
0c3a4                 | ' 
0c3a4                 | ' 	return res ;
0c3a4     54 77 02 F6 | 	mov	result1, local02
0c3a8                 | LR__1856
0c3a8     E7 F0 03 F6 | 	mov	ptra, fp
0c3ac     F2 00 A0 FD | 	call	#popregs_
0c3b0                 | _fatfs_cc_f_opendir_ret
0c3b0     2D 00 64 FD | 	ret
0c3b4                 | 
0c3b4                 | _fatfs_cc_f_closedir
0c3b4     01 CA 05 F6 | 	mov	COUNT_, #1
0c3b8     E8 00 A0 FD | 	call	#pushregs_
0c3bc     10 F0 07 F1 | 	add	ptra, #16
0c3c0     48 A7 02 F6 | 	mov	local01, arg01
0c3c4     E7 92 02 F6 | 	mov	arg02, fp
0c3c8     0C 92 06 F1 | 	add	arg02, #12
0c3cc     53 91 02 F6 | 	mov	arg01, local01
0c3d0     E8 EB BF FD | 	call	#_fatfs_cc_validate
0c3d4     00 76 4E F2 | 	cmps	result1, #0 wz
0c3d8     53 01 68 AC |  if_e	wrlong	#0, local01
0c3dc                 | ' 
0c3dc                 | ' 
0c3dc                 | ' 
0c3dc                 | ' 
0c3dc                 | ' 		dp->obj.fs = 0;
0c3dc                 | ' #line 4633 "ff.c"
0c3dc                 | ' 	}
0c3dc                 | ' 	return res;
0c3dc     E7 F0 03 F6 | 	mov	ptra, fp
0c3e0     F2 00 A0 FD | 	call	#popregs_
0c3e4                 | _fatfs_cc_f_closedir_ret
0c3e4     2D 00 64 FD | 	ret
0c3e8                 | 
0c3e8                 | _fatfs_cc_f_readdir
0c3e8     03 CA 05 F6 | 	mov	COUNT_, #3
0c3ec     E8 00 A0 FD | 	call	#pushregs_
0c3f0     14 F0 07 F1 | 	add	ptra, #20
0c3f4     48 A7 02 F6 | 	mov	local01, arg01
0c3f8     49 A9 02 F6 | 	mov	local02, arg02
0c3fc     E7 92 02 F6 | 	mov	arg02, fp
0c400     10 92 06 F1 | 	add	arg02, #16
0c404     53 91 02 F6 | 	mov	arg01, local01
0c408     B0 EB BF FD | 	call	#_fatfs_cc_validate
0c40c     3B AB 0A F6 | 	mov	local03, result1 wz
0c410     60 00 90 5D |  if_ne	jmp	#LR__1863
0c414     00 A8 0E F2 | 	cmp	local02, #0 wz
0c418     14 00 90 5D |  if_ne	jmp	#LR__1860
0c41c     53 91 02 F6 | 	mov	arg01, local01
0c420     00 92 06 F6 | 	mov	arg02, #0
0c424     0C C9 BF FD | 	call	#_fatfs_cc_dir_sdi
0c428     3B AB 02 F6 | 	mov	local03, result1
0c42c     44 00 90 FD | 	jmp	#LR__1862
0c430                 | LR__1860
0c430     53 91 02 F6 | 	mov	arg01, local01
0c434     00 92 06 F6 | 	mov	arg02, #0
0c438     98 D1 BF FD | 	call	#_fatfs_cc_dir_read
0c43c     3B AB 02 F6 | 	mov	local03, result1
0c440     04 AA 0E F2 | 	cmp	local03, #4 wz
0c444     00 AA 06 A6 |  if_e	mov	local03, #0
0c448     00 AA 0E F2 | 	cmp	local03, #0 wz
0c44c     24 00 90 5D |  if_ne	jmp	#LR__1861
0c450     53 91 02 F6 | 	mov	arg01, local01
0c454     54 93 02 F6 | 	mov	arg02, local02
0c458     E4 D8 BF FD | 	call	#_fatfs_cc_get_fileinfo
0c45c     53 91 02 F6 | 	mov	arg01, local01
0c460     00 92 06 F6 | 	mov	arg02, #0
0c464     34 CA BF FD | 	call	#_fatfs_cc_dir_next
0c468     3B AB 02 F6 | 	mov	local03, result1
0c46c     04 AA 0E F2 | 	cmp	local03, #4 wz
0c470     00 AA 06 A6 |  if_e	mov	local03, #0
0c474                 | LR__1861
0c474                 | LR__1862
0c474                 | LR__1863
0c474                 | ' 			}
0c474                 | ' 			;
0c474                 | ' 		}
0c474                 | ' 	}
0c474                 | ' 	return res ;
0c474     55 77 02 F6 | 	mov	result1, local03
0c478     E7 F0 03 F6 | 	mov	ptra, fp
0c47c     F2 00 A0 FD | 	call	#popregs_
0c480                 | _fatfs_cc_f_readdir_ret
0c480     2D 00 64 FD | 	ret
0c484                 | 
0c484                 | _fatfs_cc_f_stat
0c484     02 CA 05 F6 | 	mov	COUNT_, #2
0c488     E8 00 A0 FD | 	call	#pushregs_
0c48c     40 F0 07 F1 | 	add	ptra, #64
0c490     04 CE 05 F1 | 	add	fp, #4
0c494     E7 90 62 FC | 	wrlong	arg01, fp
0c498     49 A7 02 F6 | 	mov	local01, arg02
0c49c     E7 90 02 F6 | 	mov	arg01, fp
0c4a0     0C CE 05 F1 | 	add	fp, #12
0c4a4     E7 92 02 F6 | 	mov	arg02, fp
0c4a8     10 CE 85 F1 | 	sub	fp, #16
0c4ac     00 94 06 F6 | 	mov	arg03, #0
0c4b0     D8 E5 BF FD | 	call	#_fatfs_cc_mount_volume
0c4b4     3B A9 0A F6 | 	mov	local02, result1 wz
0c4b8     4C 00 90 5D |  if_ne	jmp	#LR__1872
0c4bc     10 CE 05 F1 | 	add	fp, #16
0c4c0     E7 90 02 F6 | 	mov	arg01, fp
0c4c4     0C CE 85 F1 | 	sub	fp, #12
0c4c8     E7 92 02 FB | 	rdlong	arg02, fp
0c4cc     04 CE 85 F1 | 	sub	fp, #4
0c4d0     1C E1 BF FD | 	call	#_fatfs_cc_follow_path
0c4d4     3B A9 0A F6 | 	mov	local02, result1 wz
0c4d8     2C 00 90 5D |  if_ne	jmp	#LR__1871
0c4dc     3B CE 05 F1 | 	add	fp, #59
0c4e0     E7 94 C2 FA | 	rdbyte	arg03, fp
0c4e4     3B CE 85 F1 | 	sub	fp, #59
0c4e8     80 94 CE F7 | 	test	arg03, #128 wz
0c4ec     06 A8 06 56 |  if_ne	mov	local02, #6
0c4f0     14 00 90 5D |  if_ne	jmp	#LR__1870
0c4f4     00 A6 0E F2 | 	cmp	local01, #0 wz
0c4f8     E7 90 02 56 |  if_ne	mov	arg01, fp
0c4fc     10 90 06 51 |  if_ne	add	arg01, #16
0c500     53 93 02 56 |  if_ne	mov	arg02, local01
0c504     38 D8 BF 5D |  if_ne	call	#_fatfs_cc_get_fileinfo
0c508                 | LR__1870
0c508                 | LR__1871
0c508                 | LR__1872
0c508                 | ' 			}
0c508                 | ' 		}
0c508                 | ' 		;
0c508                 | ' 	}
0c508                 | ' 
0c508                 | ' 	return res ;
0c508     54 77 02 F6 | 	mov	result1, local02
0c50c     E7 F0 03 F6 | 	mov	ptra, fp
0c510     F2 00 A0 FD | 	call	#popregs_
0c514                 | _fatfs_cc_f_stat_ret
0c514     2D 00 64 FD | 	ret
0c518                 | 
0c518                 | _fatfs_cc_f_unlink
0c518     02 CA 05 F6 | 	mov	COUNT_, #2
0c51c     E8 00 A0 FD | 	call	#pushregs_
0c520     74 F0 07 F1 | 	add	ptra, #116
0c524     04 CE 05 F1 | 	add	fp, #4
0c528     E7 90 62 FC | 	wrlong	arg01, fp
0c52c     00 A6 06 F6 | 	mov	local01, #0
0c530     E7 90 02 F6 | 	mov	arg01, fp
0c534     6C CE 05 F1 | 	add	fp, #108
0c538     E7 92 02 F6 | 	mov	arg02, fp
0c53c     70 CE 85 F1 | 	sub	fp, #112
0c540     02 94 06 F6 | 	mov	arg03, #2
0c544     44 E5 BF FD | 	call	#_fatfs_cc_mount_volume
0c548     3B A9 0A F6 | 	mov	local02, result1 wz
0c54c     3C 01 90 5D |  if_ne	jmp	#LR__1888
0c550     70 CE 05 F1 | 	add	fp, #112
0c554     E7 A8 02 FB | 	rdlong	local02, fp
0c558     64 CE 85 F1 | 	sub	fp, #100
0c55c     E7 A8 62 FC | 	wrlong	local02, fp
0c560     E7 90 02 F6 | 	mov	arg01, fp
0c564     08 CE 85 F1 | 	sub	fp, #8
0c568     E7 92 02 FB | 	rdlong	arg02, fp
0c56c     04 CE 85 F1 | 	sub	fp, #4
0c570     7C E0 BF FD | 	call	#_fatfs_cc_follow_path
0c574     3B A9 0A F6 | 	mov	local02, result1 wz
0c578     10 01 90 5D |  if_ne	jmp	#LR__1887
0c57c     37 CE 05 F1 | 	add	fp, #55
0c580     E7 76 C2 FA | 	rdbyte	result1, fp
0c584     37 CE 85 F1 | 	sub	fp, #55
0c588     80 76 CE F7 | 	test	result1, #128 wz
0c58c     06 A8 06 56 |  if_ne	mov	local02, #6
0c590     14 00 90 5D |  if_ne	jmp	#LR__1880
0c594     12 CE 05 F1 | 	add	fp, #18
0c598     E7 76 C2 FA | 	rdbyte	result1, fp
0c59c     12 CE 85 F1 | 	sub	fp, #18
0c5a0     01 76 CE F7 | 	test	result1, #1 wz
0c5a4     07 A8 06 56 |  if_ne	mov	local02, #7
0c5a8                 | LR__1880
0c5a8     00 A8 0E F2 | 	cmp	local02, #0 wz
0c5ac     84 00 90 5D |  if_ne	jmp	#LR__1883
0c5b0     70 CE 05 F1 | 	add	fp, #112
0c5b4     E7 90 02 FB | 	rdlong	arg01, fp
0c5b8     48 CE 85 F1 | 	sub	fp, #72
0c5bc     E7 92 02 FB | 	rdlong	arg02, fp
0c5c0     28 CE 85 F1 | 	sub	fp, #40
0c5c4     40 CB BF FD | 	call	#_fatfs_cc_ld_clust
0c5c8     3B A7 02 F6 | 	mov	local01, result1
0c5cc     12 CE 05 F1 | 	add	fp, #18
0c5d0     E7 76 C2 FA | 	rdbyte	result1, fp
0c5d4     12 CE 85 F1 | 	sub	fp, #18
0c5d8     10 76 CE F7 | 	test	result1, #16 wz
0c5dc     54 00 90 AD |  if_e	jmp	#LR__1882
0c5e0     70 CE 05 F1 | 	add	fp, #112
0c5e4     E7 A8 02 FB | 	rdlong	local02, fp
0c5e8     34 CE 85 F1 | 	sub	fp, #52
0c5ec     E7 A8 62 FC | 	wrlong	local02, fp
0c5f0     08 CE 05 F1 | 	add	fp, #8
0c5f4     E7 A6 62 FC | 	wrlong	local01, fp
0c5f8     08 CE 85 F1 | 	sub	fp, #8
0c5fc     E7 90 02 F6 | 	mov	arg01, fp
0c600     3C CE 85 F1 | 	sub	fp, #60
0c604     00 92 06 F6 | 	mov	arg02, #0
0c608     28 C7 BF FD | 	call	#_fatfs_cc_dir_sdi
0c60c     3B A9 0A F6 | 	mov	local02, result1 wz
0c610     20 00 90 5D |  if_ne	jmp	#LR__1881
0c614     E7 90 02 F6 | 	mov	arg01, fp
0c618     3C 90 06 F1 | 	add	arg01, #60
0c61c     00 92 06 F6 | 	mov	arg02, #0
0c620     B0 CF BF FD | 	call	#_fatfs_cc_dir_read
0c624     3B A9 0A F6 | 	mov	local02, result1 wz
0c628     07 A8 06 A6 |  if_e	mov	local02, #7
0c62c     04 A8 0E F2 | 	cmp	local02, #4 wz
0c630     00 A8 06 A6 |  if_e	mov	local02, #0
0c634                 | LR__1881
0c634                 | LR__1882
0c634                 | LR__1883
0c634     00 A8 0E F2 | 	cmp	local02, #0 wz
0c638     50 00 90 5D |  if_ne	jmp	#LR__1886
0c63c     E7 90 02 F6 | 	mov	arg01, fp
0c640     0C 90 06 F1 | 	add	arg01, #12
0c644     30 D6 BF FD | 	call	#_fatfs_cc_dir_remove
0c648     3B A9 0A F6 | 	mov	local02, result1 wz
0c64c     20 00 90 5D |  if_ne	jmp	#LR__1884
0c650     00 A6 0E F2 | 	cmp	local01, #0 wz
0c654     18 00 90 AD |  if_e	jmp	#LR__1884
0c658     E7 90 02 F6 | 	mov	arg01, fp
0c65c     0C 90 06 F1 | 	add	arg01, #12
0c660     53 93 02 F6 | 	mov	arg02, local01
0c664     00 94 06 F6 | 	mov	arg03, #0
0c668     D0 C2 BF FD | 	call	#_fatfs_cc_remove_chain
0c66c     3B A9 02 F6 | 	mov	local02, result1
0c670                 | LR__1884
0c670     00 A8 0E F2 | 	cmp	local02, #0 wz
0c674     14 00 90 5D |  if_ne	jmp	#LR__1885
0c678     70 CE 05 F1 | 	add	fp, #112
0c67c     E7 90 02 FB | 	rdlong	arg01, fp
0c680     70 CE 85 F1 | 	sub	fp, #112
0c684     C0 BD BF FD | 	call	#_fatfs_cc_sync_fs
0c688     3B A9 02 F6 | 	mov	local02, result1
0c68c                 | LR__1885
0c68c                 | LR__1886
0c68c                 | LR__1887
0c68c                 | LR__1888
0c68c                 | ' 			}
0c68c                 | ' 		}
0c68c                 | ' 		;
0c68c                 | ' 	}
0c68c                 | ' 
0c68c                 | ' 	return res ;
0c68c     54 77 02 F6 | 	mov	result1, local02
0c690     E7 F0 03 F6 | 	mov	ptra, fp
0c694     F2 00 A0 FD | 	call	#popregs_
0c698                 | _fatfs_cc_f_unlink_ret
0c698     2D 00 64 FD | 	ret
0c69c                 | 
0c69c                 | _fatfs_cc_f_mkdir
0c69c     03 CA 05 F6 | 	mov	COUNT_, #3
0c6a0     E8 00 A0 FD | 	call	#pushregs_
0c6a4     5C F0 07 F1 | 	add	ptra, #92
0c6a8     04 CE 05 F1 | 	add	fp, #4
0c6ac     E7 90 62 FC | 	wrlong	arg01, fp
0c6b0     E7 90 02 F6 | 	mov	arg01, fp
0c6b4     48 CE 05 F1 | 	add	fp, #72
0c6b8     E7 92 02 F6 | 	mov	arg02, fp
0c6bc     4C CE 85 F1 | 	sub	fp, #76
0c6c0     02 94 06 F6 | 	mov	arg03, #2
0c6c4     C4 E3 BF FD | 	call	#_fatfs_cc_mount_volume
0c6c8     3B A7 0A F6 | 	mov	local01, result1 wz
0c6cc     FC 01 90 5D |  if_ne	jmp	#LR__1895
0c6d0     4C CE 05 F1 | 	add	fp, #76
0c6d4     E7 A6 02 FB | 	rdlong	local01, fp
0c6d8     40 CE 85 F1 | 	sub	fp, #64
0c6dc     E7 A6 62 FC | 	wrlong	local01, fp
0c6e0     E7 90 02 F6 | 	mov	arg01, fp
0c6e4     08 CE 85 F1 | 	sub	fp, #8
0c6e8     E7 92 02 FB | 	rdlong	arg02, fp
0c6ec     04 CE 85 F1 | 	sub	fp, #4
0c6f0     FC DE BF FD | 	call	#_fatfs_cc_follow_path
0c6f4     3B A7 0A F6 | 	mov	local01, result1 wz
0c6f8     08 A6 06 A6 |  if_e	mov	local01, #8
0c6fc     04 A6 0E F2 | 	cmp	local01, #4 wz
0c700     C8 01 90 5D |  if_ne	jmp	#LR__1894
0c704     4C CE 05 F1 | 	add	fp, #76
0c708     E7 A6 02 FB | 	rdlong	local01, fp
0c70c     10 CE 85 F1 | 	sub	fp, #16
0c710     E7 A6 62 FC | 	wrlong	local01, fp
0c714     E7 90 02 F6 | 	mov	arg01, fp
0c718     3C CE 85 F1 | 	sub	fp, #60
0c71c     00 92 06 F6 | 	mov	arg02, #0
0c720     2C C3 BF FD | 	call	#_fatfs_cc_create_chain
0c724     3B A9 0A F6 | 	mov	local02, result1 wz
0c728     00 A6 06 F6 | 	mov	local01, #0
0c72c     07 A6 06 A6 |  if_e	mov	local01, #7
0c730     01 A8 0E F2 | 	cmp	local02, #1 wz
0c734     02 A6 06 A6 |  if_e	mov	local01, #2
0c738     FF FF 7F FF 
0c73c     FF A9 0E F2 | 	cmp	local02, ##-1 wz
0c740     01 A6 06 A6 |  if_e	mov	local01, #1
0c744     8C 06 B0 FD | 	call	#_fatfs_cc__get_fattime
0c748     3B AB 02 F6 | 	mov	local03, result1
0c74c     00 A6 0E F2 | 	cmp	local01, #0 wz
0c750     EC 00 90 5D |  if_ne	jmp	#LR__1891
0c754     4C CE 05 F1 | 	add	fp, #76
0c758     E7 90 02 FB | 	rdlong	arg01, fp
0c75c     4C CE 85 F1 | 	sub	fp, #76
0c760     54 93 02 F6 | 	mov	arg02, local02
0c764     0C C5 BF FD | 	call	#_fatfs_cc_dir_clear
0c768     3B A7 0A F6 | 	mov	local01, result1 wz
0c76c     D0 00 90 5D |  if_ne	jmp	#LR__1890
0c770     4C CE 05 F1 | 	add	fp, #76
0c774     E7 90 02 FB | 	rdlong	arg01, fp
0c778     4C CE 85 F1 | 	sub	fp, #76
0c77c     34 90 06 F1 | 	add	arg01, #52
0c780     20 92 06 F6 | 	mov	arg02, #32
0c784     0B 94 06 F6 | 	mov	arg03, #11
0c788     D8 00 A0 FD | 	call	#\builtin_bytefill_
0c78c     4C CE 05 F1 | 	add	fp, #76
0c790     E7 A6 02 FB | 	rdlong	local01, fp
0c794     34 A6 06 F1 | 	add	local01, #52
0c798     53 5D 48 FC | 	wrbyte	#46, local01
0c79c     E7 A6 02 FB | 	rdlong	local01, fp
0c7a0     3F A6 06 F1 | 	add	local01, #63
0c7a4     53 21 48 FC | 	wrbyte	#16, local01
0c7a8     E7 90 02 FB | 	rdlong	arg01, fp
0c7ac     4A 90 06 F1 | 	add	arg01, #74
0c7b0     48 AB 62 FC | 	wrlong	local03, arg01
0c7b4     E7 92 02 FB | 	rdlong	arg02, fp
0c7b8     49 91 02 F6 | 	mov	arg01, arg02
0c7bc     4C CE 85 F1 | 	sub	fp, #76
0c7c0     34 92 06 F1 | 	add	arg02, #52
0c7c4     54 95 02 F6 | 	mov	arg03, local02
0c7c8     70 C9 BF FD | 	call	#_fatfs_cc_st_clust
0c7cc     4C CE 05 F1 | 	add	fp, #76
0c7d0     E7 92 02 FB | 	rdlong	arg02, fp
0c7d4     49 91 02 F6 | 	mov	arg01, arg02
0c7d8     54 90 06 F1 | 	add	arg01, #84
0c7dc     4C CE 85 F1 | 	sub	fp, #76
0c7e0     34 92 06 F1 | 	add	arg02, #52
0c7e4     20 94 06 F6 | 	mov	arg03, #32
0c7e8     EC 64 BF FD | 	call	#__system____builtin_memmove
0c7ec     4C CE 05 F1 | 	add	fp, #76
0c7f0     E7 A6 02 FB | 	rdlong	local01, fp
0c7f4     55 A6 06 F1 | 	add	local01, #85
0c7f8     53 5D 48 FC | 	wrbyte	#46, local01
0c7fc     38 CE 85 F1 | 	sub	fp, #56
0c800     E7 94 02 FB | 	rdlong	arg03, fp
0c804     38 CE 05 F1 | 	add	fp, #56
0c808     E7 92 02 FB | 	rdlong	arg02, fp
0c80c     49 91 02 F6 | 	mov	arg01, arg02
0c810     4C CE 85 F1 | 	sub	fp, #76
0c814     54 92 06 F1 | 	add	arg02, #84
0c818     20 C9 BF FD | 	call	#_fatfs_cc_st_clust
0c81c     4C CE 05 F1 | 	add	fp, #76
0c820     E7 A6 02 FB | 	rdlong	local01, fp
0c824     4C CE 85 F1 | 	sub	fp, #76
0c828     03 A6 06 F1 | 	add	local01, #3
0c82c     53 03 48 FC | 	wrbyte	#1, local01
0c830     E7 90 02 F6 | 	mov	arg01, fp
0c834     0C 90 06 F1 | 	add	arg01, #12
0c838     D8 D1 BF FD | 	call	#_fatfs_cc_dir_register
0c83c     3B A7 02 F6 | 	mov	local01, result1
0c840                 | LR__1890
0c840                 | LR__1891
0c840     00 A6 0E F2 | 	cmp	local01, #0 wz
0c844     70 00 90 5D |  if_ne	jmp	#LR__1892
0c848     28 CE 05 F1 | 	add	fp, #40
0c84c     E7 90 02 FB | 	rdlong	arg01, fp
0c850     16 90 06 F1 | 	add	arg01, #22
0c854     48 AB 62 FC | 	wrlong	local03, arg01
0c858     24 CE 05 F1 | 	add	fp, #36
0c85c     E7 90 02 FB | 	rdlong	arg01, fp
0c860     24 CE 85 F1 | 	sub	fp, #36
0c864     E7 92 02 FB | 	rdlong	arg02, fp
0c868     28 CE 85 F1 | 	sub	fp, #40
0c86c     54 95 02 F6 | 	mov	arg03, local02
0c870     C8 C8 BF FD | 	call	#_fatfs_cc_st_clust
0c874     28 CE 05 F1 | 	add	fp, #40
0c878     E7 AA 02 FB | 	rdlong	local03, fp
0c87c     0B AA 06 F1 | 	add	local03, #11
0c880     55 21 48 FC | 	wrbyte	#16, local03
0c884     24 CE 05 F1 | 	add	fp, #36
0c888     E7 AA 02 FB | 	rdlong	local03, fp
0c88c     4C CE 85 F1 | 	sub	fp, #76
0c890     03 AA 06 F1 | 	add	local03, #3
0c894     55 03 48 FC | 	wrbyte	#1, local03
0c898     00 A6 0E F2 | 	cmp	local01, #0 wz
0c89c     2C 00 90 5D |  if_ne	jmp	#LR__1893
0c8a0     4C CE 05 F1 | 	add	fp, #76
0c8a4     E7 90 02 FB | 	rdlong	arg01, fp
0c8a8     4C CE 85 F1 | 	sub	fp, #76
0c8ac     98 BB BF FD | 	call	#_fatfs_cc_sync_fs
0c8b0     3B A7 02 F6 | 	mov	local01, result1
0c8b4     14 00 90 FD | 	jmp	#LR__1893
0c8b8                 | LR__1892
0c8b8     E7 90 02 F6 | 	mov	arg01, fp
0c8bc     3C 90 06 F1 | 	add	arg01, #60
0c8c0     54 93 02 F6 | 	mov	arg02, local02
0c8c4     00 94 06 F6 | 	mov	arg03, #0
0c8c8     70 C0 BF FD | 	call	#_fatfs_cc_remove_chain
0c8cc                 | LR__1893
0c8cc                 | LR__1894
0c8cc                 | LR__1895
0c8cc                 | ' 				remove_chain(&sobj, dcl, 0);
0c8cc                 | ' 			}
0c8cc                 | ' 		}
0c8cc                 | ' 		;
0c8cc                 | ' 	}
0c8cc                 | ' 
0c8cc                 | ' 	return res ;
0c8cc     53 77 02 F6 | 	mov	result1, local01
0c8d0     E7 F0 03 F6 | 	mov	ptra, fp
0c8d4     F2 00 A0 FD | 	call	#popregs_
0c8d8                 | _fatfs_cc_f_mkdir_ret
0c8d8     2D 00 64 FD | 	ret
0c8dc                 | 
0c8dc                 | _fatfs_cc_f_rename
0c8dc     03 CA 05 F6 | 	mov	COUNT_, #3
0c8e0     E8 00 A0 FD | 	call	#pushregs_
0c8e4     9C F0 07 F1 | 	add	ptra, #156
0c8e8     04 CE 05 F1 | 	add	fp, #4
0c8ec     E7 90 62 FC | 	wrlong	arg01, fp
0c8f0     04 CE 05 F1 | 	add	fp, #4
0c8f4     E7 92 62 FC | 	wrlong	arg02, fp
0c8f8     E7 90 02 F6 | 	mov	arg01, fp
0c8fc     08 CE 85 F1 | 	sub	fp, #8
0c900     4C DE BF FD | 	call	#_fatfs_cc_get_ldnumber
0c904     04 CE 05 F1 | 	add	fp, #4
0c908     E7 90 02 F6 | 	mov	arg01, fp
0c90c     6C CE 05 F1 | 	add	fp, #108
0c910     E7 92 02 F6 | 	mov	arg02, fp
0c914     70 CE 85 F1 | 	sub	fp, #112
0c918     02 94 06 F6 | 	mov	arg03, #2
0c91c     6C E1 BF FD | 	call	#_fatfs_cc_mount_volume
0c920     3B A7 0A F6 | 	mov	local01, result1 wz
0c924     68 02 90 5D |  if_ne	jmp	#LR__1912
0c928     70 CE 05 F1 | 	add	fp, #112
0c92c     E7 A8 02 FB | 	rdlong	local02, fp
0c930     60 CE 85 F1 | 	sub	fp, #96
0c934     E7 A8 62 FC | 	wrlong	local02, fp
0c938     E7 90 02 F6 | 	mov	arg01, fp
0c93c     0C CE 85 F1 | 	sub	fp, #12
0c940     E7 92 02 FB | 	rdlong	arg02, fp
0c944     04 CE 85 F1 | 	sub	fp, #4
0c948     A4 DC BF FD | 	call	#_fatfs_cc_follow_path
0c94c     3B A7 0A F6 | 	mov	local01, result1 wz
0c950     14 00 90 5D |  if_ne	jmp	#LR__1900
0c954     3B CE 05 F1 | 	add	fp, #59
0c958     E7 A8 C2 FA | 	rdbyte	local02, fp
0c95c     3B CE 85 F1 | 	sub	fp, #59
0c960     A0 A8 CE F7 | 	test	local02, #160 wz
0c964     06 A6 06 56 |  if_ne	mov	local01, #6
0c968                 | LR__1900
0c968     00 A6 0E F2 | 	cmp	local01, #0 wz
0c96c     20 02 90 5D |  if_ne	jmp	#LR__1911
0c970     74 CE 05 F1 | 	add	fp, #116
0c974     E7 90 02 F6 | 	mov	arg01, fp
0c978     48 CE 85 F1 | 	sub	fp, #72
0c97c     E7 92 02 FB | 	rdlong	arg02, fp
0c980     2C CE 85 F1 | 	sub	fp, #44
0c984     20 94 06 F6 | 	mov	arg03, #32
0c988     4C 63 BF FD | 	call	#__system____builtin_memmove
0c98c     40 CE 05 F1 | 	add	fp, #64
0c990     E7 90 02 F6 | 	mov	arg01, fp
0c994     30 CE 85 F1 | 	sub	fp, #48
0c998     E7 92 02 F6 | 	mov	arg02, fp
0c99c     10 CE 85 F1 | 	sub	fp, #16
0c9a0     30 94 06 F6 | 	mov	arg03, #48
0c9a4     30 63 BF FD | 	call	#__system____builtin_memmove
0c9a8     40 CE 05 F1 | 	add	fp, #64
0c9ac     E7 90 02 F6 | 	mov	arg01, fp
0c9b0     38 CE 85 F1 | 	sub	fp, #56
0c9b4     E7 92 02 FB | 	rdlong	arg02, fp
0c9b8     08 CE 85 F1 | 	sub	fp, #8
0c9bc     30 DC BF FD | 	call	#_fatfs_cc_follow_path
0c9c0     3B A7 0A F6 | 	mov	local01, result1 wz
0c9c4     44 00 90 5D |  if_ne	jmp	#LR__1903
0c9c8     48 CE 05 F1 | 	add	fp, #72
0c9cc     E7 A6 02 FB | 	rdlong	local01, fp
0c9d0     30 CE 85 F1 | 	sub	fp, #48
0c9d4     E7 76 02 FB | 	rdlong	result1, fp
0c9d8     18 CE 85 F1 | 	sub	fp, #24
0c9dc     3B A7 0A F2 | 	cmp	local01, result1 wz
0c9e0     20 00 90 5D |  if_ne	jmp	#LR__1901
0c9e4     50 CE 05 F1 | 	add	fp, #80
0c9e8     E7 A6 02 FB | 	rdlong	local01, fp
0c9ec     30 CE 85 F1 | 	sub	fp, #48
0c9f0     E7 76 02 FB | 	rdlong	result1, fp
0c9f4     20 CE 85 F1 | 	sub	fp, #32
0c9f8     3B A7 0A F2 | 	cmp	local01, result1 wz
0c9fc     04 A8 06 A6 |  if_e	mov	local02, #4
0ca00     04 00 90 AD |  if_e	jmp	#LR__1902
0ca04                 | LR__1901
0ca04     08 A8 06 F6 | 	mov	local02, #8
0ca08                 | LR__1902
0ca08     54 A7 02 F6 | 	mov	local01, local02
0ca0c                 | LR__1903
0ca0c     04 A6 0E F2 | 	cmp	local01, #4 wz
0ca10     4C 01 90 5D |  if_ne	jmp	#LR__1908
0ca14     E7 90 02 F6 | 	mov	arg01, fp
0ca18     40 90 06 F1 | 	add	arg01, #64
0ca1c     F4 CF BF FD | 	call	#_fatfs_cc_dir_register
0ca20     3B A7 0A F6 | 	mov	local01, result1 wz
0ca24     38 01 90 5D |  if_ne	jmp	#LR__1907
0ca28     5C CE 05 F1 | 	add	fp, #92
0ca2c     E7 AA 02 FB | 	rdlong	local03, fp
0ca30     55 91 02 F6 | 	mov	arg01, local03
0ca34     0D 90 06 F1 | 	add	arg01, #13
0ca38     18 CE 05 F1 | 	add	fp, #24
0ca3c     E7 92 02 F6 | 	mov	arg02, fp
0ca40     74 CE 85 F1 | 	sub	fp, #116
0ca44     0D 92 06 F1 | 	add	arg02, #13
0ca48     13 94 06 F6 | 	mov	arg03, #19
0ca4c     88 62 BF FD | 	call	#__system____builtin_memmove
0ca50     7F CE 05 F1 | 	add	fp, #127
0ca54     E7 A8 C2 FA | 	rdbyte	local02, fp
0ca58     0B AA 06 F1 | 	add	local03, #11
0ca5c     55 A9 42 FC | 	wrbyte	local02, local03
0ca60     54 A9 E2 F8 | 	getbyte	local02, local02, #0
0ca64     0B AA 86 F1 | 	sub	local03, #11
0ca68     10 A8 CE F7 | 	test	local02, #16 wz
0ca6c     0B AA 06 A1 |  if_e	add	local03, #11
0ca70     55 A9 C2 AA |  if_e	rdbyte	local02, local03
0ca74     20 A8 46 A5 |  if_e	or	local02, #32
0ca78     55 A9 42 AC |  if_e	wrbyte	local02, local03
0ca7c     0B AA 86 A1 |  if_e	sub	local03, #11
0ca80     0F CE 85 F1 | 	sub	fp, #15
0ca84     E7 A8 02 FB | 	rdlong	local02, fp
0ca88     70 CE 85 F1 | 	sub	fp, #112
0ca8c     03 A8 06 F1 | 	add	local02, #3
0ca90     54 03 48 FC | 	wrbyte	#1, local02
0ca94     0B AA 06 F1 | 	add	local03, #11
0ca98     55 A9 C2 FA | 	rdbyte	local02, local03
0ca9c     0B AA 86 F1 | 	sub	local03, #11
0caa0     10 A8 CE F7 | 	test	local02, #16 wz
0caa4     B8 00 90 AD |  if_e	jmp	#LR__1906
0caa8     18 CE 05 F1 | 	add	fp, #24
0caac     E7 A8 02 FB | 	rdlong	local02, fp
0cab0     30 CE 05 F1 | 	add	fp, #48
0cab4     E7 94 02 FB | 	rdlong	arg03, fp
0cab8     48 CE 85 F1 | 	sub	fp, #72
0cabc     4A A9 0A F2 | 	cmp	local02, arg03 wz
0cac0     9C 00 90 AD |  if_e	jmp	#LR__1906
0cac4     70 CE 05 F1 | 	add	fp, #112
0cac8     E7 90 02 FB | 	rdlong	arg01, fp
0cacc     48 A9 02 F6 | 	mov	local02, arg01
0cad0     70 CE 85 F1 | 	sub	fp, #112
0cad4     55 93 02 F6 | 	mov	arg02, local03
0cad8     2C C6 BF FD | 	call	#_fatfs_cc_ld_clust
0cadc     3B 93 02 F6 | 	mov	arg02, result1
0cae0     54 91 02 F6 | 	mov	arg01, local02
0cae4     60 BA BF FD | 	call	#_fatfs_cc_clst2sect
0cae8     3B AB 0A F6 | 	mov	local03, result1 wz
0caec     02 A6 06 A6 |  if_e	mov	local01, #2
0caf0     6C 00 90 AD |  if_e	jmp	#LR__1905
0caf4     70 CE 05 F1 | 	add	fp, #112
0caf8     E7 90 02 FB | 	rdlong	arg01, fp
0cafc     70 CE 85 F1 | 	sub	fp, #112
0cb00     55 93 02 F6 | 	mov	arg02, local03
0cb04     C8 B8 BF FD | 	call	#_fatfs_cc_move_window
0cb08     3B A7 0A F6 | 	mov	local01, result1 wz
0cb0c     70 CE 05 F1 | 	add	fp, #112
0cb10     E7 AA 02 FB | 	rdlong	local03, fp
0cb14     70 CE 85 F1 | 	sub	fp, #112
0cb18     54 AA 06 F1 | 	add	local03, #84
0cb1c     01 AA 06 A1 |  if_e	add	local03, #1
0cb20     55 A9 C2 AA |  if_e	rdbyte	local02, local03
0cb24     01 AA 86 A1 |  if_e	sub	local03, #1
0cb28     2E A8 0E A2 |  if_e	cmp	local02, #46 wz
0cb2c     30 00 90 5D |  if_ne	jmp	#LR__1904
0cb30     70 CE 05 F1 | 	add	fp, #112
0cb34     E7 90 02 FB | 	rdlong	arg01, fp
0cb38     28 CE 85 F1 | 	sub	fp, #40
0cb3c     E7 94 02 FB | 	rdlong	arg03, fp
0cb40     48 CE 85 F1 | 	sub	fp, #72
0cb44     55 93 02 F6 | 	mov	arg02, local03
0cb48     F0 C5 BF FD | 	call	#_fatfs_cc_st_clust
0cb4c     70 CE 05 F1 | 	add	fp, #112
0cb50     E7 A8 02 FB | 	rdlong	local02, fp
0cb54     70 CE 85 F1 | 	sub	fp, #112
0cb58     03 A8 06 F1 | 	add	local02, #3
0cb5c     54 03 48 FC | 	wrbyte	#1, local02
0cb60                 | LR__1904
0cb60                 | LR__1905
0cb60                 | LR__1906
0cb60                 | LR__1907
0cb60                 | LR__1908
0cb60     00 A6 0E F2 | 	cmp	local01, #0 wz
0cb64     28 00 90 5D |  if_ne	jmp	#LR__1910
0cb68     E7 90 02 F6 | 	mov	arg01, fp
0cb6c     10 90 06 F1 | 	add	arg01, #16
0cb70     04 D1 BF FD | 	call	#_fatfs_cc_dir_remove
0cb74     3B A7 0A F6 | 	mov	local01, result1 wz
0cb78     14 00 90 5D |  if_ne	jmp	#LR__1909
0cb7c     70 CE 05 F1 | 	add	fp, #112
0cb80     E7 90 02 FB | 	rdlong	arg01, fp
0cb84     70 CE 85 F1 | 	sub	fp, #112
0cb88     BC B8 BF FD | 	call	#_fatfs_cc_sync_fs
0cb8c     3B A7 02 F6 | 	mov	local01, result1
0cb90                 | LR__1909
0cb90                 | LR__1910
0cb90                 | LR__1911
0cb90                 | LR__1912
0cb90                 | ' 					res = sync_fs(fs);
0cb90                 | ' 				}
0cb90                 | ' 			}
0cb90                 | ' 
0cb90                 | ' 		}
0cb90                 | ' 		;
0cb90                 | ' 	}
0cb90                 | ' 
0cb90                 | ' 	return res ;
0cb90     53 77 02 F6 | 	mov	result1, local01
0cb94     E7 F0 03 F6 | 	mov	ptra, fp
0cb98     F2 00 A0 FD | 	call	#popregs_
0cb9c                 | _fatfs_cc_f_rename_ret
0cb9c     2D 00 64 FD | 	ret
0cba0                 | 
0cba0                 | _fatfs_cc___default_flush
0cba0     07 CA 05 F6 | 	mov	COUNT_, #7
0cba4     E8 00 A0 FD | 	call	#pushregs_
0cba8     48 A7 02 F6 | 	mov	local01, arg01
0cbac     53 A9 02 FB | 	rdlong	local02, local01
0cbb0     54 AB 02 FB | 	rdlong	local03, local02
0cbb4     08 A6 06 F1 | 	add	local01, #8
0cbb8     53 79 02 FB | 	rdlong	result2, local01
0cbbc     08 A6 86 F1 | 	sub	local01, #8
0cbc0     08 78 CE F7 | 	test	result2, #8 wz
0cbc4     D4 00 90 AD |  if_e	jmp	#LR__1922
0cbc8     01 AA 56 F2 | 	cmps	local03, #1 wc
0cbcc     2C 01 90 CD |  if_b	jmp	#LR__1924
0cbd0     08 A6 06 F1 | 	add	local01, #8
0cbd4     53 79 02 FB | 	rdlong	result2, local01
0cbd8     08 A6 86 F1 | 	sub	local01, #8
0cbdc     80 78 CE F7 | 	test	result2, #128 wz
0cbe0     6C 00 90 AD |  if_e	jmp	#LR__1921
0cbe4     08 A6 06 F1 | 	add	local01, #8
0cbe8     53 95 02 FB | 	rdlong	arg03, local01
0cbec     08 A6 86 F1 | 	sub	local01, #8
0cbf0     00 95 CE F7 | 	test	arg03, #256 wz
0cbf4     58 00 90 AD |  if_e	jmp	#LR__1920
0cbf8     30 A6 06 F1 | 	add	local01, #48
0cbfc     53 AD 02 FB | 	rdlong	local04, local01
0cc00     56 AF 02 F6 | 	mov	local05, local04
0cc04     30 A6 86 F1 | 	sub	local01, #48
0cc08     13 AE 46 F7 | 	zerox	local05, #19
0cc0c     14 AC 46 F0 | 	shr	local04, #20
0cc10     02 AC 66 F0 | 	shl	local04, #2
0cc14     2D AD 02 F1 | 	add	local04, __methods__
0cc18     56 AD 02 FB | 	rdlong	local04, local04
0cc1c     53 91 02 F6 | 	mov	arg01, local01
0cc20     00 92 06 F6 | 	mov	arg02, #0
0cc24     00 94 06 F6 | 	mov	arg03, #0
0cc28     02 96 06 F6 | 	mov	arg04, #2
0cc2c     31 B1 02 F6 | 	mov	local06, objptr
0cc30     57 63 02 F6 | 	mov	objptr, local05
0cc34     2D AC 62 FD | 	call	local04
0cc38     58 63 02 F6 | 	mov	objptr, local06
0cc3c     08 A6 06 F1 | 	add	local01, #8
0cc40     53 B1 02 FB | 	rdlong	local06, local01
0cc44     00 B1 26 F5 | 	andn	local06, #256
0cc48     53 B1 62 FC | 	wrlong	local06, local01
0cc4c     08 A6 86 F1 | 	sub	local01, #8
0cc50                 | LR__1920
0cc50                 | LR__1921
0cc50     18 A6 06 F1 | 	add	local01, #24
0cc54     53 AD 02 FB | 	rdlong	local04, local01
0cc58     56 AF 02 F6 | 	mov	local05, local04
0cc5c     18 A6 86 F1 | 	sub	local01, #24
0cc60     13 AE 46 F7 | 	zerox	local05, #19
0cc64     14 AC 46 F0 | 	shr	local04, #20
0cc68     02 AC 66 F0 | 	shl	local04, #2
0cc6c     2D AD 02 F1 | 	add	local04, __methods__
0cc70     56 AD 02 FB | 	rdlong	local04, local04
0cc74     0C A8 06 F1 | 	add	local02, #12
0cc78     54 93 02 FB | 	rdlong	arg02, local02
0cc7c     0C A8 86 F1 | 	sub	local02, #12
0cc80     53 91 02 F6 | 	mov	arg01, local01
0cc84     55 95 02 F6 | 	mov	arg03, local03
0cc88     31 B1 02 F6 | 	mov	local06, objptr
0cc8c     57 63 02 F6 | 	mov	objptr, local05
0cc90     2D AC 62 FD | 	call	local04
0cc94     58 63 02 F6 | 	mov	objptr, local06
0cc98     60 00 90 FD | 	jmp	#LR__1924
0cc9c                 | LR__1922
0cc9c     08 A6 06 F1 | 	add	local01, #8
0cca0     53 B1 02 FB | 	rdlong	local06, local01
0cca4     08 A6 86 F1 | 	sub	local01, #8
0cca8     04 B0 CE F7 | 	test	local06, #4 wz
0ccac     00 AA 0E 52 |  if_ne	cmp	local03, #0 wz
0ccb0     48 00 90 AD |  if_e	jmp	#LR__1923
0ccb4     55 93 62 F6 | 	neg	arg02, local03
0ccb8     49 95 02 F6 | 	mov	arg03, arg02
0ccbc     1F 94 C6 F0 | 	sar	arg03, #31
0ccc0     30 A6 06 F1 | 	add	local01, #48
0ccc4     53 AD 02 FB | 	rdlong	local04, local01
0ccc8     56 AF 02 F6 | 	mov	local05, local04
0cccc     30 A6 86 F1 | 	sub	local01, #48
0ccd0     13 AE 46 F7 | 	zerox	local05, #19
0ccd4     14 AC 46 F0 | 	shr	local04, #20
0ccd8     02 AC 66 F0 | 	shl	local04, #2
0ccdc     2D AD 02 F1 | 	add	local04, __methods__
0cce0     56 AD 02 FB | 	rdlong	local04, local04
0cce4     53 91 02 F6 | 	mov	arg01, local01
0cce8     01 96 06 F6 | 	mov	arg04, #1
0ccec     31 B1 02 F6 | 	mov	local06, objptr
0ccf0     57 63 02 F6 | 	mov	objptr, local05
0ccf4     2D AC 62 FD | 	call	local04
0ccf8     58 63 02 F6 | 	mov	objptr, local06
0ccfc                 | LR__1923
0ccfc                 | LR__1924
0ccfc     54 01 68 FC | 	wrlong	#0, local02
0cd00     04 A8 06 F1 | 	add	local02, #4
0cd04     54 01 68 FC | 	wrlong	#0, local02
0cd08     08 A6 06 F1 | 	add	local01, #8
0cd0c     53 B3 02 FB | 	rdlong	local07, local01
0cd10     0C B2 26 F5 | 	andn	local07, #12
0cd14     53 B3 62 FC | 	wrlong	local07, local01
0cd18                 | '     }
0cd18                 | '     b->cnt = 0;
0cd18                 | '     b->ptr = 0;
0cd18                 | '     f->state &= ~( (0x08) | (0x04) );
0cd18                 | '     return 0;
0cd18     00 76 06 F6 | 	mov	result1, #0
0cd1c     E7 F0 03 F6 | 	mov	ptra, fp
0cd20     F2 00 A0 FD | 	call	#popregs_
0cd24                 | _fatfs_cc___default_flush_ret
0cd24     2D 00 64 FD | 	ret
0cd28                 | 
0cd28                 | _fatfs_cc_getenv
0cd28     06 CA 05 F6 | 	mov	COUNT_, #6
0cd2c     E8 00 A0 FD | 	call	#pushregs_
0cd30     48 A7 02 F6 | 	mov	local01, arg01
0cd34     48 A9 02 F6 | 	mov	local02, arg01
0cd38     D7 06 48 FB | 	callpa	#(@LR__1931-@LR__1930)>>2,fcache_load_ptr_
0cd3c                 | LR__1930
0cd3c     54 77 CA FA | 	rdbyte	result1, local02 wz
0cd40     01 A8 06 51 |  if_ne	add	local02, #1
0cd44     F4 FF 9F 5D |  if_ne	jmp	#LR__1930
0cd48                 | LR__1931
0cd48     48 A9 82 F1 | 	sub	local02, arg01
0cd4c     54 77 02 F6 | 	mov	result1, local02
0cd50     02 00 00 FF 
0cd54     FC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1276
0cd58     35 95 0A FB | 	rdlong	arg03, ptr__fatfs_cc_dat__ wz
0cd5c     02 00 00 FF 
0cd60     FC 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1276
0cd64                 | '             return 0;
0cd64     00 76 06 A6 |  if_e	mov	result1, #0
0cd68     5C 00 90 AD |  if_e	jmp	#LR__1934
0cd6c                 | ' 
0cd6c                 | ' 	for (var = _environ_ptr; (name = *var) != 0; var++) {
0cd6c     02 00 00 FF 
0cd70     FC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1276
0cd74     35 AB 02 FB | 	rdlong	local03, ptr__fatfs_cc_dat__
0cd78     02 00 00 FF 
0cd7c     FC 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1276
0cd80                 | LR__1932
0cd80     55 AD 0A FB | 	rdlong	local04, local03 wz
0cd84     3C 00 90 AD |  if_e	jmp	#LR__1933
0cd88     56 91 02 F6 | 	mov	arg01, local04
0cd8c     53 93 02 F6 | 	mov	arg02, local01
0cd90     54 95 02 F6 | 	mov	arg03, local02
0cd94     24 AB BF FD | 	call	#_fatfs_cc_strncmp
0cd98     00 76 0E F2 | 	cmp	result1, #0 wz
0cd9c     54 AF 02 A6 |  if_e	mov	local05, local02
0cda0     56 AF 02 A1 |  if_e	add	local05, local04
0cda4     57 B1 C2 AA |  if_e	rdbyte	local06, local05
0cda8     3D B0 0E A2 |  if_e	cmp	local06, #61 wz
0cdac                 | ' 			return name+len+1;
0cdac     54 AD 02 A1 |  if_e	add	local04, local02
0cdb0     01 AC 06 A1 |  if_e	add	local04, #1
0cdb4     56 77 02 A6 |  if_e	mov	result1, local04
0cdb8     0C 00 90 AD |  if_e	jmp	#LR__1934
0cdbc     04 AA 06 F1 | 	add	local03, #4
0cdc0     BC FF 9F FD | 	jmp	#LR__1932
0cdc4                 | LR__1933
0cdc4                 | ' 	}
0cdc4                 | ' 	return 0;
0cdc4     00 76 06 F6 | 	mov	result1, #0
0cdc8                 | LR__1934
0cdc8     E7 F0 03 F6 | 	mov	ptra, fp
0cdcc     F2 00 A0 FD | 	call	#popregs_
0cdd0                 | _fatfs_cc_getenv_ret
0cdd0     2D 00 64 FD | 	ret
0cdd4                 | 
0cdd4                 | _fatfs_cc__get_fattime
0cdd4     00 CA 05 F6 | 	mov	COUNT_, #0
0cdd8     E8 00 A0 FD | 	call	#pushregs_
0cddc     34 F0 07 F1 | 	add	ptra, #52
0cde0     00 90 06 F6 | 	mov	arg01, #0
0cde4     A4 AB BF FD | 	call	#_fatfs_cc_time
0cde8     04 CE 05 F1 | 	add	fp, #4
0cdec     E7 76 62 FC | 	wrlong	result1, fp
0cdf0     E7 90 02 F6 | 	mov	arg01, fp
0cdf4     0C CE 05 F1 | 	add	fp, #12
0cdf8     E7 92 02 F6 | 	mov	arg02, fp
0cdfc     10 CE 85 F1 | 	sub	fp, #16
0ce00     70 AD BF FD | 	call	#_fatfs_cc__gmtime_r
0ce04     24 CE 05 F1 | 	add	fp, #36
0ce08     E7 76 02 FB | 	rdlong	result1, fp
0ce0c     50 76 86 F1 | 	sub	result1, #80
0ce10     09 76 66 F0 | 	shl	result1, #9
0ce14     04 CE 85 F1 | 	sub	fp, #4
0ce18     E7 92 02 FB | 	rdlong	arg02, fp
0ce1c     01 92 06 F1 | 	add	arg02, #1
0ce20     05 92 66 F0 | 	shl	arg02, #5
0ce24     49 77 42 F5 | 	or	result1, arg02
0ce28     04 CE 85 F1 | 	sub	fp, #4
0ce2c     E7 92 02 FB | 	rdlong	arg02, fp
0ce30     49 77 42 F5 | 	or	result1, arg02
0ce34     04 CE 85 F1 | 	sub	fp, #4
0ce38     E7 92 02 FB | 	rdlong	arg02, fp
0ce3c     0B 92 66 F0 | 	shl	arg02, #11
0ce40     04 CE 85 F1 | 	sub	fp, #4
0ce44     E7 90 02 FB | 	rdlong	arg01, fp
0ce48     05 90 66 F0 | 	shl	arg01, #5
0ce4c     48 93 42 F5 | 	or	arg02, arg01
0ce50     04 CE 85 F1 | 	sub	fp, #4
0ce54     E7 90 02 FB | 	rdlong	arg01, fp
0ce58     10 CE 85 F1 | 	sub	fp, #16
0ce5c     48 93 42 F5 | 	or	arg02, arg01
0ce60                 | ' 
0ce60                 | '     now = time(0);
0ce60                 | '     _gmtime_r (&now, &date);
0ce60                 | '     ffdate = ((date.tm_year - 80) << 9) | ((date.tm_mon + 1) << 5) | ((date.tm_mday));
0ce60                 | '     fftime = (date.tm_hour << 11) | (date.tm_min << 5) | (date.tm_sec);
0ce60                 | '     return (ffdate << 16) | fftime;
0ce60     10 76 66 F0 | 	shl	result1, #16
0ce64     49 77 42 F5 | 	or	result1, arg02
0ce68     E7 F0 03 F6 | 	mov	ptra, fp
0ce6c     F2 00 A0 FD | 	call	#popregs_
0ce70                 | _fatfs_cc__get_fattime_ret
0ce70     2D 00 64 FD | 	ret
0ce74                 | 
0ce74                 | _fatfs_cc_unixtime_0593
0ce74     02 CA 05 F6 | 	mov	COUNT_, #2
0ce78     E8 00 A0 FD | 	call	#pushregs_
0ce7c     34 F0 07 F1 | 	add	ptra, #52
0ce80     48 A7 02 F6 | 	mov	local01, arg01
0ce84     09 A6 46 F0 | 	shr	local01, #9
0ce88     7F A6 06 F5 | 	and	local01, #127
0ce8c     50 A8 06 F6 | 	mov	local02, #80
0ce90     53 A9 02 F1 | 	add	local02, local01
0ce94     24 CE 05 F1 | 	add	fp, #36
0ce98     E7 A8 62 FC | 	wrlong	local02, fp
0ce9c     48 A9 02 F6 | 	mov	local02, arg01
0cea0     05 A8 46 F0 | 	shr	local02, #5
0cea4     54 A9 42 F8 | 	getnib	local02, local02, #0
0cea8     01 A8 86 F1 | 	sub	local02, #1
0ceac     04 CE 85 F1 | 	sub	fp, #4
0ceb0     E7 A8 62 FC | 	wrlong	local02, fp
0ceb4     1F 90 06 F5 | 	and	arg01, #31
0ceb8     04 CE 85 F1 | 	sub	fp, #4
0cebc     E7 90 62 FC | 	wrlong	arg01, fp
0cec0     49 A9 02 F6 | 	mov	local02, arg02
0cec4     0B A8 46 F0 | 	shr	local02, #11
0cec8     1F A8 06 F5 | 	and	local02, #31
0cecc     04 CE 85 F1 | 	sub	fp, #4
0ced0     E7 A8 62 FC | 	wrlong	local02, fp
0ced4     49 A9 02 F6 | 	mov	local02, arg02
0ced8     05 A8 46 F0 | 	shr	local02, #5
0cedc     3F A8 06 F5 | 	and	local02, #63
0cee0     04 CE 85 F1 | 	sub	fp, #4
0cee4     E7 A8 62 FC | 	wrlong	local02, fp
0cee8     1F 92 06 F5 | 	and	arg02, #31
0ceec     01 92 66 F0 | 	shl	arg02, #1
0cef0     04 CE 85 F1 | 	sub	fp, #4
0cef4     E7 92 62 FC | 	wrlong	arg02, fp
0cef8     E7 90 02 F6 | 	mov	arg01, fp
0cefc     10 CE 85 F1 | 	sub	fp, #16
0cf00     C8 AA BF FD | 	call	#_fatfs_cc_mktime
0cf04                 | ' 
0cf04                 | '     date.tm_year = 80 + ((dosdate >> 9) & 0x7f);
0cf04                 | '     date.tm_mon = ((dosdate >> 5) & 0xf) - 1;
0cf04                 | '     date.tm_mday = (dosdate & 0x1f);
0cf04                 | '     date.tm_hour = (dostime >> 11) & 0x1f;
0cf04                 | '     date.tm_min = (dostime >> 5) & 0x3f;
0cf04                 | '     date.tm_sec = (dostime & 0x1f) << 1;
0cf04                 | ' 
0cf04                 | '     t = mktime(&date);
0cf04                 | ' #line 66 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0cf04                 | '     return t;
0cf04     E7 F0 03 F6 | 	mov	ptra, fp
0cf08     F2 00 A0 FD | 	call	#popregs_
0cf0c                 | _fatfs_cc_unixtime_0593_ret
0cf0c     2D 00 64 FD | 	ret
0cf10                 | 
0cf10                 | _fatfs_cc__set_dos_error_0595
0cf10     48 7D 02 F6 | 	mov	_var01, arg01
0cf14                 | ' #line 82 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0cf14                 | '     switch (derr) {
0cf14     14 7C 26 F3 | 	fle	_var01, #20
0cf18     30 7C 62 FD | 	jmprel	_var01
0cf1c                 | LR__1940
0cf1c     50 00 90 FD | 	jmp	#LR__1941
0cf20     84 00 90 FD | 	jmp	#LR__1955
0cf24     80 00 90 FD | 	jmp	#LR__1956
0cf28     7C 00 90 FD | 	jmp	#LR__1957
0cf2c     48 00 90 FD | 	jmp	#LR__1942
0cf30     44 00 90 FD | 	jmp	#LR__1943
0cf34     40 00 90 FD | 	jmp	#LR__1944
0cf38     44 00 90 FD | 	jmp	#LR__1945
0cf3c     48 00 90 FD | 	jmp	#LR__1947
0cf40     54 00 90 FD | 	jmp	#LR__1950
0cf44     38 00 90 FD | 	jmp	#LR__1946
0cf48     4C 00 90 FD | 	jmp	#LR__1951
0cf4c     48 00 90 FD | 	jmp	#LR__1952
0cf50     44 00 90 FD | 	jmp	#LR__1953
0cf54     50 00 90 FD | 	jmp	#LR__1958
0cf58     4C 00 90 FD | 	jmp	#LR__1958
0cf5c     48 00 90 FD | 	jmp	#LR__1958
0cf60     2C 00 90 FD | 	jmp	#LR__1948
0cf64     38 00 90 FD | 	jmp	#LR__1954
0cf68     2C 00 90 FD | 	jmp	#LR__1949
0cf6c     38 00 90 FD | 	jmp	#LR__1958
0cf70                 | LR__1941
0cf70     00 7E 06 F6 | 	mov	_var02, #0
0cf74                 | '         r = 0;
0cf74                 | '         break;
0cf74     34 00 90 FD | 	jmp	#LR__1959
0cf78                 | LR__1942
0cf78                 | LR__1943
0cf78                 | LR__1944
0cf78     04 7E 06 F6 | 	mov	_var02, #4
0cf7c                 | '         r =  4 ;
0cf7c                 | '         break;
0cf7c     2C 00 90 FD | 	jmp	#LR__1959
0cf80                 | LR__1945
0cf80                 | LR__1946
0cf80     06 7E 06 F6 | 	mov	_var02, #6
0cf84                 | '         r =  6 ;
0cf84                 | '         break;
0cf84     24 00 90 FD | 	jmp	#LR__1959
0cf88                 | LR__1947
0cf88     09 7E 06 F6 | 	mov	_var02, #9
0cf8c                 | '         r =  9 ;
0cf8c                 | '         break;
0cf8c     1C 00 90 FD | 	jmp	#LR__1959
0cf90                 | LR__1948
0cf90     07 7E 06 F6 | 	mov	_var02, #7
0cf94                 | '         r =  7 ;
0cf94                 | '         break;
0cf94     14 00 90 FD | 	jmp	#LR__1959
0cf98                 | LR__1949
0cf98                 | LR__1950
0cf98                 | LR__1951
0cf98                 | LR__1952
0cf98                 | LR__1953
0cf98     0A 7E 06 F6 | 	mov	_var02, #10
0cf9c                 | '         r =  10 ;
0cf9c                 | '         break;
0cf9c     0C 00 90 FD | 	jmp	#LR__1959
0cfa0                 | LR__1954
0cfa0     0B 7E 06 F6 | 	mov	_var02, #11
0cfa4                 | '         r =  11 ;
0cfa4                 | '         break;
0cfa4     04 00 90 FD | 	jmp	#LR__1959
0cfa8                 | LR__1955
0cfa8                 | LR__1956
0cfa8                 | LR__1957
0cfa8                 | LR__1958
0cfa8     0C 7E 06 F6 | 	mov	_var02, #12
0cfac                 | '         r =  12 ;
0cfac                 | '         break;
0cfac                 | LR__1959
0cfac                 | '     }
0cfac                 | '     return _seterror(r);
0cfac     00 7E 4E F2 | 	cmps	_var02, #0 wz
0cfb0     20 66 06 F1 | 	add	ptr___system__dat__, #32
0cfb4     33 7F 62 FC | 	wrlong	_var02, ptr___system__dat__
0cfb8     20 66 86 F1 | 	sub	ptr___system__dat__, #32
0cfbc     01 76 66 56 |  if_ne	neg	result1, #1
0cfc0     00 76 06 A6 |  if_e	mov	result1, #0
0cfc4                 | _fatfs_cc__set_dos_error_0595_ret
0cfc4     2D 00 64 FD | 	ret
0cfc8                 | 
0cfc8                 | _fatfs_cc_v_creat
0cfc8     04 CA 05 F6 | 	mov	COUNT_, #4
0cfcc     E8 00 A0 FD | 	call	#pushregs_
0cfd0     48 A7 02 F6 | 	mov	local01, arg01
0cfd4     49 A9 02 F6 | 	mov	local02, arg02
0cfd8     03 00 00 FF 
0cfdc     38 90 06 F6 | 	mov	arg01, ##1592
0cfe0                 | '     return _gc_alloc(size);
0cfe0     10 92 06 F6 | 	mov	arg02, #16
0cfe4     20 7F BF FD | 	call	#__system___gc_doalloc
0cfe8     3B AB 0A F6 | 	mov	local03, result1 wz
0cfec                 | '       return _seterror( 7 );
0cfec     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0cff0     33 0F 68 AC |  if_e	wrlong	#7, ptr___system__dat__
0cff4     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0cff8     01 76 66 A6 |  if_e	neg	result1, #1
0cffc     50 00 90 AD |  if_e	jmp	#LR__1961
0d000     55 91 02 F6 | 	mov	arg01, local03
0d004     00 92 06 F6 | 	mov	arg02, #0
0d008     03 00 00 FF 
0d00c     38 94 06 F6 | 	mov	arg03, ##1592
0d010     D8 00 A0 FD | 	call	#\builtin_bytefill_
0d014     55 91 02 F6 | 	mov	arg01, local03
0d018     02 00 00 FF 
0d01c     10 90 06 F1 | 	add	arg01, ##1040
0d020     54 93 02 F6 | 	mov	arg02, local02
0d024     07 94 06 F6 | 	mov	arg03, #7
0d028     D8 E0 BF FD | 	call	#_fatfs_cc_f_open
0d02c     3B AD 0A F6 | 	mov	local04, result1 wz
0d030     14 00 90 AD |  if_e	jmp	#LR__1960
0d034     55 91 02 F6 | 	mov	arg01, local03
0d038                 | '     return _gc_free(ptr);
0d038     D0 7F BF FD | 	call	#__system___gc_free
0d03c                 | '     free(f);
0d03c                 | '     return _set_dos_error(r);
0d03c     56 91 02 F6 | 	mov	arg01, local04
0d040     CC FE BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d044     08 00 90 FD | 	jmp	#LR__1961
0d048                 | LR__1960
0d048     53 AB 62 FC | 	wrlong	local03, local01
0d04c                 | '   }
0d04c                 | '   fil->vfsdata = f;
0d04c                 | '   return 0;
0d04c     00 76 06 F6 | 	mov	result1, #0
0d050                 | LR__1961
0d050     E7 F0 03 F6 | 	mov	ptra, fp
0d054     F2 00 A0 FD | 	call	#popregs_
0d058                 | _fatfs_cc_v_creat_ret
0d058     2D 00 64 FD | 	ret
0d05c                 | 
0d05c                 | _fatfs_cc_v_close
0d05c     02 CA 05 F6 | 	mov	COUNT_, #2
0d060     E8 00 A0 FD | 	call	#pushregs_
0d064     48 A7 02 FB | 	rdlong	local01, arg01
0d068     53 91 02 F6 | 	mov	arg01, local01
0d06c     02 00 00 FF 
0d070     10 90 06 F1 | 	add	arg01, ##1040
0d074     34 EE BF FD | 	call	#_fatfs_cc_f_close
0d078     3B A9 02 F6 | 	mov	local02, result1
0d07c     53 91 02 F6 | 	mov	arg01, local01
0d080                 | '     return _gc_free(ptr);
0d080     88 7F BF FD | 	call	#__system___gc_free
0d084                 | '     FAT_FIL *f = fil->vfsdata;
0d084                 | '     r=f_close(&f->fil);
0d084                 | '     free(f);
0d084                 | '     return _set_dos_error(r);
0d084     54 91 02 F6 | 	mov	arg01, local02
0d088     84 FE BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d08c     E7 F0 03 F6 | 	mov	ptra, fp
0d090     F2 00 A0 FD | 	call	#popregs_
0d094                 | _fatfs_cc_v_close_ret
0d094     2D 00 64 FD | 	ret
0d098                 | 
0d098                 | _fatfs_cc_v_opendir
0d098     04 CA 05 F6 | 	mov	COUNT_, #4
0d09c     E8 00 A0 FD | 	call	#pushregs_
0d0a0     48 A7 02 F6 | 	mov	local01, arg01
0d0a4     49 A9 02 F6 | 	mov	local02, arg02
0d0a8     30 90 06 F6 | 	mov	arg01, #48
0d0ac                 | '     return _gc_alloc(size);
0d0ac     10 92 06 F6 | 	mov	arg02, #16
0d0b0     54 7E BF FD | 	call	#__system___gc_doalloc
0d0b4     3B AB 0A F6 | 	mov	local03, result1 wz
0d0b8                 | ' #line 166 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d0b8                 | '       return _seterror( 7 );
0d0b8     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d0bc     33 0F 68 AC |  if_e	wrlong	#7, ptr___system__dat__
0d0c0     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d0c4     01 76 66 A6 |  if_e	neg	result1, #1
0d0c8     34 00 90 AD |  if_e	jmp	#LR__1971
0d0cc     54 93 02 F6 | 	mov	arg02, local02
0d0d0     55 91 02 F6 | 	mov	arg01, local03
0d0d4     C0 F1 BF FD | 	call	#_fatfs_cc_f_opendir
0d0d8     3B AD 0A F6 | 	mov	local04, result1 wz
0d0dc     14 00 90 AD |  if_e	jmp	#LR__1970
0d0e0     55 91 02 F6 | 	mov	arg01, local03
0d0e4                 | '     return _gc_free(ptr);
0d0e4     24 7F BF FD | 	call	#__system___gc_free
0d0e8                 | '         free(f);
0d0e8                 | '         return _set_dos_error(r);
0d0e8     56 91 02 F6 | 	mov	arg01, local04
0d0ec     20 FE BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d0f0     0C 00 90 FD | 	jmp	#LR__1971
0d0f4                 | LR__1970
0d0f4     04 A6 06 F1 | 	add	local01, #4
0d0f8     53 AB 62 FC | 	wrlong	local03, local01
0d0fc                 | '     }
0d0fc                 | '     dir->vfsdata = f;
0d0fc                 | '     return 0;
0d0fc     00 76 06 F6 | 	mov	result1, #0
0d100                 | LR__1971
0d100     E7 F0 03 F6 | 	mov	ptra, fp
0d104     F2 00 A0 FD | 	call	#popregs_
0d108                 | _fatfs_cc_v_opendir_ret
0d108     2D 00 64 FD | 	ret
0d10c                 | 
0d10c                 | _fatfs_cc_v_closedir
0d10c     02 CA 05 F6 | 	mov	COUNT_, #2
0d110     E8 00 A0 FD | 	call	#pushregs_
0d114     04 90 06 F1 | 	add	arg01, #4
0d118     48 A7 02 FB | 	rdlong	local01, arg01
0d11c     53 91 02 F6 | 	mov	arg01, local01
0d120     90 F2 BF FD | 	call	#_fatfs_cc_f_closedir
0d124     3B A9 02 F6 | 	mov	local02, result1
0d128     53 91 02 F6 | 	mov	arg01, local01
0d12c                 | '     return _gc_free(ptr);
0d12c     DC 7E BF FD | 	call	#__system___gc_free
0d130     00 A8 0E F2 | 	cmp	local02, #0 wz
0d134     54 91 02 56 |  if_ne	mov	arg01, local02
0d138     D4 FD BF 5D |  if_ne	call	#_fatfs_cc__set_dos_error_0595
0d13c                 | '     return r;
0d13c     54 77 02 F6 | 	mov	result1, local02
0d140     E7 F0 03 F6 | 	mov	ptra, fp
0d144     F2 00 A0 FD | 	call	#popregs_
0d148                 | _fatfs_cc_v_closedir_ret
0d148     2D 00 64 FD | 	ret
0d14c                 | 
0d14c                 | _fatfs_cc_v_readdir
0d14c     01 CA 05 F6 | 	mov	COUNT_, #1
0d150     E8 00 A0 FD | 	call	#pushregs_
0d154     2C F1 07 F1 | 	add	ptra, #300
0d158     49 A7 02 F6 | 	mov	local01, arg02
0d15c     04 90 06 F1 | 	add	arg01, #4
0d160     48 91 02 FB | 	rdlong	arg01, arg01
0d164     E7 92 02 F6 | 	mov	arg02, fp
0d168     0C 92 06 F1 | 	add	arg02, #12
0d16c     78 F2 BF FD | 	call	#_fatfs_cc_f_readdir
0d170     3B 95 0A F6 | 	mov	arg03, result1 wz
0d174     0C 00 90 AD |  if_e	jmp	#LR__1980
0d178                 | '         return _set_dos_error(r);
0d178     4A 91 02 F6 | 	mov	arg01, arg03
0d17c     90 FD BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d180     88 00 90 FD | 	jmp	#LR__1981
0d184                 | LR__1980
0d184     28 CE 05 F1 | 	add	fp, #40
0d188     E7 94 CA FA | 	rdbyte	arg03, fp wz
0d18c     28 CE 85 F1 | 	sub	fp, #40
0d190                 | '         return -1;
0d190     01 76 66 A6 |  if_e	neg	result1, #1
0d194     74 00 90 AD |  if_e	jmp	#LR__1981
0d198     E7 92 02 F6 | 	mov	arg02, fp
0d19c     28 92 06 F1 | 	add	arg02, #40
0d1a0     53 91 02 F6 | 	mov	arg01, local01
0d1a4     3F 94 06 F6 | 	mov	arg03, #63
0d1a8     7C A6 BF FD | 	call	#_fatfs_cc_strncpy
0d1ac     3F A6 06 F1 | 	add	local01, #63
0d1b0     53 01 48 FC | 	wrbyte	#0, local01
0d1b4     3F A6 86 F1 | 	sub	local01, #63
0d1b8     14 CE 05 F1 | 	add	fp, #20
0d1bc     E7 94 C2 FA | 	rdbyte	arg03, fp
0d1c0     10 94 CE F7 | 	test	arg03, #16 wz
0d1c4     50 A6 06 51 |  if_ne	add	local01, #80
0d1c8     53 03 48 5C |  if_ne	wrbyte	#1, local01
0d1cc     50 A6 E6 F3 | 	sumnz	local01, #80
0d1d0     53 01 48 AC |  if_e	wrbyte	#0, local01
0d1d4     50 A6 86 A1 |  if_e	sub	local01, #80
0d1d8     08 CE 85 F1 | 	sub	fp, #8
0d1dc     E7 94 02 FB | 	rdlong	arg03, fp
0d1e0     48 A6 06 F1 | 	add	local01, #72
0d1e4     53 95 62 FC | 	wrlong	arg03, local01
0d1e8     04 CE 05 F1 | 	add	fp, #4
0d1ec     E7 90 E2 FA | 	rdword	arg01, fp
0d1f0     02 CE 05 F1 | 	add	fp, #2
0d1f4     E7 92 E2 FA | 	rdword	arg02, fp
0d1f8     12 CE 85 F1 | 	sub	fp, #18
0d1fc     74 FC BF FD | 	call	#_fatfs_cc_unixtime_0593
0d200     04 A6 06 F1 | 	add	local01, #4
0d204     53 77 62 FC | 	wrlong	result1, local01
0d208                 | '         ent->d_type =  (0) ;
0d208                 | '     }
0d208                 | '     ent->d_size = finfo.fsize;
0d208                 | '     ent->d_mtime = unixtime(finfo.fdate, finfo.ftime);
0d208                 | '     return 0;
0d208     00 76 06 F6 | 	mov	result1, #0
0d20c                 | LR__1981
0d20c     E7 F0 03 F6 | 	mov	ptra, fp
0d210     F2 00 A0 FD | 	call	#popregs_
0d214                 | _fatfs_cc_v_readdir_ret
0d214     2D 00 64 FD | 	ret
0d218                 | 
0d218                 | _fatfs_cc_v_stat
0d218     05 CA 05 F6 | 	mov	COUNT_, #5
0d21c     E8 00 A0 FD | 	call	#pushregs_
0d220     30 F1 07 F1 | 	add	ptra, #304
0d224     48 A7 02 F6 | 	mov	local01, arg01
0d228     49 A9 02 F6 | 	mov	local02, arg02
0d22c     54 91 02 F6 | 	mov	arg01, local02
0d230     00 92 06 F6 | 	mov	arg02, #0
0d234     34 94 06 F6 | 	mov	arg03, #52
0d238     D8 00 A0 FD | 	call	#\builtin_bytefill_
0d23c     53 79 CA FA | 	rdbyte	result2, local01 wz
0d240     1C 00 90 AD |  if_e	jmp	#LR__1990
0d244     53 79 C2 FA | 	rdbyte	result2, local01
0d248     2E 78 0E F2 | 	cmp	result2, #46 wz
0d24c     01 A6 06 A1 |  if_e	add	local01, #1
0d250     53 AB C2 AA |  if_e	rdbyte	local03, local01
0d254     01 A6 86 A1 |  if_e	sub	local01, #1
0d258     00 AA 4E A2 |  if_e	cmps	local03, #0 wz
0d25c     14 00 90 5D |  if_ne	jmp	#LR__1991
0d260                 | LR__1990
0d260     18 CE 05 F1 | 	add	fp, #24
0d264     E7 20 48 FC | 	wrbyte	#16, fp
0d268     18 CE 85 F1 | 	sub	fp, #24
0d26c     00 AC 06 F6 | 	mov	local04, #0
0d270     14 00 90 FD | 	jmp	#LR__1992
0d274                 | LR__1991
0d274     E7 92 02 F6 | 	mov	arg02, fp
0d278     10 92 06 F1 | 	add	arg02, #16
0d27c     53 91 02 F6 | 	mov	arg01, local01
0d280     00 F2 BF FD | 	call	#_fatfs_cc_f_stat
0d284     3B AD 02 F6 | 	mov	local04, result1
0d288                 | LR__1992
0d288     00 AC 0E F2 | 	cmp	local04, #0 wz
0d28c     0C 00 90 AD |  if_e	jmp	#LR__1993
0d290                 | '         return _set_dos_error(r);
0d290     56 91 02 F6 | 	mov	arg01, local04
0d294     78 FC BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d298     9C 00 90 FD | 	jmp	#LR__1994
0d29c                 | LR__1993
0d29c     24 AF 06 F6 | 	mov	local05, #292
0d2a0     18 CE 05 F1 | 	add	fp, #24
0d2a4     E7 AA C2 FA | 	rdbyte	local03, fp
0d2a8     01 AA CE F7 | 	test	local03, #1 wz
0d2ac     B6 AF 06 A6 |  if_e	mov	local05, #438
0d2b0     10 AA CE F7 | 	test	local03, #16 wz
0d2b4     08 00 00 5F 
0d2b8     49 AE 46 55 |  if_ne	or	local05, ##4169
0d2bc     08 A8 06 F1 | 	add	local02, #8
0d2c0     54 AF 62 FC | 	wrlong	local05, local02
0d2c4     04 A8 06 F1 | 	add	local02, #4
0d2c8     54 03 68 FC | 	wrlong	#1, local02
0d2cc     08 CE 85 F1 | 	sub	fp, #8
0d2d0     E7 76 02 FB | 	rdlong	result1, fp
0d2d4     0C A8 06 F1 | 	add	local02, #12
0d2d8     54 77 62 FC | 	wrlong	result1, local02
0d2dc     04 A8 06 F1 | 	add	local02, #4
0d2e0     54 01 68 FC | 	wrlong	#0, local02
0d2e4     04 A8 06 F1 | 	add	local02, #4
0d2e8     01 00 80 FF 
0d2ec     54 01 68 FC | 	wrlong	##512, local02
0d2f0     E7 AA 02 FB | 	rdlong	local03, fp
0d2f4     FF AB 06 F1 | 	add	local03, #511
0d2f8     09 AA 46 F0 | 	shr	local03, #9
0d2fc     04 A8 06 F1 | 	add	local02, #4
0d300     54 AB 62 FC | 	wrlong	local03, local02
0d304     04 CE 05 F1 | 	add	fp, #4
0d308     E7 90 E2 FA | 	rdword	arg01, fp
0d30c     02 CE 05 F1 | 	add	fp, #2
0d310     E7 92 E2 FA | 	rdword	arg02, fp
0d314     16 CE 85 F1 | 	sub	fp, #22
0d318     58 FB BF FD | 	call	#_fatfs_cc_unixtime_0593
0d31c     0C A8 06 F1 | 	add	local02, #12
0d320     54 77 62 FC | 	wrlong	result1, local02
0d324     04 A8 86 F1 | 	sub	local02, #4
0d328     54 77 62 FC | 	wrlong	result1, local02
0d32c     04 A8 86 F1 | 	sub	local02, #4
0d330     54 77 62 FC | 	wrlong	result1, local02
0d334                 | '         mode |=  0010000  |  0100  |  0010  |  0001 ;
0d334                 | '     }
0d334                 | '     buf->st_mode = mode;
0d334                 | '     buf->st_nlink = 1;
0d334                 | '     buf->st_size = finfo.fsize;
0d334                 | '     buf->st_blksize = 512;
0d334                 | '     buf->st_blocks = (finfo.fsize + 511) / 512;
0d334                 | '     buf->st_atime = buf->st_mtime = buf->st_ctime = unixtime(finfo.fdate, finfo.ftime);
0d334                 | ' #line 257 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d334                 | '     return r;
0d334     56 77 02 F6 | 	mov	result1, local04
0d338                 | LR__1994
0d338     E7 F0 03 F6 | 	mov	ptra, fp
0d33c     F2 00 A0 FD | 	call	#popregs_
0d340                 | _fatfs_cc_v_stat_ret
0d340     2D 00 64 FD | 	ret
0d344                 | 
0d344                 | _fatfs_cc_v_read
0d344     02 CA 05 F6 | 	mov	COUNT_, #2
0d348     E8 00 A0 FD | 	call	#pushregs_
0d34c     1C F0 07 F1 | 	add	ptra, #28
0d350     48 A7 02 F6 | 	mov	local01, arg01
0d354     53 91 0A FB | 	rdlong	arg01, local01 wz
0d358                 | '         return _seterror( 5 );
0d358     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d35c     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
0d360     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d364     01 76 66 A6 |  if_e	neg	result1, #1
0d368     58 00 90 AD |  if_e	jmp	#LR__2001
0d36c     02 00 00 FF 
0d370     10 90 06 F1 | 	add	arg01, ##1040
0d374     E7 96 02 F6 | 	mov	arg04, fp
0d378     18 96 06 F1 | 	add	arg04, #24
0d37c     DC E1 BF FD | 	call	#_fatfs_cc_f_read
0d380     3B 97 0A F6 | 	mov	arg04, result1 wz
0d384     1C 00 90 AD |  if_e	jmp	#LR__2000
0d388     08 A6 06 F1 | 	add	local01, #8
0d38c     53 91 02 FB | 	rdlong	arg01, local01
0d390     20 90 46 F5 | 	or	arg01, #32
0d394     53 91 62 FC | 	wrlong	arg01, local01
0d398                 | '         fil->state |=  (0x20) ;
0d398                 | '         return _set_dos_error(r);
0d398     4B 91 02 F6 | 	mov	arg01, arg04
0d39c     70 FB BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d3a0     20 00 90 FD | 	jmp	#LR__2001
0d3a4                 | LR__2000
0d3a4     18 CE 05 F1 | 	add	fp, #24
0d3a8     E7 A8 0A FB | 	rdlong	local02, fp wz
0d3ac     08 A6 06 A1 |  if_e	add	local01, #8
0d3b0     53 A9 02 AB |  if_e	rdlong	local02, local01
0d3b4     10 A8 46 A5 |  if_e	or	local02, #16
0d3b8     53 A9 62 AC |  if_e	wrlong	local02, local01
0d3bc                 | '         fil->state |=  (0x10) ;
0d3bc                 | '     }
0d3bc                 | '     return x;
0d3bc     E7 76 02 FB | 	rdlong	result1, fp
0d3c0     18 CE 85 F1 | 	sub	fp, #24
0d3c4                 | LR__2001
0d3c4     E7 F0 03 F6 | 	mov	ptra, fp
0d3c8     F2 00 A0 FD | 	call	#popregs_
0d3cc                 | _fatfs_cc_v_read_ret
0d3cc     2D 00 64 FD | 	ret
0d3d0                 | 
0d3d0                 | _fatfs_cc_v_write
0d3d0     01 CA 05 F6 | 	mov	COUNT_, #1
0d3d4     E8 00 A0 FD | 	call	#pushregs_
0d3d8     1C F0 07 F1 | 	add	ptra, #28
0d3dc     48 A7 02 F6 | 	mov	local01, arg01
0d3e0     53 91 0A FB | 	rdlong	arg01, local01 wz
0d3e4                 | '         return _seterror( 5 );
0d3e4     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d3e8     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
0d3ec     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d3f0     01 76 66 A6 |  if_e	neg	result1, #1
0d3f4     44 00 90 AD |  if_e	jmp	#LR__2011
0d3f8     02 00 00 FF 
0d3fc     10 90 06 F1 | 	add	arg01, ##1040
0d400     E7 96 02 F6 | 	mov	arg04, fp
0d404     18 96 06 F1 | 	add	arg04, #24
0d408     E8 E4 BF FD | 	call	#_fatfs_cc_f_write
0d40c     3B 97 0A F6 | 	mov	arg04, result1 wz
0d410     1C 00 90 AD |  if_e	jmp	#LR__2010
0d414     08 A6 06 F1 | 	add	local01, #8
0d418     53 91 02 FB | 	rdlong	arg01, local01
0d41c     20 90 46 F5 | 	or	arg01, #32
0d420     53 91 62 FC | 	wrlong	arg01, local01
0d424                 | '         fil->state |=  (0x20) ;
0d424                 | '         return _set_dos_error(r);
0d424     4B 91 02 F6 | 	mov	arg01, arg04
0d428     E4 FA BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d42c     0C 00 90 FD | 	jmp	#LR__2011
0d430                 | LR__2010
0d430                 | '     }
0d430                 | '     return x;
0d430     18 CE 05 F1 | 	add	fp, #24
0d434     E7 76 02 FB | 	rdlong	result1, fp
0d438     18 CE 85 F1 | 	sub	fp, #24
0d43c                 | LR__2011
0d43c     E7 F0 03 F6 | 	mov	ptra, fp
0d440     F2 00 A0 FD | 	call	#popregs_
0d444                 | _fatfs_cc_v_write_ret
0d444     2D 00 64 FD | 	ret
0d448                 | 
0d448                 | _fatfs_cc_v_lseek
0d448     06 CA 05 F6 | 	mov	COUNT_, #6
0d44c     E8 00 A0 FD | 	call	#pushregs_
0d450     49 AB 02 F6 | 	mov	local03, arg02
0d454     4B AD 02 F6 | 	mov	local04, arg04
0d458     48 AF 02 FB | 	rdlong	local05, arg01
0d45c     02 00 00 FF 
0d460     10 AE 0E F1 | 	add	local05, ##1040 wz
0d464     18 00 90 5D |  if_ne	jmp	#LR__2020
0d468                 | '         return _seterror( 5 );
0d468     20 66 06 F1 | 	add	ptr___system__dat__, #32
0d46c     33 0B 68 FC | 	wrlong	#5, ptr___system__dat__
0d470     20 66 86 F1 | 	sub	ptr___system__dat__, #32
0d474     01 78 66 F6 | 	neg	result2, #1
0d478     01 76 66 F6 | 	neg	result1, #1
0d47c     58 00 90 FD | 	jmp	#LR__2023
0d480                 | LR__2020
0d480     00 AC 0E F2 | 	cmp	local04, #0 wz
0d484     24 00 90 AD |  if_e	jmp	#LR__2021
0d488     01 AC 0E F2 | 	cmp	local04, #1 wz
0d48c     14 AE 06 A1 |  if_e	add	local05, #20
0d490     57 B1 02 AB |  if_e	rdlong	local06, local05
0d494     14 AE 86 A1 |  if_e	sub	local05, #20
0d498     58 AB 02 A1 |  if_e	add	local03, local06
0d49c     0C AE 06 51 |  if_ne	add	local05, #12
0d4a0     57 B1 02 5B |  if_ne	rdlong	local06, local05
0d4a4     0C AE 86 51 |  if_ne	sub	local05, #12
0d4a8     58 AB 02 51 |  if_ne	add	local03, local06
0d4ac                 | LR__2021
0d4ac     57 91 02 F6 | 	mov	arg01, local05
0d4b0     55 93 02 F6 | 	mov	arg02, local03
0d4b4     38 EA BF FD | 	call	#_fatfs_cc_f_lseek
0d4b8     3B 91 0A F6 | 	mov	arg01, result1 wz
0d4bc     10 00 90 AD |  if_e	jmp	#LR__2022
0d4c0                 | '         return _set_dos_error(result);
0d4c0     4C FA BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d4c4     3B 79 02 F6 | 	mov	result2, result1
0d4c8     1F 78 C6 F0 | 	sar	result2, #31
0d4cc     08 00 90 FD | 	jmp	#LR__2023
0d4d0                 | LR__2022
0d4d0                 | '     }
0d4d0                 | '     return (off_t)offset;
0d4d0     55 77 02 F6 | 	mov	result1, local03
0d4d4     54 79 02 F6 | 	mov	result2, local02
0d4d8                 | LR__2023
0d4d8     E7 F0 03 F6 | 	mov	ptra, fp
0d4dc     F2 00 A0 FD | 	call	#popregs_
0d4e0                 | _fatfs_cc_v_lseek_ret
0d4e0     2D 00 64 FD | 	ret
0d4e4                 | 
0d4e4                 | _fatfs_cc_v_ioctl
0d4e4                 | ' {
0d4e4                 | '     return _seterror( 10 );
0d4e4     20 66 06 F1 | 	add	ptr___system__dat__, #32
0d4e8     33 15 68 FC | 	wrlong	#10, ptr___system__dat__
0d4ec     20 66 86 F1 | 	sub	ptr___system__dat__, #32
0d4f0     01 76 66 F6 | 	neg	result1, #1
0d4f4                 | _fatfs_cc_v_ioctl_ret
0d4f4     2D 00 64 FD | 	ret
0d4f8                 | 
0d4f8                 | _fatfs_cc_v_mkdir
0d4f8     A0 F1 BF FD | 	call	#_fatfs_cc_f_mkdir
0d4fc     3B 91 02 F6 | 	mov	arg01, result1
0d500                 | ' 
0d500                 | '     r = f_mkdir(name);
0d500                 | '     return _set_dos_error(r);
0d500     0C FA BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d504                 | _fatfs_cc_v_mkdir_ret
0d504     2D 00 64 FD | 	ret
0d508                 | 
0d508                 | _fatfs_cc_v_remove
0d508     0C F0 BF FD | 	call	#_fatfs_cc_f_unlink
0d50c     3B 91 02 F6 | 	mov	arg01, result1
0d510                 | ' 
0d510                 | '     r = f_unlink(name);
0d510                 | '     return _set_dos_error(r);
0d510     FC F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d514                 | _fatfs_cc_v_remove_ret
0d514     2D 00 64 FD | 	ret
0d518                 | 
0d518                 | _fatfs_cc_v_rmdir
0d518     FC EF BF FD | 	call	#_fatfs_cc_f_unlink
0d51c     3B 91 02 F6 | 	mov	arg01, result1
0d520                 | ' 
0d520                 | '     r = f_unlink(name);
0d520                 | '     return _set_dos_error(r);
0d520     EC F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d524                 | _fatfs_cc_v_rmdir_ret
0d524     2D 00 64 FD | 	ret
0d528                 | 
0d528                 | _fatfs_cc_v_rename
0d528     B0 F3 BF FD | 	call	#_fatfs_cc_f_rename
0d52c     3B 91 02 F6 | 	mov	arg01, result1
0d530                 | '     return _set_dos_error(r);
0d530     DC F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d534                 | _fatfs_cc_v_rename_ret
0d534     2D 00 64 FD | 	ret
0d538                 | 
0d538                 | _fatfs_cc_v_open
0d538     07 CA 05 F6 | 	mov	COUNT_, #7
0d53c     E8 00 A0 FD | 	call	#pushregs_
0d540     48 A7 02 F6 | 	mov	local01, arg01
0d544     49 A9 02 F6 | 	mov	local02, arg02
0d548     4A AB 02 F6 | 	mov	local03, arg03
0d54c     03 00 00 FF 
0d550     38 90 06 F6 | 	mov	arg01, ##1592
0d554                 | '     return _gc_alloc(size);
0d554     10 92 06 F6 | 	mov	arg02, #16
0d558     AC 79 BF FD | 	call	#__system___gc_doalloc
0d55c     3B AD 0A F6 | 	mov	local04, result1 wz
0d560                 | '       return _seterror( 7 );
0d560     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d564     33 0F 68 AC |  if_e	wrlong	#7, ptr___system__dat__
0d568     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d56c     01 76 66 A6 |  if_e	neg	result1, #1
0d570     90 00 90 AD |  if_e	jmp	#LR__2036
0d574     56 91 02 F6 | 	mov	arg01, local04
0d578     00 92 06 F6 | 	mov	arg02, #0
0d57c     03 00 00 FF 
0d580     38 94 06 F6 | 	mov	arg03, ##1592
0d584     D8 00 A0 FD | 	call	#\builtin_bytefill_
0d588                 | '   switch (flags & 3) {
0d588     55 AF 02 F6 | 	mov	local05, local03
0d58c     03 AE 0E F5 | 	and	local05, #3 wz
0d590     0C 00 90 AD |  if_e	jmp	#LR__2030
0d594     01 AE 0E F2 | 	cmp	local05, #1 wz
0d598     0C 00 90 AD |  if_e	jmp	#LR__2031
0d59c     10 00 90 FD | 	jmp	#LR__2032
0d5a0                 | LR__2030
0d5a0     01 B0 06 F6 | 	mov	local06, #1
0d5a4                 | '       fs_flags =  0x01 ;
0d5a4                 | '       break;
0d5a4     0C 00 90 FD | 	jmp	#LR__2033
0d5a8                 | LR__2031
0d5a8     02 B0 06 F6 | 	mov	local06, #2
0d5ac                 | '       fs_flags =  0x02 ;
0d5ac                 | '       break;
0d5ac     04 00 90 FD | 	jmp	#LR__2033
0d5b0                 | LR__2032
0d5b0     03 B0 06 F6 | 	mov	local06, #3
0d5b4                 | '       fs_flags =  0x01  |  0x02 ;
0d5b4                 | '       break;
0d5b4                 | LR__2033
0d5b4     08 AA CE F7 | 	test	local03, #8 wz
0d5b8     18 B0 46 55 |  if_ne	or	local06, #24
0d5bc     08 00 90 5D |  if_ne	jmp	#LR__2034
0d5c0     20 AA CE F7 | 	test	local03, #32 wz
0d5c4     30 B0 46 55 |  if_ne	or	local06, #48
0d5c8                 | LR__2034
0d5c8     56 91 02 F6 | 	mov	arg01, local04
0d5cc     02 00 00 FF 
0d5d0     10 90 06 F1 | 	add	arg01, ##1040
0d5d4     54 93 02 F6 | 	mov	arg02, local02
0d5d8     58 95 02 F6 | 	mov	arg03, local06
0d5dc     24 DB BF FD | 	call	#_fatfs_cc_f_open
0d5e0     3B B3 0A F6 | 	mov	local07, result1 wz
0d5e4     14 00 90 AD |  if_e	jmp	#LR__2035
0d5e8     56 91 02 F6 | 	mov	arg01, local04
0d5ec                 | '     return _gc_free(ptr);
0d5ec     1C 7A BF FD | 	call	#__system___gc_free
0d5f0                 | '     free(f);
0d5f0                 | ' #line 426 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d5f0                 | '     return _set_dos_error(r);
0d5f0     59 91 02 F6 | 	mov	arg01, local07
0d5f4     18 F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d5f8     08 00 90 FD | 	jmp	#LR__2036
0d5fc                 | LR__2035
0d5fc     53 AD 62 FC | 	wrlong	local04, local01
0d600                 | '   }
0d600                 | '   fil->vfsdata = f;
0d600                 | '   return 0;
0d600     00 76 06 F6 | 	mov	result1, #0
0d604                 | LR__2036
0d604     E7 F0 03 F6 | 	mov	ptra, fp
0d608     F2 00 A0 FD | 	call	#popregs_
0d60c                 | _fatfs_cc_v_open_ret
0d60c     2D 00 64 FD | 	ret
0d610                 | 
0d610                 | _fatfs_cc_v_flush
0d610     01 CA 05 F6 | 	mov	COUNT_, #1
0d614     E8 00 A0 FD | 	call	#pushregs_
0d618     48 A7 02 F6 | 	mov	local01, arg01
0d61c     80 F5 BF FD | 	call	#_fatfs_cc___default_flush
0d620     53 A7 02 FB | 	rdlong	local01, local01
0d624     02 00 00 FF 
0d628     10 A6 0E F1 | 	add	local01, ##1040 wz
0d62c                 | '         return _seterror( 5 );
0d62c     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d630     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
0d634     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d638     01 76 66 A6 |  if_e	neg	result1, #1
0d63c     10 00 90 AD |  if_e	jmp	#LR__2040
0d640     53 91 02 F6 | 	mov	arg01, local01
0d644     FC E6 BF FD | 	call	#_fatfs_cc_f_sync
0d648     3B 91 02 F6 | 	mov	arg01, result1
0d64c                 | '     }
0d64c                 | ' #line 449 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d64c                 | '     result = f_sync(f);
0d64c                 | ' #line 453 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d64c                 | '     return _set_dos_error(result);
0d64c     C0 F8 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d650                 | LR__2040
0d650     E7 F0 03 F6 | 	mov	ptra, fp
0d654     F2 00 A0 FD | 	call	#popregs_
0d658                 | _fatfs_cc_v_flush_ret
0d658     2D 00 64 FD | 	ret
0d65c                 | 
0d65c                 | _fatfs_cc_v_init
0d65c                 | ' {
0d65c                 | '     return 0;
0d65c     00 76 06 F6 | 	mov	result1, #0
0d660                 | _fatfs_cc_v_init_ret
0d660     2D 00 64 FD | 	ret
0d664                 | 
0d664                 | _fatfs_cc_v_deinit
0d664     6F 00 00 FF 
0d668     5A 93 06 F6 | 	mov	arg02, ##@LR__2151
0d66c     00 90 06 F6 | 	mov	arg01, #0
0d670     00 94 06 F6 | 	mov	arg03, #0
0d674     B8 D9 BF FD | 	call	#_fatfs_cc_f_mount
0d678     01 00 00 FF 
0d67c     08 62 06 F1 | 	add	objptr, ##520
0d680     31 91 02 FB | 	rdlong	arg01, objptr
0d684     04 62 06 F1 | 	add	objptr, #4
0d688     31 93 02 FB | 	rdlong	arg02, objptr
0d68c     01 00 00 FF 
0d690     0C 62 86 F1 | 	sub	objptr, ##524
0d694     0C 6B BF FD | 	call	#__system___freepins
0d698                 | ' #line 474 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d698                 | '     _freepins(f_pinmask);
0d698                 | '     return 0;
0d698     00 76 06 F6 | 	mov	result1, #0
0d69c                 | _fatfs_cc_v_deinit_ret
0d69c     2D 00 64 FD | 	ret
0d6a0                 | 
0d6a0                 | _fatfs_cc_get_vfs
0d6a0     01 CA 05 F6 | 	mov	COUNT_, #1
0d6a4     E8 00 A0 FD | 	call	#pushregs_
0d6a8     48 A7 02 F6 | 	mov	local01, arg01
0d6ac     58 90 06 F6 | 	mov	arg01, #88
0d6b0     24 78 BF FD | 	call	#__system___gc_alloc_managed
0d6b4     3B 91 02 F6 | 	mov	arg01, result1
0d6b8     31 77 02 F6 | 	mov	result1, objptr
0d6bc     74 76 26 F4 | 	bith	result1, #116
0d6c0     48 77 62 FC | 	wrlong	result1, arg01
0d6c4     31 77 02 F6 | 	mov	result1, objptr
0d6c8     18 76 26 F4 | 	bith	result1, #24
0d6cc     04 90 06 F1 | 	add	arg01, #4
0d6d0     48 77 62 FC | 	wrlong	result1, arg01
0d6d4     31 77 02 F6 | 	mov	result1, objptr
0d6d8     00 88 00 FF 
0d6dc     00 76 46 F5 | 	or	result1, ##17825792
0d6e0     04 90 06 F1 | 	add	arg01, #4
0d6e4     48 77 62 FC | 	wrlong	result1, arg01
0d6e8     31 77 02 F6 | 	mov	result1, objptr
0d6ec     00 90 00 FF 
0d6f0     00 76 46 F5 | 	or	result1, ##18874368
0d6f4     04 90 06 F1 | 	add	arg01, #4
0d6f8     48 77 62 FC | 	wrlong	result1, arg01
0d6fc     31 77 02 F6 | 	mov	result1, objptr
0d700     00 98 00 FF 
0d704     00 76 46 F5 | 	or	result1, ##19922944
0d708     04 90 06 F1 | 	add	arg01, #4
0d70c     48 77 62 FC | 	wrlong	result1, arg01
0d710     31 77 02 F6 | 	mov	result1, objptr
0d714     00 A0 00 FF 
0d718     00 76 46 F5 | 	or	result1, ##20971520
0d71c     04 90 06 F1 | 	add	arg01, #4
0d720     48 77 62 FC | 	wrlong	result1, arg01
0d724     04 90 06 F1 | 	add	arg01, #4
0d728     48 A7 62 FC | 	wrlong	local01, arg01
0d72c     04 90 06 F1 | 	add	arg01, #4
0d730     48 01 68 FC | 	wrlong	#0, arg01
0d734     31 77 02 F6 | 	mov	result1, objptr
0d738     00 A8 00 FF 
0d73c     00 76 46 F5 | 	or	result1, ##22020096
0d740     04 90 06 F1 | 	add	arg01, #4
0d744     48 77 62 FC | 	wrlong	result1, arg01
0d748     31 77 02 F6 | 	mov	result1, objptr
0d74c     00 B0 00 FF 
0d750     00 76 46 F5 | 	or	result1, ##23068672
0d754     04 90 06 F1 | 	add	arg01, #4
0d758     48 77 62 FC | 	wrlong	result1, arg01
0d75c     31 77 02 F6 | 	mov	result1, objptr
0d760     00 B8 00 FF 
0d764     00 76 46 F5 | 	or	result1, ##24117248
0d768     04 90 06 F1 | 	add	arg01, #4
0d76c     48 77 62 FC | 	wrlong	result1, arg01
0d770     31 77 02 F6 | 	mov	result1, objptr
0d774     37 76 26 F4 | 	bith	result1, #55
0d778     04 90 06 F1 | 	add	arg01, #4
0d77c     48 77 62 FC | 	wrlong	result1, arg01
0d780     31 77 02 F6 | 	mov	result1, objptr
0d784     00 C8 00 FF 
0d788     00 76 46 F5 | 	or	result1, ##26214400
0d78c     04 90 06 F1 | 	add	arg01, #4
0d790     48 77 62 FC | 	wrlong	result1, arg01
0d794     31 77 02 F6 | 	mov	result1, objptr
0d798     00 D0 00 FF 
0d79c     00 76 46 F5 | 	or	result1, ##27262976
0d7a0     04 90 06 F1 | 	add	arg01, #4
0d7a4     48 77 62 FC | 	wrlong	result1, arg01
0d7a8     31 77 02 F6 | 	mov	result1, objptr
0d7ac     00 D8 00 FF 
0d7b0     00 76 46 F5 | 	or	result1, ##28311552
0d7b4     04 90 06 F1 | 	add	arg01, #4
0d7b8     48 77 62 FC | 	wrlong	result1, arg01
0d7bc     31 77 02 F6 | 	mov	result1, objptr
0d7c0     56 76 26 F4 | 	bith	result1, #86
0d7c4     04 90 06 F1 | 	add	arg01, #4
0d7c8     48 77 62 FC | 	wrlong	result1, arg01
0d7cc     31 77 02 F6 | 	mov	result1, objptr
0d7d0     00 E8 00 FF 
0d7d4     00 76 46 F5 | 	or	result1, ##30408704
0d7d8     04 90 06 F1 | 	add	arg01, #4
0d7dc     48 77 62 FC | 	wrlong	result1, arg01
0d7e0     31 77 02 F6 | 	mov	result1, objptr
0d7e4     75 76 26 F4 | 	bith	result1, #117
0d7e8     04 90 06 F1 | 	add	arg01, #4
0d7ec     48 77 62 FC | 	wrlong	result1, arg01
0d7f0     31 77 02 F6 | 	mov	result1, objptr
0d7f4     94 76 26 F4 | 	bith	result1, #148
0d7f8     04 90 06 F1 | 	add	arg01, #4
0d7fc     48 77 62 FC | 	wrlong	result1, arg01
0d800     31 77 02 F6 | 	mov	result1, objptr
0d804     19 76 26 F4 | 	bith	result1, #25
0d808     04 90 06 F1 | 	add	arg01, #4
0d80c     48 77 62 FC | 	wrlong	result1, arg01
0d810     04 90 06 F1 | 	add	arg01, #4
0d814     48 01 68 FC | 	wrlong	#0, arg01
0d818     04 90 06 F1 | 	add	arg01, #4
0d81c     48 01 68 FC | 	wrlong	#0, arg01
0d820     54 90 86 F1 | 	sub	arg01, #84
0d824                 | ' 
0d824                 | '     v->close = &v_close;
0d824                 | '     v->read = &v_read;
0d824                 | '     v->write = &v_write;
0d824                 | '     v->lseek = &v_lseek;
0d824                 | '     v->ioctl = &v_ioctl;
0d824                 | '     v->flush = &v_flush;
0d824                 | '     v->vfs_data = ptr;
0d824                 | '     v->reserved = 0;
0d824                 | ' 
0d824                 | '     v->open = &v_open;
0d824                 | '     v->creat = &v_creat;
0d824                 | '     v->opendir = &v_opendir;
0d824                 | '     v->closedir = &v_closedir;
0d824                 | '     v->readdir = &v_readdir;
0d824                 | '     v->stat = &v_stat;
0d824                 | ' 
0d824                 | '     v->mkdir = &v_mkdir;
0d824                 | '     v->rmdir = &v_rmdir;
0d824                 | ' 
0d824                 | '     v->remove = &v_remove;
0d824                 | '     v->rename = &v_rename;
0d824                 | ' 
0d824                 | '     v->init = &v_init;
0d824                 | '     v->deinit = &v_deinit;
0d824                 | ' 
0d824                 | ' 
0d824                 | '     v->getcf = 0;
0d824                 | '     v->putcf = 0;
0d824                 | ' #line 532 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d824                 | '     return v;
0d824     48 77 02 F6 | 	mov	result1, arg01
0d828     E7 F0 03 F6 | 	mov	ptra, fp
0d82c     F2 00 A0 FD | 	call	#popregs_
0d830                 | _fatfs_cc_get_vfs_ret
0d830     2D 00 64 FD | 	ret
0d834                 | 
0d834                 | _fatfs_cc_gettimeofday
0d834     04 CA 05 F6 | 	mov	COUNT_, #4
0d838     E8 00 A0 FD | 	call	#pushregs_
0d83c     48 A7 02 F6 | 	mov	local01, arg01
0d840     44 54 BF FD | 	call	#__system___getus
0d844     3B 91 02 F6 | 	mov	arg01, result1
0d848     02 00 00 FF 
0d84c     08 6B 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1288
0d850     35 A9 02 FB | 	rdlong	local02, ptr__fatfs_cc_dat__
0d854     48 77 02 F6 | 	mov	result1, arg01
0d858     54 77 82 F1 | 	sub	result1, local02
0d85c     A1 07 00 FF 
0d860     40 76 16 FD | 	qdiv	result1, ##1000000
0d864     02 00 00 FF 
0d868     08 6B 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1288
0d86c     18 A8 62 FD | 	getqx	local02
0d870     A1 07 00 FF 
0d874     40 76 16 FD | 	qdiv	result1, ##1000000
0d878     00 A8 0E F2 | 	cmp	local02, #0 wz
0d87c     19 AA 62 FD | 	getqy	local03
0d880     28 00 90 AD |  if_e	jmp	#LR__2050
0d884     02 00 00 FF 
0d888     04 6B 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1284
0d88c     35 AD 02 FB | 	rdlong	local04, ptr__fatfs_cc_dat__
0d890     54 AD 02 F1 | 	add	local04, local02
0d894     35 AD 62 FC | 	wrlong	local04, ptr__fatfs_cc_dat__
0d898     55 91 82 F1 | 	sub	arg01, local03
0d89c     04 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, #4
0d8a0     35 91 62 FC | 	wrlong	arg01, ptr__fatfs_cc_dat__
0d8a4     02 00 00 FF 
0d8a8     08 6B 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1288
0d8ac                 | LR__2050
0d8ac     02 00 00 FF 
0d8b0     04 6B 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1284
0d8b4     35 AD 02 FB | 	rdlong	local04, ptr__fatfs_cc_dat__
0d8b8     02 00 00 FF 
0d8bc     04 6B 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1284
0d8c0     53 AD 62 FC | 	wrlong	local04, local01
0d8c4     04 A6 06 F1 | 	add	local01, #4
0d8c8     53 AB 62 FC | 	wrlong	local03, local01
0d8cc                 | '         lastsec += secs;
0d8cc                 | '         lastus = now - leftover;
0d8cc                 | '     }
0d8cc                 | '     tv->tv_sec = lastsec;
0d8cc                 | '     tv->tv_usec = leftover;
0d8cc                 | '     return 0;
0d8cc     00 76 06 F6 | 	mov	result1, #0
0d8d0     E7 F0 03 F6 | 	mov	ptra, fp
0d8d4     F2 00 A0 FD | 	call	#popregs_
0d8d8                 | _fatfs_cc_gettimeofday_ret
0d8d8     2D 00 64 FD | 	ret
0d8dc                 | 
0d8dc                 | _fatfs_cc__is_leap_year
0d8dc     48 77 52 F6 | 	abs	result1, arg01 wc
0d8e0     03 76 06 F5 | 	and	result1, #3
0d8e4     3B 77 8A F6 | 	negc	result1, result1 wz
0d8e8     38 00 90 5D |  if_ne	jmp	#LR__2061
0d8ec     48 77 52 F6 | 	abs	result1, arg01 wc
0d8f0     64 76 16 FD | 	qdiv	result1, #100
0d8f4     19 76 62 FD | 	getqy	result1
0d8f8     3B 77 8A F6 | 	negc	result1, result1 wz
0d8fc     1C 00 90 5D |  if_ne	jmp	#LR__2060
0d900     48 77 52 F6 | 	abs	result1, arg01 wc
0d904     90 77 16 FD | 	qdiv	result1, #400
0d908                 | '       return (0 == y % 400);
0d908     00 76 06 F6 | 	mov	result1, #0
0d90c     19 7C 62 FD | 	getqy	_var01
0d910     3E 7D 8A F6 | 	negc	_var01, _var01 wz
0d914     01 76 06 A6 |  if_e	mov	result1, #1
0d918     0C 00 90 FD | 	jmp	#_fatfs_cc__is_leap_year_ret
0d91c                 | LR__2060
0d91c                 | '     return 1;
0d91c     01 76 06 F6 | 	mov	result1, #1
0d920     04 00 90 FD | 	jmp	#_fatfs_cc__is_leap_year_ret
0d924                 | LR__2061
0d924                 | '   }
0d924                 | '   return 0;
0d924     00 76 06 F6 | 	mov	result1, #0
0d928                 | _fatfs_cc__is_leap_year_ret
0d928     2D 00 64 FD | 	ret
0d92c                 | 
0d92c                 | _fatfs_cc___tzoffset
0d92c     48 7D 0A F6 | 	mov	_var01, arg01 wz
0d930     FF FF FF FF 
0d934     49 FF 6B FC | 	wrlong	##-1, arg02
0d938     01 7E 06 F6 | 	mov	_var02, #1
0d93c     3E 81 CA 5A |  if_ne	rdbyte	_var03, _var01 wz
0d940                 | '                 return 0;
0d940     00 76 06 A6 |  if_e	mov	result1, #0
0d944     7C 02 90 AD |  if_e	jmp	#LR__2087
0d948     49 01 68 FC | 	wrlong	#0, arg02
0d94c     35 83 02 F6 | 	mov	_var04, ptr__fatfs_cc_dat__
0d950     02 00 00 FF 
0d954     DC 82 06 F1 | 	add	_var04, ##1244
0d958     D7 26 48 FB | 	callpa	#(@LR__2071-@LR__2070)>>2,fcache_load_ptr_
0d95c                 | ' 
0d95c                 | '        *hasdst = 0;
0d95c                 | ' 
0d95c                 | ' 	n = stdname;
0d95c                 | '         while (*s && isalpha(*s)) {
0d95c                 | LR__2070
0d95c     3E 81 CA FA | 	rdbyte	_var03, _var01 wz
0d960     44 00 90 AD |  if_e	jmp	#LR__2072
0d964     3E 91 C2 FA | 	rdbyte	arg01, _var01
0d968                 | ' {
0d968                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
0d968     80 90 36 F3 | 	fle	arg01, #128 wc
0d96c                 | '     return __ctype[c];
0d96c     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0d970     02 00 00 FF 
0d974     0C 77 06 F1 | 	add	result1, ##1292
0d978     3B 91 02 F1 | 	add	arg01, result1
0d97c     48 77 C2 FA | 	rdbyte	result1, arg01
0d980     0C 76 CE F7 | 	test	result1, #12 wz
0d984     20 00 90 AD |  if_e	jmp	#LR__2072
0d988     3E 85 02 F6 | 	mov	_var05, _var01
0d98c     3E 87 02 F6 | 	mov	_var06, _var01
0d990     01 86 06 F1 | 	add	_var06, #1
0d994     42 89 C2 FA | 	rdbyte	_var07, _var05
0d998     43 7D 02 F6 | 	mov	_var01, _var06
0d99c     41 89 42 FC | 	wrbyte	_var07, _var04
0d9a0     01 82 06 F1 | 	add	_var04, #1
0d9a4     B4 FF 9F FD | 	jmp	#LR__2070
0d9a8                 | LR__2071
0d9a8                 | LR__2072
0d9a8     41 01 48 FC | 	wrbyte	#0, _var04
0d9ac     00 8A 06 F6 | 	mov	_var08, #0
0d9b0     3E 81 C2 FA | 	rdbyte	_var03, _var01
0d9b4     2D 80 0E F2 | 	cmp	_var03, #45 wz
0d9b8     01 7E 66 A6 |  if_e	neg	_var02, #1
0d9bc     01 7C 06 A1 |  if_e	add	_var01, #1
0d9c0     D7 26 48 FB | 	callpa	#(@LR__2074-@LR__2073)>>2,fcache_load_ptr_
0d9c4                 | '                 sgn = -1;
0d9c4                 | '                 s++;
0d9c4                 | '         }
0d9c4                 | '         while (isdigit(*s)) {
0d9c4                 | LR__2073
0d9c4     3E 91 C2 FA | 	rdbyte	arg01, _var01
0d9c8                 | ' {
0d9c8                 | '   return  (__ctype_get(c) & 0x02 ) ;
0d9c8     80 90 36 F3 | 	fle	arg01, #128 wc
0d9cc                 | '     return __ctype[c];
0d9cc     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0d9d0     02 00 00 FF 
0d9d4     0C 77 06 F1 | 	add	result1, ##1292
0d9d8     3B 91 02 F1 | 	add	arg01, result1
0d9dc     48 77 C2 FA | 	rdbyte	result1, arg01
0d9e0     02 76 CE F7 | 	test	result1, #2 wz
0d9e4     28 00 90 AD |  if_e	jmp	#LR__2075
0d9e8     45 81 02 F6 | 	mov	_var03, _var08
0d9ec     02 80 66 F0 | 	shl	_var03, #2
0d9f0     45 81 02 F1 | 	add	_var03, _var08
0d9f4     01 80 66 F0 | 	shl	_var03, #1
0d9f8     3E 85 C2 FA | 	rdbyte	_var05, _var01
0d9fc     30 84 86 F1 | 	sub	_var05, #48
0da00     42 81 02 F1 | 	add	_var03, _var05
0da04     40 8B 02 F6 | 	mov	_var08, _var03
0da08     01 7C 06 F1 | 	add	_var01, #1
0da0c     B4 FF 9F FD | 	jmp	#LR__2073
0da10                 | LR__2074
0da10                 | LR__2075
0da10     07 00 00 FF 
0da14     10 8A 06 FD | 	qmul	_var08, ##3600
0da18     3E 81 C2 FA | 	rdbyte	_var03, _var01
0da1c     3A 80 0E F2 | 	cmp	_var03, #58 wz
0da20     18 8C 62 FD | 	getqx	_var09
0da24     6C 00 90 5D |  if_ne	jmp	#LR__2079
0da28     00 8A 06 F6 | 	mov	_var08, #0
0da2c     01 7C 06 F1 | 	add	_var01, #1
0da30     D7 26 48 FB | 	callpa	#(@LR__2077-@LR__2076)>>2,fcache_load_ptr_
0da34                 | '                 x = 0;
0da34                 | '                 s++;
0da34                 | '                 while (isdigit(*s)) {
0da34                 | LR__2076
0da34     3E 91 C2 FA | 	rdbyte	arg01, _var01
0da38                 | ' {
0da38                 | '   return  (__ctype_get(c) & 0x02 ) ;
0da38     80 90 36 F3 | 	fle	arg01, #128 wc
0da3c                 | '     return __ctype[c];
0da3c     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0da40     02 00 00 FF 
0da44     0C 77 06 F1 | 	add	result1, ##1292
0da48     3B 91 02 F1 | 	add	arg01, result1
0da4c     48 77 C2 FA | 	rdbyte	result1, arg01
0da50     02 76 CE F7 | 	test	result1, #2 wz
0da54     28 00 90 AD |  if_e	jmp	#LR__2078
0da58     45 81 02 F6 | 	mov	_var03, _var08
0da5c     02 80 66 F0 | 	shl	_var03, #2
0da60     45 81 02 F1 | 	add	_var03, _var08
0da64     01 80 66 F0 | 	shl	_var03, #1
0da68     3E 85 C2 FA | 	rdbyte	_var05, _var01
0da6c     30 84 86 F1 | 	sub	_var05, #48
0da70     42 81 02 F1 | 	add	_var03, _var05
0da74     40 8B 02 F6 | 	mov	_var08, _var03
0da78     01 7C 06 F1 | 	add	_var01, #1
0da7c     B4 FF 9F FD | 	jmp	#LR__2076
0da80                 | LR__2077
0da80                 | LR__2078
0da80     45 89 02 F6 | 	mov	_var07, _var08
0da84     04 88 66 F0 | 	shl	_var07, #4
0da88     45 89 82 F1 | 	sub	_var07, _var08
0da8c     02 88 66 F0 | 	shl	_var07, #2
0da90     44 8D 02 F1 | 	add	_var09, _var07
0da94                 | LR__2079
0da94     35 83 02 F6 | 	mov	_var04, ptr__fatfs_cc_dat__
0da98     02 00 00 FF 
0da9c     E5 82 06 F1 | 	add	_var04, ##1253
0daa0     3E 91 C2 FA | 	rdbyte	arg01, _var01
0daa4                 | ' {
0daa4                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
0daa4     80 90 36 F3 | 	fle	arg01, #128 wc
0daa8                 | '     return __ctype[c];
0daa8     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0daac     02 00 00 FF 
0dab0     0C 77 06 F1 | 	add	result1, ##1292
0dab4     3B 91 02 F1 | 	add	arg01, result1
0dab8     48 77 C2 FA | 	rdbyte	result1, arg01
0dabc     0C 76 CE F7 | 	test	result1, #12 wz
0dac0     4C 00 90 AD |  if_e	jmp	#LR__2082
0dac4     49 03 68 FC | 	wrlong	#1, arg02
0dac8                 | '                 *hasdst = 1;
0dac8                 | ' 		while (*s && isalpha(*s)) *n++ = *s++;
0dac8                 | LR__2080
0dac8     3E 81 CA FA | 	rdbyte	_var03, _var01 wz
0dacc     40 00 90 AD |  if_e	jmp	#LR__2081
0dad0     3E 91 C2 FA | 	rdbyte	arg01, _var01
0dad4                 | ' {
0dad4                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
0dad4     80 90 36 F3 | 	fle	arg01, #128 wc
0dad8                 | '     return __ctype[c];
0dad8     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0dadc     02 00 00 FF 
0dae0     0C 77 06 F1 | 	add	result1, ##1292
0dae4     3B 91 02 F1 | 	add	arg01, result1
0dae8     48 77 C2 FA | 	rdbyte	result1, arg01
0daec     0C 76 CE F7 | 	test	result1, #12 wz
0daf0     1C 00 90 AD |  if_e	jmp	#LR__2081
0daf4     3E 87 02 F6 | 	mov	_var06, _var01
0daf8     01 86 06 F1 | 	add	_var06, #1
0dafc     3E 89 C2 FA | 	rdbyte	_var07, _var01
0db00     43 7D 02 F6 | 	mov	_var01, _var06
0db04     41 89 42 FC | 	wrbyte	_var07, _var04
0db08     01 82 06 F1 | 	add	_var04, #1
0db0c     B8 FF 9F FD | 	jmp	#LR__2080
0db10                 | LR__2081
0db10                 | LR__2082
0db10     41 01 48 FC | 	wrbyte	#0, _var04
0db14     02 00 00 FF 
0db18     DC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1244
0db1c     35 81 CA FA | 	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
0db20     02 00 00 FF 
0db24     DC 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1244
0db28     20 00 90 AD |  if_e	jmp	#LR__2083
0db2c     02 00 00 FF 
0db30     DC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1244
0db34     35 81 02 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
0db38     08 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, #8
0db3c     35 81 62 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
0db40     02 00 00 FF 
0db44     D4 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1236
0db48     1C 00 90 FD | 	jmp	#LR__2084
0db4c                 | LR__2083
0db4c     02 00 00 FF 
0db50     EE 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1262
0db54     35 81 02 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
0db58     1A 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, #26
0db5c     35 81 62 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
0db60     02 00 00 FF 
0db64     D4 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1236
0db68                 | LR__2084
0db68     02 00 00 FF 
0db6c     E5 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1253
0db70     35 81 CA FA | 	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
0db74     02 00 00 FF 
0db78     E5 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1253
0db7c     20 00 90 AD |  if_e	jmp	#LR__2085
0db80     02 00 00 FF 
0db84     E5 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1253
0db88     35 81 02 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
0db8c     0D 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, #13
0db90     35 81 62 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
0db94     02 00 00 FF 
0db98     D8 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1240
0db9c     1C 00 90 FD | 	jmp	#LR__2086
0dba0                 | LR__2085
0dba0     02 00 00 FF 
0dba4     DC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1244
0dba8     35 81 02 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
0dbac     04 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, #4
0dbb0     35 81 62 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
0dbb4     02 00 00 FF 
0dbb8     D8 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1240
0dbbc                 | LR__2086
0dbbc     46 7F 02 FD | 	qmul	_var02, _var09
0dbc0                 | ' 		_tzname[1] = stdname;
0dbc0                 | ' 
0dbc0                 | '         return sgn * off;
0dbc0     18 76 62 FD | 	getqx	result1
0dbc4                 | LR__2087
0dbc4                 | _fatfs_cc___tzoffset_ret
0dbc4     2D 00 64 FD | 	ret
0dbc8                 | 
0dbc8                 | _fatfs_cc___indst
0dbc8     10 90 06 F1 | 	add	arg01, #16
0dbcc     48 7D 02 FB | 	rdlong	_var01, arg01
0dbd0     10 90 86 F1 | 	sub	arg01, #16
0dbd4     02 7C 0E F2 | 	cmp	_var01, #2 wz
0dbd8     30 00 90 5D |  if_ne	jmp	#LR__2090
0dbdc     07 7C 06 F6 | 	mov	_var01, #7
0dbe0     18 90 06 F1 | 	add	arg01, #24
0dbe4     48 7F 02 FB | 	rdlong	_var02, arg01
0dbe8     3F 7D 02 F1 | 	add	_var01, _var02
0dbec     0C 90 86 F1 | 	sub	arg01, #12
0dbf0     48 81 02 FB | 	rdlong	_var03, arg01
0dbf4     40 7D 82 F1 | 	sub	_var01, _var03
0dbf8     00 7C 56 F2 | 	cmps	_var01, #0 wc
0dbfc                 | '                         return 1;
0dbfc     01 76 06 C6 |  if_b	mov	result1, #1
0dc00     70 00 90 CD |  if_b	jmp	#_fatfs_cc___indst_ret
0dc04                 | '                 return 0;
0dc04     00 76 06 F6 | 	mov	result1, #0
0dc08     68 00 90 FD | 	jmp	#_fatfs_cc___indst_ret
0dc0c                 | LR__2090
0dc0c     10 90 06 F1 | 	add	arg01, #16
0dc10     48 7D 02 FB | 	rdlong	_var01, arg01
0dc14     10 90 86 F1 | 	sub	arg01, #16
0dc18     0A 7C 0E F2 | 	cmp	_var01, #10 wz
0dc1c     28 00 90 5D |  if_ne	jmp	#LR__2091
0dc20     18 90 06 F1 | 	add	arg01, #24
0dc24     48 7D 02 FB | 	rdlong	_var01, arg01
0dc28     0C 90 86 F1 | 	sub	arg01, #12
0dc2c     48 83 02 FB | 	rdlong	_var04, arg01
0dc30     41 7D 82 F1 | 	sub	_var01, _var04
0dc34     00 7C 56 F2 | 	cmps	_var01, #0 wc
0dc38                 | '                         return 0;
0dc38     00 76 06 C6 |  if_b	mov	result1, #0
0dc3c     34 00 90 CD |  if_b	jmp	#_fatfs_cc___indst_ret
0dc40                 | '                 return 1;
0dc40     01 76 06 F6 | 	mov	result1, #1
0dc44     2C 00 90 FD | 	jmp	#_fatfs_cc___indst_ret
0dc48                 | LR__2091
0dc48                 | '         }
0dc48                 | ' 
0dc48                 | '         return (t->tm_mon > 2 && t->tm_mon < 10);
0dc48     00 7C 06 F6 | 	mov	_var01, #0
0dc4c     10 90 06 F1 | 	add	arg01, #16
0dc50     48 7F 02 FB | 	rdlong	_var02, arg01
0dc54     10 90 86 F1 | 	sub	arg01, #16
0dc58     03 7E 56 F2 | 	cmps	_var02, #3 wc
0dc5c     10 00 90 CD |  if_b	jmp	#LR__2092
0dc60     10 90 06 F1 | 	add	arg01, #16
0dc64     48 81 02 FB | 	rdlong	_var03, arg01
0dc68     0A 80 56 F2 | 	cmps	_var03, #10 wc
0dc6c     01 7C 06 C6 |  if_b	mov	_var01, #1
0dc70                 | LR__2092
0dc70     3E 77 02 F6 | 	mov	result1, _var01
0dc74                 | _fatfs_cc___indst_ret
0dc74     2D 00 64 FD | 	ret
0dc78                 | 
0dc78                 | _fatfs_cc_disk_deinitialize
0dc78     03 CA 05 F6 | 	mov	COUNT_, #3
0dc7c     E8 00 A0 FD | 	call	#pushregs_
0dc80     01 00 00 FF 
0dc84     10 62 06 F1 | 	add	objptr, ##528
0dc88     31 91 0A FB | 	rdlong	arg01, objptr wz
0dc8c     01 00 00 FF 
0dc90     10 62 86 F1 | 	sub	objptr, ##528
0dc94                 | ' 
0dc94                 | '         return RES_NOTRDY;
0dc94     03 76 06 A6 |  if_e	mov	result1, #3
0dc98     4C 00 90 AD |  if_e	jmp	#LR__2100
0dc9c     01 00 00 FF 
0dca0     10 62 06 F1 | 	add	objptr, ##528
0dca4     31 91 02 FB | 	rdlong	arg01, objptr
0dca8     48 A7 02 F6 | 	mov	local01, arg01
0dcac     24 A6 06 F1 | 	add	local01, #36
0dcb0     53 A7 02 FB | 	rdlong	local01, local01
0dcb4     53 A9 02 F6 | 	mov	local02, local01
0dcb8     13 A6 46 F7 | 	zerox	local01, #19
0dcbc     14 A8 46 F0 | 	shr	local02, #20
0dcc0     02 A8 66 F0 | 	shl	local02, #2
0dcc4     2D A9 02 F1 | 	add	local02, __methods__
0dcc8     54 A9 02 FB | 	rdlong	local02, local02
0dccc     01 00 00 FF 
0dcd0     10 62 86 F1 | 	sub	objptr, ##528
0dcd4     31 AB 02 F6 | 	mov	local03, objptr
0dcd8     53 63 02 F6 | 	mov	objptr, local01
0dcdc     2D A8 62 FD | 	call	local02
0dce0     55 63 02 F6 | 	mov	objptr, local03
0dce4                 | '     }
0dce4                 | '     fh->close(fh);
0dce4                 | '     return RES_OK;
0dce4     00 76 06 F6 | 	mov	result1, #0
0dce8                 | LR__2100
0dce8     E7 F0 03 F6 | 	mov	ptra, fp
0dcec     F2 00 A0 FD | 	call	#popregs_
0dcf0                 | _fatfs_cc_disk_deinitialize_ret
0dcf0     2D 00 64 FD | 	ret
0dcf4                 | 
0dcf4                 | ' 	
0dcf4                 | ' 	FUNCTION pfunc(c as integer) as integer
0dcf4                 | __system____strs_cl_pfunc_
0dcf4                 | ' 		if (i < 16) then
0dcf4     04 62 06 F1 | 	add	objptr, #4
0dcf8     31 77 02 FB | 	rdlong	result1, objptr
0dcfc     04 62 86 F1 | 	sub	objptr, #4
0dd00     10 76 56 F2 | 	cmps	result1, #16 wc
0dd04     2C 00 90 3D |  if_ae	jmp	#LR__2110
0dd08     31 77 02 FB | 	rdlong	result1, objptr
0dd0c     04 62 06 F1 | 	add	objptr, #4
0dd10     31 7D 02 FB | 	rdlong	_var01, objptr
0dd14     3B 7D 02 F1 | 	add	_var01, result1
0dd18     3E 91 42 FC | 	wrbyte	arg01, _var01
0dd1c     31 77 02 FB | 	rdlong	result1, objptr
0dd20     01 76 06 F1 | 	add	result1, #1
0dd24     31 77 62 FC | 	wrlong	result1, objptr
0dd28     04 62 86 F1 | 	sub	objptr, #4
0dd2c                 | ' 			p(i) = c
0dd2c                 | ' 			i = i+1
0dd2c                 | ' 			return 1
0dd2c     01 76 06 F6 | 	mov	result1, #1
0dd30     04 00 90 FD | 	jmp	#__system____strs_cl_pfunc__ret
0dd34                 | LR__2110
0dd34                 | ' 			return -1
0dd34     01 76 66 F6 | 	neg	result1, #1
0dd38                 | __system____strs_cl_pfunc__ret
0dd38     2D 00 64 FD | 	ret
0dd3c                 | 
0dd3c                 | __system___struct__s_vfs_file_t_putchar_
0dd3c     04 CA 05 F6 | 	mov	COUNT_, #4
0dd40     E8 00 A0 FD | 	call	#pushregs_
0dd44     1C 62 06 F1 | 	add	objptr, #28
0dd48     31 A7 0A FB | 	rdlong	local01, objptr wz
0dd4c     1C 62 86 F1 | 	sub	objptr, #28
0dd50     00 76 06 A6 |  if_e	mov	result1, #0
0dd54     48 00 90 AD |  if_e	jmp	#LR__2120
0dd58     1C 62 06 F1 | 	add	objptr, #28
0dd5c     31 A9 02 FB | 	rdlong	local02, objptr
0dd60     54 AB 02 F6 | 	mov	local03, local02
0dd64     1C 62 86 F1 | 	sub	objptr, #28
0dd68     13 AA 46 F7 | 	zerox	local03, #19
0dd6c     14 A8 46 F0 | 	shr	local02, #20
0dd70     02 A8 66 F0 | 	shl	local02, #2
0dd74     2D A9 02 F1 | 	add	local02, __methods__
0dd78     54 A9 02 FB | 	rdlong	local02, local02
0dd7c     31 93 02 F6 | 	mov	arg02, objptr
0dd80     31 AD 02 F6 | 	mov	local04, objptr
0dd84     55 63 02 F6 | 	mov	objptr, local03
0dd88     2D A8 62 FD | 	call	local02
0dd8c     56 63 02 F6 | 	mov	objptr, local04
0dd90                 | '     return (i < 0) ? 0 : 1;
0dd90     00 76 56 F2 | 	cmps	result1, #0 wc
0dd94     00 A6 06 C6 |  if_b	mov	local01, #0
0dd98     01 A6 06 36 |  if_ae	mov	local01, #1
0dd9c     53 77 02 F6 | 	mov	result1, local01
0dda0                 | LR__2120
0dda0     E7 F0 03 F6 | 	mov	ptra, fp
0dda4     F2 00 A0 FD | 	call	#popregs_
0dda8                 | __system___struct__s_vfs_file_t_putchar__ret
0dda8     2D 00 64 FD | 	ret
0ddac                 | 
0ddac                 | __system___struct__s_vfs_file_t_getchar_
0ddac     03 CA 05 F6 | 	mov	COUNT_, #3
0ddb0     E8 00 A0 FD | 	call	#pushregs_
0ddb4     20 62 06 F1 | 	add	objptr, #32
0ddb8     31 91 0A FB | 	rdlong	arg01, objptr wz
0ddbc     20 62 86 F1 | 	sub	objptr, #32
0ddc0     01 76 66 A6 |  if_e	neg	result1, #1
0ddc4     38 00 90 AD |  if_e	jmp	#LR__2130
0ddc8                 | '     return getcf(__this);
0ddc8     20 62 06 F1 | 	add	objptr, #32
0ddcc     31 A7 02 FB | 	rdlong	local01, objptr
0ddd0     53 A9 02 F6 | 	mov	local02, local01
0ddd4     20 62 86 F1 | 	sub	objptr, #32
0ddd8     13 A8 46 F7 | 	zerox	local02, #19
0dddc     14 A6 46 F0 | 	shr	local01, #20
0dde0     02 A6 66 F0 | 	shl	local01, #2
0dde4     2D A7 02 F1 | 	add	local01, __methods__
0dde8     53 A7 02 FB | 	rdlong	local01, local01
0ddec     31 91 02 F6 | 	mov	arg01, objptr
0ddf0     31 AB 02 F6 | 	mov	local03, objptr
0ddf4     54 63 02 F6 | 	mov	objptr, local02
0ddf8     2D A6 62 FD | 	call	local01
0ddfc     55 63 02 F6 | 	mov	objptr, local03
0de00                 | LR__2130
0de00     E7 F0 03 F6 | 	mov	ptra, fp
0de04     F2 00 A0 FD | 	call	#popregs_
0de08                 | __system___struct__s_vfs_file_t_getchar__ret
0de08     2D 00 64 FD | 	ret
0de0c                 | 
0de0c                 | __system___struct___bas_wrap_sender_tx_
0de0c     03 CA 05 F6 | 	mov	COUNT_, #3
0de10     E8 00 A0 FD | 	call	#pushregs_
0de14     31 A7 02 FB | 	rdlong	local01, objptr
0de18     53 A9 02 F6 | 	mov	local02, local01
0de1c     13 A6 46 F7 | 	zerox	local01, #19
0de20     14 A8 46 F0 | 	shr	local02, #20
0de24     02 A8 66 F0 | 	shl	local02, #2
0de28     2D A9 02 F1 | 	add	local02, __methods__
0de2c     54 A9 02 FB | 	rdlong	local02, local02
0de30     31 AB 02 F6 | 	mov	local03, objptr
0de34     53 63 02 F6 | 	mov	objptr, local01
0de38     2D A8 62 FD | 	call	local02
0de3c     55 63 02 F6 | 	mov	objptr, local03
0de40     01 76 06 F6 | 	mov	result1, #1
0de44     E7 F0 03 F6 | 	mov	ptra, fp
0de48     F2 00 A0 FD | 	call	#popregs_
0de4c                 | __system___struct___bas_wrap_sender_tx__ret
0de4c     2D 00 64 FD | 	ret
0de50                 | 
0de50                 | __system___struct___bas_wrap_sender_rx_
0de50     03 CA 05 F6 | 	mov	COUNT_, #3
0de54     E8 00 A0 FD | 	call	#pushregs_
0de58     04 62 06 F1 | 	add	objptr, #4
0de5c     31 A7 02 FB | 	rdlong	local01, objptr
0de60     53 A9 02 F6 | 	mov	local02, local01
0de64     04 62 86 F1 | 	sub	objptr, #4
0de68     13 A8 46 F7 | 	zerox	local02, #19
0de6c     14 A6 46 F0 | 	shr	local01, #20
0de70     02 A6 66 F0 | 	shl	local01, #2
0de74     2D A7 02 F1 | 	add	local01, __methods__
0de78     53 A7 02 FB | 	rdlong	local01, local01
0de7c     31 AB 02 F6 | 	mov	local03, objptr
0de80     54 63 02 F6 | 	mov	objptr, local02
0de84     2D A6 62 FD | 	call	local01
0de88     55 63 02 F6 | 	mov	objptr, local03
0de8c     E7 F0 03 F6 | 	mov	ptra, fp
0de90     F2 00 A0 FD | 	call	#popregs_
0de94                 | __system___struct___bas_wrap_sender_rx__ret
0de94     2D 00 64 FD | 	ret
0de98                 | 
0de98                 | __system___struct___bas_wrap_sender_close_
0de98     03 CA 05 F6 | 	mov	COUNT_, #3
0de9c     E8 00 A0 FD | 	call	#pushregs_
0dea0     08 62 06 F1 | 	add	objptr, #8
0dea4     31 A7 02 FB | 	rdlong	local01, objptr
0dea8     53 A9 02 F6 | 	mov	local02, local01
0deac     08 62 86 F1 | 	sub	objptr, #8
0deb0     13 A8 46 F7 | 	zerox	local02, #19
0deb4     14 A6 46 F0 | 	shr	local01, #20
0deb8     02 A6 66 F0 | 	shl	local01, #2
0debc     2D A7 02 F1 | 	add	local01, __methods__
0dec0     53 A7 02 FB | 	rdlong	local01, local01
0dec4     31 AB 02 F6 | 	mov	local03, objptr
0dec8     54 63 02 F6 | 	mov	objptr, local02
0decc     2D A6 62 FD | 	call	local01
0ded0     55 63 02 F6 | 	mov	objptr, local03
0ded4     E7 F0 03 F6 | 	mov	ptra, fp
0ded8     F2 00 A0 FD | 	call	#popregs_
0dedc                 | __system___struct___bas_wrap_sender_close__ret
0dedc     2D 00 64 FD | 	ret
0dee0                 | 
0dee0                 | LR__2140
0dee0     2F          | 	byte	"/"
0dee1     00          | 	byte	0
0dee2                 | LR__2141
0dee2     69 6E 66    | 	byte	"inf"
0dee5     00          | 	byte	0
0dee6                 | LR__2142
0dee6     6E 61 6E    | 	byte	"nan"
0dee9     00          | 	byte	0
0deea                 | LR__2143
0deea     20 21 21 21 
0deee     20 63 6F 72 
0def2     72 75 70 74 
0def6     65 64 20 68 
0defa     65 61 70 3F 
0defe     3F 3F 20 21 
0df02     21 21 20    | 	byte	" !!! corrupted heap??? !!! "
0df05     00          | 	byte	0
0df06                 | LR__2144
0df06     20 21 21 21 
0df0a     20 6F 75 74 
0df0e     20 6F 66 20 
0df12     68 65 61 70 
0df16     20 6D 65 6D 
0df1a     6F 72 79 20 
0df1e     21 21 21 20 | 	byte	" !!! out of heap memory !!! "
0df22     00          | 	byte	0
0df23                 | LR__2145
0df23     20 21 21 21 
0df27     20 63 6F 72 
0df2b     72 75 70 74 
0df2f     65 64 20 68 
0df33     65 61 70 20 
0df37     21 21 21 20 | 	byte	" !!! corrupted heap !!! "
0df3b     00          | 	byte	0
0df3c                 | LR__2146
0df3c     00          | 	byte	0
0df3d     00          | 	byte	0
0df3e                 | LR__2147
0df3e     54 5A       | 	byte	"TZ"
0df40     00          | 	byte	0
0df41                 | LR__2148
0df41     2A 3A 3C 3E 
0df45     7C 22 3F 7F | 	byte	"*:<>|",34,"?",127
0df49     00          | 	byte	0
0df4a                 | LR__2149
0df4a     2B 2C 3B 3D 
0df4e     5B 5D       | 	byte	"+,;=[]"
0df50     00          | 	byte	0
0df51                 | LR__2150
0df51     46 41 54 33 
0df55     32 20 20 20 | 	byte	"FAT32   "
0df59     00          | 	byte	0
0df5a                 | LR__2151
0df5a     00          | 	byte	0
0df5b     00          | 	byte	0
0df5c                 | LR__2152
0df5c     2F 73 64    | 	byte	"/sd"
0df5f     00          | 	byte	0
0df60                 | LR__2153
0df60     2F 73 64 2F 
0df64     62 61 73    | 	byte	"/sd/bas"
0df67     00          | 	byte	0
0df68                 | LR__2154
0df68     2F 73 64 2F 
0df6c     62 61 73    | 	byte	"/sd/bas"
0df6f     00          | 	byte	0
0df70                 | LR__2155
0df70     6B 77 61 73 | 	byte	"kwas"
0df74     00          | 	byte	0
0df75                 | LR__2156
0df75                 | 	byte	
0df75     00          | 	byte	0
0df76     00 00       | 	alignl
0df78                 | _dat_
0df78     00 00 00 00 
0df7c     00 00 00 00 
0df80     00 00 00 00 
0df84     00 00 00 00 | 	byte	$00[16]
0df88     61 41 17 0E 
0df8c     62 42 00 00 
0df90     63 43 19 10 
0df94     64 44 00 00 | 	byte	$61, $41, $17, $0e, $62, $42, $00, $00, $63, $43, $19, $10, $64, $44, $00, $00
0df98     65 45 18 0F 
0df9c     66 46 00 00 
0dfa0     67 47 00 00 
0dfa4     68 48 00 00 | 	byte	$65, $45, $18, $0f, $66, $46, $00, $00, $67, $47, $00, $00, $68, $48, $00, $00
0dfa8     69 49 00 00 
0dfac     6A 4A 00 00 
0dfb0     6B 4B 00 00 
0dfb4     6C 4C 1F 16 | 	byte	$69, $49, $00, $00, $6a, $4a, $00, $00, $6b, $4b, $00, $00, $6c, $4c, $1f, $16
0dfb8     6D 4D 00 00 
0dfbc     6E 4E 1A 11 
0dfc0     6F 4F 1E 15 
0dfc4     70 50 00 00 | 	byte	$6d, $4d, $00, $00, $6e, $4e, $1a, $11, $6f, $4f, $1e, $15, $70, $50, $00, $00
0dfc8     71 51 00 00 
0dfcc     72 52 00 00 
0dfd0     73 53 1B 12 
0dfd4     74 54 00 00 | 	byte	$71, $51, $00, $00, $72, $52, $00, $00, $73, $53, $1b, $12, $74, $54, $00, $00
0dfd8     75 55 00 00 
0dfdc     76 56 00 00 
0dfe0     77 57 00 00 
0dfe4     78 58 1C 13 | 	byte	$75, $55, $00, $00, $76, $56, $00, $00, $77, $57, $00, $00, $78, $58, $1c, $13
0dfe8     79 59 00 00 
0dfec     7A 5A 1D 14 
0dff0     31 21 04 00 
0dff4     32 40 05 00 | 	byte	$79, $59, $00, $00, $7a, $5a, $1d, $14, $31, $21, $04, $00, $32, $40, $05, $00
0dff8     33 23 06 00 
0dffc     34 24 07 00 
0e000     35 25 08 00 
0e004     36 5E 09 00 | 	byte	$33, $23, $06, $00, $34, $24, $07, $00, $35, $25, $08, $00, $36, $5e, $09, $00
0e008     37 26 0A 00 
0e00c     38 2A 0B 00 
0e010     39 28 0C 00 
0e014     30 29 0D 00 | 	byte	$37, $26, $0a, $00, $38, $2a, $0b, $00, $39, $28, $0c, $00, $30, $29, $0d, $00
0e018     8D 8D 00 00 
0e01c     9B 9B 00 00 
0e020     88 88 00 00 
0e024     89 89 00 00 | 	byte	$8d, $8d, $00, $00, $9b, $9b, $00, $00, $88, $88, $00, $00, $89, $89, $00, $00
0e028     20 20 00 00 
0e02c     2D 5F 00 00 
0e030     3D 2B 00 00 
0e034     5B 7B 00 00 | 	byte	$20, $20, $00, $00, $2d, $5f, $00, $00, $3d, $2b, $00, $00, $5b, $7b, $00, $00
0e038     5D 7D 00 00 
0e03c     5C 7C 00 00 
0e040     23 7E 00 00 
0e044     3B 3A 00 00 | 	byte	$5d, $7d, $00, $00, $5c, $7c, $00, $00, $23, $7e, $00, $00, $3b, $3a, $00, $00
0e048     27 22 00 00 
0e04c     60 7E 03 00 
0e050     2C 3C 00 00 
0e054     2E 3E 00 00 | 	byte	$27, $22, $00, $00, $60, $7e, $03, $00, $2c, $3c, $00, $00, $2e, $3e, $00, $00
0e058     2F 3F 00 00 
0e05c     B9 B9 00 00 
0e060     BA 00 00 00 
0e064     BB 00 00 00 | 	byte	$2f, $3f, $00, $00, $b9, $b9, $00, $00, $ba, $00, $00, $00, $bb, $00, $00, $00
0e068     BC 00 00 00 
0e06c     BD 00 00 00 
0e070     BE 00 00 00 
0e074     BF 00 00 00 | 	byte	$bc, $00, $00, $00, $bd, $00, $00, $00, $be, $00, $00, $00, $bf, $00, $00, $00
0e078     C0 00 00 00 
0e07c     C1 00 00 00 
0e080     C2 00 00 00 
0e084     C3 00 00 00 | 	byte	$c0, $00, $00, $00, $c1, $00, $00, $00, $c2, $00, $00, $00, $c3, $00, $00, $00
0e088     C4 00 00 00 
0e08c     C5 00 00 00 
0e090     C6 00 00 00 
0e094     C7 00 00 00 | 	byte	$c4, $00, $00, $00, $c5, $00, $00, $00, $c6, $00, $00, $00, $c7, $00, $00, $00
0e098     C8 00 00 00 
0e09c     C9 00 00 00 
0e0a0     CA 00 00 00 
0e0a4     CB 00 00 00 | 	byte	$c8, $00, $00, $00, $c9, $00, $00, $00, $ca, $00, $00, $00, $cb, $00, $00, $00
0e0a8     7F 7F 00 00 
0e0ac     CC 00 00 00 
0e0b0     CD 00 00 00 
0e0b4     CE 00 00 00 | 	byte	$7f, $7f, $00, $00, $cc, $00, $00, $00, $cd, $00, $00, $00, $ce, $00, $00, $00
0e0b8     CF 00 00 00 
0e0bc     D0 00 00 00 
0e0c0     D1 00 00 00 
0e0c4     D2 00 00 00 | 	byte	$cf, $00, $00, $00, $d0, $00, $00, $00, $d1, $00, $00, $00, $d2, $00, $00, $00
0e0c8     2F 2F 00 00 
0e0cc     2A 2A 00 00 
0e0d0     2D 2D 00 00 
0e0d4     2B 2B 00 00 | 	byte	$2f, $2f, $00, $00, $2a, $2a, $00, $00, $2d, $2d, $00, $00, $2b, $2b, $00, $00
0e0d8     8D 8D 00 00 
0e0dc     31 31 00 00 
0e0e0     32 32 00 00 
0e0e4     33 33 00 00 | 	byte	$8d, $8d, $00, $00, $31, $31, $00, $00, $32, $32, $00, $00, $33, $33, $00, $00
0e0e8     34 34 00 00 
0e0ec     35 35 00 00 
0e0f0     36 36 00 00 
0e0f4     37 37 00 00 | 	byte	$34, $34, $00, $00, $35, $35, $00, $00, $36, $36, $00, $00, $37, $37, $00, $00
0e0f8     38 38 00 00 
0e0fc     39 39 00 00 
0e100     30 30 00 00 
0e104     2E 7F 00 00 | 	byte	$38, $38, $00, $00, $39, $39, $00, $00, $30, $30, $00, $00, $2e, $7f, $00, $00
0e108     5C 7C 00 00 
0e10c     00 00 00 00 
0e110     00 00 00 00 
0e114     3D 3D 00 00 | 	byte	$5c, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3d, $3d, $00, $00
0e118     00 00 00 00 
      ...             
0e170     00 00 00 00 
0e174     00 00 00 00 | 	byte	$00[96]
0e178     01 00 00 00 
0e17c     00 00 00 00 
0e180     00 00 00 00 
0e184     00 00 00 00 | mouse  file "mouse2.def"
0e188     00 00 00 00 
0e18c     00 00 00 00 
0e190     00 00 00 00 
0e194     00 00 00 00 | 	byte	$00[16]
0e198     01 01 00 00 
0e19c     00 00 00 00 
0e1a0     00 00 00 00 
0e1a4     00 00 00 00 | 	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e1a8     00 00 00 00 
0e1ac     00 00 00 00 
0e1b0     00 00 00 00 
0e1b4     00 00 00 00 | 	byte	$00[16]
0e1b8     01 0D 01 00 
0e1bc     00 00 00 00 
0e1c0     00 00 00 00 
0e1c4     00 00 00 00 | 	byte	$01, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e1c8     00 00 00 00 
0e1cc     00 00 00 00 
0e1d0     00 00 00 00 
0e1d4     00 00 00 00 | 	byte	$00[16]
0e1d8     01 0D 0D 01 
0e1dc     00 00 00 00 
0e1e0     00 00 00 00 
0e1e4     00 00 00 00 | 	byte	$01, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e1e8     00 00 00 00 
0e1ec     00 00 00 00 
0e1f0     00 00 00 00 
0e1f4     00 00 00 00 | 	byte	$00[16]
0e1f8     01 0D 0D 0D 
0e1fc     01 00 00 00 
0e200     00 00 00 00 
0e204     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e208     00 00 00 00 
0e20c     00 00 00 00 
0e210     00 00 00 00 
0e214     00 00 00 00 | 	byte	$00[16]
0e218     01 0D 0D 0D 
0e21c     0D 01 00 00 
0e220     00 00 00 00 
0e224     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e228     00 00 00 00 
0e22c     00 00 00 00 
0e230     00 00 00 00 
0e234     00 00 00 00 | 	byte	$00[16]
0e238     01 0D 0D 0D 
0e23c     0D 0D 01 00 
0e240     00 00 00 00 
0e244     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e248     00 00 00 00 
0e24c     00 00 00 00 
0e250     00 00 00 00 
0e254     00 00 00 00 | 	byte	$00[16]
0e258     01 0D 0D 0D 
0e25c     0D 0D 0D 01 
0e260     00 00 00 00 
0e264     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00
0e268     00 00 00 00 
0e26c     00 00 00 00 
0e270     00 00 00 00 
0e274     00 00 00 00 | 	byte	$00[16]
0e278     01 0D 0D 0D 
0e27c     0D 0D 0D 0C 
0e280     01 00 00 00 
0e284     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00, $00
0e288     00 00 00 00 
0e28c     00 00 00 00 
0e290     00 00 00 00 
0e294     00 00 00 00 | 	byte	$00[16]
0e298     01 0D 0D 0D 
0e29c     0D 0D 0D 0D 
0e2a0     0C 01 00 00 
0e2a4     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00
0e2a8     00 00 00 00 
0e2ac     00 00 00 00 
0e2b0     00 00 00 00 
0e2b4     00 00 00 00 | 	byte	$00[16]
0e2b8     01 0D 0D 0D 
0e2bc     0D 0D 0D 0D 
0e2c0     0D 0C 01 00 
0e2c4     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00
0e2c8     00 00 00 00 
0e2cc     00 00 00 00 
0e2d0     00 00 00 00 
0e2d4     00 00 00 00 | 	byte	$00[16]
0e2d8     01 0D 0D 0D 
0e2dc     0D 0D 0D 0D 
0e2e0     0D 0D 0B 01 
0e2e4     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0b, $01, $00, $00, $00, $00
0e2e8     00 00 00 00 
0e2ec     00 00 00 00 
0e2f0     00 00 00 00 
0e2f4     00 00 00 00 | 	byte	$00[16]
0e2f8     01 0D 0D 0D 
0e2fc     0C 0D 0D 03 
0e300     01 01 01 01 
0e304     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0c, $0d, $0d, $03, $01, $01, $01, $01, $00, $00, $00, $00
0e308     00 00 00 00 
0e30c     00 00 00 00 
0e310     00 00 00 00 
0e314     00 00 00 00 | 	byte	$00[16]
0e318     01 0D 0D 0C 
0e31c     01 09 0D 03 
0e320     00 00 00 00 
0e324     00 00 00 00 | 	byte	$01, $0d, $0d, $0c, $01, $09, $0d, $03, $00, $00, $00, $00, $00, $00, $00, $00
0e328     00 00 00 00 
0e32c     00 00 00 00 
0e330     00 00 00 00 
0e334     00 00 00 00 | 	byte	$00[16]
0e338     01 0D 0C 01 
0e33c     00 01 0D 0B 
0e340     01 00 00 00 
0e344     00 00 00 00 | 	byte	$01, $0d, $0c, $01, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00, $00
0e348     00 00 00 00 
0e34c     00 00 00 00 
0e350     00 00 00 00 
0e354     00 00 00 00 | 	byte	$00[16]
0e358     01 0C 01 00 
0e35c     00 01 0A 0D 
0e360     01 00 00 00 
0e364     00 00 00 00 | 	byte	$01, $0c, $01, $00, $00, $01, $0a, $0d, $01, $00, $00, $00, $00, $00, $00, $00
0e368     00 00 00 00 
0e36c     00 00 00 00 
0e370     00 00 00 00 
0e374     00 00 00 00 | 	byte	$00[16]
0e378     01 01 00 00 
0e37c     00 00 01 0D 
0e380     0B 01 00 00 
0e384     00 00 00 00 | 	byte	$01, $01, $00, $00, $00, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00
0e388     00 00 00 00 
0e38c     00 00 00 00 
0e390     00 00 00 00 
0e394     00 00 00 00 
0e398     00 00 00 00 
0e39c     00 00       | 	byte	$00[22]
0e39e     01 0B 0D 01 
0e3a2     00 00 00 00 
0e3a6     00 00 00 00 
0e3aa     00 00 00 00 | 	byte	$01, $0b, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e3ae     00 00 00 00 
0e3b2     00 00 00 00 
0e3b6     00 00 00 00 
0e3ba     00 00 00 00 
0e3be     00          | 	byte	$00[17]
0e3bf     01 01 00 00 
0e3c3     00 00 00 00 
0e3c7     00 00 00 00 
0e3cb     00 00 00 00 | 	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e3cf     00 00 00 00 
      ...             
0e573     00 00 00 00 
0e577     00          | 	byte	$00[425]
0e578                 | 	alignl
0e578                 | _hg010b_spin2_dat_
0e578                 | 
0e578     00 00 00 00 
0e57c     00 00 00 00 
0e580     00 00 00 00 
0e584     00 00 00 00 
0e588     00 00 00    | vga_font       file "vgafont.def"
0e58b     7E 81 A5 81 
0e58f     81 BD 99 81 
0e593     81 7E 00 00 
0e597     00 00 00 00 | 	byte	$7e, $81, $a5, $81, $81, $bd, $99, $81, $81, $7e, $00, $00, $00, $00, $00, $00
0e59b     7E FF DB FF 
0e59f     FF C3 E7 FF 
0e5a3     FF 7E 00 00 
0e5a7     00 00 00 00 | 	byte	$7e, $ff, $db, $ff, $ff, $c3, $e7, $ff, $ff, $7e, $00, $00, $00, $00, $00, $00
0e5ab     00 36 7F 7F 
0e5af     7F 7F 3E 1C 
0e5b3     08 00 00 00 
0e5b7     00 00 00 00 | 	byte	$00, $36, $7f, $7f, $7f, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00
0e5bb     00 08 1C 3E 
0e5bf     7F 3E 1C 08 
0e5c3     00 00 00 00 
0e5c7     00 00 00 00 | 	byte	$00, $08, $1c, $3e, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00
0e5cb     18 3C 3C E7 
0e5cf     E7 E7 18 18 
0e5d3     3C 00 00 00 
0e5d7     00 00 00 00 | 	byte	$18, $3c, $3c, $e7, $e7, $e7, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
0e5db     18 3C 7E FF 
0e5df     FF 7E 18 18 
0e5e3     3C 00 00 00 
0e5e7     00 00 00 00 | 	byte	$18, $3c, $7e, $ff, $ff, $7e, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
0e5eb     00 00 00 18 
0e5ef     3C 3C 18 00 
0e5f3     00 00 00 00 
0e5f7     00 FF FF FF | 	byte	$00, $00, $00, $18, $3c, $3c, $18, $00, $00, $00, $00, $00, $00, $ff, $ff, $ff
0e5fb     FF FF FF E7 
0e5ff     C3 C3 E7 FF 
0e603     FF FF FF FF 
0e607     FF 00 00 00 | 	byte	$ff, $ff, $ff, $e7, $c3, $c3, $e7, $ff, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
0e60b     00 00 3C 66 
0e60f     42 42 66 3C 
0e613     00 00 00 00 
0e617     00 FF FF FF | 	byte	$00, $00, $3c, $66, $42, $42, $66, $3c, $00, $00, $00, $00, $00, $ff, $ff, $ff
0e61b     FF FF C3 99 
0e61f     BD BD 99 C3 
0e623     FF FF FF FF 
0e627     FF 00 00 00 | 	byte	$ff, $ff, $c3, $99, $bd, $bd, $99, $c3, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
0e62b     78 70 58 4C 
0e62f     1E 33 33 33 
0e633     33 1E 00 00 
0e637     00 00 00 00 | 	byte	$78, $70, $58, $4c, $1e, $33, $33, $33, $33, $1e, $00, $00, $00, $00, $00, $00
0e63b     3C 66 66 66 
0e63f     66 3C 18 7E 
0e643     18 18 00 00 
0e647     00 00 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00
0e64b     FC CC FC 0C 
0e64f     0C 0C 0C 0E 
0e653     0F 07 00 00 
0e657     00 00 00 00 | 	byte	$fc, $cc, $fc, $0c, $0c, $0c, $0c, $0e, $0f, $07, $00, $00, $00, $00, $00, $00
0e65b     FE C6 FE C6 
0e65f     C6 C6 C6 E6 
0e663     E7 67 03 00 
0e667     00 00 00 00 | 	byte	$fe, $c6, $fe, $c6, $c6, $c6, $c6, $e6, $e7, $67, $03, $00, $00, $00, $00, $00
0e66b     18 18 DB 3C 
0e66f     E7 3C DB 18 
0e673     18 00 00 00 
0e677     00 00 00 01 | 	byte	$18, $18, $db, $3c, $e7, $3c, $db, $18, $18, $00, $00, $00, $00, $00, $00, $01
0e67b     03 07 0F 1F 
0e67f     7F 1F 0F 07 
0e683     03 01 00 00 
0e687     00 00 00 40 | 	byte	$03, $07, $0f, $1f, $7f, $1f, $0f, $07, $03, $01, $00, $00, $00, $00, $00, $40
0e68b     60 70 78 7C 
0e68f     7F 7C 78 70 
0e693     60 40 00 00 
0e697     00 00 00 00 | 	byte	$60, $70, $78, $7c, $7f, $7c, $78, $70, $60, $40, $00, $00, $00, $00, $00, $00
0e69b     18 3C 7E 18 
0e69f     18 18 7E 3C 
0e6a3     18 00 00 00 
0e6a7     00 00 00 00 | 	byte	$18, $3c, $7e, $18, $18, $18, $7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00
0e6ab     66 66 66 66 
0e6af     66 66 66    | 	byte	$66[7]
0e6b2     00 66 66 00 
0e6b6     00 00 00 00 
0e6ba     00 FE DB DB 
0e6be     DB DE D8 D8 | 	byte	$00, $66, $66, $00, $00, $00, $00, $00, $00, $fe, $db, $db, $db, $de, $d8, $d8
0e6c2     D8 D8 D8 00 
0e6c6     00 00 00 3E 
0e6ca     63 06 1C 36 
0e6ce     63 63 36 1C | 	byte	$d8, $d8, $d8, $00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c
0e6d2     30 63 3E 00 
0e6d6     00 00 00 00 
0e6da     00 00 00 00 
0e6de     00 00 00 7F | 	byte	$30, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
0e6e2     7F 7F 7F 00 
0e6e6     00 00 00 00 
0e6ea     00 18 3C 7E 
0e6ee     18 18 18 7E | 	byte	$7f, $7f, $7f, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $7e
0e6f2     3C 18 7E 00 
0e6f6     00 00 00 00 
0e6fa     00 18 3C 7E 
0e6fe     18 18 18 18 | 	byte	$3c, $18, $7e, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $18
0e702     18 18 18 00 
0e706     00 00 00 00 
0e70a     00 18 18 18 
0e70e     18 18 18 18 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0e712     7E 3C 18 00 
0e716     00 00 00 00 
0e71a     00 00 00 18 
0e71e     30 7F 30 18 | 	byte	$7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $18, $30, $7f, $30, $18
0e722     00 00 00 00 
0e726     00 00 00 00 
0e72a     00 00 00    | 	byte	$00[11]
0e72d     0C 06 7F 06 
0e731     0C 00 00 00 
0e735     00 00 00 00 
0e739     00 00 00 00 | 	byte	$0c, $06, $7f, $06, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e73d     00 03 03 03 
0e741     7F 00 00 00 
0e745     00 00 00 00 
0e749     00 00 00 00 | 	byte	$00, $03, $03, $03, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e74d     14 36 7F 36 
0e751     14 00 00 00 
0e755     00 00 00 00 
0e759     00 00 00 08 | 	byte	$14, $36, $7f, $36, $14, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08
0e75d     1C 1C 3E 3E 
0e761     7F 7F 00 00 
0e765     00 00 00 00 
0e769     00 00 00 7F | 	byte	$1c, $1c, $3e, $3e, $7f, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
0e76d     7F 3E 3E 1C 
0e771     1C 08 00 00 
0e775     00 00 00 00 
0e779     00 00 00 00 | 	byte	$7f, $3e, $3e, $1c, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e77d     00 00 00 00 
0e781     00 00 00 00 
0e785     00 00 00 00 
0e789     00 00       | 	byte	$00[14]
0e78b     18 3C 3C 3C 
0e78f     18 18 18 00 
0e793     18 18 00 00 
0e797     00 00 66 66 | 	byte	$18, $3c, $3c, $3c, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $66, $66
0e79b     66 24 00 00 
0e79f     00 00 00 00 
0e7a3     00 00 00 00 
0e7a7     00 00 00 00 | 	byte	$66, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e7ab     00 36 36 7F 
0e7af     36 36 36 7F 
0e7b3     36 36 00 00 
0e7b7     00 00 18 18 | 	byte	$00, $36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $18, $18
0e7bb     3E 63 43 03 
0e7bf     3E 60 60 61 
0e7c3     63 3E 18 18 
0e7c7     00 00 00 00 | 	byte	$3e, $63, $43, $03, $3e, $60, $60, $61, $63, $3e, $18, $18, $00, $00, $00, $00
0e7cb     00 00 43 63 
0e7cf     30 18 0C 06 
0e7d3     63 61 00 00 
0e7d7     00 00 00 00 | 	byte	$00, $00, $43, $63, $30, $18, $0c, $06, $63, $61, $00, $00, $00, $00, $00, $00
0e7db     1C 36 36 1C 
0e7df     6E 3B 33 33 
0e7e3     33 6E 00 00 
0e7e7     00 00 00 00 | 	byte	$1c, $36, $36, $1c, $6e, $3b, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00
0e7eb     0C 0C 0C 06 
0e7ef     00 00 00 00 
0e7f3     00 00 00 00 
0e7f7     00 00 00 00 | 	byte	$0c, $0c, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e7fb     30 18 0C 0C 
0e7ff     0C 0C 0C 0C 
0e803     18 30 00 00 
0e807     00 00 00 00 | 	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00
0e80b     0C 18 30 30 
0e80f     30 30 30 30 
0e813     18 0C 00 00 
0e817     00 00 00 00 | 	byte	$0c, $18, $30, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00
0e81b     00 00 00 66 
0e81f     3C FF 3C 66 
0e823     00 00 00 00 
0e827     00 00 00 00 | 	byte	$00, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00
0e82b     00 00 00 18 
0e82f     18 7E 18 18 
0e833     00 00 00 00 
0e837     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
0e83b     00 00 00 00 
0e83f     00 00 00 00 | 	byte	$00[8]
0e843     18 18 18 0C 
0e847     00 00 00 00 
0e84b     00 00 00 00 
0e84f     00 7F 00 00 | 	byte	$18, $18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f, $00, $00
0e853     00 00 00 00 
0e857     00 00 00 00 
0e85b     00 00 00 00 
0e85f     00 00 00 00 | 	byte	$00[16]
0e863     18 18 00 00 
0e867     00 00 00 00 
0e86b     00 00 40 60 
0e86f     30 18 0C 06 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $40, $60, $30, $18, $0c, $06
0e873     03 01 00 00 
0e877     00 00 00 00 
0e87b     1C 36 63 63 
0e87f     6B 6B 63 63 | 	byte	$03, $01, $00, $00, $00, $00, $00, $00, $1c, $36, $63, $63, $6b, $6b, $63, $63
0e883     36 1C 00 00 
0e887     00 00 00 00 
0e88b     18 1C 1E 18 
0e88f     18 18 18 18 | 	byte	$36, $1c, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18, $18
0e893     18 7E 00 00 
0e897     00 00 00 00 
0e89b     3E 63 60 30 
0e89f     18 0C 06 03 | 	byte	$18, $7e, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $30, $18, $0c, $06, $03
0e8a3     63 7F 00 00 
0e8a7     00 00 00 00 
0e8ab     3E 63 60 60 
0e8af     3C 60 60 60 | 	byte	$63, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $60, $3c, $60, $60, $60
0e8b3     63 3E 00 00 
0e8b7     00 00 00 00 
0e8bb     30 38 3C 36 
0e8bf     33 7F 30 30 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30, $30
0e8c3     30 78 00 00 
0e8c7     00 00 00 00 
0e8cb     7F 03 03 03 
0e8cf     3F 60 60 60 | 	byte	$30, $78, $00, $00, $00, $00, $00, $00, $7f, $03, $03, $03, $3f, $60, $60, $60
0e8d3     63 3E 00 00 
0e8d7     00 00 00 00 
0e8db     1C 06 03 03 
0e8df     3F 63 63 63 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $1c, $06, $03, $03, $3f, $63, $63, $63
0e8e3     63 3E 00 00 
0e8e7     00 00 00 00 
0e8eb     7F 63 60 60 
0e8ef     30 18 0C 0C | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $7f, $63, $60, $60, $30, $18, $0c, $0c
0e8f3     0C 0C 00 00 
0e8f7     00 00 00 00 
0e8fb     3E 63 63 63 
0e8ff     3E 63 63 63 | 	byte	$0c, $0c, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $3e, $63, $63, $63
0e903     63 3E 00 00 
0e907     00 00 00 00 
0e90b     3E 63 63 63 
0e90f     7E 60 60 60 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $7e, $60, $60, $60
0e913     30 1E 00 00 
0e917     00 00 00 00 
0e91b     00 00 00 18 
0e91f     18 00 00 00 | 	byte	$30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
0e923     18 18 00 00 
0e927     00 00 00 00 
0e92b     00 00 00 18 
0e92f     18 00 00 00 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
0e933     18 18 0C 00 
0e937     00 00 00 00 
0e93b     00 60 30 18 
0e93f     0C 06 0C 18 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $60, $30, $18, $0c, $06, $0c, $18
0e943     30 60 00 00 
0e947     00 00 00 00 
0e94b     00 00 00 7E 
0e94f     00 00 7E 00 | 	byte	$30, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00, $7e, $00
0e953     00 00 00 00 
0e957     00 00 00 00 
0e95b     00          | 	byte	$00[9]
0e95c     06 0C 18 30 
0e960     60 30 18 0C 
0e964     06 00 00 00 
0e968     00 00 00 3E | 	byte	$06, $0c, $18, $30, $60, $30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $3e
0e96c     63 63 30 18 
0e970     18 18 00 18 
0e974     18 00 00 00 
0e978     00 00 00 00 | 	byte	$63, $63, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00
0e97c     3E 63 63 7B 
0e980     7B 7B 3B 03 
0e984     3E 00 00 00 
0e988     00 00 00 08 | 	byte	$3e, $63, $63, $7b, $7b, $7b, $3b, $03, $3e, $00, $00, $00, $00, $00, $00, $08
0e98c     1C 36 63 63 
0e990     7F 63 63 63 
0e994     63 00 00 00 
0e998     00 00 00 3F | 	byte	$1c, $36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3f
0e99c     66 66 66 3E 
0e9a0     66 66 66 66 
0e9a4     3F 00 00 00 
0e9a8     00 00 00 3C | 	byte	$66, $66, $66, $3e, $66, $66, $66, $66, $3f, $00, $00, $00, $00, $00, $00, $3c
0e9ac     66 43 03 03 
0e9b0     03 03 43 66 
0e9b4     3C 00 00 00 
0e9b8     00 00 00 1F | 	byte	$66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00, $00, $1f
0e9bc     36 66 66 66 
0e9c0     66 66 66 36 
0e9c4     1F 00 00 00 
0e9c8     00 00 00 7F | 	byte	$36, $66, $66, $66, $66, $66, $66, $36, $1f, $00, $00, $00, $00, $00, $00, $7f
0e9cc     66 46 16 1E 
0e9d0     16 06 46 66 
0e9d4     7F 00 00 00 
0e9d8     00 00 00 7F | 	byte	$66, $46, $16, $1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $7f
0e9dc     66 46 16 1E 
0e9e0     16 06 06 06 
0e9e4     0F 00 00 00 
0e9e8     00 00 00 3C | 	byte	$66, $46, $16, $1e, $16, $06, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $3c
0e9ec     66 43 03 03 
0e9f0     7B 63 63 66 
0e9f4     5C 00 00 00 
0e9f8     00 00 00 63 | 	byte	$66, $43, $03, $03, $7b, $63, $63, $66, $5c, $00, $00, $00, $00, $00, $00, $63
0e9fc     63 63 63 7F 
0ea00     63 63 63 63 
0ea04     63 00 00 00 
0ea08     00 00 00 3C | 	byte	$63, $63, $63, $7f, $63, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3c
0ea0c     18 18 18 18 
0ea10     18 18 18 18 | 	byte	$18[8]
0ea14     3C 00 00 00 
0ea18     00 00 00 78 
0ea1c     30 30 30 30 
0ea20     30 33 33 33 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $78, $30, $30, $30, $30, $30, $33, $33, $33
0ea24     1E 00 00 00 
0ea28     00 00 00 67 
0ea2c     66 66 36 1E 
0ea30     1E 36 66 66 | 	byte	$1e, $00, $00, $00, $00, $00, $00, $67, $66, $66, $36, $1e, $1e, $36, $66, $66
0ea34     67 00 00 00 
0ea38     00 00 00 0F 
0ea3c     06 06 06 06 
0ea40     06 06 46 66 | 	byte	$67, $00, $00, $00, $00, $00, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
0ea44     7F 00 00 00 
0ea48     00 00 00 63 
0ea4c     77 7F 7F 6B 
0ea50     63 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $7f, $6b, $63, $63, $63, $63
0ea54     63 00 00 00 
0ea58     00 00 00 63 
0ea5c     67 6F 7F 7B 
0ea60     73 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63
0ea64     63 00 00 00 
0ea68     00 00 00 3E 
0ea6c     63 63 63 63 
0ea70     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
0ea74     3E 00 00 00 
0ea78     00 00 00 3F 
0ea7c     66 66 66 3E 
0ea80     06 06 06 06 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $06, $06, $06, $06
0ea84     0F 00 00 00 
0ea88     00 00 00 3E 
0ea8c     63 63 63 63 
0ea90     63 63 6B 7B | 	byte	$0f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $6b, $7b
0ea94     3E 30 70 00 
0ea98     00 00 00 3F 
0ea9c     66 66 66 3E 
0eaa0     36 66 66 66 | 	byte	$3e, $30, $70, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66
0eaa4     67 00 00 00 
0eaa8     00 00 00 3E 
0eaac     63 63 06 1C 
0eab0     30 60 63 63 | 	byte	$67, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
0eab4     3E 00 00 00 
0eab8     00 00 00 7E 
0eabc     7E 5A 18 18 
0eac0     18 18 18 18 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
0eac4     3C 00 00 00 
0eac8     00 00 00 63 
0eacc     63 63 63 63 
0ead0     63 63 63 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
0ead4     3E 00 00 00 
0ead8     00 00 00 63 
0eadc     63 63 63 63 
0eae0     63 63 36 1C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $36, $1c
0eae4     08 00 00 00 
0eae8     00 00 00 63 
0eaec     63 63 63 6B 
0eaf0     6B 6B 7F 77 | 	byte	$08, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $6b, $6b, $6b, $7f, $77
0eaf4     36 00 00 00 
0eaf8     00 00 00 63 
0eafc     63 36 3E 1C 
0eb00     1C 3E 36 63 | 	byte	$36, $00, $00, $00, $00, $00, $00, $63, $63, $36, $3e, $1c, $1c, $3e, $36, $63
0eb04     63 00 00 00 
0eb08     00 00 00 66 
0eb0c     66 66 66 3C 
0eb10     18 18 18 18 | 	byte	$63, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18
0eb14     3C 00 00 00 
0eb18     00 00 00 7F 
0eb1c     63 61 30 18 
0eb20     0C 06 43 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
0eb24     7F 00 00 00 
0eb28     00 00 00 3C 
0eb2c     0C 0C 0C 0C 
0eb30     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
0eb34     3C 00 00 00 
0eb38     00 00 00 00 
0eb3c     01 03 07 0E 
0eb40     1C 38 70 60 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $01, $03, $07, $0e, $1c, $38, $70, $60
0eb44     40 00 00 00 
0eb48     00 00 00 3C 
0eb4c     30 30 30 30 
0eb50     30 30 30 30 | 	byte	$40, $00, $00, $00, $00, $00, $00, $3c, $30, $30, $30, $30, $30, $30, $30, $30
0eb54     3C 00 00 00 
0eb58     1C 36 00 00 
0eb5c     00 00 00 00 
0eb60     00 00 00 00 | 	byte	$3c, $00, $00, $00, $1c, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0eb64     00 00 00 00 
0eb68     00 00 00 00 
0eb6c     00 00 00 00 
0eb70     00 00 00 00 
0eb74     00          | 	byte	$00[17]
0eb75     FF 00 00 0C 
0eb79     18 00 00 00 
0eb7d     00 00 00 00 
0eb81     00 00 00 00 | 	byte	$ff, $00, $00, $0c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0eb85     00 00 00 00 
0eb89     00 00 00 00 
0eb8d     00          | 	byte	$00[9]
0eb8e     1E 30 3E 33 
0eb92     33 33 6E 00 
0eb96     00 00 00 00 
0eb9a     00 07 06 06 | 	byte	$1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $07, $06, $06
0eb9e     1E 36 66 66 
0eba2     66 66 3E 00 
0eba6     00 00 00 00 
0ebaa     00 00 00 00 | 	byte	$1e, $36, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
0ebae     3E 63 03 03 
0ebb2     03 63 3E 00 
0ebb6     00 00 00 00 
0ebba     00 38 30 30 | 	byte	$3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $30, $30
0ebbe     3C 36 33 33 
0ebc2     33 33 6E 00 
0ebc6     00 00 00 00 
0ebca     00 00 00 00 | 	byte	$3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $00, $00, $00
0ebce     3E 63 7F 03 
0ebd2     03 63 3E 00 
0ebd6     00 00 00 00 
0ebda     00 38 6C 4C | 	byte	$3e, $63, $7f, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $6c, $4c
0ebde     0C 1E 0C 0C 
0ebe2     0C 0C 1E 00 
0ebe6     00 00 00 00 
0ebea     00 00 00 00 | 	byte	$0c, $1e, $0c, $0c, $0c, $0c, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
0ebee     6E 33 33 33 
0ebf2     33 33 3E 30 
0ebf6     33 1E 00 00 
0ebfa     00 07 06 06 | 	byte	$6e, $33, $33, $33, $33, $33, $3e, $30, $33, $1e, $00, $00, $00, $07, $06, $06
0ebfe     36 6E 66 66 
0ec02     66 66 67 00 
0ec06     00 00 00 00 
0ec0a     00 18 18 00 | 	byte	$36, $6e, $66, $66, $66, $66, $67, $00, $00, $00, $00, $00, $00, $18, $18, $00
0ec0e     1C 18 18 18 
0ec12     18 18 3C 00 
0ec16     00 00 00 00 
0ec1a     00 60 60 00 | 	byte	$1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $60, $60, $00
0ec1e     70 60 60 60 
0ec22     60 60 60 66 
0ec26     66 3C 00 00 
0ec2a     00 07 06 06 | 	byte	$70, $60, $60, $60, $60, $60, $60, $66, $66, $3c, $00, $00, $00, $07, $06, $06
0ec2e     66 36 1E 1E 
0ec32     36 66 67 00 
0ec36     00 00 00 00 
0ec3a     00 1C 18 18 | 	byte	$66, $36, $1e, $1e, $36, $66, $67, $00, $00, $00, $00, $00, $00, $1c, $18, $18
0ec3e     18 18 18 18 
0ec42     18 18       | 	byte	$18[6]
0ec44     3C 00 00 00 
0ec48     00 00 00 00 
0ec4c     00 00 37 7F 
0ec50     6B 6B 6B 6B | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $6b, $6b, $6b
0ec54     63 00 00 00 
0ec58     00 00 00 00 
0ec5c     00 00 3B 66 
0ec60     66 66 66 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
0ec64     66 00 00 00 
0ec68     00 00 00 00 
0ec6c     00 00 3E 63 
0ec70     63 63 63 63 | 	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63
0ec74     3E 00 00 00 
0ec78     00 00 00 00 
0ec7c     00 00 3B 66 
0ec80     66 66 66 66 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
0ec84     3E 06 06 0F 
0ec88     00 00 00 00 
0ec8c     00 00 6E 33 
0ec90     33 33 33 33 | 	byte	$3e, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $6e, $33, $33, $33, $33, $33
0ec94     3E 30 30 78 
0ec98     00 00 00 00 
0ec9c     00 00 3B 6E 
0eca0     66 06 06 06 | 	byte	$3e, $30, $30, $78, $00, $00, $00, $00, $00, $00, $3b, $6e, $66, $06, $06, $06
0eca4     0F 00 00 00 
0eca8     00 00 00 00 
0ecac     00 00 3E 63 
0ecb0     06 1C 30 63 | 	byte	$0f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63
0ecb4     3E 00 00 00 
0ecb8     00 00 00 08 
0ecbc     0C 0C 3F 0C 
0ecc0     0C 0C 0C 6C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
0ecc4     38 00 00 00 
0ecc8     00 00 00 00 
0eccc     00 00 33 33 
0ecd0     33 33 33 33 | 	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $33, $33, $33, $33, $33, $33
0ecd4     6E 00 00 00 
0ecd8     00 00 00 00 
0ecdc     00 00 63 63 
0ece0     63 63 63 36 | 	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36
0ece4     1C 00 00 00 
0ece8     00 00 00 00 
0ecec     00 00 63 63 
0ecf0     6B 6B 6B 7F | 	byte	$1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $6b, $6b, $6b, $7f
0ecf4     36 00 00 00 
0ecf8     00 00 00 00 
0ecfc     00 00 63 36 
0ed00     1C 1C 1C 36 | 	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $1c, $36
0ed04     63 00 00 00 
0ed08     00 00 00 00 
0ed0c     00 00 63 63 
0ed10     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63
0ed14     7E 60 30 1F 
0ed18     00 00 00 00 
0ed1c     00 00 7F 33 
0ed20     18 0C 06 63 | 	byte	$7e, $60, $30, $1f, $00, $00, $00, $00, $00, $00, $7f, $33, $18, $0c, $06, $63
0ed24     7F 00 00 00 
0ed28     00 00 00 70 
0ed2c     18 18 18 0E 
0ed30     18 18 18 18 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18, $18
0ed34     70 00 00 00 
0ed38     00 00 00 18 
0ed3c     18 18 18 18 
0ed40     18 18 18 18 | 	byte	$70, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18
0ed44     18 00 00 00 
0ed48     00 00 00 0E 
0ed4c     18 18 18 70 
0ed50     18 18 18 18 | 	byte	$18, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18, $18
0ed54     0E 00 00 00 
0ed58     6E 3B 00 00 
0ed5c     00 00 00 00 
0ed60     00 00 00 00 | 	byte	$0e, $00, $00, $00, $6e, $3b, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0ed64     00 00 00 00 
0ed68     00 00 00 00 
0ed6c     00 00       | 	byte	$00[10]
0ed6e     08 1C 36 63 
0ed72     63 63 7F 00 
0ed76     00 00 00 00 
0ed7a     00 3C 66 43 | 	byte	$08, $1c, $36, $63, $63, $63, $7f, $00, $00, $00, $00, $00, $00, $3c, $66, $43
0ed7e     03 03 03 03 
0ed82     43 66 3C 18 
0ed86     30 1E 00 00 
0ed8a     00 00 33 00 | 	byte	$03, $03, $03, $03, $43, $66, $3c, $18, $30, $1e, $00, $00, $00, $00, $33, $00
0ed8e     33 33 33 33 
0ed92     33 33       | 	byte	$33[6]
0ed94     6E 00 00 00 
0ed98     00 00 60 30 
0ed9c     18 00 3E 63 
0eda0     7F 03 03 63 | 	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $7f, $03, $03, $63
0eda4     3E 00 00 00 
0eda8     00 00 08 1C 
0edac     36 00 1E 30 
0edb0     3E 33 33 33 | 	byte	$3e, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $1e, $30, $3e, $33, $33, $33
0edb4     6E 00 00 00 
0edb8     00 00 00 00 
0edbc     33 00 1E 30 
0edc0     3E 33 33 33 | 	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $33, $00, $1e, $30, $3e, $33, $33, $33
0edc4     6E 00 00 00 
0edc8     00 00 1C 36 
0edcc     1C 00 33 33 
0edd0     33 33 33 33 | 	byte	$6e, $00, $00, $00, $00, $00, $1c, $36, $1c, $00, $33, $33, $33, $33, $33, $33
0edd4     6E 00 00 00 
0edd8     00 00 60 30 
0eddc     18 00 3E 63 
0ede0     03 03 03 63 | 	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $03, $03, $03, $63
0ede4     3E 00 00 00 
0ede8     00 00 00 00 
0edec     00 00 3E 63 
0edf0     03 03 03 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $03, $03, $03, $63
0edf4     3E 18 30 1E 
0edf8     00 00 00 1C 
0edfc     58 78 38 18 
0ee00     1C 1E 1A 18 | 	byte	$3e, $18, $30, $1e, $00, $00, $00, $1c, $58, $78, $38, $18, $1c, $1e, $1a, $18
0ee04     3C 00 00 00 
0ee08     00 00 00 00 
0ee0c     63 00 3E 63 
0ee10     7F 03 03 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $7f, $03, $03, $63
0ee14     3E 00 00 00 
0ee18     66 33 00 3E 
0ee1c     63 63 63 63 
0ee20     63 63 63 63 | 	byte	$3e, $00, $00, $00, $66, $33, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
0ee24     3E 00 00 00 
0ee28     00 00 CC 66 
0ee2c     33 00 3E 63 
0ee30     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $00, $cc, $66, $33, $00, $3e, $63, $63, $63, $63, $63
0ee34     3E 00 00 00 
0ee38     00 00 18 3C 
0ee3c     66 00 1C 18 
0ee40     18 18 18 18 | 	byte	$3e, $00, $00, $00, $00, $00, $18, $3c, $66, $00, $1c, $18, $18, $18, $18, $18
0ee44     3C 00 00 00 
0ee48     30 18 00 7F 
0ee4c     63 61 30 18 
0ee50     0C 06 43 63 | 	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
0ee54     7F 00 00 00 
0ee58     00 63 00 08 
0ee5c     1C 36 63 63 
0ee60     7F 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $63, $00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63
0ee64     63 00 00 00 
0ee68     30 18 00 3C 
0ee6c     66 43 03 03 
0ee70     03 03 43 66 | 	byte	$63, $00, $00, $00, $30, $18, $00, $3c, $66, $43, $03, $03, $03, $03, $43, $66
0ee74     3C 00 00 00 
0ee78     30 18 00 7F 
0ee7c     66 46 16 1E 
0ee80     16 06 46 66 | 	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66
0ee84     7F 00 00 00 
0ee88     0C 06 00 0F 
0ee8c     06 06 06 06 
0ee90     06 06 46 66 | 	byte	$7f, $00, $00, $00, $0c, $06, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
0ee94     7F 00 00 00 
0ee98     30 18 00 1C 
0ee9c     18 18 18 18 
0eea0     18 18 18 18 | 	byte	$7f, $00, $00, $00, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $18, $18, $18
0eea4     3C 00 00 00 
0eea8     00 00 08 1C 
0eeac     36 00 3E 63 
0eeb0     63 63 63 63 | 	byte	$3c, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $3e, $63, $63, $63, $63, $63
0eeb4     3E 00 00 00 
0eeb8     00 00 00 00 
0eebc     63 00 3E 63 
0eec0     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63
0eec4     3E 00 00 00 
0eec8     00 00 00 6F 
0eecc     46 26 06 06 
0eed0     06 06 46 66 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $6f, $46, $26, $06, $06, $06, $06, $46, $66
0eed4     7F 00 00 00 
0eed8     00 00 00 6E 
0eedc     4C 2C 0C 0C 
0eee0     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $6e, $4c, $2c, $0c, $0c, $0c, $0c, $0c, $0c
0eee4     1E 00 00 00 
0eee8     30 18 00 3E 
0eeec     63 63 06 1C 
0eef0     30 60 63 63 | 	byte	$1e, $00, $00, $00, $30, $18, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
0eef4     3E 00 00 00 
0eef8     00 00 60 30 
0eefc     18 00 3E 63 
0ef00     06 1C 30 63 | 	byte	$3e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $06, $1c, $30, $63
0ef04     3E 00 00 00 
0ef08     00 63 00 3E 
0ef0c     63 63 63 63 
0ef10     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
0ef14     3E 00 00 00 
0ef18     00 63 00 63 
0ef1c     63 63 63 63 
0ef20     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $63, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
0ef24     3E 00 00 00 
0ef28     6C 38 00 7E 
0ef2c     7E 5A 18 18 
0ef30     18 18 18 18 | 	byte	$3e, $00, $00, $00, $6c, $38, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
0ef34     3C 00 00 00 
0ef38     00 00 60 48 
0ef3c     2C 0C 3F 0C 
0ef40     0C 0C 0C 6C | 	byte	$3c, $00, $00, $00, $00, $00, $60, $48, $2c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
0ef44     38 00 00 00 
0ef48     00 00 00 0F 
0ef4c     26 36 1E 0E 
0ef50     07 07 46 66 | 	byte	$38, $00, $00, $00, $00, $00, $00, $0f, $26, $36, $1e, $0e, $07, $07, $46, $66
0ef54     7F 00 00 00 
0ef58     00 00 00 00 
0ef5c     00 63 36 1C 
0ef60     1C 36 63 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36, $63, $00
0ef64     00 00 00 00 
0ef68     00 00       | 	byte	$00[6]
0ef6a     36 1C 08 00 
0ef6e     3E 63 03 03 
0ef72     03 63 3E 00 
0ef76     00 00 00 00 | 	byte	$36, $1c, $08, $00, $3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00
0ef7a     30 18 0C 00 
0ef7e     1E 30 3E 33 
0ef82     33 33 6E 00 
0ef86     00 00 00 00 | 	byte	$30, $18, $0c, $00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00
0ef8a     60 30 18 00 
0ef8e     1C 18 18 18 
0ef92     18 18 3C 00 
0ef96     00 00 00 00 | 	byte	$60, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00
0ef9a     60 30 18 00 
0ef9e     3E 63 63 63 
0efa2     63 63 3E 00 
0efa6     00 00 00 00 | 	byte	$60, $30, $18, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00
0efaa     30 18 0C 00 
0efae     33 33 33 33 
0efb2     33 33 6E 00 
0efb6     00 00 00 00 | 	byte	$30, $18, $0c, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00
0efba     00 08 1C 36 
0efbe     63 63 7F 63 
0efc2     63 63 63 18 
0efc6     0C 78 00 00 | 	byte	$00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63, $63, $18, $0c, $78, $00, $00
0efca     00 00 00 00 
0efce     1E 30 3E 33 
0efd2     33 33 6E 18 
0efd6     0C 78 36 1C | 	byte	$00, $00, $00, $00, $1e, $30, $3e, $33, $33, $33, $6e, $18, $0c, $78, $36, $1c
0efda     00 7F 63 61 
0efde     30 18 0C 06 
0efe2     43 63 7F 00 
0efe6     00 00 00 00 | 	byte	$00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00
0efea     36 1C 08 00 
0efee     7F 33 18 0C 
0eff2     06 63 7F 00 
0eff6     00 00 00 00 | 	byte	$36, $1c, $08, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00
0effa     00 7F 66 46 
0effe     16 1E 16 06 
0f002     46 66 7F 18 
0f006     0C 78 00 00 | 	byte	$00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66, $7f, $18, $0c, $78, $00, $00
0f00a     00 00 00 00 
0f00e     3E 63 7F 03 
0f012     03 63 3E 18 
0f016     0C 78 00 00 | 	byte	$00, $00, $00, $00, $3e, $63, $7f, $03, $03, $63, $3e, $18, $0c, $78, $00, $00
0f01a     00 3C 66 03 
0f01e     1F 03 0F 03 
0f022     03 66 3C 00 
0f026     00 00 00 00 | 	byte	$00, $3c, $66, $03, $1f, $03, $0f, $03, $03, $66, $3c, $00, $00, $00, $00, $00
0f02a     60 30 18 00 
0f02e     7F 33 18 0C 
0f032     06 63 7F 00 
0f036     00 00 6C 38 | 	byte	$60, $30, $18, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $6c, $38
0f03a     00 3C 66 43 
0f03e     03 03 03 03 
0f042     43 66 3C 00 
0f046     00 00 00 00 | 	byte	$00, $3c, $66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00
0f04a     00 00 00 00 
0f04e     3E 63 06 1C 
0f052     30 63 3E 18 
0f056     30 1E 00 00 | 	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63, $3e, $18, $30, $1e, $00, $00
0f05a     00 00 00 00 
0f05e     00 00       | 	byte	$00[6]
0f060     6C 36 1B 36 
0f064     6C 00 00 00 
0f068     00 00 00 00 
0f06c     00 00 00 00 | 	byte	$6c, $36, $1b, $36, $6c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f070     1B 36 6C 36 
0f074     1B 00 00 00 
0f078     88 22 88 22 
0f07c     88 22 88 22 | 	byte	$1b, $36, $6c, $36, $1b, $00, $00, $00, $88, $22, $88, $22, $88, $22, $88, $22
0f080     88 22 88 22 
0f084     88 22 88 22 
0f088     AA 55 AA 55 
0f08c     AA 55 AA 55 | 	byte	$88, $22, $88, $22, $88, $22, $88, $22, $aa, $55, $aa, $55, $aa, $55, $aa, $55
0f090     AA 55 AA 55 
0f094     AA 55 AA 55 
0f098     BB EE BB EE 
0f09c     BB EE BB EE | 	byte	$aa, $55, $aa, $55, $aa, $55, $aa, $55, $bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee
0f0a0     BB EE BB EE 
0f0a4     BB EE BB EE 
0f0a8     18 18 18 18 
0f0ac     18 18 18 18 | 	byte	$bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee, $18, $18, $18, $18, $18, $18, $18, $18
0f0b0     18 18 18 18 
0f0b4     18 18 18 18 
0f0b8     18 18 18 18 
0f0bc     18 18 18    | 	byte	$18[15]
0f0bf     1F 18 18 18 
0f0c3     18 18 18 18 
0f0c7     18 30 18 00 
0f0cb     08 1C 36 63 | 	byte	$1f, $18, $18, $18, $18, $18, $18, $18, $18, $30, $18, $00, $08, $1c, $36, $63
0f0cf     63 7F 63 63 
0f0d3     63 63 00 00 
0f0d7     00 1C 36 00 
0f0db     08 1C 36 63 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $1c, $36, $00, $08, $1c, $36, $63
0f0df     63 7F 63 63 
0f0e3     63 63 00 00 
0f0e7     00 36 1C 00 
0f0eb     7F 66 46 16 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $36, $1c, $00, $7f, $66, $46, $16
0f0ef     1E 16 06 46 
0f0f3     66 7F 00 00 
0f0f7     00 00 00 00 
0f0fb     3E 63 63 06 | 	byte	$1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06
0f0ff     1C 30 60 63 
0f103     63 3E 18 30 
0f107     1E 6C 6C 6C 
0f10b     6C 6C 6F 60 | 	byte	$1c, $30, $60, $63, $63, $3e, $18, $30, $1e, $6c, $6c, $6c, $6c, $6c, $6f, $60
0f10f     6F 6C 6C 6C 
0f113     6C 6C 6C 6C 
0f117     6C 6C 6C 6C 
0f11b     6C 6C 6C 6C | 	byte	$6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
0f11f     6C 6C 6C 6C 
0f123     6C 6C 6C 6C 
0f127     6C          | 	byte	$6c[9]
0f128     00 00 00 00 
0f12c     00          | 	byte	$00[5]
0f12d     7F 60 6F 6C 
0f131     6C 6C 6C 6C 
0f135     6C 6C 6C 6C 
0f139     6C 6C 6C 6C | 	byte	$7f, $60, $6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
0f13d     6F 60 7F 00 
0f141     00 00 00 00 
0f145     00 00 00 18 
0f149     18 00 7F 63 | 	byte	$6f, $60, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $7f, $63
0f14d     61 30 18 0C 
0f151     06 43 63 7F 
0f155     00 00 00 00 
0f159     00 00 18 18 | 	byte	$61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00, $00, $18, $18
0f15d     00 7F 33 18 
0f161     0C 06 63 7F 
0f165     00 00 00 00 
0f169     00 00 00 00 | 	byte	$00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00, $00, $00, $00
0f16d     00 00 1F 18 
0f171     18 18 18 18 
0f175     18 18 18 18 
0f179     18 18 18 18 | 	byte	$00, $00, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f17d     18 18 F8 00 
0f181     00 00 00 00 
0f185     00 00 00 18 
0f189     18 18 18 18 | 	byte	$18, $18, $f8, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
0f18d     18 18 FF 00 
0f191     00 00 00 00 
0f195     00 00 00 00 
0f199     00 00 00 00 | 	byte	$18, $18, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f19d     00 00 FF 18 
0f1a1     18 18 18 18 
0f1a5     18 18 18 18 
0f1a9     18 18 18 18 | 	byte	$00, $00, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f1ad     18 18 F8 18 
0f1b1     18 18 18 18 
0f1b5     18 18 18 00 
0f1b9     00 00 00 00 | 	byte	$18, $18, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
0f1bd     00 00 FF 00 
0f1c1     00 00 00 00 
0f1c5     00 00 00 18 
0f1c9     18 18 18 18 | 	byte	$00, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
0f1cd     18 18 FF 18 
0f1d1     18 18 18 18 
0f1d5     18 18 18 63 
0f1d9     3E 00 08 1C | 	byte	$18, $18, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $63, $3e, $00, $08, $1c
0f1dd     36 63 63 7F 
0f1e1     63 63 63 63 
0f1e5     00 00 00 00 
0f1e9     00 00 63 3E | 	byte	$36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $63, $3e
0f1ed     00 1E 30 3E 
0f1f1     33 33 33 6E 
0f1f5     00 00 00 6C 
0f1f9     6C 6C 6C 6C | 	byte	$00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
0f1fd     EC 0C FC 00 
0f201     00 00 00 00 
0f205     00 00 00 00 
0f209     00 00 00 00 | 	byte	$ec, $0c, $fc, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f20d     FC 0C EC 6C 
0f211     6C 6C 6C 6C 
0f215     6C 6C 6C 6C 
0f219     6C 6C 6C 6C | 	byte	$fc, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
0f21d     EF 00 FF 00 
0f221     00 00 00 00 
0f225     00 00 00 00 
0f229     00 00 00 00 | 	byte	$ef, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f22d     FF 00 EF 6C 
0f231     6C 6C 6C 6C 
0f235     6C 6C 6C 6C 
0f239     6C 6C 6C 6C | 	byte	$ff, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
0f23d     EC 0C EC 6C 
0f241     6C 6C 6C 6C 
0f245     6C 6C 6C 00 
0f249     00 00 00 00 | 	byte	$ec, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
0f24d     FF 00 FF 00 
0f251     00 00 00 00 
0f255     00 00 00 6C 
0f259     6C 6C 6C 6C | 	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
0f25d     EF 00 EF 6C 
0f261     6C 6C 6C 6C 
0f265     6C 6C 6C 00 
0f269     00 00 00 00 | 	byte	$ef, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
0f26d     63 3E 63 63 
0f271     63 63 3E 63 
0f275     00 00 00 00 
0f279     00 00 30 7E | 	byte	$63, $3e, $63, $63, $63, $63, $3e, $63, $00, $00, $00, $00, $00, $00, $30, $7e
0f27d     30 3C 36 33 
0f281     33 33 33 6E 
0f285     00 00 00 00 
0f289     00 00 1F 36 | 	byte	$30, $3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $1f, $36
0f28d     66 66 6F 66 
0f291     66 66 36 1F 
0f295     00 00 00 36 
0f299     1C 00 1F 36 | 	byte	$66, $66, $6f, $66, $66, $66, $36, $1f, $00, $00, $00, $36, $1c, $00, $1f, $36
0f29d     66 66 66 66 
0f2a1     66 66       | 	byte	$66[6]
0f2a3     36 1F 00 00 
0f2a7     00 00 63 00 
0f2ab     7F 66 46 16 
0f2af     1E 16 06 46 | 	byte	$36, $1f, $00, $00, $00, $00, $63, $00, $7f, $66, $46, $16, $1e, $16, $06, $46
0f2b3     66 7F 00 00 
0f2b7     00 6C 38 00 
0f2bb     38 30 30 3C 
0f2bf     36 33 33 33 | 	byte	$66, $7f, $00, $00, $00, $6c, $38, $00, $38, $30, $30, $3c, $36, $33, $33, $33
0f2c3     33 6E 00 00 
0f2c7     00 36 1C 00 
0f2cb     63 67 6F 7F 
0f2cf     7B 73 63 63 | 	byte	$33, $6e, $00, $00, $00, $36, $1c, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63
0f2d3     63 63 00 00 
0f2d7     00 30 18 00 
0f2db     3C 18 18 18 
0f2df     18 18 18 18 | 	byte	$63, $63, $00, $00, $00, $30, $18, $00, $3c, $18, $18, $18, $18, $18, $18, $18
0f2e3     18 3C 00 00 
0f2e7     00 3C 66 00 
0f2eb     3C 18 18 18 
0f2ef     18 18 18 18 | 	byte	$18, $3c, $00, $00, $00, $3c, $66, $00, $3c, $18, $18, $18, $18, $18, $18, $18
0f2f3     18 3C 00 00 
0f2f7     00 00 00 36 
0f2fb     1C 08 00 3E 
0f2ff     63 7F 03 03 | 	byte	$18, $3c, $00, $00, $00, $00, $00, $36, $1c, $08, $00, $3e, $63, $7f, $03, $03
0f303     63 3E 00 00 
0f307     00 18 18 18 
0f30b     18 18 18 18 
0f30f     1F 00 00 00 | 	byte	$63, $3e, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $1f, $00, $00, $00
0f313     00 00 00 00 
0f317     00 00 00 00 
0f31b     00 00 00 00 | 	byte	$00[12]
0f31f     F8 18 18 18 
0f323     18 18 18 18 
0f327     18 FF FF FF 
0f32b     FF FF FF FF | 	byte	$f8, $18, $18, $18, $18, $18, $18, $18, $18, $ff, $ff, $ff, $ff, $ff, $ff, $ff
0f32f     FF FF FF FF 
0f333     FF FF FF FF 
0f337     FF          | 	byte	$ff[9]
0f338     00 00 00 00 
0f33c     00 00 00    | 	byte	$00[7]
0f33f     FF FF FF FF 
0f343     FF FF FF FF 
0f347     FF          | 	byte	$ff[9]
0f348     00 00 00 7E 
0f34c     7E 5A 18 18 
0f350     18 18 18 18 
0f354     3C 18 30 1E | 	byte	$00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18, $3c, $18, $30, $1e
0f358     1C 36 1C 63 
0f35c     63 63 63 63 
0f360     63 63 63 63 
0f364     3E 00 00 00 | 	byte	$1c, $36, $1c, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f368     FF FF FF FF 
0f36c     FF FF FF    | 	byte	$ff[7]
0f36f     00 00 00 00 
0f373     00 00 00 00 
0f377     00          | 	byte	$00[9]
0f378     30 18 00 3E 
0f37c     63 63 63 63 
0f380     63 63 63 63 
0f384     3E 00 00 00 | 	byte	$30, $18, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f388     00 00 00 1E 
0f38c     33 33 33 1B 
0f390     33 63 63 63 
0f394     33 00 00 00 | 	byte	$00, $00, $00, $1e, $33, $33, $33, $1b, $33, $63, $63, $63, $33, $00, $00, $00
0f398     1C 36 00 3E 
0f39c     63 63 63 63 
0f3a0     63 63 63 63 
0f3a4     3E 00 00 00 | 	byte	$1c, $36, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f3a8     30 18 00 63 
0f3ac     67 6F 7F 7B 
0f3b0     73 63 63 63 
0f3b4     63 00 00 00 | 	byte	$30, $18, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63, $63, $00, $00, $00
0f3b8     00 00 60 30 
0f3bc     18 00 3B 66 
0f3c0     66 66 66 66 
0f3c4     66 00 00 00 | 	byte	$00, $00, $60, $30, $18, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
0f3c8     00 00 36 1C 
0f3cc     08 00 3B 66 
0f3d0     66 66 66 66 
0f3d4     66 00 00 00 | 	byte	$00, $00, $36, $1c, $08, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
0f3d8     36 1C 00 3E 
0f3dc     63 63 06 1C 
0f3e0     30 60 63 63 
0f3e4     3E 00 00 00 | 	byte	$36, $1c, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63, $3e, $00, $00, $00
0f3e8     00 00 36 1C 
0f3ec     08 00 3E 63 
0f3f0     06 1C 30 63 
0f3f4     3E 00 00 00 | 	byte	$00, $00, $36, $1c, $08, $00, $3e, $63, $06, $1c, $30, $63, $3e, $00, $00, $00
0f3f8     30 18 00 3F 
0f3fc     66 66 66 3E 
0f400     36 66 66 66 
0f404     6F 00 00 00 | 	byte	$30, $18, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00
0f408     30 18 00 63 
0f40c     63 63 63 63 
0f410     63 63 63 63 
0f414     3E 00 00 00 | 	byte	$30, $18, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f418     00 00 60 30 
0f41c     18 00 3B 6E 
0f420     66 06 06 06 
0f424     0F 00 00 00 | 	byte	$00, $00, $60, $30, $18, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00
0f428     66 33 00 63 
0f42c     63 63 63 63 
0f430     63 63 63 63 
0f434     3E 00 00 00 | 	byte	$66, $33, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f438     00 00 60 30 
0f43c     18 00 63 63 
0f440     63 63 63 63 
0f444     7E 60 30 1F | 	byte	$00, $00, $60, $30, $18, $00, $63, $63, $63, $63, $63, $63, $7e, $60, $30, $1f
0f448     30 18 00 66 
0f44c     66 66 66 3C 
0f450     18 18 18 18 
0f454     3C 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18, $3c, $00, $00, $00
0f458     00 00 00 08 
0f45c     0C 0C 3F 0C 
0f460     0C 0C 0C 6C 
0f464     38 18 30 1E | 	byte	$00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c, $38, $18, $30, $1e
0f468     30 18 00 00 
0f46c     00 00 00 00 
0f470     00 00 00 00 
0f474     00 00 00 00 | 	byte	$30, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f478     00 00 00 00 
0f47c     00 00 00 00 | 	byte	$00[8]
0f480     7F 00 00 00 
0f484     00 00 00 00 
0f488     66 33 00 00 
0f48c     00 00 00 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $66, $33, $00, $00, $00, $00, $00, $00
0f490     00 00 00 00 
0f494     00 00 00 00 
0f498     00 00 00 00 
0f49c     00 00 00 00 
0f4a0     00 00 00 00 
0f4a4     00          | 	byte	$00[21]
0f4a5     0C 06 3C 36 
0f4a9     1C 00 00 00 
0f4ad     00 00 00 00 
0f4b1     00 00 00 00 | 	byte	$0c, $06, $3c, $36, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f4b5     00 00 00 63 
0f4b9     3E 00 00 00 
0f4bd     00 00 00 00 
0f4c1     00 00 00 00 | 	byte	$00, $00, $00, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f4c5     00 00 00 00 
0f4c9     3E 63 06 1C 
0f4cd     36 63 63 36 
0f4d1     1C 30 63 3E | 	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c, $30, $63, $3e
0f4d5     00 00 00 00 
0f4d9     00 00 00 00 | 	byte	$00[8]
0f4dd     18 00 7E 00 
0f4e1     18 00 00 00 
0f4e5     00 00 00 00 
0f4e9     00 00 00 00 | 	byte	$18, $00, $7e, $00, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f4ed     00 00 00 00 
0f4f1     00 00 00 00 | 	byte	$00[8]
0f4f5     18 30 1E 00 
0f4f9     00 00 1C 36 
0f4fd     36 1C 00 00 
0f501     00 00 00 00 | 	byte	$18, $30, $1e, $00, $00, $00, $1c, $36, $36, $1c, $00, $00, $00, $00, $00, $00
0f505     00 00 00 00 
0f509     63 00 00 00 
0f50d     00 00 00 00 
0f511     00 00 00 00 | 	byte	$00, $00, $00, $00, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f515     00 00 00 18 
0f519     18 00 00 00 
0f51d     00 00 00 00 
0f521     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f525     00 00 00 00 
0f529     00          | 	byte	$00[5]
0f52a     CC 66 33 00 
0f52e     33 33 33 33 
0f532     33 33 6E 00 
0f536     00 00 36 1C | 	byte	$cc, $66, $33, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $36, $1c
0f53a     00 3F 66 66 
0f53e     66 3E 36 66 
0f542     66 66 6F 00 
0f546     00 00 00 00 | 	byte	$00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00, $00, $00
0f54a     36 1C 08 00 
0f54e     3B 6E 66 06 
0f552     06 06 0F 00 
0f556     00 00 00 00 | 	byte	$36, $1c, $08, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00, $00, $00
0f55a     00 00 00 7E 
0f55e     7E 7E 7E 7E 
0f562     7E 7E 00 00 
0f566     00 00 00 00 | 	byte	$00, $00, $00, $7e, $7e, $7e, $7e, $7e, $7e, $7e, $00, $00, $00, $00, $00, $00
0f56a     00 00 00 00 
0f56e     00 00 00 00 
0f572     00 00 00 00 
0f576     00 00       | 	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f578     00 00 00 00 
      ...             
0f5a8     00 00 00 00 
0f5ac     00 00 00    | st_font        file "st4font.def"
0f5af     FF FF 00 00 
0f5b3     00 00 00 00 
0f5b7     00 18 18 18 
0f5bb     18 18 18 18 | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0f5bf     18 18 18 18 
0f5c3     18 18 18 18 
0f5c7     18          | 	byte	$18[9]
0f5c8     00 00 00 00 
0f5cc     00 00 00    | 	byte	$00[7]
0f5cf     FF FF 18 18 
0f5d3     18 18 18 18 
0f5d7     18 18 18 18 
0f5db     18 18 18 18 | 	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f5df     FF FF 00 00 
0f5e3     00 00 00 00 
0f5e7     00 18 18 18 
0f5eb     18 18 18 18 | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0f5ef     1F 1F 18 18 
0f5f3     18 18 18 18 
0f5f7     18 18 18 18 
0f5fb     18 18 18 18 | 	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f5ff     F8 F8 18 18 
0f603     18 18 18 18 
0f607     18 00 00 00 
0f60b     00 00 00 00 | 	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0f60f     1F 1F 18 18 
0f613     18 18 18 18 
0f617     18 00 00 00 
0f61b     00 00 00 00 | 	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0f61f     F8 F8 18 18 
0f623     18 18 18 18 
0f627     18 18 18 18 
0f62b     18 18 18 18 | 	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f62f     1F 1F 00 00 
0f633     00 00 00 00 
0f637     00 18 18 18 
0f63b     18 18 18 18 | 	byte	$1f, $1f, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0f63f     F8 F8 00 00 
0f643     00 00 00 00 
0f647     00 18 18 18 
0f64b     18 18 18 18 | 	byte	$f8, $f8, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0f64f     FF FF 18 18 
0f653     18 18 18 18 
0f657     18 00 00 18 
0f65b     3C 7E 66 66 | 	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $00, $00, $18, $3c, $7e, $66, $66
0f65f     66 7E 7E 66 
0f663     66 66 66 30 
0f667     18 00 00 7E 
0f66b     7E 06 06 3E | 	byte	$66, $7e, $7e, $66, $66, $66, $66, $30, $18, $00, $00, $7e, $7e, $06, $06, $3e
0f66f     3E 06 06 06 
0f673     06 7E 7E 18 
0f677     0C 30 18 3C 
0f67b     7E 66 66 06 | 	byte	$3e, $06, $06, $06, $06, $7e, $7e, $18, $0c, $30, $18, $3c, $7e, $66, $66, $06
0f67f     06 06 06 66 
0f683     66 7E 3C 00 
0f687     00 30 18 66 
0f68b     66 66 6E 6E | 	byte	$06, $06, $06, $66, $66, $7e, $3c, $00, $00, $30, $18, $66, $66, $66, $6e, $6e
0f68f     7E 7E 76 76 
0f693     66 66 66 00 
0f697     00 30 18 7C 
0f69b     7E 06 06 0E | 	byte	$7e, $7e, $76, $76, $66, $66, $66, $00, $00, $30, $18, $7c, $7e, $06, $06, $0e
0f69f     1C 38 70 60 
0f6a3     60 7E 3E 00 
0f6a7     00 30 18 7E 
0f6ab     7E 30 30 18 | 	byte	$1c, $38, $70, $60, $60, $7e, $3e, $00, $00, $30, $18, $7e, $7e, $30, $30, $18
0f6af     18 0C 0C 06 
0f6b3     06 7E 7E 00 
0f6b7     00 18 18 00 
0f6bb     7E 7E 30 30 | 	byte	$18, $0c, $0c, $06, $06, $7e, $7e, $00, $00, $18, $18, $00, $7e, $7e, $30, $30
0f6bf     18 18 0C 0C 
0f6c3     06 7E 7E 00 
0f6c7     00 30 18 3C 
0f6cb     7E 66 66 66 | 	byte	$18, $18, $0c, $0c, $06, $7e, $7e, $00, $00, $30, $18, $3c, $7e, $66, $66, $66
0f6cf     66 66 66 66 
0f6d3     66          | 	byte	$66[5]
0f6d4     7E 3C 00 00 
0f6d8     00 00 06 06 
0f6dc     06 06 16 1E 
0f6e0     0E 06 06 06 | 	byte	$7e, $3c, $00, $00, $00, $00, $06, $06, $06, $06, $16, $1e, $0e, $06, $06, $06
0f6e4     7E 7E 00 00 
0f6e8     00 00 00 00 
0f6ec     00 3C 7C 60 
0f6f0     7C 7E 66 66 | 	byte	$7e, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $7c, $60, $7c, $7e, $66, $66
0f6f4     7E 7C 30 18 
0f6f8     00 00 00 00 
0f6fc     00 3C 7E 66 
0f700     66 7E 06 06 | 	byte	$7e, $7c, $30, $18, $00, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $06, $06
0f704     7E 7C 18 0C 
0f708     00 00 30 18 
0f70c     00 3C 3E 06 
0f710     06 06 06 06 | 	byte	$7e, $7c, $18, $0c, $00, $00, $30, $18, $00, $3c, $3e, $06, $06, $06, $06, $06
0f714     7E 7C 00 00 
0f718     00 00 30 18 
0f71c     00 3E 7E 66 
0f720     66 66 66 66 | 	byte	$7e, $7c, $00, $00, $00, $00, $30, $18, $00, $3e, $7e, $66, $66, $66, $66, $66
0f724     66 66 00 00 
0f728     00 00 30 18 
0f72c     00 7C 7E 06 
0f730     0E 3C 70 60 | 	byte	$66, $66, $00, $00, $00, $00, $30, $18, $00, $7c, $7e, $06, $0e, $3c, $70, $60
0f734     7E 3E 00 00 
0f738     00 00 30 18 
0f73c     00 7E 7E 30 
0f740     18 18 0C 0C | 	byte	$7e, $3e, $00, $00, $00, $00, $30, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
0f744     7E 7E 00 00 
0f748     00 00 18 18 
0f74c     00 7E 7E 30 
0f750     18 18 0C 0C | 	byte	$7e, $7e, $00, $00, $00, $00, $18, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
0f754     7E 7E 00 00 
0f758     00 00 30 18 
0f75c     00 3C 7E 66 
0f760     66 66 66 66 | 	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $00, $3c, $7e, $66, $66, $66, $66, $66
0f764     7E 3C 00 00 
0f768     00 00 1C 1C 
0f76c     18 18 38 3C 
0f770     1C 18 18 18 | 	byte	$7e, $3c, $00, $00, $00, $00, $1c, $1c, $18, $18, $38, $3c, $1c, $18, $18, $18
0f774     3C 3C 00 00 
0f778     00 00 00 00 
0f77c     00 00 00 00 
0f780     00 00 00 00 | 	byte	$3c, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f784     00 00 00 00 
0f788     00 00       | 	byte	$00[6]
0f78a     18 18 18 18 
0f78e     18 18 18 18 | 	byte	$18[8]
0f792     00 00 18 18 
0f796     00 00 00 00 
0f79a     66 66 66 66 
0f79e     00 00 00 00 | 	byte	$00, $00, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $00, $00, $00, $00
0f7a2     00 00 00 00 
0f7a6     00 00 00 00 
0f7aa     00          | 	byte	$00[9]
0f7ab     66 66 FF FF 
0f7af     66 66 FF FF 
0f7b3     66 66 00 00 
0f7b7     00 00 18 18 | 	byte	$66, $66, $ff, $ff, $66, $66, $ff, $ff, $66, $66, $00, $00, $00, $00, $18, $18
0f7bb     7C 7E 06 06 
0f7bf     3E 7C 60 60 
0f7c3     7E 3E 18 18 
0f7c7     00 00 00 66 | 	byte	$7c, $7e, $06, $06, $3e, $7c, $60, $60, $7e, $3e, $18, $18, $00, $00, $00, $66
0f7cb     66 30 30 18 
0f7cf     18 0C 0C 66 
0f7d3     66 00 00 00 
0f7d7     00 00 3C 7E | 	byte	$66, $30, $30, $18, $18, $0c, $0c, $66, $66, $00, $00, $00, $00, $00, $3c, $7e
0f7db     66 66 3C 1C 
0f7df     1C FC FE 66 
0f7e3     66 FE FC 00 
0f7e7     00 00 00 18 | 	byte	$66, $66, $3c, $1c, $1c, $fc, $fe, $66, $66, $fe, $fc, $00, $00, $00, $00, $18
0f7eb     18 18 18 18 
0f7ef     00 00 00 00 
0f7f3     00 00 00 00 
0f7f7     00 00 00 30 | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $30
0f7fb     18 1C 0C 0C 
0f7ff     0C 0C 0C 0C 
0f803     1C 18 30 00 
0f807     00 00 00 0C | 	byte	$18, $1c, $0c, $0c, $0c, $0c, $0c, $0c, $1c, $18, $30, $00, $00, $00, $00, $0c
0f80b     18 38 30 30 
0f80f     30 30 30 30 
0f813     38 18 0C 00 
0f817     00 00 00 00 | 	byte	$18, $38, $30, $30, $30, $30, $30, $30, $38, $18, $0c, $00, $00, $00, $00, $00
0f81b     66 66 3C 3C 
0f81f     FF FF 3C 3C 
0f823     66 66 00 00 
0f827     00 00 00 00 | 	byte	$66, $66, $3c, $3c, $ff, $ff, $3c, $3c, $66, $66, $00, $00, $00, $00, $00, $00
0f82b     00 18 18 18 
0f82f     7E 7E 18 18 
0f833     18 00 00 00 
0f837     00 00 00 00 | 	byte	$00, $18, $18, $18, $7e, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0f83b     00 00 00 00 
0f83f     00 00       | 	byte	$00[6]
0f841     18 18 18 18 
0f845     18          | 	byte	$18[5]
0f846     0C 04 00 00 
0f84a     00 00 00 00 
0f84e     7E 7E 00 00 
0f852     00 00 00 00 | 	byte	$0c, $04, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $00, $00, $00, $00
0f856     00 00 00 00 
0f85a     00 00 00 00 
0f85e     00 00 00 00 
0f862     00          | 	byte	$00[13]
0f863     18 18 18 00 
0f867     00 00 00 60 
0f86b     60 60 30 30 
0f86f     18 18 0C 0C | 	byte	$18, $18, $18, $00, $00, $00, $00, $60, $60, $60, $30, $30, $18, $18, $0c, $0c
0f873     06 06 06 00 
0f877     00 00 00 3C 
0f87b     7E 66 66 66 
0f87f     76 6E 66 66 | 	byte	$06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $76, $6e, $66, $66
0f883     66 7E 3C 00 
0f887     00 00 00 18 
0f88b     18 1C 1C 18 
0f88f     18 18 18 18 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $18, $18, $1c, $1c, $18, $18, $18, $18, $18
0f893     18 7E 7E 00 
0f897     00 00 00 3C 
0f89b     7E 66 66 30 
0f89f     30 18 18 0C | 	byte	$18, $7e, $7e, $00, $00, $00, $00, $3c, $7e, $66, $66, $30, $30, $18, $18, $0c
0f8a3     0C 7E 7E 00 
0f8a7     00 00 00 7E 
0f8ab     7E 30 30 18 
0f8af     18 30 30 66 | 	byte	$0c, $7e, $7e, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $30, $30, $66
0f8b3     66 7E 3C 00 
0f8b7     00 00 00 30 
0f8bb     30 38 38 3C 
0f8bf     3C 36 36 7E | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $30, $30, $38, $38, $3c, $3c, $36, $36, $7e
0f8c3     7E 30 30 00 
0f8c7     00 00 00 7E 
0f8cb     7E 06 06 3E 
0f8cf     7E 60 60 60 | 	byte	$7e, $30, $30, $00, $00, $00, $00, $7e, $7e, $06, $06, $3e, $7e, $60, $60, $60
0f8d3     66 7E 3C 00 
0f8d7     00 00 00 38 
0f8db     3C 0E 06 06 
0f8df     3E 7E 66 66 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $38, $3c, $0e, $06, $06, $3e, $7e, $66, $66
0f8e3     66 7E 3C 00 
0f8e7     00 00 00 7E 
0f8eb     7E 60 60 30 
0f8ef     30 18 18 0C | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $7e, $7e, $60, $60, $30, $30, $18, $18, $0c
0f8f3     0C 0C 0C 00 
0f8f7     00 00 00 3C 
0f8fb     7E 66 66 3C 
0f8ff     3C 66 66 66 | 	byte	$0c, $0c, $0c, $00, $00, $00, $00, $3c, $7e, $66, $66, $3c, $3c, $66, $66, $66
0f903     66 7E 3C 00 
0f907     00 00 00 3C 
0f90b     7E 66 66 7E 
0f90f     7C 60 60 60 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $7c, $60, $60, $60
0f913     70 3C 1C 00 
0f917     00 00 00 00 
0f91b     00 00 18 18 
0f91f     18 00 00 00 | 	byte	$70, $3c, $1c, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $00
0f923     18 18 18 00 
0f927     00 00 00 00 
0f92b     00 00 18 18 
0f92f     18 00 00 18 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $18
0f933     18 18 18 0C 
0f937     04 00 00 00 
0f93b     70 38 1C 0E 
0f93f     07 0E 1C 38 | 	byte	$18, $18, $18, $0c, $04, $00, $00, $00, $70, $38, $1c, $0e, $07, $0e, $1c, $38
0f943     70 00 00 00 
0f947     00 00 00 00 
0f94b     00 00 7E 7E 
0f94f     00 00 7E 7E | 	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $7e, $7e
0f953     00 00 00 00 
0f957     00 00 00 00 | 	byte	$00[8]
0f95b     0E 1C 38 70 
0f95f     E0 70 38 1C 
0f963     0E 00 00 00 
0f967     00 00 00 3C | 	byte	$0e, $1c, $38, $70, $e0, $70, $38, $1c, $0e, $00, $00, $00, $00, $00, $00, $3c
0f96b     7E 66 66 30 
0f96f     30 18 18 18 
0f973     00 18 18 00 
0f977     00 00 00 3C | 	byte	$7e, $66, $66, $30, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $3c
0f97b     7E 66 66 66 
0f97f     66 36 06 66 
0f983     66 7E 3C 00 
0f987     00 00 00 18 | 	byte	$7e, $66, $66, $66, $66, $36, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $18
0f98b     3C 7E 66 66 
0f98f     66 7E 7E 66 
0f993     66 66 66 00 
0f997     00 00 00 3E | 	byte	$3c, $7e, $66, $66, $66, $7e, $7e, $66, $66, $66, $66, $00, $00, $00, $00, $3e
0f99b     7E 66 66 7E 
0f99f     3E 66 66 66 
0f9a3     66 7E 3E 00 
0f9a7     00 00 00 3C | 	byte	$7e, $66, $66, $7e, $3e, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $3c
0f9ab     7E 66 66 06 
0f9af     06 06 06 66 
0f9b3     66 7E 3C 00 
0f9b7     00 00 00 3E | 	byte	$7e, $66, $66, $06, $06, $06, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $3e
0f9bb     7E 66 66 66 
0f9bf     66 66 66 66 
0f9c3     66 7E 3E 00 
0f9c7     00 00 00 7E | 	byte	$7e, $66, $66, $66, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $7e
0f9cb     7E 06 06 3E 
0f9cf     3E 06 06 06 
0f9d3     06 7E 7E 00 
0f9d7     00 00 00 7E | 	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $7e, $7e, $00, $00, $00, $00, $7e
0f9db     7E 06 06 3E 
0f9df     3E 06 06 06 
0f9e3     06 06 06 00 
0f9e7     00 00 00 7C | 	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $7c
0f9eb     7E 06 06 76 
0f9ef     76 66 66 66 
0f9f3     66 7E 3C 00 
0f9f7     00 00 00 66 | 	byte	$7e, $06, $06, $76, $76, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $66
0f9fb     66 66 66 7E 
0f9ff     7E 66 66 66 
0fa03     66 66 66 00 
0fa07     00 00 00 7E | 	byte	$66, $66, $66, $7e, $7e, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $7e
0fa0b     7E 18 18 18 
0fa0f     18 18 18 18 
0fa13     18 7E 7E 00 
0fa17     00 00 00 60 | 	byte	$7e, $18, $18, $18, $18, $18, $18, $18, $18, $7e, $7e, $00, $00, $00, $00, $60
0fa1b     60 60 60 60 
0fa1f     60 60 60    | 	byte	$60[7]
0fa22     66 66 7E 3C 
0fa26     00 00 00 00 
0fa2a     66 66 36 36 
0fa2e     1E 1E 36 36 | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $36, $36, $1e, $1e, $36, $36
0fa32     66 66 C6 C6 
0fa36     00 00 00 00 
0fa3a     06 06 06 06 
0fa3e     06 06 06 06 | 	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $06, $06, $06, $06, $06, $06, $06, $06
0fa42     06 06 7E 7E 
0fa46     00 00 00 00 
0fa4a     C6 C6 EE EE 
0fa4e     FE D6 D6 C6 | 	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $c6, $c6, $ee, $ee, $fe, $d6, $d6, $c6
0fa52     C6 C6 C6 C6 
0fa56     00 00 00 00 
0fa5a     66 66 66 6E 
0fa5e     6E 7E 7E 76 | 	byte	$c6, $c6, $c6, $c6, $00, $00, $00, $00, $66, $66, $66, $6e, $6e, $7e, $7e, $76
0fa62     76 66 66 66 
0fa66     00 00 00 00 
0fa6a     3C 7E 66 66 
0fa6e     66 66 66 66 | 	byte	$76, $66, $66, $66, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
0fa72     66 66 7E 3C 
0fa76     00 00 00 00 
0fa7a     3E 7E 66 66 
0fa7e     66 66 7E 3E | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $66, $7e, $3e
0fa82     06 06 06 06 
0fa86     00 00 00 00 
0fa8a     3C 7E 66 66 
0fa8e     66 66 66 66 | 	byte	$06, $06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
0fa92     66 56 3E 6C 
0fa96     00 00 00 00 
0fa9a     3E 7E 66 66 
0fa9e     66 7E 3E 36 | 	byte	$66, $56, $3e, $6c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $7e, $3e, $36
0faa2     66 66 C6 C6 
0faa6     00 00 00 00 
0faaa     7C 7E 06 06 
0faae     0E 1C 38 70 | 	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $7c, $7e, $06, $06, $0e, $1c, $38, $70
0fab2     60 60 7E 3E 
0fab6     00 00 00 00 
0faba     7E 7E 18 18 
0fabe     18 18 18 18 | 	byte	$60, $60, $7e, $3e, $00, $00, $00, $00, $7e, $7e, $18, $18, $18, $18, $18, $18
0fac2     18 18 18 18 
0fac6     00 00 00 00 
0faca     66 66 66 66 
0face     66 66 66 66 | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
0fad2     66 66 7E 3C 
0fad6     00 00 00 00 
0fada     66 66 66 66 
0fade     66 66 66 66 | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
0fae2     3C 3C 18 18 
0fae6     00 00 00 00 
0faea     C6 C6 C6 C6 
0faee     C6 D6 D6 FE | 	byte	$3c, $3c, $18, $18, $00, $00, $00, $00, $c6, $c6, $c6, $c6, $c6, $d6, $d6, $fe
0faf2     FE EE C6 82 
0faf6     00 00 00 00 
0fafa     66 66 66 3C 
0fafe     3C 18 18 3C | 	byte	$fe, $ee, $c6, $82, $00, $00, $00, $00, $66, $66, $66, $3c, $3c, $18, $18, $3c
0fb02     3C 66 66 66 
0fb06     00 00 00 00 
0fb0a     66 66 66 66 
0fb0e     66 3C 3C 18 | 	byte	$3c, $66, $66, $66, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c, $18
0fb12     18 18 18 18 
0fb16     00 00 00 00 
0fb1a     7E 7E 30 30 
0fb1e     18 18 0C 0C | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $0c, $0c
0fb22     06 06 7E 7E 
0fb26     00 00 00 00 
0fb2a     3C 3C 0C 0C 
0fb2e     0C 0C 0C 0C | 	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $3c, $3c, $0c, $0c, $0c, $0c, $0c, $0c
0fb32     0C 0C 3C 3C 
0fb36     00 00 00 00 
0fb3a     06 06 0C 0C 
0fb3e     18 18 30 30 | 	byte	$0c, $0c, $3c, $3c, $00, $00, $00, $00, $06, $06, $0c, $0c, $18, $18, $30, $30
0fb42     60 60 C0 C0 
0fb46     00 00 00 00 
0fb4a     3C 3C 30 30 
0fb4e     30 30 30 30 | 	byte	$60, $60, $c0, $c0, $00, $00, $00, $00, $3c, $3c, $30, $30, $30, $30, $30, $30
0fb52     30 30 3C 3C 
0fb56     00 00 00 00 
0fb5a     18 18 3C 3C 
0fb5e     66 66 00 00 | 	byte	$30, $30, $3c, $3c, $00, $00, $00, $00, $18, $18, $3c, $3c, $66, $66, $00, $00
0fb62     00 00 00 00 
0fb66     00 00 00 00 
0fb6a     00 00 00 00 
0fb6e     00 00 00 00 
0fb72     00 00       | 	byte	$00[18]
0fb74     FE FE 00 00 
0fb78     00 00 0C 0C 
0fb7c     18 18 00 00 
0fb80     00 00 00 00 | 	byte	$fe, $fe, $00, $00, $00, $00, $0c, $0c, $18, $18, $00, $00, $00, $00, $00, $00
0fb84     00 00 00 00 
0fb88     00 00 00 00 
0fb8c     00          | 	byte	$00[9]
0fb8d     3C 7C 60 7C 
0fb91     7E 66 66 7E 
0fb95     7C 00 00 00 
0fb99     00 06 06 06 | 	byte	$3c, $7c, $60, $7c, $7e, $66, $66, $7e, $7c, $00, $00, $00, $00, $06, $06, $06
0fb9d     3E 7E 66 66 
0fba1     66 66 66 7E 
0fba5     3E 00 00 00 
0fba9     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $00, $00, $00
0fbad     3C 3E 06 06 
0fbb1     06 06 06 7E 
0fbb5     7C 00 00 00 
0fbb9     00 60 60 60 | 	byte	$3c, $3e, $06, $06, $06, $06, $06, $7e, $7c, $00, $00, $00, $00, $60, $60, $60
0fbbd     7C 7E 66 66 
0fbc1     66 66 66 7E 
0fbc5     7C 00 00 00 
0fbc9     00 00 00 00 | 	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $00, $00, $00, $00, $00, $00, $00
0fbcd     3C 7E 66 66 
0fbd1     7E 06 06 7E 
0fbd5     7C 00 00 00 
0fbd9     00 70 78 18 | 	byte	$3c, $7e, $66, $66, $7e, $06, $06, $7e, $7c, $00, $00, $00, $00, $70, $78, $18
0fbdd     18 7E 7E 18 
0fbe1     18 18 18 18 
0fbe5     18 00 00 00 
0fbe9     00 00 00 00 | 	byte	$18, $7e, $7e, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0fbed     7C 7E 66 66 
0fbf1     66 66 7E 7C 
0fbf5     60 7E 3E 00 
0fbf9     00 06 06 06 | 	byte	$7c, $7e, $66, $66, $66, $66, $7e, $7c, $60, $7e, $3e, $00, $00, $06, $06, $06
0fbfd     3E 7E 66 66 
0fc01     66 66 66 66 
0fc05     66 00 00 00 
0fc09     00 18 18 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $18, $18, $00
0fc0d     1C 1C 18 18 
0fc11     18 18 18 3C 
0fc15     3C 00 00 00 
0fc19     00 30 30 00 | 	byte	$1c, $1c, $18, $18, $18, $18, $18, $3c, $3c, $00, $00, $00, $00, $30, $30, $00
0fc1d     30 30 30 30 
0fc21     30 30 30 30 
0fc25     30          | 	byte	$30[9]
0fc26     3E 1E 00 00 
0fc2a     06 06 06 36 
0fc2e     36 1E 1E 1E 
0fc32     36 36 66 66 | 	byte	$3e, $1e, $00, $00, $06, $06, $06, $36, $36, $1e, $1e, $1e, $36, $36, $66, $66
0fc36     00 00 00 00 
0fc3a     1C 1C 18 18 
0fc3e     18 18 18 18 
0fc42     18 18 3C 3C | 	byte	$00, $00, $00, $00, $1c, $1c, $18, $18, $18, $18, $18, $18, $18, $18, $3c, $3c
0fc46     00 00 00 00 
0fc4a     00 00 00    | 	byte	$00[7]
0fc4d     6C FE FE D6 
0fc51     D6 C6 C6 C6 
0fc55     C6 00 00 00 
0fc59     00 00 00 00 | 	byte	$6c, $fe, $fe, $d6, $d6, $c6, $c6, $c6, $c6, $00, $00, $00, $00, $00, $00, $00
0fc5d     3E 7E 66 66 
0fc61     66 66 66 66 
0fc65     66 00 00 00 
0fc69     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
0fc6d     3C 7E 66 66 
0fc71     66 66 66 7E 
0fc75     3C 00 00 00 
0fc79     00 00 00 00 | 	byte	$3c, $7e, $66, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $00, $00, $00
0fc7d     3E 7E 66 66 
0fc81     66 66 66 7E 
0fc85     3E 06 06 00 
0fc89     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $06, $06, $00, $00, $00, $00, $00
0fc8d     7C 7E 66 66 
0fc91     66 66 66 7E 
0fc95     7C 60 60 00 
0fc99     00 00 00 00 | 	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $60, $60, $00, $00, $00, $00, $00
0fc9d     3E 7E 66 06 
0fca1     06 06 06 06 
0fca5     06 00 00 00 
0fca9     00 00 00 00 | 	byte	$3e, $7e, $66, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00
0fcad     7C 7E 06 0E 
0fcb1     3C 70 60 7E 
0fcb5     3E 00 00 00 
0fcb9     00 00 18 18 | 	byte	$7c, $7e, $06, $0e, $3c, $70, $60, $7e, $3e, $00, $00, $00, $00, $00, $18, $18
0fcbd     7E 7E 18 18 
0fcc1     18 18 18 78 
0fcc5     70 00 00 00 
0fcc9     00 00 00 00 | 	byte	$7e, $7e, $18, $18, $18, $18, $18, $78, $70, $00, $00, $00, $00, $00, $00, $00
0fccd     66 66 66 66 
0fcd1     66 66 66    | 	byte	$66[7]
0fcd4     7E 7C 00 00 
0fcd8     00 00 00 00 
0fcdc     00 66 66 66 
0fce0     66 66 3C 3C | 	byte	$7e, $7c, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c
0fce4     18 18 00 00 
0fce8     00 00 00 00 
0fcec     00 C6 C6 D6 
0fcf0     D6 FE FE EE | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $c6, $c6, $d6, $d6, $fe, $fe, $ee
0fcf4     C6 82 00 00 
0fcf8     00 00 00 00 
0fcfc     00 66 66 3C 
0fd00     3C 18 3C 3C | 	byte	$c6, $82, $00, $00, $00, $00, $00, $00, $00, $66, $66, $3c, $3c, $18, $3c, $3c
0fd04     66 66 00 00 
0fd08     00 00 00 00 
0fd0c     00 66 66 66 
0fd10     66 66 66 7E | 	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $7e
0fd14     7C 60 7E 3E 
0fd18     00 00 00 00 
0fd1c     00 7E 7E 30 
0fd20     18 18 0C 0C | 	byte	$7c, $60, $7e, $3e, $00, $00, $00, $00, $00, $7e, $7e, $30, $18, $18, $0c, $0c
0fd24     7E 7E 00 00 
0fd28     00 00 30 18 
0fd2c     18 18 18 0C 
0fd30     0C 18 18 18 | 	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $18, $18, $18, $0c, $0c, $18, $18, $18
0fd34     18 30 00 00 
0fd38     00 00 18 18 
0fd3c     18 18 18 18 
0fd40     18 18 18 18 | 	byte	$18, $30, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0fd44     18 18 00 00 
0fd48     00 00 0C 18 
0fd4c     18 18 18 30 
0fd50     30 18 18 18 | 	byte	$18, $18, $00, $00, $00, $00, $0c, $18, $18, $18, $18, $30, $30, $18, $18, $18
0fd54     18 0C 00 00 
0fd58     00 00 6C 7E 
0fd5c     36 00 00 00 
0fd60     00 00 00 00 | 	byte	$18, $0c, $00, $00, $00, $00, $6c, $7e, $36, $00, $00, $00, $00, $00, $00, $00
0fd64     00 00 00 00 
0fd68     00 00 00 00 
0fd6c     00          | 	byte	$00[9]
0fd6d     18 18 18 18 
0fd71     18 18 00 00 
0fd75     00 00 00    | 	byte	$18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
0fd78     00 6C FE FE 
0fd7c     7C 38 10 00 
0fd80     18 18 18 F8 
0fd84     F8 18 18 18 | a8_font        file "atari8.fnt"
0fd88     C0 C0 C0 C0 
0fd8c     C0 C0 C0 C0 | 	byte	$c0[8]
0fd90     18 18 18 1F 
0fd94     1F 00 00 00 
0fd98     18 18 18 1F 
0fd9c     1F 18 18 18 | 	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
0fda0     00 00 00 1F 
0fda4     1F 18 18 18 
0fda8     C0 E0 70 38 
0fdac     1C 0E 07 03 | 	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
0fdb0     03 07 0E 1C 
0fdb4     38 70 E0 C0 
0fdb8     80 C0 E0 F0 
0fdbc     F8 FC FE FF | 	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
0fdc0     00 00 00 00 
0fdc4     F0 F0 F0 F0 
0fdc8     01 03 07 0F 
0fdcc     1F 3F 7F FF | 	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
0fdd0     F0 F0 F0 F0 
0fdd4     00 00 00 00 
0fdd8     0F 0F 0F 0F 
0fddc     00 00 00 00 | 	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
0fde0     FF FF 00 00 
0fde4     00 00 00 00 
0fde8     00 00 00 00 
0fdec     00 00 FF FF | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
0fdf0     00 00 00 00 
0fdf4     0F 0F 0F 0F 
0fdf8     00 38 38 EE 
0fdfc     EE 10 38 00 | 	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
0fe00     00 00 00 F8 
0fe04     F8 18 18 18 
0fe08     00 00 00 FF 
0fe0c     FF 00 00 00 | 	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
0fe10     18 18 18 FF 
0fe14     FF 18 18 18 
0fe18     00 00 3C 7E 
0fe1c     7E 7E 3C 00 | 	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
0fe20     00 00 00 00 
0fe24     FF FF FF FF 
0fe28     03 03 03 03 
0fe2c     03 03 03 03 | 	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
0fe30     00 00 00 FF 
0fe34     FF 18 18 18 
0fe38     18 18 18 FF 
0fe3c     FF 00 00 00 | 	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
0fe40     0F 0F 0F 0F 
0fe44     0F 0F 0F 0F | 	byte	$0f[8]
0fe48     18 18 18 F8 
0fe4c     F8 00 00 00 
0fe50     1E 06 1E 06 
0fe54     7E 18 78 00 | 	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
0fe58     00 18 3C 7E 
0fe5c     18 18 18 00 
0fe60     00 18 18 18 
0fe64     7E 3C 18 00 | 	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
0fe68     00 18 0C 7E 
0fe6c     0C 18 00 00 
0fe70     00 18 30 7E 
0fe74     30 18 00 00 | 	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
0fe78     00 00 00 00 
0fe7c     00 00 00 00 
0fe80     00          | 	byte	$00[9]
0fe81     18 18 18 18 
0fe85     00 18 00 00 
0fe89     66 66 66 00 
0fe8d     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
0fe91     66 FF 66 66 
0fe95     FF 66 00 18 
0fe99     7C 06 3C 60 
0fe9d     3E 18 00 00 | 	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
0fea1     66 36 18 0C 
0fea5     66 62 00 38 
0fea9     6C 38 1C F6 
0fead     66 DC 00 00 | 	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
0feb1     18 18 18 00 
0feb5     00 00 00 00 
0feb9     70 38 18 18 
0febd     38 70 00 00 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
0fec1     0E 1C 18 18 
0fec5     1C 0E 00 00 
0fec9     66 3C FF 3C 
0fecd     66 00 00 00 | 	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
0fed1     18 18 7E 18 
0fed5     18 00 00 00 
0fed9     00 00 00 00 
0fedd     18 18 0C 00 | 	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
0fee1     00 00 7E 00 
0fee5     00 00 00 00 
0fee9     00 00 00 00 
0feed     18 18 00 00 | 	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
0fef1     60 30 18 0C 
0fef5     06 02 00 00 
0fef9     3C 66 76 6E 
0fefd     66 3C 00 00 | 	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
0ff01     18 1C 18 18 
0ff05     18 7E 00 00 
0ff09     3C 66 30 18 
0ff0d     0C 7E 00 00 | 	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
0ff11     7E 30 18 30 
0ff15     66 3C 00 00 
0ff19     30 38 3C 36 
0ff1d     7E 30 00 00 | 	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
0ff21     7E 06 3E 60 
0ff25     66 3C 00 00 
0ff29     3C 06 3E 66 
0ff2d     66 3C 00 00 | 	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
0ff31     7E 60 30 18 
0ff35     0C 0C 00 00 
0ff39     3C 66 3C 66 
0ff3d     66 3C 00 00 | 	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
0ff41     3C 66 7C 60 
0ff45     30 1C 00 00 
0ff49     00 18 18 00 
0ff4d     18 18 00 00 | 	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
0ff51     00 18 18 00 
0ff55     18 18 0C 60 
0ff59     30 18 0C 18 
0ff5d     30 60 00 00 | 	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
0ff61     00 7E 00 00 
0ff65     7E 00 00 06 
0ff69     0C 18 30 18 
0ff6d     0C 06 00 00 | 	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
0ff71     3C 66 30 18 
0ff75     00 18 00 00 
0ff79     3C 66 76 76 
0ff7d     06 7C 00 00 | 	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
0ff81     18 3C 66 66 
0ff85     7E 66 00 00 
0ff89     3E 66 3E 66 
0ff8d     66 3E 00 00 | 	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
0ff91     3C 66 06 06 
0ff95     66 3C 00 00 
0ff99     1E 36 66 66 
0ff9d     36 1E 00 00 | 	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
0ffa1     7E 06 3E 06 
0ffa5     06 7E 00 00 
0ffa9     7E 06 3E 06 
0ffad     06 06 00 00 | 	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
0ffb1     7C 06 06 76 
0ffb5     66 7C 00 00 
0ffb9     66 66 7E 66 
0ffbd     66 66 00 00 | 	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
0ffc1     7E 18 18 18 
0ffc5     18 7E 00 00 
0ffc9     60 60 60 60 
0ffcd     66 3C 00 00 | 	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
0ffd1     66 36 1E 1E 
0ffd5     36 66 00 00 
0ffd9     06 06 06 06 
0ffdd     06 7E 00 00 | 	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
0ffe1     C6 EE FE D6 
0ffe5     C6 C6 00 00 
0ffe9     66 6E 7E 7E 
0ffed     76 66 00 00 | 	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
0fff1     3C 66 66 66 
0fff5     66 3C 00 00 
0fff9     3E 66 66 3E 
0fffd     06 06 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
10001     3C 66 66 66 
10005     36 6C 00 00 
10009     3E 66 66 3E 
1000d     36 66 00 00 | 	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
10011     3C 06 3C 60 
10015     60 3C 00 00 
10019     7E 18 18 18 
1001d     18 18 00 00 | 	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
10021     66 66 66 66 
10025     66          | 	byte	$66[5]
10026     7E 00 00 66 
1002a     66 66 66 3C 
1002e     18 00 00 C6 
10032     C6 D6 FE EE | 	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
10036     C6 00 00 66 
1003a     66 3C 3C 66 
1003e     66 00 00 66 
10042     66 3C 18 18 | 	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
10046     18 00 00 7E 
1004a     30 18 0C 06 
1004e     7E 00 00 78 
10052     18 18 18 18 | 	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
10056     78 00 00 02 
1005a     06 0C 18 30 
1005e     60 00 00 1E 
10062     18 18 18 18 | 	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
10066     1E 00 00 10 
1006a     38 6C C6 00 
1006e     00 00 00 00 
10072     00 00 00 00 | 	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
10076     FF 00 00 18 
1007a     3C 7E 7E 3C 
1007e     18 00 00 00 
10082     3C 60 7C 66 | 	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
10086     7C 00 00 06 
1008a     06 3E 66 66 
1008e     3E 00 00 00 
10092     3C 06 06 06 | 	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
10096     3C 00 00 60 
1009a     60 7C 66 66 
1009e     7C 00 00 00 
100a2     3C 66 7E 06 | 	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
100a6     3C 00 00 70 
100aa     18 7C 18 18 
100ae     18 00 00 00 
100b2     7C 66 66 7C | 	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
100b6     60 3E 00 06 
100ba     06 3E 66 66 
100be     66 00 00 18 
100c2     00 1C 18 18 | 	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
100c6     3C 00 00 60 
100ca     00 60 60 60 
100ce     60 3C 00 06 
100d2     06 36 1E 36 | 	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
100d6     66 00 00 1C 
100da     18 18 18 18 
100de     3C 00 00 00 
100e2     66 FE FE D6 | 	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
100e6     C6 00 00 00 
100ea     3E 66 66 66 
100ee     66 00 00 00 
100f2     3C 66 66 66 | 	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
100f6     3C 00 00 00 
100fa     3E 66 66 3E 
100fe     06 06 00 00 
10102     7C 66 66 7C | 	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
10106     60 60 00 00 
1010a     3E 66 06 06 
1010e     06 00 00 00 
10112     7C 06 3C 60 | 	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
10116     3E 00 00 18 
1011a     7E 18 18 18 
1011e     70 00 00 00 
10122     66 66 66 66 | 	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
10126     7C 00 00 00 
1012a     66 66 66 3C 
1012e     18 00 00 00 
10132     C6 D6 FE 7C | 	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
10136     6C 00 00 00 
1013a     66 3C 18 3C 
1013e     66 00 00 00 
10142     66 66 66 7C | 	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
10146     30 1E 00 00 
1014a     7E 30 18 0C 
1014e     7E 00 00 18 
10152     3C 7E 7E 18 | 	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
10156     3C 00 18 18 
1015a     18 18 18 18 
1015e     18 18 00 7E 
10162     1E 3E 76 66 | 	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
10166     60 00 10 18 
1016a     1C 1E 1C 18 
1016e     10 00 08 18 
10172     38 78 38 18 | 	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
10176     08 00       | 	byte	$08, $00
10178     00 6C FE FE 
1017c     7C 38 10 00 
10180     18 18 18 F8 
10184     F8 18 18 18 | a8_font2       file "atari8.fnt"
10188     C0 C0 C0 C0 
1018c     C0 C0 C0 C0 | 	byte	$c0[8]
10190     18 18 18 1F 
10194     1F 00 00 00 
10198     18 18 18 1F 
1019c     1F 18 18 18 | 	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
101a0     00 00 00 1F 
101a4     1F 18 18 18 
101a8     C0 E0 70 38 
101ac     1C 0E 07 03 | 	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
101b0     03 07 0E 1C 
101b4     38 70 E0 C0 
101b8     80 C0 E0 F0 
101bc     F8 FC FE FF | 	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
101c0     00 00 00 00 
101c4     F0 F0 F0 F0 
101c8     01 03 07 0F 
101cc     1F 3F 7F FF | 	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
101d0     F0 F0 F0 F0 
101d4     00 00 00 00 
101d8     0F 0F 0F 0F 
101dc     00 00 00 00 | 	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
101e0     FF FF 00 00 
101e4     00 00 00 00 
101e8     00 00 00 00 
101ec     00 00 FF FF | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
101f0     00 00 00 00 
101f4     0F 0F 0F 0F 
101f8     00 38 38 EE 
101fc     EE 10 38 00 | 	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
10200     00 00 00 F8 
10204     F8 18 18 18 
10208     00 00 00 FF 
1020c     FF 00 00 00 | 	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
10210     18 18 18 FF 
10214     FF 18 18 18 
10218     00 00 3C 7E 
1021c     7E 7E 3C 00 | 	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
10220     00 00 00 00 
10224     FF FF FF FF 
10228     03 03 03 03 
1022c     03 03 03 03 | 	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
10230     00 00 00 FF 
10234     FF 18 18 18 
10238     18 18 18 FF 
1023c     FF 00 00 00 | 	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
10240     0F 0F 0F 0F 
10244     0F 0F 0F 0F | 	byte	$0f[8]
10248     18 18 18 F8 
1024c     F8 00 00 00 
10250     1E 06 1E 06 
10254     7E 18 78 00 | 	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
10258     00 18 3C 7E 
1025c     18 18 18 00 
10260     00 18 18 18 
10264     7E 3C 18 00 | 	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
10268     00 18 0C 7E 
1026c     0C 18 00 00 
10270     00 18 30 7E 
10274     30 18 00 00 | 	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
10278     00 00 00 00 
1027c     00 00 00 00 
10280     00          | 	byte	$00[9]
10281     18 18 18 18 
10285     00 18 00 00 
10289     66 66 66 00 
1028d     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
10291     66 FF 66 66 
10295     FF 66 00 18 
10299     7C 06 3C 60 
1029d     3E 18 00 00 | 	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
102a1     66 36 18 0C 
102a5     66 62 00 38 
102a9     6C 38 1C F6 
102ad     66 DC 00 00 | 	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
102b1     18 18 18 00 
102b5     00 00 00 00 
102b9     70 38 18 18 
102bd     38 70 00 00 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
102c1     0E 1C 18 18 
102c5     1C 0E 00 00 
102c9     66 3C FF 3C 
102cd     66 00 00 00 | 	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
102d1     18 18 7E 18 
102d5     18 00 00 00 
102d9     00 00 00 00 
102dd     18 18 0C 00 | 	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
102e1     00 00 7E 00 
102e5     00 00 00 00 
102e9     00 00 00 00 
102ed     18 18 00 00 | 	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
102f1     60 30 18 0C 
102f5     06 02 00 00 
102f9     3C 66 76 6E 
102fd     66 3C 00 00 | 	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
10301     18 1C 18 18 
10305     18 7E 00 00 
10309     3C 66 30 18 
1030d     0C 7E 00 00 | 	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
10311     7E 30 18 30 
10315     66 3C 00 00 
10319     30 38 3C 36 
1031d     7E 30 00 00 | 	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
10321     7E 06 3E 60 
10325     66 3C 00 00 
10329     3C 06 3E 66 
1032d     66 3C 00 00 | 	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
10331     7E 60 30 18 
10335     0C 0C 00 00 
10339     3C 66 3C 66 
1033d     66 3C 00 00 | 	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
10341     3C 66 7C 60 
10345     30 1C 00 00 
10349     00 18 18 00 
1034d     18 18 00 00 | 	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
10351     00 18 18 00 
10355     18 18 0C 60 
10359     30 18 0C 18 
1035d     30 60 00 00 | 	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
10361     00 7E 00 00 
10365     7E 00 00 06 
10369     0C 18 30 18 
1036d     0C 06 00 00 | 	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
10371     3C 66 30 18 
10375     00 18 00 00 
10379     3C 66 76 76 
1037d     06 7C 00 00 | 	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
10381     18 3C 66 66 
10385     7E 66 00 00 
10389     3E 66 3E 66 
1038d     66 3E 00 00 | 	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
10391     3C 66 06 06 
10395     66 3C 00 00 
10399     1E 36 66 66 
1039d     36 1E 00 00 | 	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
103a1     7E 06 3E 06 
103a5     06 7E 00 00 
103a9     7E 06 3E 06 
103ad     06 06 00 00 | 	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
103b1     7C 06 06 76 
103b5     66 7C 00 00 
103b9     66 66 7E 66 
103bd     66 66 00 00 | 	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
103c1     7E 18 18 18 
103c5     18 7E 00 00 
103c9     60 60 60 60 
103cd     66 3C 00 00 | 	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
103d1     66 36 1E 1E 
103d5     36 66 00 00 
103d9     06 06 06 06 
103dd     06 7E 00 00 | 	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
103e1     C6 EE FE D6 
103e5     C6 C6 00 00 
103e9     66 6E 7E 7E 
103ed     76 66 00 00 | 	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
103f1     3C 66 66 66 
103f5     66 3C 00 00 
103f9     3E 66 66 3E 
103fd     06 06 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
10401     3C 66 66 66 
10405     36 6C 00 00 
10409     3E 66 66 3E 
1040d     36 66 00 00 | 	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
10411     3C 06 3C 60 
10415     60 3C 00 00 
10419     7E 18 18 18 
1041d     18 18 00 00 | 	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
10421     66 66 66 66 
10425     66          | 	byte	$66[5]
10426     7E 00 00 66 
1042a     66 66 66 3C 
1042e     18 00 00 C6 
10432     C6 D6 FE EE | 	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
10436     C6 00 00 66 
1043a     66 3C 3C 66 
1043e     66 00 00 66 
10442     66 3C 18 18 | 	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
10446     18 00 00 7E 
1044a     30 18 0C 06 
1044e     7E 00 00 78 
10452     18 18 18 18 | 	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
10456     78 00 00 02 
1045a     06 0C 18 30 
1045e     60 00 00 1E 
10462     18 18 18 18 | 	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
10466     1E 00 00 10 
1046a     38 6C C6 00 
1046e     00 00 00 00 
10472     00 00 00 00 | 	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
10476     FF 00 00 18 
1047a     3C 7E 7E 3C 
1047e     18 00 00 00 
10482     3C 60 7C 66 | 	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
10486     7C 00 00 06 
1048a     06 3E 66 66 
1048e     3E 00 00 00 
10492     3C 06 06 06 | 	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
10496     3C 00 00 60 
1049a     60 7C 66 66 
1049e     7C 00 00 00 
104a2     3C 66 7E 06 | 	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
104a6     3C 00 00 70 
104aa     18 7C 18 18 
104ae     18 00 00 00 
104b2     7C 66 66 7C | 	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
104b6     60 3E 00 06 
104ba     06 3E 66 66 
104be     66 00 00 18 
104c2     00 1C 18 18 | 	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
104c6     3C 00 00 60 
104ca     00 60 60 60 
104ce     60 3C 00 06 
104d2     06 36 1E 36 | 	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
104d6     66 00 00 1C 
104da     18 18 18 18 
104de     3C 00 00 00 
104e2     66 FE FE D6 | 	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
104e6     C6 00 00 00 
104ea     3E 66 66 66 
104ee     66 00 00 00 
104f2     3C 66 66 66 | 	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
104f6     3C 00 00 00 
104fa     3E 66 66 3E 
104fe     06 06 00 00 
10502     7C 66 66 7C | 	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
10506     60 60 00 00 
1050a     3E 66 06 06 
1050e     06 00 00 00 
10512     7C 06 3C 60 | 	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
10516     3E 00 00 18 
1051a     7E 18 18 18 
1051e     70 00 00 00 
10522     66 66 66 66 | 	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
10526     7C 00 00 00 
1052a     66 66 66 3C 
1052e     18 00 00 00 
10532     C6 D6 FE 7C | 	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
10536     6C 00 00 00 
1053a     66 3C 18 3C 
1053e     66 00 00 00 
10542     66 66 66 7C | 	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
10546     30 1E 00 00 
1054a     7E 30 18 0C 
1054e     7E 00 00 18 
10552     3C 7E 7E 18 | 	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
10556     3C 00 18 18 
1055a     18 18 18 18 
1055e     18 18 00 7E 
10562     1E 3E 76 66 | 	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
10566     60 00 10 18 
1056a     1C 1E 1C 18 
1056e     10 00 08 18 
10572     38 78 38 18 | 	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
10576     08 00       | 	byte	$08, $00
10578     00 00 00 00 
      ...             
10784     00 00 00 00 
10788     00 00       | amiga_font     file "amigafont.def"
1078a     18 18 18 18 
1078e     18 18       | 	byte	$18[6]
10790     00 18 18 00 
10794     00 00 00 00 
10798     00 00 66 66 
1079c     66 00 00 00 | 	byte	$00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $00, $00, $00
107a0     00 00 00 00 
107a4     00 00 00 00 
107a8     00 00       | 	byte	$00[10]
107aa     36 36 7F 36 
107ae     36 36 7F 36 
107b2     36 00 00 00 
107b6     00 00 00 00 | 	byte	$36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $00, $00, $00
107ba     18 7C 06 06 
107be     3C 60 60 3E 
107c2     18 00 00 00 
107c6     00 00 00 00 | 	byte	$18, $7c, $06, $06, $3c, $60, $60, $3e, $18, $00, $00, $00, $00, $00, $00, $00
107ca     00 00 C6 69 
107ce     36 18 6C 96 
107d2     63 00 00 00 
107d6     00 00 00 00 | 	byte	$00, $00, $c6, $69, $36, $18, $6c, $96, $63, $00, $00, $00, $00, $00, $00, $00
107da     1C 36 36 1E 
107de     6E 3B 33 73 
107e2     DE 00 00 00 
107e6     00 00 00 00 | 	byte	$1c, $36, $36, $1e, $6e, $3b, $33, $73, $de, $00, $00, $00, $00, $00, $00, $00
107ea     18 18 0C 00 
107ee     00 00 00 00 
107f2     00 00 00 00 
107f6     00 00 00 00 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
107fa     30 18 0C 0C 
107fe     0C 0C 0C 18 
10802     30 00 00 00 
10806     00 00 00 00 | 	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00, $00
1080a     0C 18 30 30 
1080e     30 30 30 18 
10812     0C 00 00 00 
10816     00 00 00 00 | 	byte	$0c, $18, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00, $00
1081a     00 66 66 3C 
1081e     FF 3C 66 66 
10822     00 00 00 00 
10826     00 00 00 00 | 	byte	$00, $66, $66, $3c, $ff, $3c, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00
1082a     00 18 18 18 
1082e     7E 18 18 18 
10832     00 00 00 00 
10836     00 00 00 00 | 	byte	$00, $18, $18, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
1083a     00 00 00 00 
1083e     00 00 00    | 	byte	$00[7]
10841     18 18 0C 00 
10845     00 00 00 00 
10849     00 00 00 00 
1084d     00 7E 00 00 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00
10851     00 00 00 00 
10855     00 00 00 00 
10859     00 00 00 00 
1085d     00 00 00 00 | 	byte	$00[16]
10861     18 18 00 00 
10865     00 00 00 00 
10869     00 00 C0 60 
1086d     30 18 0C 06 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $c0, $60, $30, $18, $0c, $06
10871     03 00 00 00 
10875     00 00 00 00 
10879     00 3C 66 66 
1087d     76 7E 6E 66 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $76, $7e, $6e, $66
10881     66 3C 00 00 
10885     00 00 00 00 
10889     00 18 1C 1E 
1088d     18 18 18 18 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18
10891     18 18 00 00 
10895     00 00 00 00 
10899     00 3C 66 60 
1089d     60 30 18 0C | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $30, $18, $0c
108a1     06 7E 00 00 
108a5     00 00 00 00 
108a9     00 3C 66 60 
108ad     60 38 60 60 | 	byte	$06, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $38, $60, $60
108b1     66 3C 00 00 
108b5     00 00 00 00 
108b9     00 30 38 3C 
108bd     36 33 7F 30 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30
108c1     30 30 00 00 
108c5     00 00 00 00 
108c9     00 7E 06 06 
108cd     3E 60 60 60 | 	byte	$30, $30, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06, $3e, $60, $60, $60
108d1     66 3C 00 00 
108d5     00 00 00 00 
108d9     00 38 0C 06 
108dd     06 3E 66 66 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $06, $06, $3e, $66, $66
108e1     66 3C 00 00 
108e5     00 00 00 00 
108e9     00 7E 60 60 
108ed     60 30 18 18 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $7e, $60, $60, $60, $30, $18, $18
108f1     18 18 00 00 
108f5     00 00 00 00 
108f9     00 3C 66 66 
108fd     66 3C 66 66 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $3c, $66, $66
10901     66 3C 00 00 
10905     00 00 00 00 
10909     00 3C 66 66 
1090d     66 7C 60 60 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $7c, $60, $60
10911     30 1C 00 00 
10915     00 00 00 00 
10919     00 00 00 18 
1091d     18 00 00 18 | 	byte	$30, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $18
10921     18 00 00 00 
10925     00 00 00 00 
10929     00 00 00 18 
1092d     18 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
10931     18 18 0C 00 
10935     00 00 00 00 
10939     00 00 00 60 
1093d     18 06 18 60 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $60, $18, $06, $18, $60
10941     00 00 00 00 
10945     00 00 00 00 
10949     00 00 00 00 | 	byte	$00[12]
1094d     7E 00 7E 00 
10951     00 00 00 00 
10955     00 00 00 00 
10959     00 00 00 06 | 	byte	$7e, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06
1095d     18 60 18 06 
10961     00 00 00 00 
10965     00 00 00 00 
10969     00 3C 66 60 | 	byte	$18, $60, $18, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60
1096d     60 30 18 00 
10971     18 18 00 00 
10975     00 00 00 00 
10979     00 3E 63 63 | 	byte	$60, $30, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
1097d     7B 6B 7B 03 
10981     03 1E 00 00 
10985     00 00 00 00 
10989     00 3E 63 63 | 	byte	$7b, $6b, $7b, $03, $03, $1e, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
1098d     63 7F 63 63 
10991     63 63 00 00 
10995     00 00 00 00 
10999     00 3E 66 66 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66
1099d     66 3E 66 66 
109a1     66 3E 00 00 
109a5     00 00 00 00 
109a9     00 78 0C 06 | 	byte	$66, $3e, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $78, $0c, $06
109ad     06 06 06 06 
109b1     0C 78 00 00 
109b5     00 00 00 00 
109b9     00 1F 33 63 | 	byte	$06, $06, $06, $06, $0c, $78, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $63
109bd     63 63 63 63 
109c1     33 1F 00 00 
109c5     00 00 00 00 
109c9     00 7E 06 06 | 	byte	$63, $63, $63, $63, $33, $1f, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
109cd     06 1E 06 06 
109d1     06 7E 00 00 
109d5     00 00 00 00 
109d9     00 7E 06 06 | 	byte	$06, $1e, $06, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
109dd     06 1E 06 06 
109e1     06 06 00 00 
109e5     00 00 00 00 
109e9     00 3C 66 06 | 	byte	$06, $1e, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06
109ed     06 76 66 66 
109f1     66 7C 00 00 
109f5     00 00 00 00 
109f9     00 63 63 63 | 	byte	$06, $76, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63
109fd     63 7F 63 63 
10a01     63 63 00 00 
10a05     00 00 00 00 
10a09     00 3C 18 18 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3c, $18, $18
10a0d     18 18 18 18 
10a11     18          | 	byte	$18[5]
10a12     3C 00 00 00 
10a16     00 00 00 00 
10a1a     60 60 60 60 
10a1e     60 60 60 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60, $60, $60, $60, $60, $63
10a22     3E 00 00 00 
10a26     00 00 00 00 
10a2a     C3 63 33 1B 
10a2e     0F 1B 33 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $c3, $63, $33, $1b, $0f, $1b, $33, $63
10a32     C3 00 00 00 
10a36     00 00 00 00 
10a3a     03 03 03 03 
10a3e     03 03 03 03 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $03, $03, $03, $03, $03, $03, $03, $03
10a42     7F 00 00 00 
10a46     00 00 00 00 
10a4a     63 77 7F 6B 
10a4e     63 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $6b, $63, $63, $63, $63
10a52     63 00 00 00 
10a56     00 00 00 00 
10a5a     63 67 6F 7B 
10a5e     73 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7b, $73, $63, $63, $63
10a62     63 00 00 00 
10a66     00 00 00 00 
10a6a     3E 63 63 63 
10a6e     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63
10a72     3E 00 00 00 
10a76     00 00 00 00 
10a7a     3E 66 66 66 
10a7e     3E 06 06 06 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e, $06, $06, $06
10a82     06 00 00 00 
10a86     00 00 00 00 
10a8a     3E 63 63 63 
10a8e     63 63 63 7B | 	byte	$06, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $7b
10a92     FE 00 00 00 
10a96     00 00 00 00 
10a9a     1F 33 33 33 
10a9e     1F 1B 33 63 | 	byte	$fe, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $33, $33, $1f, $1b, $33, $63
10aa2     63 00 00 00 
10aa6     00 00 00 00 
10aaa     3C 66 06 0C 
10aae     18 30 60 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06, $0c, $18, $30, $60, $66
10ab2     3C 00 00 00 
10ab6     00 00 00 00 
10aba     7E 18 18 18 
10abe     18 18 18 18 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $7e, $18, $18, $18, $18, $18, $18, $18
10ac2     18 00 00 00 
10ac6     00 00 00 00 
10aca     63 63 63 63 
10ace     63 63 63 63 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63
10ad2     3E 00 00 00 
10ad6     00 00 00 00 
10ada     63 63 63 63 
10ade     63 36 36 1C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36, $36, $1c
10ae2     08 00 00 00 
10ae6     00 00 00 00 
10aea     C3 C3 C3 C3 
10aee     C3 DB FF E7 | 	byte	$08, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $c3, $c3, $c3, $db, $ff, $e7
10af2     C3 00 00 00 
10af6     00 00 00 00 
10afa     C3 C3 66 3C 
10afe     18 3C 66 C3 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $3c, $66, $c3
10b02     C3 00 00 00 
10b06     00 00 00 00 
10b0a     C3 C3 66 3C 
10b0e     18 18 18 18 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $18, $18, $18
10b12     18 00 00 00 
10b16     00 00 00 00 
10b1a     7F 60 60 30 
10b1e     18 0C 06 03 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $7f, $60, $60, $30, $18, $0c, $06, $03
10b22     7F 00 00 00 
10b26     00 00 00 00 
10b2a     3C 0C 0C 0C 
10b2e     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
10b32     3C 00 00 00 
10b36     00 00 00 00 
10b3a     00 03 06 0C 
10b3e     18 30 60 C0 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $03, $06, $0c, $18, $30, $60, $c0
10b42     00 00 00 00 
10b46     00 00 00 00 | 	byte	$00[8]
10b4a     3C 30 30 30 
10b4e     30 30 30 30 
10b52     3C 00 00 00 
10b56     00 00 00 00 | 	byte	$3c, $30, $30, $30, $30, $30, $30, $30, $3c, $00, $00, $00, $00, $00, $00, $00
10b5a     08 1C 36 63 
10b5e     00 00 00 00 
10b62     00 00 00 00 
10b66     00 00 00 00 | 	byte	$08, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10b6a     00 00 00 00 
10b6e     00 00 00 00 
10b72     00          | 	byte	$00[9]
10b73     7F 00 00 00 
10b77     00 00 00 18 
10b7b     18 30 00 00 
10b7f     00 00 00 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $18, $18, $30, $00, $00, $00, $00, $00, $00
10b83     00 00 00 00 
10b87     00 00 00 00 
10b8b     00 00       | 	byte	$00[10]
10b8d     3C 60 7C 66 
10b91     66 7C 00 00 
10b95     00 00 00 00 
10b99     00 06 06 06 | 	byte	$3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $06, $06, $06
10b9d     3E 66 66 66 
10ba1     66 3E 00 00 
10ba5     00 00 00 00 
10ba9     00 00 00 00 | 	byte	$3e, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10bad     3C 06 06 06 
10bb1     06 3C 00 00 
10bb5     00 00 00 00 
10bb9     00 60 60 60 | 	byte	$3c, $06, $06, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60
10bbd     7C 66 66 66 
10bc1     66 7C 00 00 
10bc5     00 00 00 00 
10bc9     00 00 00 00 | 	byte	$7c, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10bcd     3C 66 7E 06 
10bd1     06 3C 00 00 
10bd5     00 00 00 00 
10bd9     00 38 0C 0C | 	byte	$3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $0c
10bdd     3E 0C 0C 0C 
10be1     0C 0C 00 00 
10be5     00 00 00 00 
10be9     00 00 00 00 | 	byte	$3e, $0c, $0c, $0c, $0c, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10bed     7C 66 66 66 
10bf1     7C 60 60 3C 
10bf5     00 00 00 00 
10bf9     00 06 06 06 | 	byte	$7c, $66, $66, $66, $7c, $60, $60, $3c, $00, $00, $00, $00, $00, $06, $06, $06
10bfd     3E 66 66 66 
10c01     66 66 00 00 
10c05     00 00 00 00 
10c09     00 00 18 00 | 	byte	$3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $18, $00
10c0d     18 18 18 18 
10c11     18          | 	byte	$18[5]
10c12     30 00 00 00 
10c16     00 00 00 00 
10c1a     00 30 00 30 
10c1e     30 30 30 30 | 	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $30, $00, $30, $30, $30, $30, $30
10c22     30 30 1E 00 
10c26     00 00 00 00 
10c2a     03 03 03 33 
10c2e     1B 0F 1B 33 | 	byte	$30, $30, $1e, $00, $00, $00, $00, $00, $03, $03, $03, $33, $1b, $0f, $1b, $33
10c32     63 00 00 00 
10c36     00 00 00 00 
10c3a     18 18 18 18 
10c3e     18 18 18 18 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
10c42     30 00 00 00 
10c46     00 00 00 00 
10c4a     00 00 00 37 
10c4e     7F 6B 63 63 | 	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $63, $63
10c52     63 00 00 00 
10c56     00 00 00 00 
10c5a     00 00 00 3E 
10c5e     66 66 66 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $66
10c62     66 00 00 00 
10c66     00 00 00 00 
10c6a     00 00 00 3C 
10c6e     66 66 66 66 | 	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $66
10c72     3C 00 00 00 
10c76     00 00 00 00 
10c7a     00 00 00 3E 
10c7e     66 66 66 3E | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e
10c82     06 06 06 00 
10c86     00 00 00 00 
10c8a     00 00 00 7C 
10c8e     66 66 66 7C | 	byte	$06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7c, $66, $66, $66, $7c
10c92     60 60 60 00 
10c96     00 00 00 00 
10c9a     00 00 00 3E 
10c9e     66 06 06 06 | 	byte	$60, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $06, $06, $06
10ca2     06 00 00 00 
10ca6     00 00 00 00 
10caa     00 00 00 3C 
10cae     06 0C 30 60 | 	byte	$06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $06, $0c, $30, $60
10cb2     3E 00 00 00 
10cb6     00 00 00 00 
10cba     00 0C 0C 3E 
10cbe     0C 0C 0C 0C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $0c, $0c, $3e, $0c, $0c, $0c, $0c
10cc2     38 00 00 00 
10cc6     00 00 00 00 
10cca     00 00 00 66 
10cce     66 66 66 66 | 	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66
10cd2     7C 00 00 00 
10cd6     00 00 00 00 
10cda     00 00 00 66 
10cde     66 66 66 3C | 	byte	$7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
10ce2     18 00 00 00 
10ce6     00 00 00 00 
10cea     00 00 00 63 
10cee     63 63 6B 3E | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $6b, $3e
10cf2     36 00 00 00 
10cf6     00 00 00 00 
10cfa     00 00 00 63 
10cfe     36 1C 1C 36 | 	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36
10d02     63 00 00 00 
10d06     00 00 00 00 
10d0a     00 00 00 66 
10d0e     66 66 66 3C | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
10d12     18 0C 06 00 
10d16     00 00 00 00 
10d1a     00 00 00 7E 
10d1e     30 18 0C 06 | 	byte	$18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $30, $18, $0c, $06
10d22     7E 00 00 00 
10d26     00 00 00 00 
10d2a     70 18 18 18 
10d2e     0E 18 18 18 | 	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18
10d32     70 00 00 00 
10d36     00 00 00 00 
10d3a     18 18 18 18 
10d3e     18 18 18 18 | 	byte	$70, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
10d42     18 00 00 00 
10d46     00 00 00 00 
10d4a     0E 18 18 18 
10d4e     70 18 18 18 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18
10d52     0E 00 00 00 
10d56     00 00 00 00 
10d5a     46 5D 31 00 
10d5e     00 00 00 00 | 	byte	$0e, $00, $00, $00, $00, $00, $00, $00, $46, $5d, $31, $00, $00, $00, $00, $00
10d62     00 00 00 00 
10d66     00 00 00 00 | 	byte	$00[8]
10d6a     C0 F0 3C 0F 
10d6e     C3 F0 3C 0F 
10d72     03 00 00 00 
10d76     00 00 00 00 | 	byte	$c0, $f0, $3c, $0f, $c3, $f0, $3c, $0f, $03, $00, $00, $00, $00, $00, $00, $00
10d7a     18 18 00 18 
10d7e     18 18 18 18 
10d82     18 00 00 00 
10d86     00 00 00 00 | 	byte	$18, $18, $00, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
10d8a     18 18 7E 1B 
10d8e     1B 7E 18 18 
10d92     00 00 00 00 
10d96     00 00 00 00 | 	byte	$18, $18, $7e, $1b, $1b, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
10d9a     78 CC 0C 0C 
10d9e     1E 0C 0C 06 
10da2     7F 00 00 00 
10da6     00 00 00 00 | 	byte	$78, $cc, $0c, $0c, $1e, $0c, $0c, $06, $7f, $00, $00, $00, $00, $00, $00, $00
10daa     66 3C 66 66 
10dae     3C 66 00 00 
10db2     00 00 00 00 
10db6     00 00 00 00 | 	byte	$66, $3c, $66, $66, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10dba     C3 C3 66 3C 
10dbe     18 7E 18 18 
10dc2     18 00 00 00 
10dc6     00 00 00 00 | 	byte	$c3, $c3, $66, $3c, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
10dca     18 18 18 18 
10dce     00 18 18 18 
10dd2     18 00 00 00 
10dd6     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
10dda     3C 06 06 3C 
10dde     66 66 66 3C 
10de2     60 60 3C 00 
10de6     00 00 00 00 | 	byte	$3c, $06, $06, $3c, $66, $66, $66, $3c, $60, $60, $3c, $00, $00, $00, $00, $00
10dea     66 66 00 00 
10dee     00 00 00 00 
10df2     00 00 00 00 
10df6     00 00 00 00 | 	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10dfa     7E 81 B9 85 
10dfe     85 B9 81 7E 
10e02     00 00 00 00 
10e06     00 00 00 00 | 	byte	$7e, $81, $b9, $85, $85, $b9, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
10e0a     3C 33 33 7E 
10e0e     00 7F 00 00 
10e12     00 00 00 00 
10e16     00 00 00 00 | 	byte	$3c, $33, $33, $7e, $00, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10e1a     00 00 CC 66 
10e1e     33 66 CC 00 
10e22     00 00 00 00 
10e26     00 00 00 00 | 	byte	$00, $00, $cc, $66, $33, $66, $cc, $00, $00, $00, $00, $00, $00, $00, $00, $00
10e2a     7E 60 60 00 
10e2e     00 00 00 00 
10e32     00 00 00 00 
10e36     00 00 00 00 | 	byte	$7e, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10e3a     7E 81 9D A5 
10e3e     9D A5 81 7E 
10e42     00 00 00 00 
10e46     00 00 00 00 | 	byte	$7e, $81, $9d, $a5, $9d, $a5, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
10e4a     7E 00 00 00 
10e4e     00 00 00 00 
10e52     00 00 00 00 
10e56     00 00 00 00 | 	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10e5a     3C 66 66 3C 
10e5e     00 00 00 00 
10e62     00 00 00 00 
10e66     00 00 00 00 | 	byte	$3c, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10e6a     18 18 18 7E 
10e6e     18 18 18 00 
10e72     7E 00 00 00 
10e76     00 00 00 00 | 	byte	$18, $18, $18, $7e, $18, $18, $18, $00, $7e, $00, $00, $00, $00, $00, $00, $00
10e7a     1E 30 30 18 
10e7e     0C 06 3E 00 
10e82     00 00 00 00 
10e86     00 00 00 00 | 	byte	$1e, $30, $30, $18, $0c, $06, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
10e8a     1E 30 30 1C 
10e8e     30 30 1E 00 
10e92     00 00 00 00 
10e96     00 00 00 00 | 	byte	$1e, $30, $30, $1c, $30, $30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
10e9a     30 18 0C 06 
10e9e     00 00 00 00 
10ea2     00 00 00 00 
10ea6     00 00 00 00 | 	byte	$30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10eaa     00 00 00 66 
10eae     66 66 66 66 
10eb2     FE 06 06 00 
10eb6     00 00 00 00 | 	byte	$00, $00, $00, $66, $66, $66, $66, $66, $fe, $06, $06, $00, $00, $00, $00, $00
10eba     7C 5E 5E 5E 
10ebe     5C 50 50 50 
10ec2     50 50 00 00 
10ec6     00 00 00 00 | 	byte	$7c, $5e, $5e, $5e, $5c, $50, $50, $50, $50, $50, $00, $00, $00, $00, $00, $00
10eca     00 00 00 18 
10ece     18 00 00 00 
10ed2     00 00 00 00 
10ed6     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10eda     00 00 00 00 
10ede     00 00 00 00 
10ee2     00          | 	byte	$00[9]
10ee3     30 18 00 00 
10ee7     00 00 00 18 
10eeb     1C 18 18 18 
10eef     18 18 00 00 | 	byte	$30, $18, $00, $00, $00, $00, $00, $18, $1c, $18, $18, $18, $18, $18, $00, $00
10ef3     00 00 00 00 
10ef7     00 00 00    | 	byte	$00[7]
10efa     3C 66 66 3C 
10efe     00 7E 00 00 
10f02     00 00 00 00 
10f06     00 00 00 00 | 	byte	$3c, $66, $66, $3c, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10f0a     00 00 33 66 
10f0e     CC 66 33 00 
10f12     00 00 00 00 
10f16     00 00 00 00 | 	byte	$00, $00, $33, $66, $cc, $66, $33, $00, $00, $00, $00, $00, $00, $00, $00, $00
10f1a     02 63 32 1A 
10f1e     4E 66 F3 40 
10f22     40 00 00 00 
10f26     00 00 00 00 | 	byte	$02, $63, $32, $1a, $4e, $66, $f3, $40, $40, $00, $00, $00, $00, $00, $00, $00
10f2a     04 C6 64 34 
10f2e     7C 8C 46 23 
10f32     F0 00 00 00 
10f36     00 00 00 00 | 	byte	$04, $c6, $64, $34, $7c, $8c, $46, $23, $f0, $00, $00, $00, $00, $00, $00, $00
10f3a     03 C4 66 34 
10f3e     5B 6C F6 43 
10f42     40 00 00 00 
10f46     00 00 00 00 | 	byte	$03, $c4, $66, $34, $5b, $6c, $f6, $43, $40, $00, $00, $00, $00, $00, $00, $00
10f4a     18 18 00 18 
10f4e     0C 06 06 66 
10f52     3C 00 00 00 
10f56     00 00 00 00 | 	byte	$18, $18, $00, $18, $0c, $06, $06, $66, $3c, $00, $00, $00, $00, $00, $00, $00
10f5a     06 0C 3E 63 
10f5e     63 7F 63 63 
10f62     63 00 00 00 
10f66     00 00 00 00 | 	byte	$06, $0c, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
10f6a     30 18 3E 63 
10f6e     63 7F 63 63 
10f72     63 00 00 00 
10f76     00 00 00 00 | 	byte	$30, $18, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
10f7a     0C 33 3E 63 
10f7e     63 63 7F 63 
10f82     63 00 00 00 
10f86     00 00 00 00 | 	byte	$0c, $33, $3e, $63, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
10f8a     4E 39 3E 63 
10f8e     63 7F 63 63 
10f92     63 00 00 00 
10f96     00 00 00 00 | 	byte	$4e, $39, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
10f9a     63 00 3E 63 
10f9e     63 7F 63 63 
10fa2     63 00 00 00 
10fa6     00 00 00 00 | 	byte	$63, $00, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
10faa     1C 22 1C 36 
10fae     63 63 7F 63 
10fb2     63 00 00 00 
10fb6     00 00 00 00 | 	byte	$1c, $22, $1c, $36, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
10fba     F8 3C 3C 36 
10fbe     F6 3F 33 33 
10fc2     F3 00 00 00 
10fc6     00 00 00 00 | 	byte	$f8, $3c, $3c, $36, $f6, $3f, $33, $33, $f3, $00, $00, $00, $00, $00, $00, $00
10fca     78 0C 06 06 
10fce     06 06 06 0C 
10fd2     78 30 18 00 
10fd6     00 00 00 00 | 	byte	$78, $0c, $06, $06, $06, $06, $06, $0c, $78, $30, $18, $00, $00, $00, $00, $00
10fda     0C 18 7E 06 
10fde     06 3E 06 06 
10fe2     7E 00 00 00 
10fe6     00 00 00 00 | 	byte	$0c, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
10fea     30 18 7E 06 
10fee     06 3E 06 06 
10ff2     7E 00 00 00 
10ff6     00 00 00 00 | 	byte	$30, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
10ffa     18 66 7E 06 
10ffe     06 3E 06 06 
11002     7E 00 00 00 
11006     00 00 00 00 | 	byte	$18, $66, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
1100a     66 00 7E 06 
1100e     06 3E 06 06 
11012     7E 00 00 00 
11016     00 00 00 00 | 	byte	$66, $00, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
1101a     0C 18 3C 18 
1101e     18 18 18 18 
11022     3C 00 00 00 
11026     00 00 00 00 | 	byte	$0c, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
1102a     30 18 3C 18 
1102e     18 18 18 18 
11032     3C 00 00 00 
11036     00 00 00 00 | 	byte	$30, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
1103a     18 66 3C 18 
1103e     18 18 18 18 
11042     3C 00 00 00 
11046     00 00 00 00 | 	byte	$18, $66, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
1104a     66 00 3C 18 
1104e     18 18 18 18 
11052     3C 00 00 00 
11056     00 00 00 00 | 	byte	$66, $00, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
1105a     1E 36 66 66 
1105e     6F 66 66 36 
11062     1E 00 00 00 
11066     00 00 00 00 | 	byte	$1e, $36, $66, $66, $6f, $66, $66, $36, $1e, $00, $00, $00, $00, $00, $00, $00
1106a     8E 73 67 6F 
1106e     7B 73 63 63 
11072     63 00 00 00 
11076     00 00 00 00 | 	byte	$8e, $73, $67, $6f, $7b, $73, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
1107a     06 0C 3E 63 
1107e     63 63 63 63 
11082     3E 00 00 00 
11086     00 00 00 00 | 	byte	$06, $0c, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
1108a     30 18 3E 63 
1108e     63 63 63 63 
11092     3E 00 00 00 
11096     00 00 00 00 | 	byte	$30, $18, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
1109a     0C 33 3E 63 
1109e     63 63 63 63 
110a2     3E 00 00 00 
110a6     00 00 00 00 | 	byte	$0c, $33, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
110aa     8E 71 3E 63 
110ae     63 63 63 63 
110b2     3E 00 00 00 
110b6     00 00 00 00 | 	byte	$8e, $71, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
110ba     63 00 3E 63 
110be     63 63 63 63 
110c2     3E 00 00 00 
110c6     00 00 00 00 | 	byte	$63, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
110ca     00 00 63 36 
110ce     1C 1C 36 63 
110d2     00 00 00 00 
110d6     00 00 00 00 | 	byte	$00, $00, $63, $36, $1c, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00
110da     BE 63 73 7B 
110de     6B 6F 67 63 
110e2     3F 00 00 00 
110e6     00 00 00 00 | 	byte	$be, $63, $73, $7b, $6b, $6f, $67, $63, $3f, $00, $00, $00, $00, $00, $00, $00
110ea     0C 18 63 63 
110ee     63 63 63 63 
110f2     3E 00 00 00 
110f6     00 00 00 00 | 	byte	$0c, $18, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
110fa     18 0C 63 63 
110fe     63 63 63 63 
11102     3E 00 00 00 
11106     00 00 00 00 | 	byte	$18, $0c, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
1110a     08 36 63 63 
1110e     63 63 63 63 
11112     3E 00 00 00 
11116     00 00 00 00 | 	byte	$08, $36, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
1111a     63 00 63 63 
1111e     63 63 63 63 
11122     3E 00 00 00 
11126     00 00 00 00 | 	byte	$63, $00, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
1112a     30 18 C3 66 
1112e     3C 18 18 18 
11132     18 00 00 00 
11136     00 00 00 00 | 	byte	$30, $18, $c3, $66, $3c, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
1113a     03 03 3F 63 
1113e     63 3F 03 03 
11142     03 00 00 00 
11146     00 00 00 00 | 	byte	$03, $03, $3f, $63, $63, $3f, $03, $03, $03, $00, $00, $00, $00, $00, $00, $00
1114a     3C 66 66 66 
1114e     36 66 66 66 
11152     36 06 06 00 
11156     00 00 00 00 | 	byte	$3c, $66, $66, $66, $36, $66, $66, $66, $36, $06, $06, $00, $00, $00, $00, $00
1115a     06 0C 00 3C 
1115e     60 7C 66 66 
11162     7C 00 00 00 
11166     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
1116a     60 30 00 3C 
1116e     60 7C 66 66 
11172     7C 00 00 00 
11176     00 00 00 00 | 	byte	$60, $30, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
1117a     18 66 00 3C 
1117e     60 7C 66 66 
11182     7C 00 00 00 
11186     00 00 00 00 | 	byte	$18, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
1118a     8E 71 00 3C 
1118e     60 7C 66 66 
11192     7C 00 00 00 
11196     00 00 00 00 | 	byte	$8e, $71, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
1119a     00 66 00 3C 
1119e     60 7C 66 66 
111a2     7C 00 00 00 
111a6     00 00 00 00 | 	byte	$00, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
111aa     18 24 18 3C 
111ae     60 7C 66 66 
111b2     7C 00 00 00 
111b6     00 00 00 00 | 	byte	$18, $24, $18, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
111ba     00 00 00 7E 
111be     D8 FE 1B 1B 
111c2     EE 00 00 00 
111c6     00 00 00 00 | 	byte	$00, $00, $00, $7e, $d8, $fe, $1b, $1b, $ee, $00, $00, $00, $00, $00, $00, $00
111ca     00 00 00 3C 
111ce     06 06 06 06 
111d2     3C 18 0C 00 
111d6     00 00 00 00 | 	byte	$00, $00, $00, $3c, $06, $06, $06, $06, $3c, $18, $0c, $00, $00, $00, $00, $00
111da     06 0C 00 3C 
111de     66 7E 06 06 
111e2     3C 00 00 00 
111e6     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
111ea     60 30 00 3C 
111ee     66 7E 06 06 
111f2     3C 00 00 00 
111f6     00 00 00 00 | 	byte	$60, $30, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
111fa     18 66 00 3C 
111fe     66 7E 06 06 
11202     3C 00 00 00 
11206     00 00 00 00 | 	byte	$18, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
1120a     00 66 00 3C 
1120e     66 7E 06 06 
11212     3C 00 00 00 
11216     00 00 00 00 | 	byte	$00, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
1121a     0C 18 00 18 
1121e     18 18 18 18 
11222     30 00 00 00 
11226     00 00 00 00 | 	byte	$0c, $18, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
1122a     18 0C 00 0C 
1122e     0C 0C 0C 0C 
11232     18 00 00 00 
11236     00 00 00 00 | 	byte	$18, $0c, $00, $0c, $0c, $0c, $0c, $0c, $18, $00, $00, $00, $00, $00, $00, $00
1123a     18 66 00 18 
1123e     18 18 18 18 
11242     30 00 00 00 
11246     00 00 00 00 | 	byte	$18, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
1124a     00 66 00 18 
1124e     18 18 18 18 
11252     30 00 00 00 
11256     00 00 00 00 | 	byte	$00, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
1125a     03 06 3F 18 
1125e     3C 66 66 66 
11262     3C 00 00 00 
11266     00 00 00 00 | 	byte	$03, $06, $3f, $18, $3c, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
1126a     8E 71 00 3E 
1126e     66 66 66 66 
11272     66 00 00 00 
11276     00 00 00 00 | 	byte	$8e, $71, $00, $3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
1127a     06 0C 00 3C 
1127e     66 66 66 66 
11282     3C 00 00 00 
11286     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
1128a     60 30 00 3C 
1128e     66 66 66 66 
11292     3C 00 00 00 
11296     00 00 00 00 | 	byte	$60, $30, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
1129a     18 66 00 3C 
1129e     66 66 66 66 
112a2     3C 00 00 00 
112a6     00 00 00 00 | 	byte	$18, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
112aa     8E 71 00 3C 
112ae     66 66 66 66 
112b2     3C 00 00 00 
112b6     00 00 00 00 | 	byte	$8e, $71, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
112ba     00 66 00 3C 
112be     66 66 66 66 
112c2     3C 00 00 00 
112c6     00 00 00 00 | 	byte	$00, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
112ca     00 18 18 00 
112ce     7E 00 18 18 
112d2     00 00 00 00 
112d6     00 00 00 00 | 	byte	$00, $18, $18, $00, $7e, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
112da     00 00 00 7E 
112de     73 7B 6F 67 
112e2     3F 00 00 00 
112e6     00 00 00 00 | 	byte	$00, $00, $00, $7e, $73, $7b, $6f, $67, $3f, $00, $00, $00, $00, $00, $00, $00
112ea     0C 18 00 66 
112ee     66 66 66 66 
112f2     7C 00 00 00 
112f6     00 00 00 00 | 	byte	$0c, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
112fa     30 18 00 66 
112fe     66 66 66 66 
11302     7C 00 00 00 
11306     00 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
1130a     18 66 00 66 
1130e     66 66 66 66 
11312     7C 00 00 00 
11316     00 00 00 00 | 	byte	$18, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
1131a     00 66 00 66 
1131e     66 66 66 66 
11322     7C 00 00 00 
11326     00 00 00 00 | 	byte	$00, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
1132a     30 18 00 66 
1132e     66 66 66 3C 
11332     18 0C 06 00 
11336     00 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
1133a     06 06 06 3E 
1133e     66 66 66 3E 
11342     06 06 06 00 
11346     00 00 00 00 | 	byte	$06, $06, $06, $3e, $66, $66, $66, $3e, $06, $06, $06, $00, $00, $00, $00, $00
1134a     00 66 00 66 
1134e     66 66 66 3C 
11352     18 0C 06 00 
11356     00 00 00 00 | 	byte	$00, $66, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
1135a     00 7E 66 66 
1135e     66 66 66 66 
11362     66 7E 00 00 
11366     00 00 00 00 | 	byte	$00, $7e, $66, $66, $66, $66, $66, $66, $66, $7e, $00, $00, $00, $00, $00, $00
1136a     00 00 00 00 
      ...             
11572     00 00 00 00 
11576     00 00       | 	byte	$00[526]
11578     00 00 00 00 
1157c     00          | vga16          long  $00000000,$00008000,$00800000,$00808000,$80000000,$80008000,$80400000,$AAAAAA00,$55555500,$0000FF00,$00FF0000,$00FFFF00,$FF000000,$FF00FF00,$FFFF0000,$FFFFFF00
1157d     80 00 00 00 
11581     00 80 00 00 
11585     80 80 00 00 
11589     00 00 80 00 | 	byte	$80, $00, $00, $00, $00, $80, $00, $00, $80, $80, $00, $00, $00, $00, $80, $00
1158d     80 00 80 00 
11591     00 40 80 00 
11595     AA AA AA 00 
11599     55 55 55 00 | 	byte	$80, $00, $80, $00, $00, $40, $80, $00, $aa, $aa, $aa, $00, $55, $55, $55, $00
1159d     FF 00 00 00 
115a1     00 FF 00 00 
115a5     FF FF 00 00 
115a9     00 00 FF 00 | 	byte	$ff, $00, $00, $00, $00, $ff, $00, $00, $ff, $ff, $00, $00, $00, $00, $ff, $00
115ad     FF 00 FF 00 
115b1     00 FF FF 00 
115b5     FF FF FF    | 	byte	$ff, $00, $ff, $00, $00, $ff, $ff, $00, $ff, $ff, $ff
115b8     00 00 00 00 
115bc     00          | ataripalette   file "ataripalettep2.def"
115bd     11 11 11 00 
115c1     22 22 22 00 
115c5     33 33 33 00 
115c9     44 44 44 00 | 	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
115cd     55 55 55 00 
115d1     66 66 66 00 
115d5     77 77 77 00 
115d9     88 88 88 00 | 	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
115dd     99 99 99 00 
115e1     AA AA AA 00 
115e5     BB BB BB 00 
115e9     CC CC CC 00 | 	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
115ed     DD DD DD 00 
115f1     EE EE EE 00 
115f5     FF FF FF 00 
115f9     00 0A 20 00 | 	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
115fd     00 14 40 00 
11601     00 1E 60 00 
11605     00 28 80 00 
11609     00 32 9F 00 | 	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
1160d     00 3C BF 00 
11611     00 46 DF 00 
11615     00 50 FF 00 
11619     1C 63 FF 00 | 	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
1161d     39 77 FF 00 
11621     55 8A FF 00 
11625     71 9E FF 00 
11629     8E B1 FF 00 | 	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
1162d     AA C5 FF 00 
11631     C6 D8 FF 00 
11635     E3 EC FF 00 
11639     00 00 20 00 | 	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
1163d     00 00 40 00 
11641     00 00 60 00 
11645     00 00 80 00 
11649     00 00 9F 00 | 	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
1164d     00 00 BF 00 
11651     00 00 DF 00 
11655     00 00 FF 00 
11659     1C 1C FF 00 | 	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
1165d     39 39 FF 00 
11661     55 55 FF 00 
11665     71 71 FF 00 
11669     8E 8E FF 00 | 	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
1166d     AA AA FF 00 
11671     C6 C6 FF 00 
11675     E3 E3 FF 00 
11679     10 00 20 00 | 	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
1167d     20 00 40 00 
11681     30 00 60 00 
11685     40 00 80 00 
11689     50 00 9F 00 | 	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
1168d     60 00 BF 00 
11691     70 00 DF 00 
11695     80 00 FF 00 
11699     8E 1C FF 00 | 	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
1169d     9C 39 FF 00 
116a1     AA 55 FF 00 
116a5     B8 71 FF 00 
116a9     C7 8E FF 00 | 	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
116ad     D5 AA FF 00 
116b1     E3 C6 FF 00 
116b5     F1 E3 FF 00 
116b9     20 00 20 00 | 	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
116bd     40 00 40 00 
116c1     60 00 60 00 
116c5     80 00 80 00 
116c9     9F 00 9F 00 | 	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
116cd     BF 00 BF 00 
116d1     DF 00 DF 00 
116d5     FF 00 FF 00 
116d9     FF 1C FF 00 | 	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
116dd     FF 39 FF 00 
116e1     FF 55 FF 00 
116e5     FF 71 FF 00 
116e9     FF 8E FF 00 | 	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
116ed     FF AA FF 00 
116f1     FF C6 FF 00 
116f5     FF E3 FF 00 
116f9     20 00 10 00 | 	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
116fd     40 00 20 00 
11701     60 00 30 00 
11705     80 00 40 00 
11709     9F 00 50 00 | 	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
1170d     BF 00 60 00 
11711     DF 00 70 00 
11715     FF 00 80 00 
11719     FF 1C 8E 00 | 	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
1171d     FF 39 9C 00 
11721     FF 55 AA 00 
11725     FF 71 B8 00 
11729     FF 8E C7 00 | 	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
1172d     FF AA D5 00 
11731     FF C6 E3 00 
11735     FF E3 F1 00 
11739     20 00 00 00 | 	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
1173d     40 00 00 00 
11741     60 00 00 00 
11745     80 00 00 00 
11749     9F 00 00 00 | 	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
1174d     BF 00 00 00 
11751     DF 00 00 00 
11755     FF 00 00 00 
11759     FF 1C 1C 00 | 	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
1175d     FF 39 39 00 
11761     FF 55 55 00 
11765     FF 71 71 00 
11769     FF 8E 8E 00 | 	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
1176d     FF AA AA 00 
11771     FF C6 C6 00 
11775     FF E3 E3 00 
11779     20 08 00 00 | 	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
1177d     40 10 00 00 
11781     60 18 00 00 
11785     80 20 00 00 
11789     9F 28 00 00 | 	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
1178d     BF 30 00 00 
11791     DF 38 00 00 
11795     FF 40 00 00 
11799     FF 55 1C 00 | 	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
1179d     FF 6A 39 00 
117a1     FF 80 55 00 
117a5     FF 95 71 00 
117a9     FF AA 8E 00 | 	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
117ad     FF BF AA 00 
117b1     FF D5 C6 00 
117b5     FF EA E3 00 
117b9     20 10 00 00 | 	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
117bd     40 20 00 00 
117c1     60 30 00 00 
117c5     80 40 00 00 
117c9     9F 50 00 00 | 	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
117cd     BF 60 00 00 
117d1     DF 70 00 00 
117d5     FF 80 00 00 
117d9     FF 8E 1C 00 | 	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
117dd     FF 9C 39 00 
117e1     FF AA 55 00 
117e5     FF B8 71 00 
117e9     FF C7 8E 00 | 	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
117ed     FF D5 AA 00 
117f1     FF E3 C6 00 
117f5     FF F1 E3 00 
117f9     20 18 00 00 | 	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
117fd     40 30 00 00 
11801     60 48 00 00 
11805     80 60 00 00 
11809     9F 78 00 00 | 	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
1180d     BF 90 00 00 
11811     DF A8 00 00 
11815     FF C0 00 00 
11819     FF C7 1C 00 | 	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
1181d     FF CE 39 00 
11821     FF D5 55 00 
11825     FF DC 71 00 
11829     FF E3 8E 00 | 	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
1182d     FF EA AA 00 
11831     FF F1 C6 00 
11835     FF F8 E3 00 
11839     18 20 00 00 | 	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
1183d     30 40 00 00 
11841     48 60 00 00 
11845     60 80 00 00 
11849     78 9F 00 00 | 	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
1184d     90 BF 00 00 
11851     A8 DF 00 00 
11855     C0 FF 00 00 
11859     C7 FF 1C 00 | 	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
1185d     CE FF 39 00 
11861     D5 FF 55 00 
11865     DC FF 71 00 
11869     E3 FF 8E 00 | 	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
1186d     EA FF AA 00 
11871     F1 FF C6 00 
11875     F8 FF E3 00 
11879     00 20 00 00 | 	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
1187d     00 40 00 00 
11881     00 60 00 00 
11885     00 80 00 00 
11889     00 9F 00 00 | 	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
1188d     00 BF 00 00 
11891     00 DF 00 00 
11895     00 FF 00 00 
11899     1C FF 1C 00 | 	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
1189d     39 FF 39 00 
118a1     55 FF 55 00 
118a5     71 FF 71 00 
118a9     8E FF 8E 00 | 	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
118ad     AA FF AA 00 
118b1     C6 FF C6 00 
118b5     E3 FF E3 00 
118b9     00 20 0A 00 | 	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
118bd     00 40 14 00 
118c1     00 60 1E 00 
118c5     00 80 28 00 
118c9     00 9F 32 00 | 	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
118cd     00 BF 3C 00 
118d1     00 DF 46 00 
118d5     00 FF 50 00 
118d9     1C FF 63 00 | 	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
118dd     39 FF 77 00 
118e1     55 FF 8A 00 
118e5     71 FF 9E 00 
118e9     8E FF B1 00 | 	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
118ed     AA FF C5 00 
118f1     C6 FF D8 00 
118f5     E3 FF EC 00 
118f9     00 20 14 00 | 	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
118fd     00 40 28 00 
11901     00 60 3C 00 
11905     00 80 50 00 
11909     00 9F 64 00 | 	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
1190d     00 BF 78 00 
11911     00 DF 8C 00 
11915     00 FF A0 00 
11919     1C FF AB 00 | 	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
1191d     39 FF B5 00 
11921     55 FF C0 00 
11925     71 FF CA 00 
11929     8E FF D5 00 | 	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
1192d     AA FF DF 00 
11931     C6 FF EA 00 
11935     E3 FF F4 00 
11939     00 20 20 00 | 	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
1193d     00 40 40 00 
11941     00 60 60 00 
11945     00 80 80 00 
11949     00 9F 9F 00 | 	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
1194d     00 BF BF 00 
11951     00 DF DF 00 
11955     00 FF FF 00 
11959     1C FF FF 00 | 	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
1195d     39 FF FF 00 
11961     55 FF FF 00 
11965     71 FF FF 00 
11969     8E FF FF 00 | 	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
1196d     AA FF FF 00 
11971     C6 FF FF 00 
11975     E3 FF FF 00 
11979     00 14 20 00 | 	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
1197d     00 28 40 00 
11981     00 3C 60 00 
11985     00 50 80 00 
11989     00 64 9F 00 | 	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
1198d     00 78 BF 00 
11991     00 8C DF 00 
11995     00 A0 FF 00 
11999     1C AB FF 00 | 	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
1199d     39 B5 FF 00 
119a1     55 C0 FF 00 
119a5     71 CA FF 00 
119a9     8E D5 FF 00 | 	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
119ad     AA DF FF 00 
119b1     C6 EA FF 00 
119b5     E3 F4 FF    | 	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
119b8     00 00 00 00 
119bc     00          | ataripalette2  file "ataripalettep2.def"
119bd     11 11 11 00 
119c1     22 22 22 00 
119c5     33 33 33 00 
119c9     44 44 44 00 | 	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
119cd     55 55 55 00 
119d1     66 66 66 00 
119d5     77 77 77 00 
119d9     88 88 88 00 | 	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
119dd     99 99 99 00 
119e1     AA AA AA 00 
119e5     BB BB BB 00 
119e9     CC CC CC 00 | 	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
119ed     DD DD DD 00 
119f1     EE EE EE 00 
119f5     FF FF FF 00 
119f9     00 0A 20 00 | 	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
119fd     00 14 40 00 
11a01     00 1E 60 00 
11a05     00 28 80 00 
11a09     00 32 9F 00 | 	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
11a0d     00 3C BF 00 
11a11     00 46 DF 00 
11a15     00 50 FF 00 
11a19     1C 63 FF 00 | 	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
11a1d     39 77 FF 00 
11a21     55 8A FF 00 
11a25     71 9E FF 00 
11a29     8E B1 FF 00 | 	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
11a2d     AA C5 FF 00 
11a31     C6 D8 FF 00 
11a35     E3 EC FF 00 
11a39     00 00 20 00 | 	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
11a3d     00 00 40 00 
11a41     00 00 60 00 
11a45     00 00 80 00 
11a49     00 00 9F 00 | 	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
11a4d     00 00 BF 00 
11a51     00 00 DF 00 
11a55     00 00 FF 00 
11a59     1C 1C FF 00 | 	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
11a5d     39 39 FF 00 
11a61     55 55 FF 00 
11a65     71 71 FF 00 
11a69     8E 8E FF 00 | 	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
11a6d     AA AA FF 00 
11a71     C6 C6 FF 00 
11a75     E3 E3 FF 00 
11a79     10 00 20 00 | 	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
11a7d     20 00 40 00 
11a81     30 00 60 00 
11a85     40 00 80 00 
11a89     50 00 9F 00 | 	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
11a8d     60 00 BF 00 
11a91     70 00 DF 00 
11a95     80 00 FF 00 
11a99     8E 1C FF 00 | 	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
11a9d     9C 39 FF 00 
11aa1     AA 55 FF 00 
11aa5     B8 71 FF 00 
11aa9     C7 8E FF 00 | 	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
11aad     D5 AA FF 00 
11ab1     E3 C6 FF 00 
11ab5     F1 E3 FF 00 
11ab9     20 00 20 00 | 	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
11abd     40 00 40 00 
11ac1     60 00 60 00 
11ac5     80 00 80 00 
11ac9     9F 00 9F 00 | 	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
11acd     BF 00 BF 00 
11ad1     DF 00 DF 00 
11ad5     FF 00 FF 00 
11ad9     FF 1C FF 00 | 	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
11add     FF 39 FF 00 
11ae1     FF 55 FF 00 
11ae5     FF 71 FF 00 
11ae9     FF 8E FF 00 | 	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
11aed     FF AA FF 00 
11af1     FF C6 FF 00 
11af5     FF E3 FF 00 
11af9     20 00 10 00 | 	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
11afd     40 00 20 00 
11b01     60 00 30 00 
11b05     80 00 40 00 
11b09     9F 00 50 00 | 	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
11b0d     BF 00 60 00 
11b11     DF 00 70 00 
11b15     FF 00 80 00 
11b19     FF 1C 8E 00 | 	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
11b1d     FF 39 9C 00 
11b21     FF 55 AA 00 
11b25     FF 71 B8 00 
11b29     FF 8E C7 00 | 	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
11b2d     FF AA D5 00 
11b31     FF C6 E3 00 
11b35     FF E3 F1 00 
11b39     20 00 00 00 | 	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
11b3d     40 00 00 00 
11b41     60 00 00 00 
11b45     80 00 00 00 
11b49     9F 00 00 00 | 	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
11b4d     BF 00 00 00 
11b51     DF 00 00 00 
11b55     FF 00 00 00 
11b59     FF 1C 1C 00 | 	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
11b5d     FF 39 39 00 
11b61     FF 55 55 00 
11b65     FF 71 71 00 
11b69     FF 8E 8E 00 | 	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
11b6d     FF AA AA 00 
11b71     FF C6 C6 00 
11b75     FF E3 E3 00 
11b79     20 08 00 00 | 	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
11b7d     40 10 00 00 
11b81     60 18 00 00 
11b85     80 20 00 00 
11b89     9F 28 00 00 | 	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
11b8d     BF 30 00 00 
11b91     DF 38 00 00 
11b95     FF 40 00 00 
11b99     FF 55 1C 00 | 	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
11b9d     FF 6A 39 00 
11ba1     FF 80 55 00 
11ba5     FF 95 71 00 
11ba9     FF AA 8E 00 | 	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
11bad     FF BF AA 00 
11bb1     FF D5 C6 00 
11bb5     FF EA E3 00 
11bb9     20 10 00 00 | 	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
11bbd     40 20 00 00 
11bc1     60 30 00 00 
11bc5     80 40 00 00 
11bc9     9F 50 00 00 | 	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
11bcd     BF 60 00 00 
11bd1     DF 70 00 00 
11bd5     FF 80 00 00 
11bd9     FF 8E 1C 00 | 	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
11bdd     FF 9C 39 00 
11be1     FF AA 55 00 
11be5     FF B8 71 00 
11be9     FF C7 8E 00 | 	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
11bed     FF D5 AA 00 
11bf1     FF E3 C6 00 
11bf5     FF F1 E3 00 
11bf9     20 18 00 00 | 	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
11bfd     40 30 00 00 
11c01     60 48 00 00 
11c05     80 60 00 00 
11c09     9F 78 00 00 | 	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
11c0d     BF 90 00 00 
11c11     DF A8 00 00 
11c15     FF C0 00 00 
11c19     FF C7 1C 00 | 	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
11c1d     FF CE 39 00 
11c21     FF D5 55 00 
11c25     FF DC 71 00 
11c29     FF E3 8E 00 | 	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
11c2d     FF EA AA 00 
11c31     FF F1 C6 00 
11c35     FF F8 E3 00 
11c39     18 20 00 00 | 	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
11c3d     30 40 00 00 
11c41     48 60 00 00 
11c45     60 80 00 00 
11c49     78 9F 00 00 | 	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
11c4d     90 BF 00 00 
11c51     A8 DF 00 00 
11c55     C0 FF 00 00 
11c59     C7 FF 1C 00 | 	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
11c5d     CE FF 39 00 
11c61     D5 FF 55 00 
11c65     DC FF 71 00 
11c69     E3 FF 8E 00 | 	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
11c6d     EA FF AA 00 
11c71     F1 FF C6 00 
11c75     F8 FF E3 00 
11c79     00 20 00 00 | 	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
11c7d     00 40 00 00 
11c81     00 60 00 00 
11c85     00 80 00 00 
11c89     00 9F 00 00 | 	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
11c8d     00 BF 00 00 
11c91     00 DF 00 00 
11c95     00 FF 00 00 
11c99     1C FF 1C 00 | 	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
11c9d     39 FF 39 00 
11ca1     55 FF 55 00 
11ca5     71 FF 71 00 
11ca9     8E FF 8E 00 | 	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
11cad     AA FF AA 00 
11cb1     C6 FF C6 00 
11cb5     E3 FF E3 00 
11cb9     00 20 0A 00 | 	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
11cbd     00 40 14 00 
11cc1     00 60 1E 00 
11cc5     00 80 28 00 
11cc9     00 9F 32 00 | 	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
11ccd     00 BF 3C 00 
11cd1     00 DF 46 00 
11cd5     00 FF 50 00 
11cd9     1C FF 63 00 | 	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
11cdd     39 FF 77 00 
11ce1     55 FF 8A 00 
11ce5     71 FF 9E 00 
11ce9     8E FF B1 00 | 	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
11ced     AA FF C5 00 
11cf1     C6 FF D8 00 
11cf5     E3 FF EC 00 
11cf9     00 20 14 00 | 	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
11cfd     00 40 28 00 
11d01     00 60 3C 00 
11d05     00 80 50 00 
11d09     00 9F 64 00 | 	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
11d0d     00 BF 78 00 
11d11     00 DF 8C 00 
11d15     00 FF A0 00 
11d19     1C FF AB 00 | 	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
11d1d     39 FF B5 00 
11d21     55 FF C0 00 
11d25     71 FF CA 00 
11d29     8E FF D5 00 | 	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
11d2d     AA FF DF 00 
11d31     C6 FF EA 00 
11d35     E3 FF F4 00 
11d39     00 20 20 00 | 	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
11d3d     00 40 40 00 
11d41     00 60 60 00 
11d45     00 80 80 00 
11d49     00 9F 9F 00 | 	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
11d4d     00 BF BF 00 
11d51     00 DF DF 00 
11d55     00 FF FF 00 
11d59     1C FF FF 00 | 	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
11d5d     39 FF FF 00 
11d61     55 FF FF 00 
11d65     71 FF FF 00 
11d69     8E FF FF 00 | 	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
11d6d     AA FF FF 00 
11d71     C6 FF FF 00 
11d75     E3 FF FF 00 
11d79     00 14 20 00 | 	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
11d7d     00 28 40 00 
11d81     00 3C 60 00 
11d85     00 50 80 00 
11d89     00 64 9F 00 | 	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
11d8d     00 78 BF 00 
11d91     00 8C DF 00 
11d95     00 A0 FF 00 
11d99     1C AB FF 00 | 	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
11d9d     39 B5 FF 00 
11da1     55 C0 FF 00 
11da5     71 CA FF 00 
11da9     8E D5 FF 00 | 	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
11dad     AA DF FF 00 
11db1     C6 EA FF 00 
11db5     E3 F4 FF    | 	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
11db8                 | 
11db8                 | '**********************************************************************************
11db8                 | '
11db8                 | '        Timings and colors definitions
11db8                 | '
11db8                 | '**********************************************************************************
11db8                 | 
11db8                 | '                      bf.hs, hs,  bf.vis  visible, up p., vsync, down p.,  cpl, total lines, clock,       hubset                                scanlines  ud bord mode reserved
11db8     08 00 00 00 
11dbc     3C 00 00 00 
11dc0     08 00 00 00 
11dc4     00 04 00 00 | timings         long   8,     60,  8,       1024,   7,     4,     1,        128, 600,         340500000,   %1_100111__10_1010_1000__1111_1011,   600,        0,     192, 0, 0
11dc8     07 00 00 00 
11dcc     04 00 00 00 
11dd0     01 00 00 00 
11dd4     80 00 00 00 | 	byte	$07, $00, $00, $00, $04, $00, $00, $00, $01, $00, $00, $00, $80, $00, $00, $00
11dd8     58 02 00 00 
11ddc     20 9E 4B 14 
11de0     FB A8 9E 01 
11de4     58 02 00 00 | 	byte	$58, $02, $00, $00, $20, $9e, $4b, $14, $fb, $a8, $9e, $01, $58, $02, $00, $00
11de8     00 00 00 00 
11dec     C0 00 00 00 
11df0     00 00 00 00 
11df4     00 00 00 00 | 	byte	$00, $00, $00, $00, $c0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
11df8                 | 'timings        long   16,    80,  12,      1024,   8,     4,     8,        128, 576,         336956522,   %1_101101__11_0000_0110__1111_1011,   576,        0,     192, 0, 0
11df8     00 75 C7 97 
11dfc     27 47 F6 0A 
11e00     05 79 CB 9B 
11e04     2B 4B EA 0F | vgacolors       byte   0, 117, 199, 151, 39, 71, 246, 10, 5, 121, 203, 155, 43, 75, 234, 15
11e08                 | 
11e08                 | ''--------  Initialization  ----------------------------------------------------------------
11e08                 | 
11e08     28 0C 64 FD | hdmi            setq    #6
11e0c     00 A5 05 FB |                 rdlong  vblankptr,  ptra                   ' read pointers
11e10     28 10 64 FD |                 setq    #8
11e14     D3 8A 01 FB |                 rdlong  m_bs,modeptr                       ' read timings
11e18                 | 
11e18     1F AC 1D F4 |                 bitl    hbase, #31 wcz                     ' if pin 31 is set, use full strength for Adafruit Pico HDMI board
11e1c     3C 00 66 FD |                 setcmod #$100                              ' enable HDMI mode
11e20     C0 C7 05 F6 |                 mov     t1,#448                            ' 7 << 6          
11e24     D6 C6 01 F1 |                 add     t1,hbase
11e28     58 C6 61 FD |                 drvl    t1                                 ' #7<<6 + hdmi_base      ' enable HDMI pins
11e2c     E3 00 08 AC |         if_z    wrpin   #0, t1  '#7<<6 + hdmi_base         ' for Adafruit breakout board - full logic as in Pico, the board has 220 Ohm resistors on it
11e30     7B 0B 80 5F 
11e34     E3 00 0B 5C | 	if_nz   wrpin   ##%10110_1111_0111_10_00000_0, t1  ' #7<<6 + hdmi_base      ' a '123 ohm BITDAC for Parallax breakout board
11e38     66 66 86 FF 
11e3c     1D 9A 65 FD |                 setxfrq ##$0CCCCCCC+1                      ' set streamer freq to 1/10th clk
11e40                 | '
11e40     D6 C6 01 F6 |                 mov 	t1,hbase			   '
11e44     11 C6 65 F0 |                 shl 	t1,#17                             '
11e48     E3 A2 01 F1 |                 add 	lutg8,t1                           ' add the pin base to he streamer constant
11e4c     02 92 85 F1 |                 sub 	i_upporch,#2			   ' the driver will call 2 blank lines itself to preload the buffer, so sub #2 from up porch time
11e50                 | 
11e50     01 C6 61 FD |                 cogid   t1              		   ' get a cogid
11e54     0C C6 05 FA |                 mul     t1, #12                            ' compute the offset to PSRAM mailbox 
11e58     E3 AE 01 F1 |                 add     mailbox, t1                        ' add offset to find this COG's mailbox
11e5c                 | 
11e5c                 | ''--------  frame rendering main loop  ---------------------------------------------------
11e5c                 | 
11e5c     28 06 64 FD | p101            setq 	#3
11e60     00 A5 05 FB | 		rdlong  vblankptr,ptra
11e64     28 6A 64 FD |                 setq    #47+6				   ' read sprite data
11e68     D8 DC 01 FB | 	 	rdlong  sprite1pointer,spriteptr
11e6c     00 4A 06 F6 | 		mov     spriteline,#0                      ' init the sprite line variable
11e70     00 A0 05 F6 |                 mov     dlinum, #0
11e74     01 9E 05 F1 |                 add     frames,#1			   ' increment the frame counter
11e78     D5 B8 01 F6 |                 mov     dlptr2,dlptr			   ' init the temporary DL pointer
11e7c                 | 
11e7c                 | 
11e7c     00 9C 05 F6 |                 mov     linenum,#0			   ' init the current line #
11e80     00 CE 05 F6 |                 mov     rcnt,#0			   	   ' init the DL repeat counter
11e84     ED D2 01 F6 |                 mov     rcnt2a,affffffff 		   ' why?!                
11e88                 |                 
11e88                 | 
11e88                 | 
11e88                 | '' ------- reload the palette. If bit31 set, don't reload, to prevent blinking while modifying the palette
11e88                 |   
11e88     1F A8 15 F4 |                 testb   paletteptr,#31 wc
11e8c     29 FE 65 3D |          if_nc  setq2   #255
11e90     D4 00 00 3B |          if_nc  rdlong  $000, paletteptr                   'read palette
11e94                 | 
11e94                 | '' -----   up porch (before the picture)
11e94                 | 
11e94     C0 C2 01 F6 |                 mov     hsync0,sync_000      	           ' init constants for sync
11e98     C1 C4 01 F6 |                 mov     hsync1,sync_001	
11e9c     40 92 45 FB |                 callpa  i_upporch ,#blank                  ' call the porch line i_upporch (-2) times
11ea0     D2 00 68 FC |                 wrlong  #0,vblankptr                       ' the vblank time ends here
11ea4                 |  
11ea4                 |    
11ea4                 |  
11ea4     E1 8A C1 FC |                 xcont   m_bs,hsync0                        ' horizontal sync
11ea8     E2 8C B1 FC |                 xzero   m_sn,hsync1
11eac     60 00 B0 FD |          	     call    #dli	                  ' call DL interpreter for line #0 at line #(-2) - 2 lines earlier, so it can start preloading data from PSRAM
11eb0     E1 8E C1 FC |                 xcont   m_bv,hsync0     
11eb4     E1 90 C1 FC |                 xcont   m_vi,hsync0
11eb8     DF 80 78 FC |                          rdfast  #64,buf1d                          ' prepare the HUB buffer for 4 scanlines
11ebc                 | 
11ebc     E1 8A C1 FC |                 xcont   m_bs,hsync0                        ' horizontal sync
11ec0     E2 8C B1 FC |                 xzero   m_sn,hsync1
11ec4     48 00 B0 FD | 		call    #dli
11ec8     E1 8E C1 FC |                 xcont   m_bv,hsync0     
11ecc     E1 90 C1 FC |                 xcont   m_vi,hsync0
11ed0     20 01 B0 FD |                  call    #sprite				   ' sprites for line #0
11ed4                 |                 	
11ed4                 |                 
11ed4                 | 
11ed4                 |  
11ed4                 | '' ------- the main screen drawing starts here
11ed4                 | 
11ed4     E1 8A C1 FC | p301            xcont   m_bs,hsync0   			  ' make a right porch
11ed8     E2 8C B1 FC |                 xzero   m_sn,hsync1                       ' make hsync
11edc     30 00 B0 FD |                 call    #dli                              ' process the DL for line+2                
11ee0     E1 8E C1 FC |                 xcont   m_bv,hsync0
11ee4     00 A2 C5 FC |                 xcont   lutg8,#0			  ' display the line 
11ee8     01 9C 05 F1 |                  add     linenum,#1                        ' increment the current line number 
11eec     04 01 B0 FD |                  call    #sprite                           ' process sprites for line+1             
11ef0                 |               
11ef0                 | 
11ef0     CD 9C 09 F2 |                 cmp     linenum,i_totalvis  wz            ' check if all lines displayed
11ef4     DC FF 9F 5D |     if_nz       jmp     #p301                             ' if not, display the next line
11ef8                 | 
11ef8                 | ' ---------------- All visible lines displayed now, start vblank  
11ef8                 | 
11ef8     D2 02 68 FC | p112            wrlong  #1,vblankptr                       ' tell the system that the vblank started
11efc     28 96 45 FB |                 callpa  i_downporch ,#blank                ' bottom blanks
11f00     C2 C2 01 F6 |                 mov     hsync0,sync_222                    ' vsync on
11f04     C3 C4 01 F6 |                 mov     hsync1,sync_223
11f08     25 94 45 FB |                 callpa  i_vsync,#blank                     ' vertical sync blanks
11f0c     4C FF 9F FD |                 jmp     #p101                              ' return to the main loop
11f10                 | 
11f10                 | '' --------------- END of frame rendering loop ---------------------------------------------------------------------------
11f10                 | 
11f10                 | '' --------------- Display list interpreter ---------------------------------------------------------------------------
11f10                 | 
11f10     00 CE 0D F2 | dli             cmp     rcnt,#0 wz			   ' check the DL repeat counter 
11f14                 | 
11f14     DC BA 01 AB |     if_z        rdlong  dl,dlptr2				
11f18     04 B8 05 A1 |     if_z        add     dlptr2,#4
11f1c     14 00 90 AD |     if_z        jmp     #p307                              ' no repeat, goto read and interpret the next DL entry
11f20                 | 
11f20     01 CE 8D F1 |                 sub     rcnt,#1 wz                         ' decrement the repeat counter
11f24     EB BA 01 56 |     if_nz       mov     dl,rdl                             ' restore repeating DL entry from temporary buffer
11f28     E8 D2 19 F7 |                 incmod  rcnt2a,rcnt2 wcz                   ' address update counter
11f2c     EA BA 01 C1 |     if_c        add     dl,roffset                         ' if it rollovers, add the offset to the data address
11f30     DD D6 01 F6 |                 mov     rdl,dl                             ' save the result
11f34                 | 
11f34     DD C0 19 F6 | p307	        mov     framebuf2,dl wcz                   ' move this to framebuf2. If normal DL entry, the frame buffer start will be extracted from this
11f38     DD C6 41 F8 |                 getnib  t1,dl,#0
11f3c     02 C6 0D F2 |                 cmp     t1,#%0010 wz			   ' 0010 - display a normal graphics line, preload it from the PSRAM
11f40     70 00 90 AD |     if_z        jmp     #preload
11f44     00 C6 0D F2 |     		cmp     t1,#%0000 wz			   ' 0000 - display a line from a PSRAM list
11f48     94 00 90 AD |     if_z        jmp     #preload2
11f4c     01 C6 0D F2 |                 cmp     t1,#%0001 wz			   ' 0001 - repeat
11f50     0C 00 90 AD |     if_z        jmp     #p390
11f54     03 C6 0D F2 |                 cmp     t1,#%0011 wz			   ' 0011 - palette reload
11f58     28 00 90 AD |     if_z        jmp     #p391  
11f5c                 | 
11f5c     2D 00 64 FD | p308            ret
11f60                 |    
11f60     DC D6 01 FB | p390            rdlong  rdl,dlptr2                         ' read the next DL entry to repeat
11f64     E0 CE 39 F9 |                 getword rcnt,framebuf2,#1                  ' read the repeat count
11f68     04 CE 45 F0 |                 shr     rcnt,#4                            ' from 12 upper bits
11f6c     ED D2 01 F6 |                 mov     rcnt2a,affffffff                   ' I still don't know why?
11f70     E0 D0 61 F8 |                 getnib  rcnt2,framebuf2,#4                 ' read the pointer update counter
11f74     E0 D4 31 F9 |                 getword roffset,framebuf2,#0               ' read the offset to add
11f78     04 D4 45 F0 |                 shr     roffset,#4                         ' clean the command field from offset
11f7c     04 D4 65 F0 |                 shl     roffset,#4                         ' and make it ready to add to the DL entry (address=20 upper bits)
11f80     8C FF 9F FD |                 jmp     #dli                               ' now start repeating 
11f84                 |  
11f84                 | '' --------  Reload palette. To do 
11f84                 | 
11f84     E0 C6 51 F8 | p391           	getnib  t1,framebuf2,#2			   ' get a bank (0..15) of 16 colors
11f88     04 C6 65 F0 |          	shl     t1,#4				   ' compute the LUT address
11f8c     0C C0 45 F0 |         	shr     framebuf2,#12			   ' compute the HUB address of 16 new colors
11f90     29 1E 64 FD |          	setq2   #15				   ' load 16 entries
11f94     00 C6 8D F9 |          	altd    t1                                 ' from t1 LUT address
11f98     E0 00 00 FB |         	rdlong  $000, framebuf2         	
11f9c     70 FF 9F FD |         	jmp     #dli                
11fa0                 |       
11fa0                 | '' --------------- A display list interpreter end ------------------------------------------------------------------------    
11fa0                 | 
11fa0                 | 
11fa0                 | '' --------------- Blank and vsync procedures called via callpa have to be in the middle of the code ---------------------
11fa0                 | 
11fa0     E1 8A C1 FC | blank           xcont   m_bs,hsync0                        ' horizontal sync
11fa4     E2 8C B1 FC |                 xzero   m_sn,hsync1
11fa8     E1 8E C1 FC |                 xcont   m_bv,hsync0     
11fac     E1 90 C1 FC |                 xcont   m_vi,hsync0
11fb0     FB ED 6F 0B |         _ret_   djnz    pa,#blank
11fb4                 |         
11fb4                 | '' -------------- Preload a line from PSRAM        
11fb4                 |         
11fb4     D0 BC 01 F6 | preload         mov     buf1c,dlinum			   ' preload a line buffer #dlinum (0..3)
11fb8     0A BC 65 F0 |                 shl     buf1c,#10		           ' 1024 bytes per line
11fbc     DF BC 01 F1 |                 add     buf1c,buf1d			   ' add the start address (himem-debug-4096) : Todo: debug variable!
11fc0     DE B4 01 F6 |                 mov     buf1,buf1c
11fc4     03 A0 05 F7 |                 incmod  dlinum,#3
11fc8                 | 
11fc8     04 C0 45 F0 |                 shr     framebuf2,#4                      ' get the PSRAM start address from DL - Todo: use new DL format
11fcc     32 B7 01 F6 |                 mov     buf2,a1024
11fd0     E0 B2 01 F6 |                 mov     cmd,framebuf2                      ' set the address
11fd4     0B B2 3D F8 |                 setnib  cmd, #%1011, #7                    ' attach the command - read burst from the external memory
11fd8     28 04 64 FD |                 setq    #2				   ' write 3 longs to the mailbox
11fdc     D7 B2 61 0C |     _ret_       wrlong  cmd,mailbox			   ' read the PSRAM
11fe0                 |  
11fe0                 |  
11fe0                 | preload2      '  incmod  dlinum,#3
11fe0     04 C0 45 F0 |                 shr 	framebuf2,#4
11fe4     ED B2 01 F6 |                 mov 	cmd,affffffff
11fe8     E0 B4 01 F6 |                 mov 	buf1,framebuf2
11fec     28 02 64 FD |                 setq	#1
11ff0     D7 B2 61 0C |     _ret_	wrlong  cmd,mailbox
11ff4                 |                 
11ff4                 | 
11ff4                 | '' -------------- Draw sprites
11ff4                 | 
11ff4     CF 5C 02 F6 | sprite          mov t8,frames
11ff8     10 5C 0E F5 | 		and t8,#16 wz
11ffc     11 48 06 F6 |                 mov spritenum, #17			' 16 +2 sprites. Todo: this should be a parameter
12000     10 48 06 A6 | 	if_z    mov spritenum, #16	
12004                 | 		
12004                 | 
12004     24 57 02 F6 | p802            mov     t5,spritenum		   	' prepare a pointer to load sprite data
12008     03 56 06 FA |                 mul     t5,#3          			' one sprite data set needs 3 longs
1200c     EF 56 96 F9 |                 alts    t5,#sprite1xy
12010     00 4E 3A F9 |                 getword sprite_y,0-0,#1		        ' get a sprite y
12014     0F 4E 66 F7 |                 signx	sprite_y,#15			' they can be negative
12018     EF 56 96 F9 |                 alts    t5,#sprite1xy
1201c     00 4C 32 F9 |                 getword sprite_x,0-0,#0                 ' and x
12020     0F 4C 66 F7 |                 signx	sprite_x,#15
12024     F0 56 96 F9 |                 alts    t5,#sprite1wh
12028     00 52 3A F9 |                 getword sprite_h,0-0,#1		       	' get a sprite height
1202c     01 52 86 F1 |                 sub     sprite_h,#1
12030     F0 56 96 F9 |                 alts    t5,#sprite1wh
12034     00 50 32 F9 |                 getword sprite_w,0-0,#0                 ' and width
12038                 | 
12038                 | 
12038     32 4D 5A F2 |                	cmps	sprite_x,a1024 wcz	         
1203c     BC 00 90 3D |      if_ge	jmp 	#p801                           ' go out if >1023
12040     00 50 5E F2 |               	cmps	sprite_w,#0 wcz	         
12044     B4 00 90 AD |      if_e	jmp 	#p801                           ' go out if w=0
12048     00 52 5E F2 |               	cmps	sprite_h,#0 wcz	         
1204c     AC 00 90 AD |      if_e	jmp 	#p801                           ' go out if h=0
12050     00 5E 06 F6 |                 mov 	t9,#0
12054     28 5F 82 F1 |                 sub 	t9,sprite_w                      	
12058     2F 4D 5A F2 |      		cmps  	sprite_x,t9 wcz   		'
1205c     9C 00 90 ED |      if_le	jmp 	#p801	                        ' go out if sprite out of screen at right
12060                 |      
12060     CE C8 01 F6 |   		mov     t2,linenum			' display line # to check if sprite has to be displayed
12064     27 C9 D9 F1 |   		subs    t2,sprite_y wcz                 ' check if the sprite has to be displayed
12068     90 00 90 CD |      if_c       jmp     #p801				' if not, go out
1206c     29 C9 19 F2 |                 cmp     t2,sprite_h wcz		    	' we have now the sprite line #, check, if it is not >= sprite height
12070     88 00 90 1D |      if_gt      jmp     #p801				' if yes, go out
12074                 |                 
12074     25 CB 01 F6 |                 mov     t3,spriteline			' compute the line buffer addres where to put the sprite line
12078     0A CA 65 F0 |                 shl     t3,#10			       	' =1024*spriteline where spriteline=0..3		' 
1207c     DF CA 01 F1 |                 add     t3,buf1d			' line buffer addr
12080                 |   		
12080     1F 4C 16 F4 |   		testb	sprite_x,#31 wc 		' check if sprite pos <0
12084     26 CB 01 31 |      if_nc      add     t3,sprite_x   			' if >=0 add xpos. If <0, the address is the start of the line  - now we have the address to where wmlong the sprite
12088                 | 
12088     28 C9 01 FA |                 mul 	t2,sprite_w			' compute the offset to the sprite line data
1208c     26 51 02 C1 |      if_c	add     sprite_w,sprite_x		' if sprite_x negative, shorten the width
12090     26 C9 81 C1 |      if_c	sub 	t2,sprite_x			' and add the offset (sub negative) to the sprite data offset
12094                 |  
12094     EE 56 96 F9 |                 alts    t5,#sprite1pointer		' get the pointer to the sprite (3 longs per sprite data)
12098     00 C8 01 F1 |                 add     t2,0-0				' then add the offset
1209c     10 00 90 CD |      if_c 	jmp     #p899		
120a0                 | 	
120a0                 | 	
120a0     26 CD 01 F6 | 		mov 	t4,sprite_x	'
120a4     28 CD 01 F1 | 		add	t4,sprite_w
120a8     32 CD 99 F1 | 		sub     t4,a1024 wcz			' check if the sprite goes right off the screen
120ac                 | 
120ac     E6 50 82 31 | 	if_nc	sub	sprite_w,t4			' if yes, make it narrower
120b0                 | 
120b0     28 59 02 F6 | p899		mov 	t6,sprite_w
120b4     01 58 86 F1 | 	 	sub     t6,#1
120b8     02 58 46 F0 | 	 	shr	t6,#2				' bytes to longs
120bc                 | 
120bc     28 58 62 FD |                 setq   	t6
120c0     E4 E0 02 FB |                 rdlong 368,t2				' read sprite data to the cog
120c4     28 5D 02 F6 |                 mov t8,sprite_w
120c8     03 5C 0E F5 |                 and t8,#3 wz				' if width mod 4=0 we have full longs, nothing to do
120cc     24 00 90 AD |         if_z    jmp #p898
120d0                 |          
120d0                 |         
120d0     70 5F 06 F6 |                 mov  t9,#368
120d4     2C 5F 02 F1 |                 add t9,t6				' find the last long of the sprite
120d8                 | 
120d8     04 5C C6 F2 |                 subr t8,#4				' if modulo4=1, mask 3 bytes, if 2, mask 2, if 1, mask 3
120dc     08 5C 06 FA |                 mul t8,#8				' bits to shr
120e0     FF FF 7F FF 
120e4     FF 5B 06 F6 |                 mov t7,##-1				' full of 1s
120e8     2E 5B 42 F0 |                 shr t7,t8				' SHR to make 0s for masking
120ec     00 5E 8E F9 |                 altd t9,#0				' and mask 
120f0     2D 01 00 F5 |                 and 0-0, t7
120f4                 |                
120f4                 | 
120f4     28 58 62 FD | p898            setq   t6				' write the sprite data to the line buffer
120f8     E5 E0 7A FA |                 wmlong 368,t3				
120fc                 |                 
120fc     C1 49 7E FB | p801            djnf spritenum,#p802			' get the next sprite
12100     03 4A 06 F7 |                 incmod spriteline,#3			' prepare to fill the next line
12104     2D 00 64 FD |                 ret
12108                 | 	
12108                 | 	
12108                 |                
12108                 |  
12108                 | '' -------------- Graphics line ------------------------------------------------------------
12108                 |  
12108                 | 
12108                 | '' consts and vars
12108                 | 
12108     52 4D 35 D5 | sync_000        long    %1101010100_1101010100_1101010100_10    '
1210c     AE 42 35 D5 | sync_001        long    %1101010100_1101010100_0010101011_10    '        hsync
12110     52 45 15 55 | sync_222        long    %0101010100_0101010100_0101010100_10    'vsync
12114     AE 4A 15 55 | sync_223        long    %0101010100_0101010100_1010101011_10    'vsync + hsync
12118                 | 
12118     00 2C 1A 00 | border          long    %00000000_00011010_00101100_00000000
1211c                 | 
1211c                 | '------ these longs will be set by setmode function
1211c                 | 
1211c     00 00 00 00 | m_bs            long    0        'blanks before sync
12120     00 00 00 00 | m_sn            long    0        'sync
12124     00 00 00 00 | m_bv            long    0        'blanks before visible
12128     00 00 00 00 | m_vi            long    0        'visible pixels #
1212c                 | 'm_border        long    0        'left/right borders
1212c     00 00 00 00 | i_upporch       long    0        'up porch lines
12130     00 00 00 00 | i_vsync         long    0        'vsync lines
12134     00 00 00 00 | i_downporch     long    0        'down porch lines
12138     00 00 00 00 | i_cpl           long    0        'chars/longs per line
1213c     00 00 00 00 | i_totalvis      long    0
12140                 | 
12140                 | '-------------------------------------
12140                 |  
12140     00 00 00 00 | linenum         long    0
12144     00 00 00 00 | frames          long    0
12148     00 00 00 00 | dlinum long 0
1214c     00 04 88 70 | lutg8           long    $70880400 ' 0111_0000_1000_1000
12150                 | 
12150     00 00 00 00 | vblankptr       long    0
12154     00 00 00 00 | modeptr         long    0
12158     00 00 00 00 | paletteptr      long    0
1215c     00 00 00 00 | dlptr           long    0
12160     01 00 00 00 | hbase           long    1
12164     00 00 00 00 | mailbox         long    0
12168     00 00 00 00 | spriteptr          long 0
1216c                 | 
1216c     00 00 00 00 | cmd             long    0
12170     00 EC 07 00 | buf1            long    $80000-1024-4096
12174     00 04 00 00 | buf2            long    1024
12178     01 00 00 00 | dlptr2          long    1
1217c     01 00 00 00 | dl              long    1
12180                 | 
12180     00 00 00 00 | buf1c long 0
12184     00 EC 07 00 | buf1d            long    $80000-1024-4096
12188     01 00 00 00 | framebuf2       long    1
1218c     01 00 00 00 | hsync0          long    1
12190     01 00 00 00 | hsync1          long    1
12194                 | 
12194     01 00 00 00 | t1              long    1
12198     00 00 00 00 | t2 long 0
1219c     00 00 00 00 | t3 long 0
121a0     00 00 00 00 | t4 long 0
121a4                 | 
121a4     00 00 00 00 | rcnt            long    0  'dl repeat count
121a8     00 00 00 00 | rcnt2           long    0
121ac     00 00 00 00 | rcnt2a          long    0
121b0     00 00 00 00 | roffset         long    0
121b4     00 00 00 00 | rdl             long    0  'dl repeat line
121b8     00 00 00 00 | dlc             long    0  'dl command
121bc                 | 
121bc     FF FF FF FF | affffffff       long    $ffffffff
121c0     00 00 00 00 | sprite1pointer long 0
121c4     00 00 00 00 | sprite1xy      long 0
121c8     00 00 00 00 | sprite1wh      long 0
121cc     00 00 00 00 | sprite2pointer long 0
121d0     00 00 00 00 | sprite2xy      long 0
121d4     00 00 00 00 | sprite2wh      long 0
121d8     00 00 00 00 | sprite3pointer long 0
121dc     00 00 00 00 | sprite3xy      long 0
121e0     00 00 00 00 | sprite3wh      long 0
121e4     00 00 00 00 | sprite4pointer long 0
121e8     00 00 00 00 | sprite4xy      long 0
121ec     00 00 00 00 | sprite4wh      long 0
121f0     00 00 00 00 | sprite5pointer long 0
121f4     00 00 00 00 | sprite5xy      long 0
121f8     00 00 00 00 | sprite5wh      long 0
121fc     00 00 00 00 | sprite6pointer long 0
12200     00 00 00 00 | sprite6xy      long 0
12204     00 00 00 00 | sprite6wh      long 0
12208     00 00 00 00 | sprite7pointer long 0
1220c     00 00 00 00 | sprite7xy      long 0
12210     00 00 00 00 | sprite7wh      long 0
12214     00 00 00 00 | sprite8pointer long 0
12218     00 00 00 00 | sprite8xy      long 0
1221c     00 00 00 00 | sprite8wh      long 0
12220     00 00 00 00 | sprite9pointer long 0
12224     00 00 00 00 | sprite9xy      long 0
12228     00 00 00 00 | sprite9wh      long 0
1222c     00 00 00 00 | sprite10pointer long 0
12230     00 00 00 00 | sprite10xy      long 0
12234     00 00 00 00 | sprite10wh      long 0
12238     00 00 00 00 | sprite11pointer long 0
1223c     00 00 00 00 | sprite11xy      long 0
12240     00 00 00 00 | sprite11wh      long 0
12244     00 00 00 00 | sprite12pointer long 0
12248     00 00 00 00 | sprite12xy      long 0
1224c     00 00 00 00 | sprite12wh      long 0
12250     00 00 00 00 | sprite13pointer long 0
12254     00 00 00 00 | sprite13xy      long 0
12258     00 00 00 00 | sprite13wh      long 0
1225c     00 00 00 00 | sprite14pointer long 0
12260     00 00 00 00 | sprite14xy      long 0
12264     00 00 00 00 | sprite14wh      long 0
12268     00 00 00 00 | sprite15pointer long 0
1226c     00 00 00 00 | sprite15xy      long 0
12270     00 00 00 00 | sprite15wh      long 0
12274     00 00 00 00 | sprite16pointer long 0
12278     00 00 00 00 | sprite16xy      long 0
1227c     00 00 00 00 | sprite16wh      long 0
12280     00 00 00 00 | sprite17pointer long 0
12284     00 00 00 00 | sprite17xy      long 0
12288     00 00 00 00 | sprite17wh      long 0
1228c     00 00 00 00 | sprite18pointer long 0
12290     00 00 00 00 | sprite18xy      long 0
12294     00 00 00 00 | sprite18wh      long 0
12298     00 00 00 00 | spritenum long 0
1229c                 | 
1229c     00 00 00 00 | spriteline long 0
122a0     84 03 00 00 | sprite_x long 900
122a4     00 00 00 00 | sprite_y long 0
122a8     10 00 00 00 | sprite_w long 16
122ac     40 00 00 00 | sprite_h long 64
122b0     00 00 00 00 | l2 long 0
122b4     00 00 00 00 | t5 long 0
122b8     00 00 00 00 | t6 long 0
122bc     00 00 00 00 | t7 long 0
122c0     00 00 00 00 | t8 long 0
122c4     00 00 00 00 | t9 long 0
122c8     00 00 00 00 | preloadaddr long 0
122cc     00 00 00 00 | preloadlineaddr long 0
122d0     00 04 00 00 | a1024 long 1024
122d4                 | 
122d4     E0 03 00 00 | aa long 992
122d8     FF 03 00 00 | a1023 long 1023
122dc     00 10 00 00 | a4096 long 4096
122e0                 |  fit 368
122e0                 |  fit 368
122e0                 | _psram_spin2_dat_
122e0     00 00 00 00 
      ...             
123d8     00 00 00 00 
123dc     00 00 00 00 |     listdata long 0[8*8]
123e0                 |             orgh
123e0                 | 
123e0                 | ' driver state
123e0     FF FF FF FF | drivercog   long    -1  ' COG id of driver
123e4     FF FF FF FF | driverlock  long    -1  ' LOCK id of driver
123e8                 | 
123e8                 | ' delay profile
123e8     07 00 00 00 
123ec     00 CF 7B 05 
123f0     80 D1 F0 08 
123f4     80 4F 47 0C | delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
123f8     80 C4 60 0F 
123fc     80 39 7A 12 
12400     40 2D D9 13 
12404     00 00 00 00 | 	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
12408                 | 
12408                 | ' data to be passed to driver when starting it
12408                 | startupData
12408     00 00 00 00 |     long    0           ' current frequency
1240c     00 00 00 00 |     long    FLAGS       ' optional flags for driver
12410     00 00 00 00 |     long    0           ' reset pin mask on port A for PSRAM (none)
12414     00 00 00 00 |     long    0           ' reset pin mask on port B for PSRAM (none)
12418     28 00 00 00 |     long    DATABUS     ' PSRAM data bus start pin
1241c     28 24 01 00 |     long    deviceData  ' address of devices data structure in HUBRAM
12420     A8 24 01 00 |     long    qosData     ' address of QoS data structure in HUBRAM
12424     C8 24 01 00 |     long    mailboxes   ' address of mailbox structure in HUBRAM
12428                 | 
12428                 | ' data for memory
12428                 | deviceData
12428                 |     ' 16 bank parameters follow (16MB per bank)
12428     00 00 00 00 
      ...             
12460     00 00 00 00 
12464     00 00 00 00 |     long    0[16]                               ' banks 0-15
12468                 |     ' 16 banks of pin parameters follow
12468     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
1246c     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
12470     FF FF FF FF 
      ...             
124a0     FF FF FF FF 
124a4     FF FF FF FF |     long    -1[14]                              ' banks 2-15
124a8                 | 
124a8                 | ' data for COG polling
124a8                 | qosData 
124a8     00 00 FF FF 
124ac     00 00 FF FF 
124b0     00 00 FF FF 
124b4     00 00 FF FF |     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
124b8     00 00 FF FF 
124bc     00 00 FF FF 
124c0     00 00 FF FF 
124c4     00 00 FF FF | 	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
124c8                 |     
124c8                 | ' mailbox storage
124c8                 | 
124c8                 | mailboxes
124c8     00 00 00 00 
      ...             
12520     00 00 00 00 
12524     00 00 00 00 |     long    0[8*3]          ' 3 longs per mailbox per COG
12528                 | 	alignl
12528                 | _psram16drv_spin2_dat_
12528                 |                             orgh
12528     00 00 00 00 
      ...             
12540     00 00 00 00 
12544     00 00 00 00 | scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
12548                 | 
12548                 | driver_start
12548                 |                             org
12548 000             | '..................................................................................................
12548 000             | ' Memory layout for COG RAM once operational:
12548 000             | '
12548 000             | '  COG RAM address      Usage
12548 000             | '  ---------------      ----
12548 000             | '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
12548 000             | '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
12548 000             | '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
12548 000             | '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
12548 000             | '   $100-$197           Mailbox poller, error handlers, and all driver management code
12548 000             | '  ~$198-$1F3           State and register variables
12548 000             | '
12548 000             | ' Also during driver COG startup:
12548 000             | '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
12548 000             | ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
12548 000             | '..................................................................................................
12548 000             |                             
12548 000             | ' Mailbox storage after vector initialization
12548 000             | 
12548 000 FC 01 B0 FD | req0                        call    #init                   'do HW setup/initialization
1254c 001 F0 E3 AB FA | data0                       rdlut   c, b wz                 'read bank info          
12550 002 F0 DF 03 F6 | count0                      mov     a, b                    'set COGRAM address low nibble
12554 003 68 F0 07 A6 | req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
12558 004 0A E2 17 F4 | data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
1255c 005 50 F0 07 16 | count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
12560 006 58 F0 07 46 | req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
12564 007 08 E2 07 F6 | data2                       mov     c, #$8                  'setup vector base to $80
12568 008 F1 DF 0B F8 | count2                      setnib  a, c, #1                'prepare vector base address for bank
1256c 009 00 DE 8F F9 | req3                        altd    a, #0                   'prepare COG destination read address
12570 00a 61 01 A4 FA | data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
12574 00b 0F E2 0F F7 | count3                      incmod  c, #15 wz               'next vector
12578 00c EC FF 9F 5D | req4        if_nz           jmp     #count2                 'repeat
1257c 00d 0F E0 0F F7 | data4                       incmod  b, #15 wz               'next bank
12580 00e C8 FF 9F 5D | count4      if_nz           jmp     #data0                  'repeat
12584 00f 20 F0 07 F6 | req5                        mov     ptra, #$20              'setup base LUT address to clear
12588 010 50 0A DC FC | data5                       rep     #5, #80                 'update next 80 longs      
1258c 011 E2 F1 13 F2 | count5                      cmp     ptra, header wc         'check if LUT address range 
12590 012 E3 F1 93 32 | req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
12594 013 61 01 3C CC | data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
12598 014 61 B1 37 3C | count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
1259c 015 A5 29 00 31 | req7        if_nc           add     $-1, const512           'increment source of LUT write data
125a0 016 FF C0 03 F6 | data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
125a4 017 26 FF 05 06 | count7      _ret_           mov     255, #dolist            'setup list address, return to notify
125a8 018             | 
125a8 018             | ' Mailbox parameter addresses per COG once patched
125a8 018             |                             
125a8 018 04 00 00 00 | cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
125ac 019 10 00 00 00 | cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
125b0 01a 1C 00 00 00 | cog2mboxdata                long    2*12+4                  '...
125b4 01b 28 00 00 00 | cog3mboxdata                long    3*12+4
125b8 01c 34 00 00 00 | cog4mboxdata                long    4*12+4
125bc 01d 40 00 00 00 | cog5mboxdata                long    5*12+4
125c0 01e 4C 00 00 00 | cog6mboxdata                long    6*12+4
125c4 01f 58 00 00 00 | cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
125c8 020             | 
125c8 020             | '..................................................................................................
125c8 020             | ' Per COG request and state setup and service branching
125c8 020             |         
125c8 020             | cog0                 
125c8 020 20 F0 07 F6 |                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
125cc 021 18 F2 03 F6 |                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
125d0 022 D0 C3 03 F6 |                             mov     id, id0                 'get COG0 state
125d4 023 E1 47 3B F9 |                             getword limit, id, #1           'get COG0 burst limit
125d8 024 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
125dc 025 30 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
125e0 026 00 B0 03 F6 |                             mov     addr1, req0             'get mailbox request parameter for COG0
125e4 027 01 B2 03 F6 |                             mov     hubdata, data0          'get COG0 mailbox data parameter
125e8 028 02 B4 03 F6 |                             mov     count, count0           'get COG0 mailbox count parameter
125ec 029 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
125f0 02a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
125f4 02b 33 CA 63 FD |                             execf   request-0               'jump to service
125f8 02c             | cog1                        
125f8 02c 2A F0 07 F6 |                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
125fc 02d 19 F2 03 F6 |                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
12600 02e D1 C3 03 F6 |                             mov     id, id1                 'get COG1 state
12604 02f E1 47 3B F9 |                             getword limit, id, #1           'get COG1 burst limit
12608 030 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
1260c 031 00 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12610 032 03 B0 03 F6 |                             mov     addr1, req1             'get mailbox request parameter for COG1
12614 033 04 B2 03 F6 |                             mov     hubdata, data1          'get COG1 mailbox data parameter
12618 034 05 B4 03 F6 |                             mov     count, count1           'get COG1 mailbox count parameter
1261c 035 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12620 036 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12624 037 33 CA 63 FD |                             execf   request-0               'jump to service
12628 038             | cog2                         
12628 038 34 F0 07 F6 |                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
1262c 039 1A F2 03 F6 |                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
12630 03a D2 C3 03 F6 |                             mov     id, id2                 'get COG2 state
12634 03b E1 47 3B F9 |                             getword limit, id, #1           'get COG2 burst limit
12638 03c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
1263c 03d D0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12640 03e 06 B0 03 F6 |                             mov     addr1, req2             'get mailbox request parameter for COG2
12644 03f 07 B2 03 F6 |                             mov     hubdata, data2          'get COG2 mailbox data parameter
12648 040 08 B4 03 F6 |                             mov     count, count2           'get COG2 mailbox count parameter
1264c 041 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12650 042 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12654 043 33 CA 63 FD |                             execf   request-0               'jump to service
12658 044             | cog3                        
12658 044 3E F0 07 F6 |                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
1265c 045 1B F2 03 F6 |                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
12660 046 D3 C3 03 F6 |                             mov     id, id3                 'get COG3 state
12664 047 E1 47 3B F9 |                             getword limit, id, #1           'get COG3 burst limit
12668 048 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
1266c 049 A0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12670 04a 09 B0 03 F6 |                             mov     addr1, req3             'get mailbox request parameter for COG3
12674 04b 0A B2 03 F6 |                             mov     hubdata, data3          'get COG3 mailbox data parameter
12678 04c 0B B4 03 F6 |                             mov     count, count3           'get COG3 mailbox count parameter
1267c 04d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12680 04e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12684 04f 33 CA 63 FD |                             execf   request-0               'jump to service
12688 050             | cog4                        
12688 050 48 F0 07 F6 |                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
1268c 051 1C F2 03 F6 |                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
12690 052 D4 C3 03 F6 |                             mov     id, id4                 'get COG4 state
12694 053 E1 47 3B F9 |                             getword limit, id, #1           'get COG4 burst limit
12698 054 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
1269c 055 70 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
126a0 056 0C B0 03 F6 |                             mov     addr1, req4             'get mailbox request parameter for COG4
126a4 057 0D B2 03 F6 |                             mov     hubdata, data4          'get COG4 mailbox data parameter
126a8 058 0E B4 03 F6 |                             mov     count, count4           'get COG4 mailbox count parameter
126ac 059 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
126b0 05a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
126b4 05b 33 CA 63 FD |                             execf   request-0               'jump to service
126b8 05c             | cog5                        
126b8 05c 52 F0 07 F6 |                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
126bc 05d 1D F2 03 F6 |                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
126c0 05e D5 C3 03 F6 |                             mov     id, id5                 'get COG5 state
126c4 05f E1 47 3B F9 |                             getword limit, id, #1           'get COG5 burst limit
126c8 060 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
126cc 061 40 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
126d0 062 0F B0 03 F6 |                             mov     addr1, req5             'get mailbox request parameter for COG5
126d4 063 10 B2 03 F6 |                             mov     hubdata, data5          'get COG5 mailbox data parameter
126d8 064 11 B4 03 F6 |                             mov     count, count5           'get COG5 mailbox count parameter
126dc 065 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
126e0 066 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
126e4 067 33 CA 63 FD |                             execf   request-0               'jump to service
126e8 068             | cog6                        
126e8 068 5C F0 07 F6 |                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
126ec 069 1E F2 03 F6 |                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
126f0 06a D6 C3 03 F6 |                             mov     id, id6                 'get COG6 state
126f4 06b E1 47 3B F9 |                             getword limit, id, #1           'get COG6 burst limit
126f8 06c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
126fc 06d 10 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12700 06e 12 B0 03 F6 |                             mov     addr1, req6             'get mailbox request parameter for COG6
12704 06f 13 B2 03 F6 |                             mov     hubdata, data6          'get COG6 mailbox data parameter
12708 070 14 B4 03 F6 |                             mov     count, count6           'get COG6 mailbox count parameter
1270c 071 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12710 072 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12714 073 33 CA 63 FD |                             execf   request-0               'jump to service
12718 074             | cog7                        
12718 074 66 F0 07 F6 |                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
1271c 075 1F F2 03 F6 |                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
12720 076 D7 C3 03 F6 |                             mov     id, id7                 'get COG7 state
12724 077 E1 47 3B F9 |                             getword limit, id, #1           'get COG7 burst limit
12728 078 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
1272c 079 E0 02 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12730 07a 15 B0 03 F6 |                             mov     addr1, req7             'get mailbox request parameter for COG7
12734 07b 16 B2 03 F6 |                             mov     hubdata, data7          'get COG7 mailbox data parameter
12738 07c 17 B4 03 F6 |                             mov     count, count7           'get COG7 mailbox count parameter
1273c 07d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12740 07e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12744 07f 33 CA 63 FD |                             execf   request-0               'jump to service
12748 080             | 
12748 080             |                             fit     128
12748 080             |                             fit     128
12748 080             | pad                         long    0[128-$]                'align init code to $80
12748 080             | 
12748 080             | '..................................................................................................
12748 080             | 
12748 080             | ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
12748 080             | 
12748 080             | init                        
12748 080             |                             ' get driver scratch long address in hub
12748 080 01 DA 63 FD |                             cogid   hubscratch              'get cogid
1274c 081 01 DA 07 F1 |                             add     hubscratch, #1          'increase by 1 from 1-8
12750 082 04 DA 07 FA |                             mul     hubscratch, #4          'multiply by 4 to get 4-32
12754 083 F9 DB C3 F2 |                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
12758 084             |                     
12758 084             |                             ' read in the additional LUT RAM code
12758 084 F9 41 03 F1 |                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
1275c 085 29 9E 67 FD |                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
12760 086 A0 61 00 FB |                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
12764 087             | 
12764 087             |                             ' read the startup parameters
12764 087 28 0E 64 FD |                             setq    #8-1                    'read 8 longs from hub
12768 088 00 41 07 FB |                             rdlong  startupparams, ptra     '.. as the startup parameters 
1276c 089             | 
1276c 089             |                             ' setup some of the config flag dependent state and patch LUTRAM
1276c 089 1C 42 0F F4 |                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
12770 08a             | 
12770 08a F9 71 03 A1 |             if_z            add     expansion, ptrb         'compensate for HUB address
12774 08b 01 00 00 5F 
12778 08c FB 70 07 56 |             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
1277c 08d 1D 42 17 F4 |                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
12780 08e AA 57 43 35 |             if_nc           or      clkconfig, registered   'enable this if so
12784 08f 00 58 07 36 |             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
12788 090             | 
12788 090             |                             ' setup data pin modes and data bus pin group in streamer commands
12788 090 38 48 07 F5 |                             and     datapins, #%111000      'compute base pin
1278c 091 01 00 00 FF 
12790 092 C0 49 47 F5 |                             or      datapins, ##(15<<6)     'configure 16 pins total
12794 093 A4 DF 03 F6 |                             mov     a, datapins             'get data pin base
12798 094 A4 55 03 FC |                             wrpin   registered, datapins    'prepare data pins for address phase transfer
1279c 095 03 DE 47 F0 |                             shr     a, #3                   'determine data pin group
127a0 096 07 DE 07 F5 |                             and     a, #7                   'ignore the unwanted bits
127a4 097 08 DE 47 F5 |                             or      a, #8
127a8 098 EF 2F 2B F8 |                             setnib  ximm8lut, a, #5         'setup bus group in streamer
127ac 099 EF 31 2B F8 |                             setnib  xrecvlo8, a, #5
127b0 09a EF 35 2B F8 |                             setnib  xrecvdata, a, #5
127b4 09b EF 37 2B F8 |                             setnib  xsenddata, a, #5
127b8 09c EF 39 2B F8 |                             setnib  xsendimm, a, #5
127bc 09d 01 DE 07 F1 |                             add     a, #1
127c0 09e EF 33 2B F8 |                             setnib  xrecvhi8, a, #5         ' increase port by one
127c4 09f             |  
127c4 09f             |                             ' setup device control pin states
127c4 09f 29 3E 64 FD |                             setq2   #32-1                   'read 32 longs to LUTRAM
127c8 0a0 A5 01 00 FB |                             rdlong  $000, devicelist        'read bank/pin data for all banks    
127cc 0a1 01 00 00 FF 
127d0 0a2 00 4A 07 F6 |                             mov     const512, ##512         'prepare constant
127d4 0a3             | 
127d4 0a3 10 F2 07 F6 |                             mov     ptrb, #16               'point to bank pin config data
127d8 0a4 10 14 DC FC |                             rep     @pinloop, #16           'iterate through 16 banks
127dc 0a5 E1 CF B7 FA |                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
127e0 0a6 AF CF 03 F5 |                             and     pinconfig, pinmask      'save us from invalid bits in args
127e4 0a7 E7 53 E3 38 |             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
127e8 0a8 A9 01 08 3C |             if_nc           wrpin   #0, cspin               'clear smart pin mode
127ec 0a9 59 52 63 3D |             if_nc           drvh    cspin                   'setup pins for all banks
127f0 0aa E7 51 EB 38 |             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
127f4 0ab 50 50 63 3D |             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
127f8 0ac A8 57 03 3C |             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
127fc 0ad A8 03 18 3C |             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
12800 0ae 58 50 63 3D |             if_nc           drvl    clkpin                  'set clk state low
12804 0af             | pinloop
12804 0af             |                             ' generate minimum CE high time before access
12804 0af A1 07 00 FF 
12808 0b0 40 40 17 FD |                             qdiv    frequency, ##1000000    'convert from Hz to MHz
1280c 0b1 18 E2 63 FD |                             getqx   c                       'get P2 clocks per microsecond
12810 0b2 96 DE 07 F6 |                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
12814 0b3 F1 DF 03 FA |                             mul     a, c                    'convert microseconds to clocks
12818 0b4 1F DE 63 FD |                             waitx   a                       'delay
1281c 0b5 E8 05 B0 FD |                             call    #hwinit                 'setup HW into QSPI mode
12820 0b6             | 
12820 0b6             |                             ' setup the COG mailboxes and addresses 
12820 0b6 08 04 DC FC |                             rep     #2, #8                  'setup loop to patch mailbox addresses
12824 0b7 38 70 A5 F9 |                             alti    $+1, #%111_000          'increase D field
12828 0b8 A7 31 00 F1 |                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
1282c 0b9             | 
1282c 0b9 28 2E 64 FD |                             setq    #24-1
12830 0ba A7 01 68 FC |                             wrlong  #0, mbox                'clear out mailboxes ????
12834 0bb             | 
12834 0bb             |                             ' setup the polling loop for active COGs 
12834 0bb 01 C2 63 FD |                             cogid   id
12838 0bc D0 C3 97 F9 |                             alts    id, #id0                'determine id register of control COG
1283c 0bd 00 90 B6 F9 |                             setd    patchid, #0             'patch into destination address
12840 0be 2A F0 63 FD |                             push    ptra                    'save ptra before we lose it
12844 0bf 0A F0 07 F6 |                             mov     ptra, #10
12848 0c0 E1 F1 03 FA |                             mul     ptra, id
1284c 0c1 20 F0 07 F1 |                             add     ptra, #$20              'prep ptra for reloadcogs
12850 0c2 B0 C3 97 F9 |                             alts    id, #cog0_handler       'add to handler base
12854 0c3 00 48 BE F9 |                             sets    ctrlpollinst, #0-0      'patch into jump instruction
12858 0c4 03 C2 07 FA |                             mul     id, #3
1285c 0c5 E1 49 B2 F9 |                             setd    ctrlpollinst, id
12860 0c6 09 C3 A7 FA |                             rdlut   id, ptra[9]             'save original value
12864 0c7 09 C1 37 FC |                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
12868 0c8 D8 01 B0 FD |                             call    #reloadcogs
1286c 0c9 09 C3 37 FC |                             wrlut   id, ptra[9]             'restore original value
12870 0ca 2B F0 63 FD |                             pop     ptra                    'restore original ptra
12874 0cb             |                             ' move LUT control vectors into temporary location to avoid clobbering them later
12874 0cb D8 E5 B7 F9 |                             setd    d, #addr1
12878 0cc 60 E4 BF F9 |                             sets    d, #(ctrl_vect & $1ff)
1287c 0cd 08 04 DC FC |                             rep     #2, #8
12880 0ce 3F E4 A7 F9 |                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
12884 0cf 60 B0 A7 FA |                             rdlut   addr1-0, #$60-0
12888 0d0             | 
12888 0d0             |                             'setup control COG service handling, we need to patch 5 instructions
12888 0d0             |                             'one existing instruction is moved earlier and four instructions get replaced
12888 0d0 01 C2 63 FD |                             cogid   id
1288c 0d1 0C DE 07 F6 |                             mov     a, #(cog1-cog0)         'get code separation of handlers
12890 0d2 E1 DF 03 FA |                             mul     a, id                   'scale ID by separation
12894 0d3 24 DE 07 F1 |                             add     a, #cog0+4              'add to base for COG0 and offset
12898 0d4 EF E5 B3 F9 |                             setd    d, a                    'set this as the destination
1289c 0d5 02 DE 07 F1 |                             add     a, #2                   'increment COG address
128a0 0d6 EF E5 BB F9 |                             sets    d, a                    'set this as the source
128a4 0d7 3C E4 A7 F9 |                             alti    d, #%111_100             
128a8 0d8 00 00 00 F6 |                             mov     0-0, 0-0                'move instruction
128ac 0d9 EE E4 BF F9 |                             sets    d, #controlpatch        'set source of patched instructions
128b0 0da 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
128b4 0db 3F E4 A7 F9 |                             alti    d, #%111_111
128b8 0dc 00 00 00 F6 |                             mov     0-0, 0-0
128bc 0dd A5 E5 03 F1 |                             add     d, const512             'skip two instructions
128c0 0de A5 E5 03 F1 |                             add     d, const512
128c4 0df 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
128c8 0e0 3F E4 A7 F9 |                             alti    d, #%111_111
128cc 0e1 00 00 00 F6 |                             mov     0-0, 0-0
128d0 0e2             |                             
128d0 0e2             |                             ' setup register values for control vector loop setup after we return
128d0 0e2 E1 C5 03 F6 |                             mov     header, id              'get cog ID
128d4 0e3 0A C4 07 FA |                             mul     header, #10             'multiply by size of state memory per COG
128d8 0e4 20 C4 07 F1 |                             add     header, #$20            'add to COG state base address in LUT
128dc 0e5 E2 C7 03 F6 |                             mov     trailer, header         'determine start/end LUT address
128e0 0e6 09 C6 07 F1 |                             add     trailer, #9             '...for control region
128e4 0e7 E0 C3 43 F5 |                             or      id, initctrl            'set id field for control COG
128e8 0e8 D0 C3 8F F9 |                             altd    id, #id0
128ec 0e9 E1 01 00 F6 |                             mov     0-0, id                 'setup id field for notification
128f0 0ea F8 F3 03 F6 |                             mov     ptrb, ptra              'get startup parameter address
128f4 0eb 04 F2 07 F1 |                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
128f8 0ec 00 E0 07 F6 |                             mov     b, #0                   'prepare b for upcoming loop
128fc 0ed 2A 14 66 0D |                 _ret_       push    #notify                 'continue init in mailbox area
12900 0ee             |  
12900 0ee D8 CB 7B F8 | controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
12904 0ef 07 CA 07 F5 |                             and     request, #7
12908 0f0 F8 CB 03 F1 |                             add     request, ptra           'add request vector offset
1290c 0f1 E5 CB A3 FA |                             rdlut   request, request        'lookup jump vector service table 
12910 0f2             | 
12910 0f2             |                             fit     $100                    'ensure all init code fits this space
12910 0f2             |                             fit     $100                    'ensure all init code fits this space
12910 0f2             | 
12910 0f2 00 00 00 00 
      ...             
12940 0fe 00 00 00 00 
12944 0ff 00 00 00 00 |                             long    0[$100-$]               'pad more if required until table ends
12948 100             | 
12948 100             | '..................................................................................................
12948 100             | ' Error result handling and COG notification of request completion
12948 100             | 
12948 100 04 04 4C FB | unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
1294c 101 03 02 4C FB | invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
12950 102 02 06 4C FB | invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
12954 103 01 08 4C FB | alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
12958 104 05 EC 07 F6 | busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
1295c 105 D0 C3 8F F9 | err                         altd    id, #id0                'adjust for the running COG
12960 106 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
12964 107 08 01 3C FC |                             wrlut   #0, ptra[8]             'cancel any resume state
12968 108 32 04 64 FD |                             skipf   #%10                    'dont notify with success code 0 below
1296c 109 BF ED 67 FC |                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
12970 10a BF 01 6C FC | notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
12974 10b 0B C2 0F F4 |                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
12978 10c E1 DF C3 F9 |                             decod   a, id                   'convert COG ID to bitmask
1297c 10d 3F DE 63 AD |             if_z            cogatn  a                       'notify COG via ATN
12980 10e             | ' Poller re-starts here after a COG is serviced
12980 10e 0F C2 0F F4 | poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
12984 10f E6 5F 03 57 |             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
12988 110 AF 45 CB F9 |                             bmask   mask, rrcounter         'generate a RR skip mask from the count
1298c 111             | ' Main dynamic polling loop repeats until a request arrives
1298c 111 00 00 DC FC | polling_loop                rep     #0-0, #0                'repeat until we get a request for something
12990 112 28 2E 64 FD |                             setq    #24-1                   'read 24 longs
12994 113 A7 01 00 FB |                             rdlong  req0, mbox              'get all mailbox requests and data longs
12998 114             | 
12998 114 B0 01 B0 FB | polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
1299c 115 32 44 63 FD |                             skipf   mask                    ']after all priority COG handlers if present
129a0 116 B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
129a4 117 B2 0D B0 FB |                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
129a8 118 B3 13 B0 FB |                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
129ac 119 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
129b0 11a B5 1F B0 FB |                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
129b4 11b B6 25 B0 FB |                             tjs     req6, cog6_handler      ']based on the active COGs being polled
129b8 11c B7 2B B0 FB |                             tjs     req7, cog7_handler      ']and whether priority or round robin.
129bc 11d B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
129c0 11e B2 0D B0 FB |                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
129c4 11f B3 13 B0 FB |                             tjs     req3, cog3_handler      ']have changed.
129c8 120 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
129cc 121 B5 1F B0 FB |                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
129d0 122 B6 25 B0 FB |                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
129d4 123 B7 2B B0 FB | pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
129d8 124             | 
129d8 124 B0 01 B0 FB | ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
129dc 125 32 44 63 FD | skipfinst                   skipf   mask                    'instruction template for skipf
129e0 126             |  
129e0 126             | '..................................................................................................
129e0 126             | ' List handler                               
129e0 126             | 
129e0 126 01 B0 A7 FB | dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
129e4 127 33 C0 63 FD |                             execf   burstwrite              'otherwise do a burst write to this bank
129e8 128 28 0E 64 FD | real_list                   setq    #8-1                    'read 8 longs (largest request size)
129ec 129 D9 B1 03 FB |                             rdlong  addr1, hubdata          '..to update the request state
129f0 12a D7 B1 BF FB |                             tjns    addr1, #invalidlist     'error if request list item not valid
129f4 12b D0 C3 8F F9 |                             altd    id, #id0                'get COG state
129f8 12c 09 00 3C F4 |                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
129fc 12d 09 C2 27 F4 |                             bith    id, #LIST_BIT           'retain fact that we are in a list
12a00 12e 44 FF 9F AD |             if_z            jmp     #unsupported            'no list recursion is allowed!
12a04 12f D8 CB FB F8 |                             getbyte request, addr1, #3      'get upper byte of this request
12a08 130 00 CA 8F F9 | service_request             altd    request, #0             'get request address in COG RAM
12a0c 131 33 00 60 FD |                             execf   0-0                     'process the request 
12a10 132             | 
12a10 132             | '..................................................................................................
12a10 132             | ' Restoring per COG state and resuming where we left off
12a10 132             | 
12a10 132 00 B1 A7 FA | restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
12a14 133 01 B3 A7 FA |                             rdlut   hubdata, ptra[1]
12a18 134 02 B5 A7 FA |                             rdlut   count, ptra[2]
12a1c 135 03 B7 B7 FA |                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
12a20 136 D8 CB FB F8 |                             getbyte request, addr1, #3
12a24 137 33 D2 63 3D |             if_nc           execf   resume                  'if not extended then resume immediately
12a28 138 04 B9 A7 FA |                             rdlut   total, ptra[4]          'we need to read the extended parameters
12a2c 139 05 BB A7 FA |                             rdlut   offset1, ptra[5]
12a30 13a 06 BD A7 FA |                             rdlut   offset2, ptra[6]
12a34 13b 07 BF A7 FA |                             rdlut   link, ptra[7]
12a38 13c 09 D5 A7 FA |                             rdlut   orighubsize, ptra[9]
12a3c 13d 33 D2 63 FD |                             execf   resume                  'then resume what we were doing last time
12a40 13e             |                    
12a40 13e             | '..................................................................................................
12a40 13e             | ' Re-configuration of QoS settings and custom polling loop sequence generator
12a40 13e             | 
12a40 13e 2A 14 66 FD | reconfig                    push    #notify                 'setup return addr, then reload 
12a44 13f 28 0E 64 FD | reloadcogs                  setq    #8-1                    'reload all per COG QoS params
12a48 140 A6 B1 03 FB |                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
12a4c 141 D0 DF B7 F9 |                             setd    a, #id0
12a50 142 D8 DF BF F9 |                             sets    a, #addr1
12a54 143 FE FF FF FF 
12a58 144 28 00 66 FD |                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
12a5c 145 08 04 DC FC |                             rep     #2, #8                  'repeat for 8 COGs
12a60 146 3F DE A7 F9 |                             alti    a, #%111_111 
12a64 147 00 00 F0 F9 |                             muxq    0-0, 0-0
12a68 148 09 01 A4 FA | patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
12a6c 149 01 E2 63 FD |                             cogid   c
12a70 14a F1 41 C3 F9 |                             decod   excludedcogs, c         'exclude driver cog initially
12a74 14b 08 DE 07 F6 |                             mov     a, #$8                  'a iterates through prio levels 8=lowest
12a78 14c 01 EC 67 F6 |                             neg     pa, #1                  'start with all ones
12a7c 14d 07 E2 07 F6 | fillprio                    mov     c, #7                   'c iterates through cogs
12a80 14e D0 E3 97 F9 | prioloop                    alts    c, #id0
12a84 14f 00 E0 03 F6 |                             mov     b, 0-0
12a88 150 F0 E5 3B F9 |                             getword d, b, #1                'get burst field
12a8c 151 F2 E5 CB F7 |                             test    d wz                    'if burst=0 
12a90 152 F1 41 23 A4 |             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
12a94 153 0C 00 90 AD |             if_z            jmp     #excluded               
12a98 154 F0 E5 5B F8 |                             getnib  d, b, #3                'get RR/PRI flag & priority
12a9c 155 EF E5 0B F2 |                             cmp     d, a wz                 'compare against current priority level
12aa0 156 F1 ED 83 A8 |             if_z            rolnib  pa, c, #0               'if matches include COG at this level
12aa4 157 F6 E3 7F FB | excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
12aa8 158 0F DE 0F F7 |                             incmod  a, #15 wz               'next level
12aac 159 CC FF 9F 5D |             if_nz           jmp     #fillprio 
12ab0 15a             | 
12ab0 15a             | 'determine priority cogs and build instructions for the polling sequence
12ab0 15a 00 EE 07 F6 |                             mov     pb, #0                  'clear out set of priority COGs
12ab4 15b 03 DE 07 F6 |                             mov     a, #3                   'start with no COGs being polled + 3 instructions
12ab8 15c 14 E5 B7 F9 |                             setd    d, #polling_code        'initialize COGRAM write position
12abc 15d             | 
12abc 15d 08 18 DC FC |                             rep     @endprioloop, #8        'test all 8 priority slots
12ac0 15e 03 EC 17 F4 |                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
12ac4 15f F6 E3 43 F8 |                             getnib  c, pa, #0               'get cogid ID at this priority level
12ac8 160 F1 EF 0B 34 |             if_nc           testb   pb, c wz                'check if already exists as priority COG
12acc 161 F1 EF 23 14 |             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
12ad0 162 01 DE 07 11 |             if_nc_and_nz    add     a, #1                   'add another COG to poll 
12ad4 163 B0 E3 97 19 |             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
12ad8 164 00 46 BE 19 |             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
12adc 165 03 E2 07 1A |             if_nc_and_nz    mul     c, #3
12ae0 166 F1 47 B2 19 |             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
12ae4 167 38 E4 A7 19 |             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
12ae8 168 23 01 00 16 |             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
12aec 169 04 EC 07 F0 |                             ror     pa, #4                  'advance to next priority
12af0 16a             | endprioloop
12af0 16a FF EE 67 F5 |                             xor     pb, #$ff                'invert to find all the non-priority COGs
12af4 16b A0 EF 23 F5 |                             andn    pb, excludedcogs        'and remove any other excluded COGs
12af8 16c F7 CD AB F7 |                             ones    rrlimit, pb wz          'count the number of RR COGs
12afc 16d E6 DF 03 F1 |                             add     a, rrlimit              'account for this number of RR COGs to poll
12b00 16e 01 CC 87 F1 |                             sub     rrlimit, #1             'setup last RR count value for incmod
12b04 16f 38 E4 A7 F9 |                             alti    d, #%111_000            'generate the control polling instruction
12b08 170 24 01 00 F6 |                             mov     0-0, ctrlpollinst       'write the instruction
12b0c 171 38 E4 A7 59 |             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
12b10 172 25 01 00 56 |             if_nz           mov     0-0, skipfinst          'add the skipf instruction
12b14 173 02 DE 07 51 |             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
12b18 174 EF 23 B2 F9 |                             setd    polling_loop, a         'save it as the repeat count
12b1c 175 2D 00 64 AD |             if_z            ret                             'we are done now, if no round robin COGs
12b20 176             | 
12b20 176             | ' populate the round robin COG polling instructions
12b20 176 02 5E 07 F6 |                             mov     rrcounter, #2           'fill the RR poll instruction list twice
12b24 177 F7 E1 03 F6 | rrloop                      mov     b, pb                   'get the set of RR COGs
12b28 178 00 E2 07 F6 |                             mov     c, #0                   'start at COG ID = 0
12b2c 179 00 DE 07 F6 |                             mov     a, #0                   'req mailbox COGRAM address for COG 0
12b30 17a 01 E0 5F F0 | nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
12b34 17b EF 47 B2 C9 |             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
12b38 17c B0 E3 97 C9 |             if_c            alts    c, #cog0_handler        'determine jump address
12b3c 17d 00 46 BE C9 |             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
12b40 17e 38 E4 A7 C9 |             if_c            alti    d, #%111_000            'generate new COG RAM write address
12b44 17f 23 01 00 C6 |             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
12b48 180 01 E2 07 F1 |                             add     c, #1                   'increment the COG ID
12b4c 181 03 DE 07 F1 |                             add     a, #3                   'increase the request address
12b50 182 DC FF 9F 5D |             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
12b54 183 F3 5F 6F 0B |             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
12b58 184             | '..................................................................................................
12b58 184             | ' Code to get/set driver settings per bank or to dump COG/LUT state
12b58 184             | 
12b58 184             | set_latency                                                 '            (a) set latency
12b58 184             | get_latency                                                 '            (b) get latency
12b58 184             | set_burst                                                   '            (c) set burst size of bank
12b58 184             | get_burst                                                   '            (d) get burst size of bank
12b58 184             |                                                             '            (e) dump state
12b58 184 D8 E1 73 F8 |                             getnib  b, addr1, #6            ' a b c d    get bank address
12b5c 185 28 FE 67 FD | dump_state                  setq    #511                    ' | | | | e  prepare burst write
12b60 186 D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
12b64 187             |                                                             ' | | | | e  account for following AUGS
12b64 187 04 00 00 FF 
12b68 188 00 B2 07 F1 |                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
12b6c 189 29 FE 67 FD |                             setq2   #511                    ' | | | | e  prepare burst write
12b70 18a D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
12b74 18b 10 E0 07 F1 |                             add     b, #16                  ' a b | | |  point to latency params
12b78 18c F0 DF A3 FA |                             rdlut   a, b                    ' a b c d |  read data for bank
12b7c 18d D9 DF DB F8 |                             setbyte a, hubdata, #3          ' a | | | |  patch latency
12b80 18e D9 DF 03 F6 |                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
12b84 18f F0 DF 33 FC |                             wrlut   a, b                    ' a | c | |  if setting, save bank data
12b88 190 EF DF FB F8 |                             getbyte a, a, #3                ' | b | | |  extract latency field only
12b8c 191 80 DF 67 FC |                             wrlong  a, ptrb                 ' | b | d |  write result          
12b90 192 DC FD 9F FD |                             jmp     #notify                 ' a b c d e  return success
12b94 193             | 
12b94 193             | '..................................................................................................
12b94 193             | ' Misc EXECF code
12b94 193             | 
12b94 193 33 72 63 FD | start_read_exec             execf   newburstr
12b98 194 33 7C 63 FD | start_write_exec            execf   resumewrites
12b9c 195 33 78 63 FD | continue_read_exec          execf   lockedreads
12ba0 196 33 7A 63 FD | continue_write_exec         execf   lockedwrites
12ba4 197             | 
12ba4 197             | '..................................................................................................
12ba4 197             | ' Variables
12ba4 197             | 
12ba4 197 08 00 CF 20 | ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
12ba8 198 01 00 C6 E0 | xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
12bac 199 01 00 C6 E0 | xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
12bb0 19a 00 00 C0 F0 | xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
12bb4 19b 00 00 C0 B0 | xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
12bb8 19c 02 00 C0 70 | xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
12bbc 19d             | 
12bbc 19d 00 00 00 80 | xfreq1          long    $80000000
12bc0 19e 00 00 00 40 | xfreq2          long    $40000000
12bc4 19f 03 00 00 00 | delay           long    3
12bc8 1a0             | 
12bc8 1a0             | lutcodeaddr                 
12bc8 1a0             | startupparams
12bc8 1a0             | excludedcogs                                    'careful: shared register use!
12bc8 1a0 CC 07 00 00 | frequency       long    lut_code - driver_start 'determine offset of LUT code from base
12bcc 1a1 00 00 00 00 | flags           long    0
12bd0 1a2             | mask                                            'careful: shared register use!
12bd0 1a2 00 00 00 00 | resetmaskA      long    0
12bd4 1a3             | limit                                           'careful: shared register use!
12bd4 1a3 00 00 00 00 | resetmaskB      long    0
12bd8 1a4 00 00 00 00 | datapins        long    0
12bdc 1a5             | const512                                        'careful: shared register use!
12bdc 1a5 00 00 00 00 | devicelist      long    0
12be0 1a6 00 00 00 00 | coglist         long    0
12be4 1a7 00 00 00 00 | mbox            long    0 
12be8 1a8             | 
12be8 1a8             | clkpin                                          'shared with code patched during init
12be8 1a8 A8 03 18 FC | clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
12bec 1a9             | cspin                                           'shared with code patched during init
12bec 1a9 1D 3A 63 FD | speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
12bf0 1aa 00 00 01 00 | registered      long    %100_000_000_00_00000_0 'config pin for clocked input
12bf4 1ab 4A 00 00 00 | clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
12bf8 1ac 01 00 00 00 | clkdelay        long    1
12bfc 1ad 00 00 00 00 | regdatabus      long    0
12c00 1ae             | 
12c00 1ae 10 00 00 00 | deviceaddr      long    $10
12c04 1af             | rrcounter
12c04 1af 7F 7F 3F FF | pinmask         long    $ff3f7f7f
12c08 1b0             | 
12c08 1b0             | ' jump addresses for the per COG handlers
12c08 1b0 20 00 00 00 | cog0_handler    long    cog0
12c0c 1b1 2C 00 00 00 | cog1_handler    long    cog1
12c10 1b2 38 00 00 00 | cog2_handler    long    cog2
12c14 1b3 44 00 00 00 | cog3_handler    long    cog3
12c18 1b4 50 00 00 00 | cog4_handler    long    cog4
12c1c 1b5 5C 00 00 00 | cog5_handler    long    cog5
12c20 1b6 68 00 00 00 | cog6_handler    long    cog6
12c24 1b7 74 00 00 00 | cog7_handler    long    cog7
12c28 1b8 0C 0F 00 00 | expansion       long    gfxexpansion - driver_start
12c2c 1b9             | 
12c2c 1b9             | ' EXECF sequences
12c2c 1b9 70 7A 80 22 | newburstr       long    (%0010001010000000011110 << 10) + r_burst
12c30 1ba 48 9B EF 00 | lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
12c34 1bb 41 F3 05 74 | restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
12c38 1bc 80 22 3F 00 | lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
12c3c 1bd 4B F3 E0 0F | lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
12c40 1be 4B 03 E0 0F | resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
12c44 1bf 76 02 8A 84 | resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
12c48 1c0             | 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
12c48 1c0             | 
12c48 1c0             | 
12c48 1c0             | ' SKIPF sequences
12c48 1c0             | skiptable
12c48 1c0 7E 30 0C 00 |                 long    %11000011000001111110  ' read modify write byte
12c4c 1c1 0E 37 03 00 |                 long    %110011011100001110    ' read modify write word
12c50 1c2 00 00 00 00 |                 long    0                      ' read modify write long
12c54 1c3 7E 00 00 00 |                 long    %1111110               ' single byte read
12c58 1c4 8E 07 00 00 |                 long    %11110001110           ' single word read
12c5c 1c5 00 00 00 00 | pattern2        long    0
12c60 1c6 00 00 00 00 | pattern3        long    0
12c64 1c7 77 02 00 00 | singlelong      long    %1001110111  
12c68 1c8 FD 10 80 6F | skipcase_a      long    %01101111100000000001000011111101
12c6c 1c9 10 18 50 00 | skipcase_b      long    %00000000010100000001100000010000
12c70 1ca 11 3E 60 00 | skipcase_c      long    %00000000011000000011111000010001
12c74 1cb 02 0F 00 00 | skipseq_write   long    %00000000000000000000111100000010
12c78 1cc             | 
12c78 1cc             | ' LUT RAM address values
12c78 1cc FF 02 00 00 | complete_rw     long    complete_rw_lut
12c7c 1cd DD 02 00 00 | continue_read   long    continue_read_lut
12c80 1ce DB 02 00 00 | continue_write  long    continue_write_lut
12c84 1cf F6 02 00 00 | noread          long    noread_lut
12c88 1d0             | 
12c88 1d0 00 00 00 00 | id0             long    0
12c8c 1d1 01 00 00 00 | id1             long    1
12c90 1d2 02 00 00 00 | id2             long    2
12c94 1d3 03 00 00 00 | id3             long    3
12c98 1d4 04 00 00 00 | id4             long    4
12c9c 1d5 05 00 00 00 | id5             long    5
12ca0 1d6 06 00 00 00 | id6             long    6
12ca4 1d7 07 00 00 00 | id7             long    7
12ca8 1d8             | 
12ca8 1d8             | 'These next 10 request registers below are also temporarily reused during init 
12ca8 1d8             | 'and COG updates and need to follow immediately after id0-id7
12ca8 1d8 00 00 00 00 | addr1           long    0
12cac 1d9 00 00 00 00 | hubdata         long    0
12cb0 1da 00 00 00 00 | count           long    0
12cb4 1db 00 00 00 00 | addr2           long    0
12cb8 1dc 00 00 00 00 | total           long    0
12cbc 1dd 00 00 00 00 | offset1         long    0
12cc0 1de 00 00 00 00 | offset2         long    0
12cc4 1df 00 00 00 00 | link            long    0
12cc8 1e0             | 
12cc8 1e0             | burstwrite                                      'note shared register use during init
12cc8 1e0 00 10 F0 FE | initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
12ccc 1e1 00 00 00 00 | id              long    0
12cd0 1e2             | 
12cd0 1e2 00 00 00 00 | header          long    0
12cd4 1e3 00 00 00 00 | trailer         long    0
12cd8 1e4 00 00 00 00 | cmdaddr         long    0
12cdc 1e5 00 00 00 00 | request         long    0
12ce0 1e6 00 00 00 00 | rrlimit         long    0
12ce4 1e7 00 00 00 00 | pinconfig       long    0
12ce8 1e8 00 00 00 00 | clks            long    0
12cec 1e9 00 00 00 00 | resume          long    0
12cf0 1ea 00 00 00 00 | orighubsize     long    0
12cf4 1eb 00 00 00 00 | wrclks          long    0
12cf8 1ec             | 
12cf8 1ec 00 00 00 00 | pattern         long    0
12cfc 1ed 00 00 00 00 | hubscratch      long    0
12d00 1ee 00 10 00 00 | val4k           long    4096
12d04 1ef             | 
12d04 1ef             | ' temporary general purpose regs
12d04 1ef 00 00 00 00 | a               long    0
12d08 1f0 00 00 00 00 | b               long    0
12d0c 1f1 00 00 00 00 | c               long    0
12d10 1f2 00 00 00 00 | d               long    0
12d14 1f3             | 
12d14 1f3             |                 fit     502
12d14 1f3             |                 fit     502
12d14 1f3             | 
12d14 1f3             | '..................................................................................................
12d14 1f3             | 
12d14 1f3             |             orgh
12d14                 | 
12d14                 | lut_code
12d14                 | 'HW init code up to 80 longs
12d14                 | 
12d14                 | '..................................................................................................
12d14                 | ' Memory layout for LUT RAM once operational:
12d14                 | '
12d14                 | '  LUT RAM address      Usage
12d14                 | '  ---------------      ----
12d14                 | '    $200-$20F          Bank parameters: burst + type + size per bank (16)
12d14                 | '    $210-$21F          Pin parameters : latency + control pins per bank (16)
12d14                 | '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
12d14                 | '    $270-$3FF          Main PSRAM access code in LUTRAM 
12d14                 | '
12d14                 | ' Also during driver COG startup:
12d14                 | ' $230-$24F is used for HW init setup
12d14                 | ' $250-$26F is used as temporary vector storage 
12d14                 | '..................................................................................................
12d14                 | 
12d14                 |                 org $230    
12d14 230             | 
12d14 230             | ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
12d14 230 1D 3C 63 FD | hwinit                      setxfrq xfreq2
12d18 231 24 16 60 FD |                             pollxfi
12d1c 232 FF AA 2A FF 
12d20 233 FF ED 07 F6 |                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
12d24 234 28 00 B0 FD |                             call    #sendqspi
12d28 235 07 F8 07 FF 
12d2c 236 F0 ED 07 F6 |                             mov     pa, ##$0FF00FF0         '$66 - reset enable
12d30 237 28 00 B0 FD |                             call    #sendspi
12d34 238 F8 07 78 FF 
12d38 239 0F EC 07 F6 |                             mov     pa, ##$F00FF00F         '$99 - reset
12d3c 23a 1C 00 B0 FD |                             call    #sendspi
12d40 23b 7F 78 78 FF 
12d44 23c 00 ED 07 F6 |                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
12d48 23d 10 00 B0 FD |                             call    #sendspi 
12d4c 23e 2D 00 64 FD |                             ret
12d50 23f             | 
12d50 23f 04 D0 07 F6 | sendqspi                    mov     clks,#4
12d54 240 32 0C 64 FD |                             skipf   #%110
12d58 241 9C EF 03 F6 |                             mov     pb, xsendimm
12d5c 242             | 
12d5c 242 10 D0 07 F6 | sendspi                     mov     clks, #16
12d60 243 97 EF 03 F6 |                             mov     pb, ximm8lut
12d64 244 58 52 63 FD |                             drvl    cspin                   'active low chip select
12d68 245 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
12d6c 246 F6 EF A3 FC |                             xinit   pb, pa                  'send 32 bit immediate data
12d70 247 A8 D1 23 FC |                             wypin   clks, clkpin            'start memory clock output 
12d74 248 24 36 60 FD |                             waitxfi                         'wait for the completion
12d78 249 50 48 63 FD |                             fltl    datapins                'float data bus
12d7c 24a 59 52 63 FD |                             drvh    cspin                   'raise chip select
12d80 24b 1F 90 65 0D |             _ret_           waitx   #200                    'delay before return to ensure CS delay
12d84 24c             | 
12d84 24c 00 00 00 00 
12d88 24d 00 00 00 00 
12d8c 24e 00 00 00 00 
12d90 24f 00 00 00 00 |                 long    0[$270-32-$]
12d94 250             |     
12d94 250             |                 fit     $270-32  ' keep room for 32 vector longs
12d94 250             |                 fit     $270-32  ' keep room for 32 vector longs
12d94 250             | ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
12d94 250             | rw_vect ' PSRAM jump vectors
12d94 250 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
12d98 251 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
12d9c 252 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
12da0 253 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
12da4 254 41 E3 00 74 |                 long    (%0111010000000000111000 << 10) + w_single
12da8 255 41 93 00 74 |                 long    (%0111010000000000100100 << 10) + w_single
12dac 256 41 73 00 74 |                 long    (%0111010000000000011100 << 10) + w_single
12db0 257 47 1B 00 FE |                 long    (%1111111000000000000110 << 10) + w_burst
12db4 258             | ro_vect ' R/O PSRAM jump vectors
12db4 258 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
12db8 259 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
12dbc 25a 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
12dc0 25b 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
12dc4 25c 00 01 00 00 |                 long    unsupported
12dc8 25d 00 01 00 00 |                 long    unsupported
12dcc 25e 00 01 00 00 |                 long    unsupported
12dd0 25f 00 01 00 00 |                 long    unsupported
12dd4 260             | ctrl_vect ' Control jump vectors
12dd4 260 84 F9 39 00 |                 long    (%0000000000111001111110 << 10) + get_latency
12dd8 261 00 01 00 00 |                 long    unsupported
12ddc 262 84 F9 7B 00 |                 long    (%0000000001111011111110 << 10) + get_burst
12de0 263 85 01 7F 00 |                 long    (%0000000001111111000000 << 10) + dump_state
12de4 264 84 F9 D1 00 |                 long    (%0000000011010001111110 << 10) + set_latency
12de8 265 00 01 00 00 |                 long    unsupported
12dec 266 84 F9 CB 00 |                 long    (%0000000011001011111110 << 10) + set_burst
12df0 267 3E 01 00 00 |                 long    reconfig 
12df4 268             | no_vect ' Invalid bank jump vectors
12df4 268 01 01 00 00 |                 long    invalidbank
12df8 269 01 01 00 00 |                 long    invalidbank
12dfc 26a 01 01 00 00 |                 long    invalidbank
12e00 26b 01 01 00 00 |                 long    invalidbank
12e04 26c 01 01 00 00 |                 long    invalidbank
12e08 26d 01 01 00 00 |                 long    invalidbank
12e0c 26e 01 01 00 00 |                 long    invalidbank
12e10 26f 01 01 00 00 |                 long    invalidbank
12e14 270             | 
12e14 270             |                 fit     $270
12e14 270             |                 fit     $270
12e14 270             | '..................................................................................................
12e14 270             | ' PSRAM READS
12e14 270             |                                                             ' a b c d e f
12e14 270             |                                                             ' B W L B R L  (a) byte read
12e14 270             |                                                             ' Y O O U E O  (b) word read
12e14 270             |                                                             ' T R N R S C  (c) long read
12e14 270             |                                                             ' E D G S U K  (d) new burst read
12e14 270             |                                                             '       T M E  (e) resumed sub-burst
12e14 270             |                                                             '         E D  (f) locked sub-burst
12e14 270             | 
12e14 270             | 
12e14 270 DA D5 03 F6 | r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
12e18 271 DA B5 CB F7 | r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
12e1c 272 36 D9 07 F6 |                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
12e20 273 20 D9 27 A5 |             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
12e24 274 02 34 27 F9 |                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
12e28 275 80 B4 97 FB |                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
12e2c 276 E5 E1 43 F8 | r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
12e30 277 F0 E1 A3 FA |                             rdlut   b, b                    ' a b c d e    get bank limit/mask
12e34 278 F0 45 CB F9 |                             bmask   mask, b                 ' | | | d e    build mask for addr
12e38 279 F0 3F EB F8 |                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
12e3c 27a 11 E0 47 F0 | p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
12e40 27b F0 47 23 F3 |                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
12e44 27c 05 3E 57 F0 |                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
12e48 27d 10 5A 67 04 |             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
12e4c 27e 10 5A 67 F4 |                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
12e50 27f F9 3B 83 FC |                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
12e54 280 D9 3B 83 FC | r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
12e58 281 DA E3 03 F6 |                             mov     c, count                ' | | | d e f  get count of bytes left to read
12e5c 282 A3 E3 33 F3 |                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
12e60 283 20 D0 17 F6 |                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
12e64 284 CD D3 03 C6 |             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
12e68 285 CC D3 03 36 |             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
12e6c 286 32 20 64 FD |                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
12e70 287 E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
12e74 288 AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
12e78 289 E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
12e7c 28a E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
12e80 28b 54 00 90 FD |                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
12e84 28c             | 
12e84 28c             |                             ' fall through to read bursts
12e84 28c             |                         
12e84 28c             | burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
12e84 28c D8 E5 03 F6 |                             mov     d, addr1                'get start address
12e88 28d 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
12e8c 28e EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
12e90 28f F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
12e94 290 CD D3 03 C6 |             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
12e98 291 00 D8 07 F6 |                             mov     pattern, #0             'enable all by default
12e9c 292 01 B0 17 F4 |                             testb   addr1, #1 wc            'test if start addr starts in second word
12ea0 293 01 D8 67 F4 |                             bitnc   pattern, #1             'enable delay cycle if so
12ea4 294 6C D0 63 FD |                             wrc     clks                    'and account for its clock cycle
12ea8 295 00 B0 17 F4 |                             testb   addr1, #0 wc            'test if start addr starts on odd byte
12eac 296 02 D8 67 F4 |                             bitnc   pattern, #2             'add hi 8 transfer initially
12eb0 297 F1 E5 03 F6 |                             mov     d, c                    'get count of bytes to be read into HUB
12eb4 298 01 E4 87 C1 |             if_c            sub     d, #1                   'minus 1 if start addr was odd
12eb8 299 01 E4 4F F0 |                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
12ebc 29a F2 D1 23 F1 |                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
12ec0 29b F2 35 23 F9 |                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
12ec4 29c 03 D8 87 F4 |                             bitz    pattern, #3             'adjust the pattern to include this
12ec8 29d 00 E2 D7 F4 |                             testb   c, #0 xorc              'test for end address
12ecc 29e 04 D8 67 F4 |                             bitnc   pattern, #4             'include low 8 bit transfer if required
12ed0 29f 0E D0 27 F1 |                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
12ed4 2a0 E8 D1 03 F1 |                             add     clks, clks
12ed8 2a1             | readcommon
12ed8 2a1 D8 C9 03 F6 |                             mov     cmdaddr, addr1          'get start address of transfer
12edc 2a2 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
12ee0 2a3 EB C8 DF F8 |                             setbyte cmdaddr, #$EB, #3       'add quad read command
12ee4 2a4             | 
12ee4 2a4 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
12ee8 2a5 69 C8 63 FD |                             rev     cmdaddr
12eec 2a6 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
12ef0 2a7 61 C8 63 FD |                             mergeb  cmdaddr
12ef4 2a8             | 
12ef4 2a8 58 52 63 FD |                             drvl    cspin                   'activate chip select
12ef8 2a9 58 48 63 FD |                             drvl    datapins                'enable data bus
12efc 2aa             |             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
12efc 2aa E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'stream out command+address
12f00 2ab A8 D1 23 FC |                             wypin   clks, clkpin            'start clock output
12f04 2ac 00 00 CC FC |                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
12f08 2ad 00 0C CC FC |                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
12f0c 2ae             |                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
12f0c 2ae 50 48 63 FD |                             fltl    datapins                'safe to float the data bus, address has been sent by now
12f10 2af A4 5B 03 FC |                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
12f14 2b0 28 3A 63 FD |                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
12f18 2b1 00 3E C7 FC |                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
12f1c 2b2 00 0C CC FC |                             xcont   #6, #0                  'fixed delay offset to expand delay range
12f20 2b3 32 D8 63 FD |                             skipf   pattern                 'choose path below
12f24 2b4             |                                                             'Bursts Bytes Words Longs  RMW FromWrites
12f24 2b4 28 3C 63 FD |                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
12f28 2b5 00 02 CC FC |                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
12f2c 2b6 00 32 C7 FC |                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
12f30 2b7 00 34 C7 FC |                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
12f34 2b8 00 30 C7 FC |                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
12f38 2b9 2D D2 63 FD |                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
12f3c 2ba 24 36 60 FD |                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
12f40 2bb A4 55 03 FC |                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
12f44 2bc 59 52 63 0D |             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
12f48 2bd 59 52 63 FD |                             drvh    cspin                   '         b     c           e       deassert chip select and continue
12f4c 2be E5 E5 4B F8 |                             getnib  d, request, #1          'get request code value
12f50 2bf 03 E4 87 51 |             if_nz           sub     d, #3                   'offset for table if RMW
12f54 2c0 BB E5 8F F9 |                             altd    d, #skiptable-5         'patch next instruction
12f58 2c1 32 00 60 FD |                             skipf   0-0                     'generate skip sequence
12f5c 2c2             |                                                             ' B   W  RMWB RMWW RMLL 
12f5c 2c2 80 DF 07 FB |                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
12f60 2c3 28 B4 63 FD |                             setq    count                   ' |   |   |    |    e   setup bit mux mask
12f64 2c4 D9 DF F3 F9 |                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
12f68 2c5 40 00 90 FD |                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
12f6c 2c6 01 B0 17 F4 |                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
12f70 2c7 EF EF 3B C9 |             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
12f74 2c8 EF EF 33 39 |             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
12f78 2c9 D8 E5 03 F6 |                             mov     d, addr1                ' a   |   c    d
12f7c 2ca 03 E4 07 F5 |                             and     d, #3                   ' a   |   c    |        get LSBs of address
12f80 2cb EF E5 6F F9 |                             altgb   d, #a                   ' a   |   c    |        index into long
12f84 2cc 00 EE E3 F8 |                             getbyte pb                      ' a   |   c    |        and extract the byte
12f88 2cd 80 EF 67 FC |                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
12f8c 2ce C0 00 B0 FD |                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
12f90 2cf 2D 00 64 FD |                             ret                             ' a   b   |    |        then return
12f94 2d0 28 B4 63 FD |                             setq    count                   '         c    d        setup bit mux mask
12f98 2d1 D9 EF F3 F9 |                             muxq    pb, hubdata             '         c    d        apply bit mux
12f9c 2d2 EF E5 67 F9 |                             altsb   d, #a                   '         c    |
12fa0 2d3 F7 01 C0 F8 |                             setbyte 0-0, pb, #0             '         c    |
12fa4 2d4 F7 DF 2B C9 |             if_c            setword a, pb, #1               '         |    d
12fa8 2d5 F7 DF 23 39 |             if_nc           setword a, pb, #0               '         |    d
12fac 2d6 37 8A 07 F6 | writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
12fb0 2d7 EF B3 03 F6 |                             mov     hubdata, a              'write a to PSRAM
12fb4 2d8 14 D6 07 F6 |                             mov     wrclks, #20             '20 clocks to write a long
12fb8 2d9 CC D3 03 F6 |                             mov     resume, complete_rw     'we'll complete the operation after this
12fbc 2da 10 03 90 FD |                             jmp     #writecommon
12fc0 2db             | 
12fc0 2db             | '..................................................................................................
12fc0 2db             | ' Burst continuation testing
12fc0 2db             | 
12fc0 2db 32 96 63 FD | continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
12fc4 2dc BE D3 03 F6 |                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
12fc8 2dd             | continue_read_lut          
12fc8 2dd BF D3 03 F6 |                             mov     resume, resumereads     ' | setup resume address to execf
12fcc 2de F1 B3 03 F1 |                             add     hubdata, c              ' a compute the next hub addr to use
12fd0 2df F1 B5 83 F1 |                             sub     count, c                ' a account for the bytes already sent
12fd4 2e0 D8 E3 03 F1 |                             add     c, addr1                ' a compute next external mem address
12fd8 2e1 28 44 63 FD |                             setq    mask                    ' a configure mask for bit muxing
12fdc 2e2 F1 B1 F3 F9 |                             muxq    addr1, c                ' a perform address bit muxing
12fe0 2e3 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
12fe4 2e4 14 00 90 5D |             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
12fe8 2e5 E1 47 3B F9 |                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
12fec 2e6 F0 47 23 F3 |                             fle     limit, b                ' | also re-apply per bank limit
12ff0 2e7 2A 2A 67 0D |             _ret_           push    #continue_read_exec     ' | 
12ff4 2e8 04 00 90 5D |             if_nz           jmp     #yield                  ' a
12ff8 2e9 2A 2C 67 0D |             _ret_           push    #continue_write_exec    ' a
12ffc 2ea             | 
12ffc 2ea 04 B9 37 FC | yield                       wrlut   total, ptra[4]          'save context for next time
13000 2eb 05 BB 37 FC |                             wrlut   offset1, ptra[5]        'save context for next time
13004 2ec 06 BD 37 FC |                             wrlut   offset2, ptra[6]        'save context for next time
13008 2ed 07 BF 37 FC |                             wrlut   link, ptra[7]           'save context for next time
1300c 2ee 00 B1 37 FC | yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
13010 2ef 01 B3 37 FC |                             wrlut   hubdata, ptra[1]        'save context for next time
13014 2f0 02 B5 37 FC |                             wrlut   count, ptra[2]          'save context for next time
13018 2f1 03 B7 37 FC |                             wrlut   addr2, ptra[3]          'save context for next time
1301c 2f2 08 D3 37 FC |                             wrlut   resume, ptra[8]         'save next resume address
13020 2f3 09 D5 37 FC |                             wrlut   orighubsize, ptra[9]    'save original hub size
13024 2f4 2A 1C 66 0D |             _ret_           push    #poller
13028 2f5             | 
13028 2f5             | 
13028 2f5 32 BE 65 FD | notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
1302c 2f6             | nowrite_lut                                                 '  (a) new skip sequence 
1302c 2f6 32 00 64 FD | noread_lut                  skipf   #0                      ' | cancel skipping
13030 2f7 08 01 3C FC |                             wrlut   #0, ptra[8]             ' | clear resume
13034 2f8 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
13038 2f9 40 F8 9F 5D |             if_nz           jmp     #notify                 ' | if not a request list then we are done
1303c 2fa 1F B6 0F F4 |                             testb   addr2, #31 wz           ' | check if extended list item
13040 2fb DF B7 03 A6 | donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
13044 2fc 1C 00 B0 FD | checklist                   call    #checknext              ' | handle running from list
13048 2fd 2D 00 64 FD |                             ret                             ' | continue processing
1304c 2fe 2A 9E 63 0D |             _ret_           push    noread                  'continue end of transfer
13050 2ff             | '..................................................................................................
13050 2ff             | ' Completion of requests
13050 2ff             | 
13050 2ff             | complete_rw_lut             
13050 2ff 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        'test for running from a request list   
13054 300 32 04 64 AD |             if_z            skipf   #%10                    'if a request list then skip notification
13058 301 08 01 3C FC |                             wrlut   #0, ptra[8]             ' a   default is not to resume
1305c 302 2A 14 66 0D |             _ret_           push    #notify                 ' |   if not a request list then we are done
13060 303 0D B6 B7 FB |                             tjs     addr2, #extendedreq     '     test for special extended request  
13064 304 07 B6 97 FB | checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
13068 305 BF ED 07 FB |                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
1306c 306 05 EC BF FB |                             tjns    pa, #listcomplete       'exit if it has
13070 307 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz
13074 308 DB B3 03 A6 |             if_z            mov     hubdata, addr2
13078 309 32 62 64 AD |             if_z            skipf   #%110001
1307c 30a 32 10 64 5D |             if_nz           skipf   #%1000                  'do not notify if list is continuing
13080 30b 80 B7 67 FC |                             wrlong  addr2, ptrb             ' a  write back next list address
13084 30c D0 C3 8F F9 | listcomplete                altd    id, #id0                ' a  compute COG's state address
13088 30d 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
1308c 30e 2A 14 66 0D |             _ret_           push    #notify                 ' |  we are done with the list
13090 30f 2A 1C 66 0D |             _ret_           push    #poller                 ' a  we are still continuing the list
13094 310 2A 50 66 0D |             _ret_           push    #real_list              ' a  we are still continuing the list
13098 311 E3 B5 97 FB | extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
1309c 312 DB DF 7B F8 |                             getnib  a, addr2, #7            'check the request type
130a0 313 0F DE 0F F2 |                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
130a4 314 D8 DF 73 F8 |                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
130a8 315 32 90 63 5D |             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
130ac 316             |                                                             ' skipcase (a) gfx copy to/from hub
130ac 316             |                                                             ' skipcase (b) gfx copy extmem bank to bank
130ac 316             |                                                             ' skipcase (c) linear copy extmem bank to bank
130ac 316 DB DF 73 F8 |                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
130b0 317 EF E5 AB FA |                             rdlut   d, a wz                 ' a      load bank information and check if valid
130b4 318 31 02 64 5D |             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
130b8 319 2A 02 66 0D |             _ret_           push    #invalidbank            ' |      otherwise bail out after this
130bc 31a DD BB CB F7 |                             test    offset1 wz              ' |      check for first offset being zero
130c0 31b DE BD CB A7 |             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
130c4 31c 32 94 63 AD |             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
130c8 31d 32 92 63 FD |                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
130cc 31e F1 B3 03 F1 |                             add     hubdata, c              ' a b c  add bytes just sent to hub address
130d0 31f EA B3 83 F1 |                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
130d4 320 D8 E3 03 F1 |                             add     c, addr1                ' a b c  compute next address to use
130d8 321 DC B9 CB F7 |                             test    total wz                ' a b |  check for zero tranfers
130dc 322 DC D5 2B F3 |                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
130e0 323 44 FF 9F AD |             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
130e4 324 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a b c  check if reading/writing
130e8 325 EA B5 03 F6 |                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
130ec 326 EA E3 83 F1 |                             sub     c, orighubsize          ' a b |  rewind to original position
130f0 327 DD E3 03 A1 |             if_z            add     c, offset1              ' a b |  add any dst scanline offset
130f4 328 DE E3 03 51 |             if_nz           add     c, offset2              ' a b |  add any src scanline offset
130f8 329 DE B3 03 A1 |             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
130fc 32a DD B3 03 51 |             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
13100 32b 28 44 63 FD |                             setq    mask                    ' a b c  configure mask for bit muxing
13104 32c F1 B1 F3 F9 |                             muxq    addr1, c                ' a b c  perform address bit muxing
13108 32d D8 DF 03 F6 |                             mov     a, addr1                ' | b c  ]
1310c 32e DB B1 03 F6 |                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
13110 32f EF B7 03 F6 |                             mov     addr2, a                ' | b c  ]
13114 330 1E B0 A7 F4 |                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
13118 331 0F B6 3F F8 |                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
1311c 332 01 B8 8F F1 |                             sub     total, #1 wz            ' a | |  decrement scanline count
13120 333 01 B8 8F A1 |             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
13124 334 EA B9 8B A1 |             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
13128 335 DF B7 03 A6 |             if_z            mov     addr2, link
1312c 336 34 FF 9F AD |             if_z            jmp     #checknext
13130 337 D8 CB FB F8 | moretransfers               getbyte request, addr1, #3      'prepare next request
13134 338 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
13138 339 32 1C 64 AD |             if_z            skipf   #%1110                  '     skip some code if we are locked
1313c 33a 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a   test if will be reading or writing
13140 33b BE D3 03 A6 |             if_z            mov     resume, resumewrites    ' |   resume burst writing
13144 33c B9 D3 03 56 |             if_nz           mov     resume, newburstr       ' |   resume burst reading
13148 33d B0 FE 9F FD |                             jmp     #yield                  ' |   yield to poller
1314c 33e 31 02 64 AD |             if_z            skip    #%1                     '     skip next instruction for writing case
13150 33f 2A 26 67 0D |             _ret_           push    #start_read_exec        '(|)  do new read burst next 
13154 340 2A 28 67 0D |             _ret_           push    #start_write_exec       'do new write burst next
13158 341             | 
13158 341             | '..................................................................................................
13158 341             | ' PSRAM WRITES
13158 341             |                                                             '  a b c d e f g h
13158 341             | 
13158 341             |                                                             '  B W L F B R L L (a) byte write(s)
13158 341             |                                                             '  Y O O I U E O O (b) word write(s)
13158 341             |                                                             '  T R N L R S C C (c) long write(s)
13158 341             |                                                             '  E D G L S U K K (d) resumed fill
13158 341             |                                                             '          T M E E (e) new burst write
13158 341             |                                                             '            E D D (f) resumed burst
13158 341             |                                                             '              F B (g) locked fill
13158 341             |                                                             '              I U (h) locked burst write
13158 341             |                                                             '              L R 
13158 341             |                                                             '              L S 
13158 341             |                                                             '                T 
13158 341             | 
13158 341             | w_single                   
13158 341             | w_fill_cont           
13158 341 D8 DF 7B F8 |                             getnib  a, addr1, #7            '  a b c d          obtain request
1315c 342 03 DE 07 F5 |                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
13160 343 00 B2 FF F9 |                             movbyts hubdata, #0             '  a | | |          replicate byte across long
13164 344 44 B2 FF F9 |                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
13168 345 01 B0 27 F5 |                             andn    addr1, #1               '  | b | |          align word addresses
1316c 346 03 B0 27 F5 |                             andn    addr1, #3               '  | | c |          align long addresses
13170 347 DA D5 03 F6 | w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
13174 348 01 B4 0F F2 | w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
13178 349 EF B5 63 F0 |                             shl     count, a                '  a b c | |   |    scale into bytes
1317c 34a AB B5 97 FB |                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
13180 34b DA E3 03 F6 | w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
13184 34c 76 02 A0 FD |                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
13188 34d             |                ' disable call to r_resume_burst for single longs when z=0
13188 34d E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
1318c 34e AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
13190 34f E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
13194 350 E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
13198 351 3F 8A 0F F6 |                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
1319c 352 A3 E3 33 F3 |                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
131a0 353 CE D3 03 C6 |             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
131a4 354 CC D3 03 36 |             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
131a8 355 D9 DF 03 F6 |                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
131ac 356 14 D6 07 F6 |                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
131b0 357 01 DE 17 F4 |                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
131b4 358 C7 8B 03 F6 |                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
131b8 359 14 01 90 8D |             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
131bc 35a 09 8A 67 25 |             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
131c0 35b 5C 00 90 2D |             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
131c4 35c 0F 8A 07 F6 |                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
131c8 35d             |         
131c8 35d             |             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
131c8 35d             |             '
131c8 35d             |             '  At least one of these 3 optional components will be sent
131c8 35d             |             '     header - first partial long of data, gets aligned to PSRAM long boundary
131c8 35d             |             '     body - N x full longs of data
131c8 35d             |             '     trailer - last partial long of data
131c8 35d             |             '
131c8 35d             |             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
131c8 35d             |             '
131c8 35d             |             'Case    Type                           Sends
131c8 35d             |             ' 1)     Single byte/word write         header only (takes its own optimized path)
131c8 35d             |             ' 2)     Single long write              body only (takes its own optimized path)
131c8 35d             |             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
131c8 35d             |             ' 4)     Multiple long fill             body only
131c8 35d             |             ' 5)     Burst write                    optional header, optional body, optional trailer
131c8 35d             | 
131c8 35d             |                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
131c8 35d D8 E5 03 F6 |                             mov     d, addr1                'get start address
131cc 35e 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
131d0 35f EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
131d4 360 F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
131d8 361 CE D3 03 C6 |             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
131dc 362 13 8C 07 F6 |                             mov     pattern3, #%10011
131e0 363 D8 E5 03 F6 |                             mov     d, addr1                'get start address position 
131e4 364 03 E4 0F F5 |                             and     d, #3 wz                'get alignment
131e8 365 04 E2 17 F2 |                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
131ec 366 10 D6 07 F6 |                             mov     wrclks, #16             'clocks needed for address phase
131f0 367 F1 EF 03 F6 |                             mov     pb, c                   'get number of bytes to send
131f4 368 F2 EF 03 F1 |                             add     pb, d                   'and increase total to send, including initial re-alignment
131f8 369 40 00 90 2D |             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
131fc 36a             |                             
131fc 36a F0 CA 17 F2 |                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
13200 36b 32 3C 64 CD |             if_c            skipf   #%11110                 'if fill skip burst write stuff
13204 36c 04 D6 07 F1 |                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
13208 36d F2 DF 83 F1 |                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
1320c 36e EF E5 03 FB |                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
13210 36f 04 DE 07 F1 |                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
13214 370 32 08 64 FD |                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
13218 371 04 EE 9F F1 |                             sub     pb, #4 wcz              ' subtract a long from the total
1321c 372 00 8A 07 F4 |                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
13220 373 D9 E5 03 F6 | single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
13224 374 88 01 B0 FD |                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
13228 375 5A B0 47 FB |                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
1322c 376 ED C5 03 FB |                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
13230 377 28 EC 63 FD |                             setq    pa                      ' setup byte mux mask
13234 378 F2 C5 F3 F9 |                             muxq    header, d               ' copy bytes into long
13238 379 94 00 90 ED |             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
1323c 37a             | 
1323c 37a F0 CA 17 F2 | header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
13240 37b F7 E5 03 F6 |                             mov     d, pb                   'preserve the count
13244 37c 03 EE 2F F5 |                             andn    pb, #3 wz               'determine the number of full long bytes left to send
13248 37d 07 EE 97 FB |                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
1324c 37e             |                  
1324c 37e F7 D7 03 F1 |                             add     wrclks, pb              'include this number of bytes as more clock transitions
13250 37f 32 14 64 CD |             if_c            skipf   #%1010                 'for fills we can skip burst stuff
13254 380 0C 8A 27 C5 |             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
13258 381 01 8A 07 F4 |                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
1325c 382 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute word count for bursts
13260 383 F7 37 23 F9 |                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
13264 384 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
13268 385             | 
13268 385 03 E4 07 F5 | body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
1326c 386 17 E4 97 FB |                             tjz     d, #trailer_done        'no trailer to send, we exit now
13270 387 DA E3 0B C2 |             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
13274 388 CC D3 0B 32 |             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
13278 389 F2 E3 83 51 |             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
1327c 38a 4C 00 90 5D |             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
13280 38b             | 
13280 38b             |                             'we have 1-3 more aligned residual bytes left to send as the trailer
13280 38b F0 E5 47 F5 |                             or      d, #$1f0                'setup mux mask address
13284 38c F2 ED A3 FA |                             rdlut   pa, d                   'read mux mask for this length at offset 0
13288 38d 2A B0 63 FD |                             push    addr1                   'save address
1328c 38e             | 
1328c 38e             | ' use this code (note: foldover can occur here in PSRAM bank)
1328c 38e F1 B1 03 F1 |                             add     addr1, c                'find last long address in PSRAM
13290 38f 01 B0 87 F1 |                             sub     addr1, #1               '..to be rewritten
13294 390 18 01 B0 FD |                             call    #readlong               'read data from this external address
13298 391             |             
13298 391 D9 E5 03 C6 |             if_c            mov     d, hubdata              'get data to be sent for fills
1329c 392 32 3C 64 CD |             if_c            skipf   #%11110                 'skip burst code for fills
132a0 393 2B B0 63 FD |                             pop     addr1                   'restore address
132a4 394 F7 E5 03 F6 |                             mov     d, pb                   ' | get number of full longs that were sent
132a8 395 02 E4 67 F0 |                             shl     d, #2                   ' | convert to bytes
132ac 396 EF E5 03 F1 |                             add     d, a                    ' | add to start adress of longs to stream
132b0 397 F2 E5 03 FB |                             rdlong  d, d                    ' | read this last long from HUB RAM
132b4 398             | 
132b4 398 ED C7 03 FB |                             rdlong  trailer, hubscratch     'read external RAM data value
132b8 399 28 EC 63 FD |                             setq    pa                      'setup byte mask
132bc 39a F2 C7 F3 F9 |                             muxq    trailer, d              'apply byte mask to data via muxq
132c0 39b 04 D6 07 F1 |                             add     wrclks, #4              'increase by 4 more clocks
132c4 39c 05 8A 07 F4 |                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
132c8 39d 00 8C 07 F4 |                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
132cc 39e             | 
132cc 39e             |                             'trailer is done
132cc 39e EF 3B 73 FC | trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
132d0 39f             | 
132d0 39f D8 C9 03 F6 | writecommon                 mov     cmdaddr, addr1          'get start address of transfer
132d4 3a0 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
132d8 3a1 02 C8 DF F8 |                             setbyte cmdaddr, #$02, #3       'add quad write command
132dc 3a2             | 
132dc 3a2 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
132e0 3a3 69 C8 63 FD |                             rev     cmdaddr                 
132e4 3a4 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
132e8 3a5 61 C8 63 FD |                             mergeb  cmdaddr
132ec 3a6             |                             
132ec 3a6 58 52 63 FD |                             drvl    cspin                   'activate chip select
132f0 3a7 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
132f4 3a8 E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
132f8 3a9 A8 D7 23 FC |                             wypin   wrclks, clkpin          'start memory clock output 
132fc 3aa             |                                                          
132fc 3aa 32 8A 63 FD |                             skipf   pattern2                '   B W L Burst FB FW FL RMW
13300 3ab E2 39 C3 FC |                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
13304 3ac 00 36 C7 FC |                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
13308 3ad F7 03 D8 FC |                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
1330c 3ae D9 39 C3 FC |                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
13310 3af 32 8C 63 FD |                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
13314 3b0 E3 39 C3 FC |                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
13318 3b1 2D D2 63 FD |                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
1331c 3b2 24 36 60 FD |                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
13320 3b3 50 48 63 FD |                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
13324 3b4 59 52 63 0D |             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
13328 3b5             |  
13328 3b5 59 52 63 FD |                             drvh    cspin
1332c 3b6 09 C2 17 F4 | check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
13330 3b7 F1 B5 8B F1 |                             sub     count, c wz             'account for bytes written
13334 3b8 34 00 90 5D |             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
13338 3b9 08 01 3C FC |                             wrlut   #0, ptra[8]             'default is not to resume
1333c 3ba 3C F5 9F 3D |             if_nc           jmp     #notify                 'if not a request list then we are done
13340 3bb 40 B7 BF FB |                             tjns    addr2, #checklist       'if not extended, check next list entry
13344 3bc 3E B9 67 FB |                             djz     total, #donerepeats     'check for repeats remaining
13348 3bd B8 B9 B3 FB |                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
1334c 3be EA E5 03 F6 |                             mov     d, orighubsize
13350 3bf EF E5 63 F0 |                             shl     d, a
13354 3c0 F2 E3 83 F1 |                             sub     c, d
13358 3c1 DD E3 03 F1 |                             add     c, offset1
1335c 3c2 F2 B5 03 F6 |                             mov     count, d                'restore original count
13360 3c3 E5 E1 43 F8 | readmask                    getnib  b, request, #0          'get bank parameter LUT address
13364 3c4 F0 E1 A3 FA |                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
13368 3c5 F0 45 CB F9 |                             bmask   mask, b                 'build mask for addr (in case count=1)
1336c 3c6 D8 E3 03 F1 | continue_fill               add     c, addr1                'add bytes to destination address
13370 3c7 28 44 63 FD |                             setq    mask                    'setup bit mask
13374 3c8 F1 B1 F3 F9 |                             muxq    addr1, c                'setup new external memory address
13378 3c9 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
1337c 3ca 33 74 63 AD |             if_z            execf   lockedfill              'continue next fill operation
13380 3cb BB D3 03 F6 |                             mov     resume, restorefill
13384 3cc 00 B6 07 36 |             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
13388 3cd 80 FC BF 3D |             if_nc           call    #yieldfill              'we have to yield now to other COGs
1338c 3ce 6C FC BF CD |             if_c            call    #yield
13390 3cf 2D 00 64 FD |                             ret
13394 3d0             |                            
13394 3d0             | getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
13394 3d0             |                       '     rczl    pa                      'rotate left into address offset
13394 3d0             |                       '     rczl    c wcz                   'restore count and flags
13394 3d0 03 E2 EF F7 |                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
13398 3d1 02 EC 67 F0 |                             shl     pa, #2
1339c 3d2 28 06 64 AD |             if_z            setq    #3
133a0 3d3 F1 ED F3 A9 |             if_z            muxq    pa, c
133a4 3d4 F0 ED 47 F5 |                             or      pa, #$1f0               'setup LUT address offset
133a8 3d5 F6 ED A3 FA |            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
133ac 3d6 2D 00 7C FD |                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
133b0 3d7             | 
133b0 3d7 ED 3B 83 FC | readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
133b4 3d8 02 34 27 F9 |                             setword xrecvdata, #2, #0       'read 2x16 words
133b8 3d9 20 D0 07 F6 |                             mov     clks, #32               '32 read clock transitions
133bc 3da 36 D8 07 F6 |                             mov     pattern, #%110110       'setup read skip pattern
133c0 3db 14 FB 9F FD |                             jmp     #readcommon             'read then return directly to caller
133c4 3dc             |         
133c4 3dc             | 
133c4 3dc             | '..................................................................................................
133c4 3dc             | 
133c4 3dc             |                 fit 1024-32
133c4 3dc             |                 fit 1024-32
133c4 3dc 00 00 00 00 
133c8 3dd 00 00 00 00 
133cc 3de 00 00 00 00 
133d0 3df 00 00 00 00 |                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
133d4 3e0             |                 org 1024-32
133d4 000             | 
133d4 000             | ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
133d4 000 00 00 00 00 |                 long $0000
133d8 001 11 11 00 00 |                 long $1111
133dc 002 22 22 00 00 |                 long $2222
133e0 003 33 33 00 00 |                 long $3333
133e4 004 44 44 00 00 |                 long $4444
133e8 005 55 55 00 00 |                 long $5555
133ec 006 66 66 00 00 |                 long $6666
133f0 007 77 77 00 00 |                 long $7777
133f4 008 88 88 00 00 |                 long $8888
133f8 009 99 99 00 00 |                 long $9999
133fc 00a AA AA 00 00 |                 long $aaaa
13400 00b BB BB 00 00 |                 long $bbbb
13404 00c CC CC 00 00 |                 long $cccc
13408 00d DD DD 00 00 |                 long $dddd
1340c 00e EE EE 00 00 |                 long $eeee
13410 00f FF FF 00 00 |                 long $ffff
13414 010             | 
13414 010             | 'masks
13414 010 FF FF FF FF |                 long $ffffffff ' 00 aligned 0/4 length
13418 011 FF 00 00 00 |                 long $000000ff ' 00 aligned 1 length
1341c 012 FF FF 00 00 |                 long $0000ffff ' 00 aligned 2 length
13420 013 FF FF FF 00 |                 long $00ffffff ' 00 aligned 3 length
13424 014             | 
13424 014 00 FF FF FF |                 long $ffffff00 ' 01 aligned 0/4 length
13428 015 00 FF 00 00 |                 long $0000ff00 ' 01 aligned 1 length
1342c 016 00 FF FF 00 |                 long $00ffff00 ' 01 aligned 2 length
13430 017 00 FF FF FF |                 long $ffffff00 ' 01 aligned 3 length
13434 018             | 
13434 018 00 00 FF FF |                 long $ffff0000 ' 10 aligned 0/4 length
13438 019 00 00 FF 00 |                 long $00ff0000 ' 10 aligned 1 length
1343c 01a 00 00 FF FF |                 long $ffff0000 ' 10 aligned 2 length
13440 01b 00 00 FF FF |                 long $ffff0000 ' 10 aligned 3 length
13444 01c             | 
13444 01c 00 00 00 FF |                 long $ff000000 ' 11 aligned 0/4 length
13448 01d 00 00 00 FF |                 long $ff000000 ' 11 aligned 1 length
1344c 01e 00 00 00 FF |                 long $ff000000 ' 11 aligned 2 length
13450 01f 00 00 00 FF |                 long $ff000000 ' 11 aligned 3 length
13454 020             | 
13454 020             |         fit 1024
13454 020             |         fit 1024
13454 020             | 
13454 020             | '--------------------------------------------------------------------------------------------------
13454 020             |         orgh
13454                 | 
13454                 | gfxexpansion
13454                 |                             'simple line drawing graphics expansion of memory driver
13454                 |                             'jmp     #donerepeats                'just return for now
13454                 | 
13454     DB B1 0B F2 |                             cmp     addr1, addr2 wz         'see if we've reached the end
13458     FB 02 80 AD |             if_z            jmp     #donerepeats            'nothing more to draw
1345c     01 B8 07 F1 |                             add     total, #1               'restore total after decrement
13460     DD E1 03 F6 |                             mov     b, offset1              'get error term
13464     01 E0 67 F0 |                             shl     b, #1                   'compute e2 = 2 x error
13468     DE E5 33 F9 |                             getword d, offset2, #0          'get dx = abs(x0-x1)
1346c     10 BC C7 F0 |                             sar     offset2, #16            'get dy = -abs(y0-y1)
13470     DE E1 53 F2 |                             cmps    b, offset2 wc           'compare if e2 >= dy
13474     00 E2 07 F6 |                             mov     c, #0                   'clear accumulator reg
13478     31 1C 64 CD |             if_c            skip    #%1110                  'if not, skip
1347c     EF DF C3 F9 |                             decod   a                       'decode as 1,2,or 4 byte size
13480     DE BB 03 F1 |                             add     offset1, offset2        'err+=dy 
13484     10 B8 0F F4 |                             testb   total, #16 wz           'check sign sx   
13488     EF E3 C3 F3 |                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
1348c     F0 E5 53 F2 |                             cmps    d, b wc                 'compare if e2 <= dx
13490     31 3C 64 CD |             if_c            skip    #%11110                 'if not, skip
13494     F2 BD 43 F9 |                             rolword offset2, d, #0          'restore offset
13498     F2 BB 03 F1 |                             add     offset1, d              'err+=dx
1349c     11 B8 0F F4 |                             testb   total, #17 wz           'check sign sy
134a0     DC E5 33 F9 |                             getword d, total, #0            'get line width
134a4     F2 E3 C3 F3 |                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
134a8     EF DF 93 F7 |                             encod   a wc                    'restore size and set carry
134ac     EA B5 03 F6 |                             mov     count, orighubsize      'reset the fill width
134b0     EF B5 63 F0 |                             shl     count, a                '..for the type of transfer
134b4     C3 03 80 FD |                             jmp     #readmask               'continue filling
134b8                 | 	alignl
134b8                 | _usbnew_spin2_dat_
134b8                 |                 org     $000
134b8 000             | 
134b8 000             | usb_host_start
134b8 000 F9 8F 02 F6 |                 mov     hcog_base_addr, ptrb
134bc 001             | 
134bc 001 03 00 00 FF 
134c0 002 D0 72 07 F6 |                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
134c4 003 02 72 47 F0 |                 shr     htmp, #2                        ' so byte->long for the lut cell count
134c8 004 B4 04 A0 FE |                 loc     pb, #@hlut_start - @usb_host_start
134cc 005 47 EF 03 F1 |                 add     pb, hcog_base_addr
134d0 006 29 72 63 FD |                 setq2   htmp
134d4 007 F7 01 00 FB |                 rdlong  0, pb                           ' Do the hub->lut copy
134d8 008             | 
134d8 008 88 0B A0 FE |                 loc     pb, #@usb_host_init - @usb_host_start
134dc 009 47 EF 03 F1 |                 add     pb, hcog_base_addr
134e0 00a 2C EE 63 FD |                 jmp     pb                              ' Initialize host and enter main processing loop
134e4 00b             | 
134e4 00b             | '------------------------------------------------------------------------------
134e4 00b             | ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
134e4 00b             | ' special because the receiving function must not respond with either STALL or
134e4 00b             | ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
134e4 00b             | ' non-control endpoint receives a SETUP token, or the function receives a
134e4 00b             | ' corrupt packet, it must ignore the transaction
134e4 00b             | '------------------------------------------------------------------------------
134e4 00b             | ' On entry:
134e4 00b             | '   PTRA - start address of the SETUP data struct.
134e4 00b             | ' On exit:
134e4 00b             | '   retval - PID_ACK on success, otherwise error code.
134e4 00b             | '------------------------------------------------------------------------------
134e4 00b             | txn_setup
134e4 00b 2D BC C6 F8 |                 setbyte ep_addr_pid, #PID_SETUP, #0
134e8 00c 08 B0 06 F6 |                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
134ec 00d 03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
134f0 00e 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
134f4 00f F8 ED 03 F6 |                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
134f8 010             | .setup
134f8 010 24 01 B0 FD |                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
134fc 011 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13500 012 2D 00 64 AD |         if_z    ret
13504 013 7C 0B B0 FD |                 call    #retry_wait
13508 014 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
1350c 015 2D 00 64 AD |         if_z    ret
13510 016 F6 F1 03 F6 |                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
13514 017 E0 FF 9F FD |                 jmp     #.setup
13518 018             | 
13518 018             | '------------------------------------------------------------------------------
13518 018             | ' IN/INTERRUPT transaction.
13518 018             | ' Possible function response: STALL or NAK handshake, or DATAx packet.
13518 018             | '------------------------------------------------------------------------------
13518 018             | ' On entry:
13518 018             | '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
13518 018             | '     CRC(b19..23).
13518 018             | ' On exit:
13518 018             | '------------------------------------------------------------------------------
13518 018             | txn_in
13518 018 90 03 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
1351c 019 69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
13520 01a BC 00 B0 FD |                 call    #utx_token                      ' Put IN request on the bus
13524 01b             | 
13524 01b             |                 ' Fall through to urx_packet
13524 01b             | 
13524 01b             | '------------------------------------------------------------------------------
13524 01b             | ' Wait for a packet from a device/function. As host, the only two packet types
13524 01b             | ' received are handshakes and IN DATAx.
13524 01b             | '------------------------------------------------------------------------------
13524 01b             | ' On entry:
13524 01b             | ' On exit:
13524 01b             | '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
13524 01b             | '     returned.
13524 01b             | '------------------------------------------------------------------------------
13524 01b             | urx_packet
13524 01b 22 A7 82 FA |                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
13528 01c 04 A6 16 F4 |                 testb   urx, #SOPB              wc
1352c 01d F4 FF 9F CD |         if_c    jmp     #urx_packet
13530 01e 1A 94 63 FD |                 getct   hct2
13534 01f 4E 95 6B FA |                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
13538 020 05 96 06 F4 |                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
1353c 021 00 A8 06 F6 |                 mov     newb_flg, #0                    ' Initialize for multi-byte read
13540 022             | .wait_sop
13540 022 22 A7 8A FA |                 rdpin   urx, dm
13544 023 04 A6 16 F4 |                 testb   urx, #SOPB              wc
13548 024 08 00 90 CD |         if_c    jmp     #.get_pid
1354c 025 FC 25 CC FB |                 jnct2   #.wait_sop
13550 026 05 BE 06 06 |         _ret_   mov     retval, #ERR_TAT
13554 027             | .get_pid
13554 027 28 02 B0 FD |                 call    #urx_next
13558 028 06 A6 16 F4 |                 testb   urx, #BUS_ERRB          wc
1355c 029 04 00 90 3D |         if_nc   jmp     #.chk_pid
13560 02a 02 BE 06 06 |         _ret_   mov     retval, #ERR_URX
13564 02b             | .chk_pid
13564 02b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13568 02c 5A BE 0E 52 |         if_nz   cmp     retval, #PID_NAK        wz
1356c 02d 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz
13570 02e 38 00 90 AD |         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
13574 02f 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
13578 030 C3 BE 0E F2 |                 cmp     retval, #PID_DATA0      wz
1357c 031 28 01 90 2D |    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
13580 032 10 00 90 8D |    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
13584 033 4B BE 0E F2 |                 cmp     retval, #PID_DATA1      wz
13588 034 1C 01 90 8D |    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
1358c 035 04 00 90 2D |    if_z_and_nc  jmp     #.ack_resend
13590 036 04 BE 06 06 |         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
13594 037             | .ack_resend
13594 037 22 A7 82 FA |                 rqpin   urx, dm
13598 038 05 A6 16 F4 |                 testb   urx, #EOPB              wc
1359c 039 F4 FF 9F 3D |         if_nc   jmp     #.ack_resend
135a0 03a D2 BE 06 F6 |                 mov     retval, #PID_ACK
135a4 03b 98 01 B0 FD |                 call    #utx_handshake                  ' Send handshake PID and return to caller
135a8 03c 09 BE 06 06 |         _ret_   mov     retval, #ERR_DATAX_SYNC
135ac 03d             | .chk_eop
135ac 03d 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
135b0 03e 1C 00 90 3D |         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
135b4 03f C8 01 B0 FD |                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
135b8 040 05 96 16 F4 |                 testb   hstatus, #EOPB          wc
135bc 041 10 00 90 CD |         if_c    jmp     #.idle                          ' Low-speed EOP seen
135c0 042 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
135c4 043 04 BE 06 36 |         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
135c8 044 02 BE 06 A6 |         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
135cc 045 2D 00 64 FD |                 ret
135d0 046             | .idle
135d0 046 22 A7 82 FA |                 rqpin   urx, dm
135d4 047 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
135d8 048 F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
135dc 049 2D 00 64 FD |                 ret
135e0 04a             | 
135e0 04a             | '------------------------------------------------------------------------------
135e0 04a             | ' Send a token packet with CRC5 checksum of address and endpoint. It is the
135e0 04a             | ' responsibility of the caller to append the appropriate inter-packet delay,
135e0 04a             | ' if one is required.
135e0 04a             | '------------------------------------------------------------------------------
135e0 04a             | ' On entry:
135e0 04a             | '   ep_addr_pid - packed with the PID, address and endpoint.
135e0 04a             | ' On exit:
135e0 04a             | '------------------------------------------------------------------------------
135e0 04a             | utx_token
135e0 04a 22 A7 82 FA |                 rqpin   urx, dm
135e4 04b 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
135e8 04c F4 FF 9F 3D |         if_nc   jmp     #utx_token
135ec 04d 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
135f0 04e 34 0D B0 CD |         if_c    call    #utx_pre
135f4 04f 80 A4 06 F6 |                 mov     utx, #OUT_SOP
135f8 050 70 01 B0 FD |                 call    #utx_byte                       ' Send sync byte
135fc 051 5E 73 03 F6 |                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
13600 052 03 B8 06 F6 |                 mov     pkt_cnt, #3
13604 053             | .next_byte
13604 053 B9 A5 E2 F8 |                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
13608 054 08 72 47 F0 |                 shr     htmp, #8                        ' Shift to next byte to send
1360c 055             | .wait
1360c 055 40 46 72 FD |                 testp   dp                      wc
13610 056 F8 FF 9F 3D |         if_nc   jmp     #.wait
13614 057 23 03 08 FC |                 akpin   dp
13618 058 22 A5 22 FC |                 wypin   utx, dm
1361c 059 F9 B9 6E 0B |         _ret_   djnz    pkt_cnt, #.next_byte
13620 05a             | 
13620 05a             | '------------------------------------------------------------------------------
13620 05a             | ' SETUP/OUT/INTERRUPT transaction.
13620 05a             | ' Possible function response in order of precedence: STALL, ACK, NAK.
13620 05a             | '------------------------------------------------------------------------------
13620 05a             | ' On entry:
13620 05a             | '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
13620 05a             | '     CRC(b19..23).
13620 05a             | '   PTRA - start address of the data buff/struct that has the bytes to send.
13620 05a             | '   pkt_data - count of DATAx payload bytes to send.
13620 05a             | ' On exit:
13620 05a             | '------------------------------------------------------------------------------
13620 05a             | txn_out
13620 05a 88 02 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
13624 05b B8 FF BF FD |                 call    #utx_token                      ' Put SETUP/OUT token on the bus
13628 05c 00 00 C0 FF 
1362c 05d F8 01 78 FC |                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
13630 05e 58 B9 02 F6 |                 mov     pkt_cnt, pkt_data
13634 05f             | 
13634 05f             |                 ' Fall through to utx_data
13634 05f             | 
13634 05f             | '------------------------------------------------------------------------------
13634 05f             | ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
13634 05f             | ' calculated while the data byte is being shifted out. Since data stage
13634 05f             | ' success/fail is not determined until the status stage of the transaction,
13634 05f             | ' this routine is only concerned about the current DATAx packet.
13634 05f             | '------------------------------------------------------------------------------
13634 05f             | ' On entry:
13634 05f             | '   PTRA - hub start address of the data to read.
13634 05f             | '   pkt_cnt - data payload size.
13634 05f             | ' On exit:
13634 05f             | '------------------------------------------------------------------------------
13634 05f             | utx_data
13634 05f 22 A7 82 FA |                 rqpin   urx, dm
13638 060 04 A6 16 F4 |                 testb   urx, #SOPB              wc
1363c 061 F4 FF 9F CD |         if_c    jmp     #utx_data
13640 062 4D 99 02 F6 |                 mov     hctwait, ip_delay
13644 063 2C 0A B0 FD |                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
13648 064 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
1364c 065 D8 0C B0 CD |         if_c    call    #utx_pre
13650 066 80 A4 06 F6 |                 mov     utx, #OUT_SOP
13654 067 14 01 B0 FD |                 call    #utx_byte                       ' Send sync
13658 068 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
1365c 069 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
13660 06a C3 A4 06 36 |         if_nc   mov     utx, #PID_DATA0
13664 06b 4B A4 06 C6 |         if_c    mov     utx, #PID_DATA1
13668 06c 00 01 B0 FD |                 call    #utx_byte                       ' No CRC calc done on PID
1366c 06d 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
13670 06e 1C 00 90 AD |         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
13674 06f             | .read_byte
13674 06f 10 A4 62 FD |                 rfbyte  utx                             ' Fetch data byte
13678 070 F0 00 B0 FD |                 call    #utx_byte
1367c 071 69 A4 62 FD |                 rev     utx                             ' Calculate CRC while the data is shifting out
13680 072 28 A4 62 FD |                 setq    utx                             ' SETQ left-justifies the reflected data byte
13684 073 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
13688 074 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
1368c 075 F9 B9 6E FB |                 djnz    pkt_cnt, #.read_byte
13690 076             | .send_crc
13690 076 E0 BB E6 F4 |                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
13694 077 5D A5 E2 F8 |                 getbyte utx, crc, #0
13698 078 D0 00 B0 FD |                 call    #utx_byte
1369c 079 5D A5 EA F8 |                 getbyte utx, crc, #1
136a0 07a C8 00 B0 FD |                 call    #utx_byte                       ' Last CRC byte out
136a4 07b 7C FE 9F FD |                 jmp     #urx_packet                     ' Handle function response/error and back to caller
136a8 07c             | 
136a8 07c             | '------------------------------------------------------------------------------
136a8 07c             | ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
136a8 07c             | ' payload bytes are received. The routine reads bytes until EOP is detected and
136a8 07c             | ' expects that the packet includes at least the CRC word.
136a8 07c             | '
136a8 07c             | ' In control transfers, it's possible to recieve fewer data bytes than what
136a8 07c             | ' was requested, which makes it difficult to determine where the data stops
136a8 07c             | ' and the CRC word begins. So the CRC calculation is done on every byte of the
136a8 07c             | ' packet, including the CRC word. The CRC value should then be equal to the
136a8 07c             | ' USB-16 expected residual value of 0xB001.
136a8 07c             | '
136a8 07c             | ' The routine writes the IN packet data to a static max_packet_size buffer
136a8 07c             | ' so the caller can verify IN success before writing the data to its final
136a8 07c             | ' destination.
136a8 07c             | '------------------------------------------------------------------------------
136a8 07c             | ' On entry:
136a8 07c             | '   pkt_data - max byte count expected to be in the packet.
136a8 07c             | '   newb_flg - signals new byte ready when toggled.
136a8 07c             | ' On exit:
136a8 07c             | '   pkt_cnt - actual number of bytes read.
136a8 07c             | '------------------------------------------------------------------------------
136a8 07c             | urx_data
136a8 07c F7 77 03 F6 |                 mov     htmp2, pb
136ac 07d 27 EF 03 F6 |                 mov     pb, urx_buff_p
136b0 07e 00 00 C0 FF 
136b4 07f F7 01 88 FC |                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
136b8 080 BB EF 03 F6 |                 mov     pb, htmp2
136bc 081 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
136c0 082 00 B8 06 F6 |                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
136c4 083 58 85 03 F6 |                 mov     pkt_tmp, pkt_data
136c8 084 02 84 07 F1 |                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
136cc 085             | .wait_byte
136cc 085             | ' In-line rx for max speed
136cc 085 22 A7 82 FA |                 rqpin   urx, dm
136d0 086 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
136d4 087 53 A5 02 F5 |                 and     utx, urx
136d8 088 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
136dc 089 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
136e0 08a 0C 00 90 5D |         if_nz   jmp     #.get_byte                      ' New byte!
136e4 08b 05 A6 16 F4 |                 testb   urx, #EOPB              wc
136e8 08c 38 00 90 CD |         if_c    jmp     #.chk_crc                       ' At end-of-packet
136ec 08d DC FF 9F FD |                 jmp     #.wait_byte
136f0 08e             | .get_byte
136f0 08e 53 BF EA F8 |                 getbyte retval, urx, #1                 ' New byte from smart pins
136f4 08f 15 BE 62 FD |                 wfbyte  retval                          ' Add it to the data buffer
136f8 090 69 BE 62 FD |                 rev     retval                          ' Calculate CRC while next byte is shifting in
136fc 091 28 BE 62 FD |                 setq    retval                          ' SETQ left-justifies the reflected data byte
13700 092 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
13704 093 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
13708 094             | .end_crc
13708 094 01 B8 06 F1 |                 add     pkt_cnt, #1
1370c 095 C2 B9 1A F2 |                 cmp     pkt_cnt, pkt_tmp        wcz
13710 096 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
13714 097 2D 00 64 1D |         if_a    ret
13718 098             | ' For full-speed at 80MHz, the time it takes to do the final byte write and
13718 098             | ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
13718 098             | ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
13718 098             | ' to miss it, so cheat a bit and look for SOP clear here.
13718 098 22 A7 82 FA |                 rqpin   urx, dm
1371c 099 05 A6 16 F4 |                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
13720 09a A8 FF 9F 3D |         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
13724 09b             | ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
13724 09b             | .chk_crc
13724 09b 02 B8 86 F1 |                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
13728 09c 58 00 00 FF 
1372c 09d 01 BA 6E F5 |                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
13730 09e F0 FD 9F 5D |         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
13734 09f D2 BE 06 F6 |                 mov     retval, #PID_ACK
13738 0a0 4D 99 02 F6 |                 mov     hctwait, ip_delay
1373c 0a1 34 09 B0 FD |                 call    #poll_waitx
13740 0a2             | 
13740 0a2             |                 ' Fall through to utx_handshake
13740 0a2             | 
13740 0a2             | '------------------------------------------------------------------------------
13740 0a2             | ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
13740 0a2             | ' the appropriate IP delay has been inserted.
13740 0a2             | '------------------------------------------------------------------------------
13740 0a2             | ' On entry:
13740 0a2             | '   retval - handshake PID to send.
13740 0a2             | ' On exit:
13740 0a2             | '   retval unchanged.
13740 0a2             | '------------------------------------------------------------------------------
13740 0a2             | utx_handshake
13740 0a2 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
13744 0a3 E0 0B B0 CD |         if_c    call    #utx_pre
13748 0a4 80 A4 06 F6 |                 mov     utx, #OUT_SOP
1374c 0a5 1C 00 B0 FD |                 call    #utx_byte                       ' Send sync
13750 0a6 5F A5 02 F6 |                 mov     utx, retval
13754 0a7 14 00 B0 FD |                 call    #utx_byte                       ' Send handshake PID
13758 0a8             | .idle
13758 0a8 22 A7 82 FA |                 rqpin   urx, dm
1375c 0a9 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
13760 0aa F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
13764 0ab 4E 99 02 F6 |                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
13768 0ac 08 09 90 FD |                 jmp     #poll_waitx
1376c 0ad             | 
1376c 0ad             | '------------------------------------------------------------------------------
1376c 0ad             | ' Wait for the USB tx buffer to empty and feed it a new byte.
1376c 0ad             | '------------------------------------------------------------------------------
1376c 0ad             | ' On entry:
1376c 0ad             | '   utx - byte to transmit.
1376c 0ad             | ' On exit:
1376c 0ad             | '------------------------------------------------------------------------------
1376c 0ad             | utx_byte
1376c 0ad 40 46 72 FD |                 testp   dp                      wc
13770 0ae F8 FF 9F 3D |         if_nc   jmp     #utx_byte
13774 0af 23 03 08 FC |                 akpin   dp
13778 0b0 1F 94 62 FD |                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
1377c 0b1 22 A5 22 0C |         _ret_   wypin   utx, dm
13780 0b2             | 
13780 0b2             | '------------------------------------------------------------------------------
13780 0b2             | ' Fetch the next data byte of a packet. Always check receiver status for EOP.
13780 0b2             | '------------------------------------------------------------------------------
13780 0b2             | ' On entry:
13780 0b2             | ' On exit:
13780 0b2             | '   retval - the byte read.
13780 0b2             | '   urx - the receiver status. The caller must check the hstatus reg EOP flag
13780 0b2             | '     on return. If EOP is set, the byte in reg retval remains as the last byte
13780 0b2             | '     received.
13780 0b2             | '------------------------------------------------------------------------------
13780 0b2             | urx_next
13780 0b2 22 A7 8A FA |                 rdpin   urx, dm
13784 0b3 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
13788 0b4 53 A5 02 F5 |                 and     utx, urx
1378c 0b5 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
13790 0b6 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
13794 0b7 53 BF EA 58 |         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
13798 0b8 2D 00 64 5D |         if_nz   ret                                     ' New byte is priority, so return now
1379c 0b9 04 A6 16 F4 |                 testb   urx, #SOPB              wc
137a0 0ba 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
137a4 0bb D8 FF 9F 4D |    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
137a8 0bc 05 96 26 34 |         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
137ac 0bd 2D 00 64 FD |                 ret
137b0 0be             | 
137b0 0be             | '------------------------------------------------------------------------------
137b0 0be             | ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
137b0 0be             | ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
137b0 0be             | ' length, and the PID is not included in the CRC calculation:
137b0 0be             | '  CRC5  FRAME_NUMBER SOF (full-speed)
137b0 0be             | '  CRC5  ENDP ADDRESS PID
137b0 0be             | ' %00000_1111_1111111_xxxxxxxx
137b0 0be             | '------------------------------------------------------------------------------
137b0 0be             | ' On entry:
137b0 0be             | '   ep_addr_pid - stuffed with the function endpoint, address and
137b0 0be             | '     SETUP/IN/OUT/SOF PID according to the USB standard.
137b0 0be             | ' On exit:
137b0 0be             | '   ep_addr_pid - CRC value appended to the packet.
137b0 0be             | '------------------------------------------------------------------------------
137b0 0be             | calc_crc5
137b0 0be FF 03 00 FF 
137b4 0bf FF BD 06 F5 |                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
137b8 0c0 5E 73 03 F6 |                 mov     htmp, ep_addr_pid
137bc 0c1 08 72 47 F0 |                 shr     htmp, #8                        ' PID not included in CRC calc
137c0 0c2 1F BA 06 F6 |                 mov     crc, #$1f                       ' Initial CRC5 value
137c4 0c3 69 72 63 FD |                 rev     htmp                            ' Input data reflected
137c8 0c4 28 72 63 FD |                 setq    htmp                            ' CRCNIB setup for data bits 0..7
137cc 0c5 14 BA DE F9 |                 crcnib  crc, #USB5_POLY
137d0 0c6 14 BA DE F9 |                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
137d4 0c7 09 72 77 F0 |                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
137d8 0c8 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
137dc 0c9 01 72 77 F0 |                 shl     htmp, #1                wc
137e0 0ca 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
137e4 0cb 01 72 77 F0 |                 shl     htmp, #1                wc
137e8 0cc 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
137ec 0cd 1F BA 66 F5 |                 xor     crc, #$1f                       ' Final XOR value
137f0 0ce 13 BA 66 F0 |                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
137f4 0cf 5D BD 42 05 |         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
137f8 0d0             | 
137f8 0d0             | '------------------------------------------------------------------------------
137f8 0d0             | ' Full-speed/low-speed frame timing interrupt service routine.
137f8 0d0             | '------------------------------------------------------------------------------
137f8 0d0             | isr1_fsframe
137f8 0d0 1A 92 62 FD |                 getct   iframe_ct_base
137fc 0d1 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
13800 0d2 B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
13804 0d3 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
13808 0d4             | .wait
13808 0d4 40 46 72 FD |                 testp   dp                      wc
1380c 0d5 F8 FF 9F 3D |         if_nc   jmp     #.wait
13810 0d6 23 03 08 FC |                 akpin   dp
13814 0d7 A5 A4 06 F6 |                 mov     utx, #PID_SOF
13818 0d8 22 01 29 FC |                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
1381c 0d9 4C FF BF FD |                 call    #utx_byte                       ' Send token PID byte
13820 0da 1F B6 06 F6 |                 mov     icrc, #$1f                      ' Prime the CRC5 pump
13824 0db 59 B5 02 F6 |                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
13828 0dc 69 B4 62 FD |                 rev     sof_pkt                         ' Input data reflected
1382c 0dd 28 B4 62 FD |                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
13830 0de 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY
13834 0df 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
13838 0e0 59 A5 E2 F8 |                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
1383c 0e1 2C FF BF FD |                 call    #utx_byte
13840 0e2 08 B4 66 F0 |                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
13844 0e3 03 04 DC FC |                 rep     #2, #3                          ' Three data bits left to process
13848 0e4 01 B4 76 F0 |                 shl     sof_pkt, #1             wc
1384c 0e5 14 B6 D6 F9 |                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
13850 0e6 1F B6 66 F5 |                 xor     icrc, #$1f                      ' Final XOR value
13854 0e7 59 A5 EA F8 |                 getbyte utx, frame, #1                  ' Send remaining frame number bits
13858 0e8 03 B6 66 F0 |                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
1385c 0e9 5B A5 42 F5 |                 or      utx, icrc
13860 0ea 08 FF BF FD |                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
13864 0eb A4 83 03 F6 |                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
13868 0ec 20 00 90 FD |                 jmp     #isr1_wait
1386c 0ed             | isr1_lsframe
1386c 0ed 1A 92 62 FD |                 getct   iframe_ct_base
13870 0ee 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
13874 0ef B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
13878 0f0             | .wait
13878 0f0 40 46 72 FD |                 testp   dp                      wc
1387c 0f1 F8 FF 9F 3D |         if_nc   jmp     #.wait
13880 0f2 23 03 08 FC |                 akpin   dp
13884 0f3 22 09 28 FC |                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
13888 0f4 A3 83 03 F6 |                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
1388c 0f5             | isr1_wait
1388c 0f5 22 A5 82 FA |                 rqpin   utx, dm
13890 0f6 04 A4 16 F4 |                 testb   utx, #SOPB                 wc
13894 0f7 F4 FF 9F CD |         if_c    jmp     #isr1_wait
13898 0f8 01 B2 06 F1 |                 add     frame, #1                       ' Next frame# and check for wrap around
1389c 0f9 03 00 00 FF 
138a0 0fa FF B3 06 F5 |                 and     frame, ##$7ff
138a4 0fb 1F 82 63 FD |                 waitx   isrtmp1                         ' Make sure bus is idle
138a8 0fc F5 FF 3B FB |                 reti1
138ac 0fd             | 
138ac 0fd             | '------------------------------------------------------------------------------
138ac 0fd             | ' Wait for a window within the 1ms frame boundary that will ensure that a
138ac 0fd             | ' transaction will complete before the next frame is triggered.
138ac 0fd             | '------------------------------------------------------------------------------
138ac 0fd             | ' On entry:
138ac 0fd             | ' On exit:
138ac 0fd             | '------------------------------------------------------------------------------
138ac 0fd             | wait_txn_ok
138ac 0fd 1A 76 63 FD |                 getct   htmp2
138b0 0fe 49 77 83 F1 |                 sub     htmp2, iframe_ct_base
138b4 0ff 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
138b8 100 A1 77 1B C2 |         if_c    cmp     htmp2, _txn_ok_ls_      wcz
138bc 101 A2 77 1B 32 |         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
138c0 102 E8 FF 9F 1D |         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
138c4 103 2D 00 64 FD |                 ret
138c8 104             | 
138c8 104             | '------------------------------------------------------------------------------
138c8 104             | ' A device connection was detected, or a bus reset was requested by the USB
138c8 104             | ' client. Set the appropriate smart pin FS/LS speed mode to match the device
138c8 104             | ' and perform a reset sequence prior to device enumeration.
138c8 104             | '------------------------------------------------------------------------------
138c8 104             | dev_reset
138c8 104 22 A7 82 FA |                 rqpin   urx, dm
138cc 105 01 A6 16 F4 |                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
138d0 106 F4 03 B0 CD |         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
138d4 107 E0 03 B0 3D |         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
138d8 108             | reset
138d8 108 25 00 64 FD |                 setint1 #0                              ' Don't want frame interrupt while in reset
138dc 109 22 03 28 FC |                 wypin   #OUT_SE0, dm                    ' Assert bus reset
138e0 10a 1F 5C 63 FD |                 waitx   _reset_hold_                    ' Spec is >= 10ms
138e4 10b 22 01 28 FC |                 wypin   #OUT_IDLE, dm
138e8 10c 00 B2 06 F6 |                 mov     frame, #0                       ' Reset the frame timespan count
138ec 10d 1A 92 62 FD |                 getct   iframe_ct_base
138f0 10e 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
138f4 10f B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
138f8 110 59 73 03 F6 |                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
138fc 111 24 72 07 F1 |                 add     htmp, #36
13900 112 25 02 64 FD |                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
13904 113             | .framewait
13904 113 B9 B3 1A F2 |                 cmp     frame, htmp             wcz
13908 114 F8 FF 9F CD |         if_b    jmp     #.framewait
1390c 115 2D 00 64 FD |                 ret
13910 116             | 
13910 116             | '------------------------------------------------------------------------------
13910 116             | ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
13910 116             | '------------------------------------------------------------------------------
13910 116             | ' On entry:
13910 116             | '   PTRA - source address.
13910 116             | '   PB - destination address.
13910 116             | '   hr0 - length of copy, in bytes.
13910 116             | ' On exit:
13910 116             | '------------------------------------------------------------------------------
13910 116             | hmemcpy
13910 116 61 73 C7 FA |                 rdbyte  htmp, ptra++
13914 117 F7 73 43 FC |                 wrbyte  htmp, pb
13918 118 01 EE 07 F1 |                 add     pb, #1
1391c 119 FC 87 6F 0B |         _ret_   djnz    hr0, #hmemcpy
13920 11a             | 
13920 11a             | '------------------------------------------------------------------------------
13920 11a             | ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
13920 11a             | ' loop until the errant device is disconnected.
13920 11a             | '------------------------------------------------------------------------------
13920 11a             | ' On entry:
13920 11a             | ' On exit:
13920 11a             | '------------------------------------------------------------------------------
13920 11a             | host_error
13920 11a             |           if ERROR_LED >= 0
13920 11a             |           end
13920 11a A0 07 90 FD |                 jmp     #host_reset                     ' See if it works...
13924 11b             | 
13924 11b             | '------------------------------------------------------------------------------
13924 11b             | ' Get HID descriptor buffer for current port
13924 11b             | '------------------------------------------------------------------------------
13924 11b             | ' On entry:
13924 11b             | ' On exit:
13924 11b             | '   PB - HID descriptor buffer pointer
13924 11b             | '------------------------------------------------------------------------------
13924 11b             | get_hid_descr_buffer
13924 11b 2D EF 03 F6 |                 mov     pb, hdev_port
13928 11c 01 EE E7 F2 |                 cmpsub  pb, #1
1392c 11d 00 EF 07 FA |                 mul     pb, #HID_DESCR_LEN
13930 11e 25 EF 03 01 |         _ret_   add     pb, hid_descr_p
13934 11f             | 
13934 11f             | 
13934 11f 01 A0 00 00 | usb16_poly_r    long    USB16_POLY
13938 120             | 
13938 120             | ' USB commands and error codes
13938 120 00 00 00 00 | cmd_data        long    0
1393c 121 00 00 00 00 | usb_err_code    long    ERR_NONE
13940 122             | 
13940 122             | ' Parameters block assigned at cog startup
13940 122 12 00 00 00 | dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
13944 123 13 00 00 00 | dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
13948 124 11 00 00 00 | usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
1394c 125             | if ACTIVITY_LED >= 0
1394c 125             | host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
1394c 125             | end
1394c 125             | if ERROR_LED >= 0
1394c 125             | host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
1394c 125             | end
1394c 125 00 00 00 00 | hid_descr_p     long    0
13950 126             | 'hid_report_p    long    0, 0[MAX_DEVICES]
13950 126             | 'hkbd_report_p   long    0
13950 126 00 00 00 00 | hub_descr_p     long    0
13954 127 00 00 00 00 | urx_buff_p      long    0
13958 128 00 00 00 00 | dev_desc_buff_p long    0
1395c 129 00 00 00 00 | con_desc_buff_p long    0
13960 12a 00 00 00 00 | cache_start_p   long    0
13964 12b 00 00 00 00 | cache_end_p     long    0
13968 12c             | if EMUPAD_MAX_PLAYER > 0
13968 12c             | emupad_out_ptr  long    0
13968 12c             | end
13968 12c 00 00 00 00 | save_sysclk     long    0         ' Save the current sysclock as the client may change it
1396c 12d             | 
1396c 12d             | hdev_init_start
1396c 12d             | hdev_port       res     1
1396c 12d             | hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
1396c 12d             | kbm_next_datax  res     1
1396c 12d             | hub_intf_num    res     1
1396c 12d             | hub_next_datax  res     1
1396c 12d             | hub_status_chg  res     1
1396c 12d             | hub_port_status res     1
1396c 12d             | if HAVE_MOUSE
1396c 12d             | ms_intf_num     res     1
1396c 12d             | ms_in_max_pkt   res     1
1396c 12d             | end
1396c 12d             | kb_intf_num     res     1
1396c 12d             | kb_interval     res     1
1396c 12d             | kb_in_max_pkt   res     1
1396c 12d             | kb_max_index    res     1
1396c 12d             | kb_led_states   res     1
1396c 12d             | gp_intf_num     res     1
1396c 12d             | gp_interval     res     1
1396c 12d             | gp_max_index    res     1
1396c 12d             | gp_descr_len    res     1+MAX_DEVICES
1396c 12d             | hdev_init_end
1396c 12d             | 
1396c 12d             | ' Initialized at cog startup:
1396c 12d             | hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
1396c 12d             | iframe_ct_new   res     1
1396c 12d             | iframe_ct_base  res     1
1396c 12d             | utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
1396c 12d             | 
1396c 12d             | ' This register block is reset to zero when a USB device connects
1396c 12d             | hreg_init_start
1396c 12d             | hstatus         res     1         ' Host status flags
1396c 12d             | hctwait         res     1         ' Poll-based wait clocks
1396c 12d             | ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
1396c 12d             | tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
1396c 12d             | nak_retry       res     1         ' NAK retry count, unlimited retries if zero
1396c 12d             | xfer_retry      res     1         ' Control transfer retry count
1396c 12d             | retry           res     1         ' Transaction retry count
1396c 12d             | utx             res     1         ' Byte to transmit on USB
1396c 12d             | urx             res     1         ' LSByte receiver status flags, MSByte received data
1396c 12d             | newb_flg        res     1         ' Receive "new byte" bit toggle detector
1396c 12d             | max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
1396c 12d             | total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
1396c 12d             | stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
1396c 12d             | pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
1396c 12d             | frame           res     1         ' USB 1ms frame counter value
1396c 12d             | sof_pkt         res     1         ' ISR frame# packet and CRC5
1396c 12d             | icrc            res     1         ' Only used by the 1ms frame output ISR routine
1396c 12d             | pkt_cnt         res     1         ' Count of DATAx packet payload bytes
1396c 12d             | crc             res     1         ' Used for CRC16 calculation
1396c 12d             | ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
1396c 12d             | retval          res     1         ' Global success/fail return parameter
1396c 12d             | context_retval  res     1         ' Operation contextual return parameter
1396c 12d             | ' Device stuff
1396c 12d             | hdev_id         res     1+MAX_DEVICES
1396c 12d             | hdev_bcd        res     1
1396c 12d             | hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
1396c 12d             | ' Keyboard/mouse stuff
1396c 12d             | hctrl_ep_addr   res     1
1396c 12d             | hctrl_max_pkt   res     1
1396c 12d             | hconfig_base    res     1
1396c 12d             | hcon_tot_len    res     1         ' Size of the complete config descriptor chain
1396c 12d             | hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
1396c 12d             | hdev_class      res     1
1396c 12d             | hdev_subclass   res     1
1396c 12d             | hdev_protocol   res     1
1396c 12d             | hsearch_key     res     1         ' Descriptor type to search for in the config chain
1396c 12d             | hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
1396c 12d             | hhub_ctrl_ep    res     1         ' Hub control endpoint address
1396c 12d             | hhub_ep_addr    res     1         ' Hub interface endpoint address
1396c 12d             | hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
1396c 12d             | hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
1396c 12d             | if HAVE_MOUSE
1396c 12d             | hmouse_ep_addr  res     1 ' Mouse interface endpoint address
1396c 12d             | end
1396c 12d             | hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
1396c 12d             | hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
1396c 12d             | hdev_ep_addr    res     1+MAX_DEVICES
1396c 12d             | hdev_out_addr   res     1
1396c 12d             | 
1396c 12d             | if EMUPAD_MAX_PLAYER > 0
1396c 12d             | hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
1396c 12d             | hpad_emupad_buffer res EMUPAD_MAX_PLAYER
1396c 12d             | hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
1396c 12d             | end
1396c 12d             | 
1396c 12d             | hreg_init_end
1396c 12d             | 
1396c 12d             | hidr_start
1396c 12d             | hidr_usage      res     1 ' <- can get trashed after parsing
1396c 12d             | hidr_flags      res     1
1396c 12d             | hidr_axis       res     4
1396c 12d             | hidr_buttons    res     1
1396c 12d             | hidr_hats       res     1
1396c 12d             | '' Above are actually useful values, 6 longs
1396c 12d             | hidr_type       res     1
1396c 12d             | hidr_id         res     1
1396c 12d             | hidr_offset     res     1
1396c 12d             | hidr_usage_idx  res     1
1396c 12d             | ' below need to be push/pop'd
1396c 12d             | hidr_state      res     1
1396c 12d             | hidr_size       res     1
1396c 12d             | hidr_count      res     1
1396c 12d             | hidr_lminmax    res     1
1396c 12d             | hidr_pminmax    res     1
1396c 12d             | hidr_end
1396c 12d             | 
1396c 12d             | ' Variables dependent on the system freqency
1396c 12d             | _var_64_lower_  res     1
1396c 12d             | _var_64_upper_  res     1
1396c 12d             | _12Mbps_        res     1
1396c 12d             | _1_5Mbps_       res     1
1396c 12d             | _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
1396c 12d             | _1us_           res     1         ' 1us
1396c 12d             | _10us_          res     1         ' 10us
1396c 12d             | _33us_          res     1         ' 33us
1396c 12d             | _txn_err_       res     1         ' 250us
1396c 12d             | _500us_         res     1         ' 500us
1396c 12d             | _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
1396c 12d             | _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
1396c 12d             | _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
1396c 12d             | _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
1396c 12d             | _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
1396c 12d             | _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
1396c 12d             | _preamble_wait_ res     1
1396c 12d             | _1ms_           res     1         ' 1ms
1396c 12d             | _2ms_           res     1         ' 2ms
1396c 12d             | _suspend_wait_  res     1         ' 3ms
1396c 12d             | _4ms_           res     1         ' 4ms
1396c 12d             | _xfer_wait_     res     1         ' 5ms
1396c 12d             | _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
1396c 12d             | _reset_hold_    res     1         ' 15ms
1396c 12d             | _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
1396c 12d             | _21ms_          res     1         ' 21ms
1396c 12d             | _100ms_         res     1         ' 100ms
1396c 12d             | _500ms_         res     1         ' 500ms
1396c 12d             | _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
1396c 12d             | _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
1396c 12d             | '------------------------------------------------------------------------------
1396c 12d             | _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
1396c 12d             | _usb_d_ls_nco_  res     1
1396c 12d             | _usb_h_fs_nco_  res     1
1396c 12d             | _usb_d_fs_nco_  res     1
1396c 12d             | '------------------------------------------------------------------------------
1396c 12d             | ' Scratch registers
1396c 12d             | htmp            res     1         ' Scratch registers whose context remains within the same code block
1396c 12d             | htmp1           res     1
1396c 12d             | htmp2           res     1
1396c 12d             | htmp3           res     1
1396c 12d             | hrep            res     1         ' Repeat count
1396c 12d             | hsave0          res     1         ' Subroutine parameter saves
1396c 12d             | hsave1          res     1
1396c 12d             | hsave2          res     1
1396c 12d             | isrtmp1         res     1
1396c 12d             | pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
1396c 12d             | hr0             res     1         ' Multi-purpose registers
1396c 12d             | hr1             res     1
1396c 12d             | hr2             res     1
1396c 12d             | hr3             res     1
1396c 12d             | hpar1           res     1         ' Routine entry/exit parameters
1396c 12d             | hpar2           res     1
1396c 12d             | hpar3           res     1
1396c 12d             | hct2            res     1         ' Function response bus turn-around timer
1396c 12d             | hct3            res     1         ' Keyboard/mouse poll timer
1396c 12d             | mod_cnt         res     1         ' Used in idle loops
1396c 12d             | 
1396c 12d             |                 fit     $1F0
1396c 12d             |                 fit     $1F0
1396c 12d             |                 org     $200
1396c 200             | hlut_start
1396c 200             | 
1396c 200             | '------------------------------------------------------------------------------
1396c 200             | ' Full-speed is the host's native speed, so all that is needed is to set the FS
1396c 200             | ' settings to startup defaults.
1396c 200             | '------------------------------------------------------------------------------
1396c 200             | ' On entry:
1396c 200             | ' On exit: Save/restore caller C flag state if C is changed in this routine!
1396c 200             | '------------------------------------------------------------------------------
1396c 200             | set_speed_full
1396c 200 D0 E8 07 F6 |                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
13970 201 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
13974 202 A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
13978 203 A4 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
1397c 204             | '                ret                             wcz     ' Restore caller flags on exit
1397c 204             | 
1397c 204             | '------------------------------------------------------------------------------
1397c 204             | ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
1397c 204             | ' is a downstream hub connected (not yet implemented), the baud generator
1397c 204             | ' remains set at the full-speed rate, but signaling is switched to low-speed,
1397c 204             | ' which reverses the D-/D+ polarity. The polarity can be changed without
1397c 204             | ' putting the smart pins into reset.
1397c 204             | '------------------------------------------------------------------------------
1397c 204             | ' On entry:
1397c 204             | ' On exit: CZ flags restored to caller states
1397c 204             | '------------------------------------------------------------------------------
1397c 204             | set_speed_low
1397c 204 80 96 CE F7 |                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
13980 205 ED E8 07 A6 |         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
13984 206 22 6B 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
13988 207 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
1398c 208 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
13990 209 A3 9B 02 F6 |                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
13994 20a 02 96 26 F4 |                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
13998 20b 2D 00 7C FD |                 ret                             wcz     ' Restore caller flags on exit
1399c 20c             | 
1399c 20c             | '------------------------------------------------------------------------------
1399c 20c             | ' Perform configuration stuff required when a device intitially connects.
1399c 20c             | '------------------------------------------------------------------------------
1399c 20c             | ' On entry:
1399c 20c             | ' On exit:
1399c 20c             | '------------------------------------------------------------------------------
1399c 20c             | on_connect
1399c 20c 02 86 07 F6 |                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
139a0 20d D8 FB BF FD |                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
139a4 20e             | .retry
139a4 20e 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
139a8 20f 01 8E 07 C6 |         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
139ac 210 02 8E 07 36 |         if_nc   mov     hpar1, #USB_SPEED_FULL
139b0 211 00 08 00 FF 
139b4 212 00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
139b8 213 20 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
139bc 214 47 F1 03 F1 |                 add     ptra, hcog_base_addr
139c0 215 03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
139c4 216 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
139c8 217 F4 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
139cc 218 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
139d0 219 18 00 90 AD |         if_z    jmp     #.get_dev_desc
139d4 21a B2 99 02 F6 |                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
139d8 21b 4C 03 B0 FD |                 call    #poll_waitx
139dc 21c 01 86 8F F1 |                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
139e0 21d F0 FB 9F AD |         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
139e4 21e A4 FB BF FD |                 call    #reset                          ' Try another reset to see if the device responds
139e8 21f B8 FF 9F FD |                 jmp     #.retry
139ec 220             | .get_dev_desc
139ec 220 28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
139f0 221 07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
139f4 222 F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
139f8 223 A8 99 02 F6 |                 mov     hctwait, _1ms_
139fc 224 28 03 B0 FD |                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
13a00 225 88 FB BF FD |                 call    #reset
13a04 226 38 1E C0 FE |                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
13a08 227 47 F1 03 F1 |                 add     ptra, hcog_base_addr
13a0c 228 01 11 5C FC |                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
13a10 229 D8 01 B0 FD |                 call    #control_write                  ' Execute SetAddress()
13a14 22a D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13a18 22b 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
13a1c 22c AD 99 02 F6 |                 mov     hctwait, _8ms_
13a20 22d 04 03 B0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
13a24 22e 04 00 00 FF 
13a28 22f 00 BC 06 F6 |                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
13a2c 230 34 FA BF FD |                 call    #calc_crc5
13a30 231 20 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
13a34 232 47 F1 03 F1 |                 add     ptra, hcog_base_addr
13a38 233 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
13a3c 234 F7 AD C2 FA |                 rdbyte  total_data, pb
13a40 235 03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
13a44 236 78 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
13a48 237 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13a4c 238 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
13a50 239 5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
13a54 23a 28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
13a58 23b 07 DB C6 FA |                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
13a5c 23c A0 99 02 F6 |                 mov     hctwait, _500us_
13a60 23d C4 02 B0 FD |                 call    #poll_waitx
13a64 23e 28 1E C0 FE |                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
13a68 23f 47 F1 03 F1 |                 add     ptra, hcog_base_addr
13a6c 240 03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
13a70 241 29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
13a74 242 48 00 B0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
13a78 243 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13a7c 244 2D 00 64 5D |         if_nz   ret
13a80 245 29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
13a84 246 F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
13a88 247 61 87 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
13a8c 248 61 89 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
13a90 249 00 73 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
13a94 24a 09 86 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
13a98 24b 02 88 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
13a9c 24c 56 73 1B A2 |         if_z    cmp     htmp, total_data        wcz
13aa0 24d 0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
13aa4 24e 2C FB 9F CD |         if_b    jmp     #host_error
13aa8 24f 24 13 80 FE |                 loc     pa, #@init_kbdm_data - @usb_host_start
13aac 250 47 ED 03 F1 |                 add     pa, hcog_base_addr
13ab0 251 2D EC 63 FD |                 call    pa
13ab4 252 B8 0D 80 FE |                 loc     pa, #@hparse_con_desc - @usb_host_start
13ab8 253 47 ED 03 F1 |                 add     pa, hcog_base_addr
13abc 254 2C EC 63 FD |                 jmp     pa
13ac0 255             | 
13ac0 255             | '------------------------------------------------------------------------------
13ac0 255             | ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
13ac0 255             | ' Status reporting is always in the function-to-host direction.
13ac0 255             | '------------------------------------------------------------------------------
13ac0 255             | ' On entry:
13ac0 255             | '   PTRA - start address of the SETUP data in hub.
13ac0 255             | '   PB - start address of the buffer/struct to be written to during the IN data
13ac0 255             | '     stage.
13ac0 255             | '   ep_addr_pid - device address, endpoint and CRC5.
13ac0 255             | ' On exit:
13ac0 255             | '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
13ac0 255             | '     contains the count of data stage bytes actually received, which must
13ac0 255             | '     always be <= the count requested.
13ac0 255             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
13ac0 255             | '     more specific USB operation error code.
13ac0 255             | '------------------------------------------------------------------------------
13ac0 255             | control_read
13ac0 255 5E 8F 03 F6 |                 mov     hpar1, ep_addr_pid
13ac4 256 F8 91 03 F6 |                 mov     hpar2, ptra
13ac8 257 F7 93 03 F6 |                 mov     hpar3, pb                       ' Save dest buffer pointer
13acc 258 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
13ad0 259             | .xfer_start
13ad0 259 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
13ad4 25a C0 F6 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
13ad8 25b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13adc 25c 2D 00 64 5D |         if_nz   ret                                     ' Back to caller to handle error
13ae0 25d 00 AC 0E F2 |                 cmp     total_data, #0          wz
13ae4 25e 90 01 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
13ae8 25f 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
13aec 260 61 00 00 FF 
13af0 261 50 9F 06 F6 |                 mov     nak_retry, ##IN_NAK_RETRIES
13af4 262 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
13af8 263             | .data
13af8 263 56 B1 02 F6 |                 mov     pkt_data, total_data
13afc 264 57 B1 82 F1 |                 sub     pkt_data, stage_data
13b00 265 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
13b04 266 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
13b08 267             | .nak_retry
13b08 267 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
13b0c 268             | .in_retry
13b0c 268 BC F6 BF FD |                 call    #txn_in
13b10 269 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
13b14 26a 28 00 90 AD |         if_z    jmp     #.commit
13b18 26b 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
13b1c 26c A8 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
13b20 26d 14 02 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
13b24 26e 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
13b28 26f DC FF 9F AD |         if_z    jmp     #.nak_retry                     ' Function not ready to send data
13b2c 270 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
13b30 271 94 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
13b34 272 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
13b38 273 D0 FF 9F 5D |         if_nz   jmp     #.in_retry                      ' Bus error retry
13b3c 274 2D 00 64 FD |                 ret                                     ' The transfer has failed
13b40 275             | .commit
13b40 275 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
13b44 276 38 00 90 AD |         if_z    jmp     #.pre_status                    ' and also end-of-data
13b48 277 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
13b4c 278 5C 87 03 F6 |                 mov     hr0, pkt_cnt
13b50 279 F7 F1 0B F2 |                 cmp     ptra, pb                wz
13b54 27a 6C FA BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
13b58 27b 5C AF 02 F1 |                 add     stage_data, pkt_cnt             ' Update bytes received on commit
13b5c 27c 56 AF 0A F2 |                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
13b60 27d 1C 00 90 AD |         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
13b64 27e 58 B9 1A F2 |                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
13b68 27f 14 00 90 CD |         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
13b6c 280 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET
13b70 281 5F C1 02 16 |         if_a    mov     context_retval, retval          ' In this case overall and context are the same
13b74 282 2D 00 64 1D |         if_a    ret                                     ' Caller must handle ERR_PACKET
13b78 283 03 96 E6 F4 |                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
13b7c 284 78 FF 9F FD |                 jmp     #.data                          ' Start next IN transaction
13b80 285             | .pre_status
13b80 285 57 AD 02 F6 |                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
13b84 286 E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0
13b88 287 00 B0 06 F6 |                 mov     pkt_data, #0
13b8c 288 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
13b90 289 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
13b94 28a 61 00 00 FF 
13b98 28b 50 9F 06 F6 |                 mov     nak_retry, ##OUT_NAK_RETRIES
13b9c 28c             | .out_retry
13b9c 28c 34 F7 BF FD |                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
13ba0 28d D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13ba4 28e 2D 00 64 AD |         if_z    ret                                     ' All is good when ACK
13ba8 28f 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
13bac 290 18 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
13bb0 291 84 01 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
13bb4 292 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
13bb8 293 0C 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
13bbc 294 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
13bc0 295 D8 FF 9F 5D |         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
13bc4 296 2D 00 64 FD |                 ret                                     ' Caller must handle transfer retirement
13bc8 297             | ' I've encountered transfer STALL, even though the data looks correct, and
13bc8 297             | ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
13bc8 297             | ' ControlRead() transfer gets things unstuck most of the time...
13bc8 297             | .xfer_retry
13bc8 297 AC 99 02 F6 |                 mov     hctwait, _xfer_wait_
13bcc 298 58 01 B0 FD |                 call    #poll_waitx
13bd0 299 8C F9 BF FD |                 call    #wait_txn_ok
13bd4 29a C7 BD 02 F6 |                 mov     ep_addr_pid, hpar1
13bd8 29b C8 F1 03 F6 |                 mov     ptra, hpar2
13bdc 29c C9 EF 03 F6 |                 mov     pb, hpar3
13be0 29d BB A1 6E FB |                 djnz    xfer_retry, #.xfer_start
13be4 29e 5F C1 02 F6 |                 mov     context_retval, retval          ' Preserve the USB error code
13be8 29f 07 BE 06 06 |         _ret_   mov     retval, #ERR_XFER_RETRY
13bec 2a0             | 
13bec 2a0             | '------------------------------------------------------------------------------
13bec 2a0             | ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
13bec 2a0             | ' reporting is always in the function-to-host direction. It is assumed that
13bec 2a0             | ' the SETUP data struct is filled with the required values.
13bec 2a0             | '------------------------------------------------------------------------------
13bec 2a0             | ' On entry:
13bec 2a0             | '   PTRA - points to the start of the struct for the SETUP data.
13bec 2a0             | '   PB - the start address of the struct/buffer to be read for the OUT data
13bec 2a0             | '     stage.
13bec 2a0             | '   ep_addr_pid - the proper CRC'd address and endpoint to use.
13bec 2a0             | ' On exit:
13bec 2a0             | '   retval - used to convey the success/failure of each stage.
13bec 2a0             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
13bec 2a0             | '     more specific USB operation error code.
13bec 2a0             | '------------------------------------------------------------------------------
13bec 2a0             | control_write
13bec 2a0 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
13bf0 2a1 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
13bf4 2a2 0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
13bf8 2a3             | 
13bf8 2a3 5E 8F 03 F6 |                 mov     hpar1, ep_addr_pid
13bfc 2a4 F8 91 03 F6 |                 mov     hpar2, ptra
13c00 2a5 F7 93 03 F6 |                 mov     hpar3, pb
13c04 2a6 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
13c08 2a7             | .xfer_start
13c08 2a7 00 9E 06 F6 |                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
13c0c 2a8 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
13c10 2a9 84 F5 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
13c14 2aa D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13c18 2ab EC 00 90 5D |         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
13c1c 2ac 00 AC 0E F2 |                 cmp     total_data, #0          wz
13c20 2ad 54 00 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
13c24 2ae 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
13c28 2af E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
13c2c 2b0 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
13c30 2b1 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
13c34 2b2             | .data
13c34 2b2 56 B1 02 F6 |                 mov     pkt_data, total_data
13c38 2b3 57 B1 82 F1 |                 sub     pkt_data, stage_data
13c3c 2b4 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
13c40 2b5 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
13c44 2b6             | .out_retry
13c44 2b6 F7 F1 03 F6 |                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
13c48 2b7 88 F6 BF FD |                 call    #txn_out
13c4c 2b8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13c50 2b9 10 00 90 AD |         if_z    jmp     #.commit                        ' Function got the data
13c54 2ba E0 00 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
13c58 2bb 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
13c5c 2bc E4 FF 9F 5D |         if_nz   jmp     #.out_retry
13c60 2bd A4 00 90 FD |                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
13c64 2be             | .commit
13c64 2be F8 EF 03 F6 |                 mov     pb, ptra                        ' Save the current buffer/struct location
13c68 2bf 58 AF 02 F1 |                 add     stage_data, pkt_data
13c6c 2c0 56 AF 0A F2 |                 cmp     stage_data, total_data  wz
13c70 2c1 03 96 E6 54 |         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
13c74 2c2 BC FF 9F 5D |         if_nz   jmp     #.data                          ' More data to send
13c78 2c3             | pre_status_in
13c78 2c3 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
13c7c 2c4 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
13c80 2c5             | .status_retry
13c80 2c5 00 B0 06 F6 |                 mov     pkt_data, #0
13c84 2c6 44 F5 BF FD |                 call    #txn_in
13c88 2c7 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
13c8c 2c8 00 B0 0E A2 |         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
13c90 2c9 74 00 90 AD |         if_z    jmp     #dwnstream_reset                ' Control Write finished
13c94 2ca 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
13c98 2cb 2D 00 64 AD |         if_z    ret
13c9c 2cc 98 00 B0 FD |                 call    #retry_wait                     ' NAK or bus error, so delay a bit
13ca0 2cd 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
13ca4 2ce D8 FF 9F 5D |         if_nz   jmp     #.status_retry
13ca8 2cf             | '               ret                                     ' Caller must handle transfer retirement
13ca8 2cf             | 
13ca8 2cf             | '------------------------------------------------------------------------------
13ca8 2cf             | ' Execute an IN interrupt transaction.
13ca8 2cf             | '------------------------------------------------------------------------------
13ca8 2cf             | ' On entry:
13ca8 2cf             | '   ep_addr_pid - The function address and endpoint for the IN request.
13ca8 2cf             | '   hpar2 - Address of the IN data buffer
13ca8 2cf             | '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
13ca8 2cf             | ' On exit:
13ca8 2cf             | '   retval - the result of the operation.
13ca8 2cf             | '   hpar3 - the count of IN data bytes actually received.
13ca8 2cf             | '------------------------------------------------------------------------------
13ca8 2cf             | do_int_in
13ca8 2cf 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
13cac 2d0 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
13cb0 2d1 0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
13cb4 2d2             | 
13cb4 2d2 C9 73 33 F9 |                 getword htmp, hpar3, #0
13cb8 2d3 C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz
13cbc 2d4 03 96 A6 F4 |                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
13cc0 2d5 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES
13cc4 2d6             | .retry
13cc4 2d6 C9 B1 3A F9 |                 getword pkt_data, hpar3, #1             ' IN max packet length
13cc8 2d7 00 F5 BF FD |                 call    #txn_in
13ccc 2d8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK if data received
13cd0 2d9 1C 00 90 AD |         if_z    jmp     #.commit
13cd4 2da 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
13cd8 2db 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
13cdc 2dc 24 00 90 AD |         if_z    jmp     #.post_ret                      ' The caller must handle either
13ce0 2dd 54 00 B0 FD |                 call    #retry_wait
13ce4 2de 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
13ce8 2df 18 00 90 AD |         if_z    jmp     #.post_ret
13cec 2e0 D4 FF 9F FD |                 jmp     #.retry
13cf0 2e1             | .commit
13cf0 2e1 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy the rx buffer
13cf4 2e2 C8 EF 03 F6 |                 mov     pb, hpar2                       ' to the destination buffer
13cf8 2e3 5C 87 0B F6 |                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
13cfc 2e4 F7 F1 0B 52 |         if_nz   cmp     ptra, pb                wz
13d00 2e5 C0 F8 BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
13d04 2e6             | .post_ret
13d04 2e6 5C 93 03 F6 |                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
13d08 2e7             | 
13d08 2e7             | 
13d08 2e7             | '------------------------------------------------------------------------------
13d08 2e7             | ' Resets the downstream hub port to FS
13d08 2e7             | '------------------------------------------------------------------------------
13d08 2e7             | dwnstream_reset
13d08 2e7 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
13d0c 2e8 2D 00 64 3D |         if_nc   ret                                     ' No LS device, reset not needed
13d10 2e9             | 
13d10 2e9 0E 6A 07 F4 |                 bitl    _usb_h_ls_nco_, #14
13d14 2ea 07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
13d18 2eb 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
13d1c 2ec 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
13d20 2ed A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
13d24 2ee A4 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
13d28 2ef             | 
13d28 2ef             | '------------------------------------------------------------------------------
13d28 2ef             | ' The one millisecond frame timer is implemented as an interrupt service
13d28 2ef             | ' routine. Since this timing is critical, care must be taken to avoid any
13d28 2ef             | ' instructions that can delay the interrupt branch, which will likely upset
13d28 2ef             | ' the timer. WAITX is among those instructions, so any time you're inside
13d28 2ef             | ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
13d28 2ef             | '------------------------------------------------------------------------------
13d28 2ef             | ' On entry:
13d28 2ef             | '   hctwait - wait interval in sysclocks.
13d28 2ef             | ' On exit:
13d28 2ef             | '------------------------------------------------------------------------------
13d28 2ef             | poll_waitx
13d28 2ef 1A 94 63 FD |                 getct   hct2
13d2c 2f0 4C 95 6B FA |                 addct2  hct2, hctwait
13d30 2f1             | .wait
13d30 2f1 FF 25 CC FB |                 jnct2   #.wait
13d34 2f2 2D 00 64 FD |                 ret
13d38 2f3             | 
13d38 2f3             | '------------------------------------------------------------------------------
13d38 2f3             | ' Transaction retry handling for NAK/STALL or bus error.
13d38 2f3             | '------------------------------------------------------------------------------
13d38 2f3             | ' On entry:
13d38 2f3             | '   retval - transaction response PID or error code.
13d38 2f3             | ' On exit:
13d38 2f3             | '------------------------------------------------------------------------------
13d38 2f3             | retry_wait
13d38 2f3 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
13d3c 2f4 2D 00 64 AD |         if_z    ret                                     ' STALL is special case
13d40 2f5 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
13d44 2f6 14 00 90 AD |         if_z    jmp     #.nak
13d48 2f7 9F 99 02 F6 |                 mov     hctwait, _txn_err_              ' Transaction error wait...
13d4c 2f8 D8 FF BF FD |                 call    #poll_waitx
13d50 2f9             | .dec
13d50 2f9 01 A2 8E F1 |                 sub     retry, #1               wz
13d54 2fa 06 BE 06 A6 |         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
13d58 2fb 2D 00 64 FD |                 ret                                     ' Retry result to caller
13d5c 2fc             | .nak
13d5c 2fc 9E 99 02 F6 |                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
13d60 2fd C4 FF BF FD |                 call    #poll_waitx
13d64 2fe 00 9E 0E F2 |                 cmp     nak_retry, #NAK_NOLIMIT wz
13d68 2ff 2D 00 64 AD |         if_z    ret                                     ' Indefinite NAK retries
13d6c 300 01 9E 8E F1 |                 sub     nak_retry, #1           wz
13d70 301 08 BE 06 A6 |         if_z    mov     retval, #ERR_NAK
13d74 302 2D 00 64 FD |                 ret
13d78 303             | 
13d78 303             | host_reset
13d78 303 25 00 64 FD |                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
13d7c 304 14 72 07 FB |                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
13d80 305             | ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
13d80 305 BD 01 05 FF 
13d84 306 00 72 1F F2 |                 cmp     htmp, ##168_000_000     wcz
13d88 307 00 94 06 E6 |         if_be   mov     utx_tweak, #0
13d8c 308 03 94 06 16 |         if_a    mov     utx_tweak, #3   '#20
13d90 309             | ' Check to see if the system clock has been changed.
13d90 309 2C 73 0B F2 |                 cmp     htmp, save_sysclk       wz
13d94 30a C4 0B A0 5E |         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
13d98 30b 47 EF 03 51 |         if_nz   add     pb, hcog_base_addr
13d9c 30c 2D EE 63 5D |         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
13da0 30d 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
13da4 30e 40 46 62 FD |                 dirl    dp
13da8 30f             | 
13da8 30f 28 02 64 FD |                 setq    #1
13dac 310 80 00 80 FF 
13db0 311 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
13db4 312 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
13db8 313             | .enable
13db8 313 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
13dbc 314 41 46 62 FD |                 dirh    dp
13dc0 315 1F 38 63 FD |                 waitx   _1us_
13dc4 316 22 01 28 FC |                 wypin   #OUT_IDLE, dm
13dc8 317             | 
13dc8 317             |                 ' Handle Port protection enable and startup delay
13dc8 317 00 48 56 F2 |                 cmps    usb_enable_pin, #0      wc
13dcc 318 58 48 62 3D |         if_ae   drvl    usb_enable_pin                 ' disable port
13dd0 319 1F 60 63 FD |                 waitx   _21ms_                          ' Wait a while for everything to turn off
13dd4 31a 59 48 62 3D |         if_ae   drvh    usb_enable_pin                  ' Enable the port
13dd8 31b 1F 60 63 FD |                 waitx   _21ms_                          ' Hold to let the idle state get settled
13ddc 31c             | 
13ddc 31c             |                 'call #dev_reset ' TODO THINK ABOUT THIS
13ddc 31c             | 
13ddc 31c             | discon_entry
13ddc 31c 03 98 07 F6 |                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
13de0 31d             | 
13de0 31d 4B ED B7 F9 |                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
13de4 31e 3B 04 DC FC |                 rep     @.regloop,#hreg_init_end - hreg_init_start
13de8 31f 38 EC A7 F9 |                 alti    pa, #%000_111_000
13dec 320 00 00 04 F6 |                 mov     0-0, #0
13df0 321             | .regloop
13df0 321             |               
13df0 321             |         if HAVE_HIDPAD
13df0 321 F8 27 A0 FE |                 loc     pb, #@hidpad_report - @usb_host_start
13df4 322 47 EF 03 F1 |                 add     pb, hcog_base_addr
13df8 323 28 6E 64 FD |                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
13dfc 324 F7 01 68 FC |                 wrlong  #0,pb
13e00 325             |         end
13e00 325             |         if EMUPAD_MAX_PLAYER > 0
13e00 325             |         end
13e00 325             | 
13e00 325             |                 ' Fall through to disconnected loop
13e00 325             | 
13e00 325             | '-----------------------------------------------------------------------------------------------------------------
13e00 325             | ' Device connect handling (Section 7.1.7.3).
13e00 325             | '-----------------------------------------------------------------------------------------------------------------
13e00 325             | ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
13e00 325             | ' device to connect (Section 7.1.7.3).
13e00 325             | '-----------------------------------------------------------------------------------------------------------------
13e00 325             | disconnected
13e00 325 14 88 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
13e04 326 2C 89 0B F2 |                 cmp     hr1, save_sysclk        wz
13e08 327 6C FF 9F 5D |         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
13e0c 328 03 88 47 F0 |                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
13e10 329 1F 88 63 FD |                 waitx   hr1                             ' it down to smaller wait chunks
13e14 32a             |         if ACTIVITY_LED >= 0
13e14 32a             |         end
13e14 32a 22 A7 82 FA |                 rqpin   urx, dm
13e18 32b 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
13e1c 32c E0 FF 9F AD |         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
13e20 32d 28 00 90 5D |         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
13e24 32e             | .se1_test
13e24 32e B1 99 02 F6 |                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
13e28 32f FC FE BF FD |                 call    #poll_waitx
13e2c 330 22 A7 82 FA |                 rqpin   urx, dm
13e30 331 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
13e34 332 00 BE 06 56 |         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
13e38 333 A0 FF 9F 5D |         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
13e3c 334             | .se1            'SE1 is a fatal error condition
13e3c 334 B1 99 02 F6 |                 mov     hctwait, _100ms_
13e40 335 E4 FE BF FD |                 call    #poll_waitx
13e44 336 03 BE 06 F6 |                 mov     retval, #ERR_SE1
13e48 337 88 F7 BF FD |                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
13e4c 338             | .connect_test                                           ' Test lines until stable J/K state seen
13e4c 338 1F 62 63 FD |                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
13e50 339 22 A7 82 FA |                 rqpin   urx, dm
13e54 33a 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
13e58 33b 80 FF 9F AD |         if_z    jmp     #discon_entry                   ' D+ and D- low
13e5c 33c C4 FF 9F AD |         if_e    jmp     #.se1_test                      ' D+ and D- high
13e60 33d             | connected
13e60 33d 01 96 26 F4 |                 bith    hstatus, #CONNECTEDB            ' Device plugged in
13e64 33e 34 FB BF FD |                 call    #on_connect                     ' Initial device configuration
13e68 33f D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
13e6c 340 6C FF 9F 5D |         if_nz   jmp     #discon_entry
13e70 341             | .set_pulse
13e70 341 1A 66 63 FD |                 getct   _pulse_time_
13e74 342 B2 67 03 F1 |                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
13e78 343             | ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
13e78 343             | ' of 1ms and make a correction, if necessary.
13e78 343             | '                mov     htmp, _1ms_
13e78 343             | '                subs    htmp, iframe_delta
13e78 343             | '                adds    _frame1ms_clks_, htmp
13e78 343             | '                debug(udec(_frame1ms_clks_))
13e78 343             | 
13e78 343             |                 ' Fall through to idle/processing loop
13e78 343 07 5A 1E F2 |                 cmp     hdev_port, #MAX_DEVICES wcz
13e7c 344 00 5A 06 16 |         if_a    mov     hdev_port, #0 
13e80 345             | 
13e80 345             | hidle
13e80 345 22 A7 82 FA |                 rqpin   urx, dm
13e84 346 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
13e88 347 98 00 90 CD |         if_c    jmp     #.se0_test
13e8c 348 24 06 70 FD |                 pollct3                         wc
13e90 349 68 00 90 3D |         if_nc   jmp     #.nopoll
13e94 34a 1A 96 63 FD |                 getct   hct3
13e98 34b A8 97 73 FA |                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
13e9c 34c             | 
13e9c 34c 6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
13ea0 34d 00 72 E3 F8 |                 getbyte htmp
13ea4 34e             | 
13ea4 34e 09 72 0F F2 |                 cmp     htmp, #HUB_READY        wz
13ea8 34f 8C 1B 80 AE |         if_z    loc     pa, #@hget_hub_status - @usb_host_start
13eac 350 40 00 90 AD |         if_z    jmp     #.poll
13eb0 351             | 
13eb0 351             |         if _HAVE_GAMEPAD
13eb0 351 06 72 0F F2 |                 cmp     htmp, #HID_READY        wz
13eb4 352 08 72 0F 52 |         if_nz   cmp     htmp, #PS3_READY        wz
13eb8 353 07 72 0F 52 |         if_nz   cmp     htmp, #XINPUT_READY     wz
13ebc 354 F4 15 80 AE |         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
13ec0 355 2C 00 90 AD |         if_z    jmp     #.poll
13ec4 356             |         end
13ec4 356             | 
13ec4 356             |         if HAVE_MOUSE
13ec4 356 04 72 0F F2 |                 cmp     htmp, #M_READY          wz
13ec8 357 44 15 80 AE |         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
13ecc 358 20 00 90 AD |         if_z    jmp     #.poll
13ed0 359             |         end
13ed0 359             | 
13ed0 359 03 72 0F F2 |                 cmp     htmp, #KB_READY         wz
13ed4 35a AC 13 80 AE |         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
13ed8 35b 14 00 90 AD |         if_z    jmp     #.poll
13edc 35c             | 
13edc 35c 05 72 0F F2 |                 cmp     htmp, #KBM_READY        wz
13ee0 35d 14 00 90 5D |         if_nz   jmp     #.skip_poll
13ee4 35e 09 96 FE F4 |                 bitnot  hstatus, #KBM_TOGGLEB   wcz
13ee8 35f AC 13 80 3E |         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
13eec 360             |         if HAVE_MOUSE
13eec 360 44 15 80 CE |         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
13ef0 361             |         else
13ef0 361             |         end
13ef0 361             | 
13ef0 361             | .poll
13ef0 361 47 ED 03 F1 |                 add     pa, hcog_base_addr
13ef4 362 2D EC 63 FD |                 call    pa
13ef8 363             | .skip_poll
13ef8 363             | 
13ef8 363 07 5A 06 F7 |                 incmod  hdev_port, #MAX_DEVICES
13efc 364             | 
13efc 364             | .nopoll
13efc 364 0E 40 0E F2 |                 cmp     cmd_data, #CMD_SUSPEND  wz
13f00 365 44 00 90 AD |         if_z    jmp     #hsuspend
13f04 366 10 40 0E F2 |                 cmp     cmd_data, #CMD_RESET    wz
13f08 367 00 40 06 A6 |         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
13f0c 368 68 FE 9F AD |         if_z    jmp     #host_reset                     ' See if it works...
13f10 369 1A 86 63 FD |                 getct   hr0
13f14 36a B3 87 1B F2 |                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
13f18 36b             |         if ACTIVITY_LED >= 0
13f18 36b             |         end
13f18 36b 1A 66 63 3D |         if_ae   getct   _pulse_time_
13f1c 36c B2 67 03 31 |         if_ae   add     _pulse_time_, _500ms_
13f20 36d 5C FF 9F FD |                 jmp     #hidle
13f24 36e             | ' Check for extended SE0 state on the bus
13f24 36e             | .se0_test
13f24 36e A8 99 02 F6 |                 mov     hctwait, _1ms_
13f28 36f FC FD BF FD |                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
13f2c 370 22 A7 82 FA |                 rqpin   urx, dm
13f30 371 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
13f34 372 48 FF 9F 3D |         if_nc   jmp     #hidle                          ' Bus still IDLE
13f38 373 24 F6 BF FD |                 call    #wait_txn_ok
13f3c 374 00 00 80 FF 
13f40 375 22 01 28 FC |                 wypin   ##OUT_IDLE, dm                  ' Float USB
13f44 376             |                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
13f44 376 94 FE 9F FD |                 jmp     #discon_entry                   ' Device disconnected
13f48 377             | 
13f48 377             | hsuspend
13f48 377 14 F6 BF FD |                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
13f4c 378 25 00 64 FD |                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
13f50 379 1F 54 63 FD |                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
13f54 37a 22 01 28 FC |                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
13f58 37b 00 40 06 F6 |                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
13f5c 37c 00 98 07 F6 |                 mov     mod_cnt, #0
13f60 37d             | 
13f60 37d             |                 ' Fall through to resume wait loop
13f60 37d             | 
13f60 37d             | hwait_resume
13f60 37d 14 88 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
13f64 37e 02 88 47 F0 |                 shr     hr1, #2
13f68 37f 1F 88 63 FD |                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
13f6c 380             |         if ACTIVITY_LED >= 0
13f6c 380             |         end
13f6c 380 0F 40 0E F2 |                 cmp     cmd_data, #CMD_RESUME   wz
13f70 381 EC FF 9F 5D |         if_nz   jmp     #hwait_resume
13f74 382 14 72 07 FB |                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
13f78 383 2C 73 0B F2 |                 cmp     htmp, save_sysclk       wz
13f7c 384 18 00 90 AD |         if_z    jmp     #.resume
13f80 385 C4 0B A0 FE |                 loc     pb, #@hinit_usb_timings - @usb_host_start
13f84 386 47 EF 03 F1 |                 add     pb, hcog_base_addr
13f88 387 2D EE 63 FD |                 call    pb                              ' Recalculate sysclk dependent timing values
13f8c 388 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
13f90 389 22 6F 13 3C |         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
13f94 38a 22 6B 13 CC |         if_c    wxpin   _usb_h_ls_nco_, dm
13f98 38b             | .resume
13f98 38b 22 05 28 FC |                 wypin   #OUT_K, dm
13f9c 38c 1F 5E 63 FD |                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
13fa0 38d 22 03 28 FC |                 wypin   #OUT_SE0, dm
13fa4 38e A3 73 03 F6 |                 mov     htmp, _ip_delay_ls_
13fa8 38f 01 72 47 F0 |                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
13fac 390 1F 72 63 FD |                 waitx   htmp
13fb0 391 22 07 28 FC |                 wypin   #OUT_J, dm
13fb4 392 01 72 47 F0 |                 shr     htmp, #1
13fb8 393 1F 72 63 FD |                 waitx   htmp
13fbc 394 22 01 28 FC |                 wypin   #OUT_IDLE, dm
13fc0 395 1A 92 62 FD |                 getct   iframe_ct_base
13fc4 396 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
13fc8 397 B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
13fcc 398 25 02 64 FD |                 setint1 #1                              ' Enable the 1ms frame ISR
13fd0 399 AB 99 02 F6 |                 mov     hctwait, _4ms_
13fd4 39a 50 FD BF FD |                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
13fd8 39b 00 40 06 06 |         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
13fdc 39c             | 
13fdc 39c             | '------------------------------------------------------------------------------
13fdc 39c             | ' Send preamble to enable low-speed HUB ports
13fdc 39c             | '------------------------------------------------------------------------------
13fdc 39c             | ' On entry:
13fdc 39c             | ' On exit:
13fdc 39c             | '   USB baud rate set to low-speed
13fdc 39c             | '------------------------------------------------------------------------------
13fdc 39c             | utx_pre
13fdc 39c 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
13fe0 39d 40 46 62 FD |                 dirl    dp
13fe4 39e 28 02 64 FD |                 setq    #1
13fe8 39f 22 01 08 FC |                 wrpin   #0, dm                          ' Disable smartpin mode
13fec 3a0 58 44 62 FD |                 drvl    dm
13ff0 3a1 59 46 62 FD |                 drvh    dp
13ff4 3a2             | 
13ff4 3a2 1E 00 00 FF 
13ff8 3a3 80 72 07 F6 |                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
13ffc 3a4             | 
13ffc 3a4 11 08 DC FC |                 rep     @.l1, #16 + 1
14000 3a5 01 72 57 F0 |                 shr     htmp, #1        wc
14004 3a6 28 02 64 3D |         if_nc   setq    #1
14008 3a7 4F 44 62 3D |         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
1400c 3a8 1F 4E 63 FD |                 waitx   _preamble_wait_
14010 3a9             | .l1
14010 3a9             | 
14010 3a9 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
14014 3aa 40 46 62 FD |                 dirl    dp
14018 3ab 28 02 64 FD |                 setq    #1
1401c 3ac 80 00 80 FF 
14020 3ad 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
14024 3ae 22 6B 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
14028 3af 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
1402c 3b0 41 46 62 FD |                 dirh    dp
14030 3b1 22 01 28 FC |                 wypin   #OUT_IDLE, dm
14034 3b2             | 
14034 3b2 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
14038 3b3 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
1403c 3b4 A3 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
14040 3b5             | 
14040 3b5             | hlut_end
14040 3b5             |                 fit     $400
14040 3b5             |                 fit     $400
14040 3b5             |                 orgh
14040                 | if OVERLAP_MEMORY
14040                 |                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
14040                 | end
14040                 | '------------------------------------------------------------------------------
14040                 | ' Routines called from cog space.
14040                 | '------------------------------------------------------------------------------
14040                 | ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
14040                 | '------------------------------------------------------------------------------
14040                 | 
14040                 | '------------------------------------------------------------------------------
14040                 | ' USB host cog initialization.
14040                 | '------------------------------------------------------------------------------
14040                 | usb_host_init
14040                 |                 ' Initialize buffer pointers
14040                 |         if OVERLAP_MEMORY
14040                 |         else
14040     4C 15 B0 FE |                 loc     pb, #hid_descr
14044                 |         end
14044     F7 4B 02 F6 |                 mov     hid_descr_p, pb
14048                 |                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
14048                 |                 {
14048                 |                 }
14048                 |         
14048                 |                 {
14048                 |                 }
14048                 |                 'loc     pb,#hkbd_report
14048                 |                 'mov     hkbd_report_p,pb
14048                 | 
14048     44 1D B0 FE |                 loc     pb, #hub_descr
1404c     F7 4D 02 F6 |                 mov     hub_descr_p, pb
14050     59 1D B0 FE |                 loc     pb, #urx_buff
14054     F7 4F 02 F6 |                 mov     urx_buff_p, pb
14058     D1 1D B0 FE |                 loc     pb, #dev_desc_buff
1405c     F7 51 02 F6 |                 mov     dev_desc_buff_p, pb
14060     DB 1D B0 FE |                 loc     pb, #con_desc_buff
14064     F7 53 02 F6 |                 mov     con_desc_buff_p, pb
14068     24 15 B0 FE |                 loc     pb, #usb_cache_start
1406c     F7 55 02 F6 |                 mov     cache_start_p, pb
14070     25 1D B0 FE |                 loc     pb, #usb_cache_end
14074     F7 57 02 F6 |                 mov     cache_end_p, pb
14078                 | 
14078                 |         if ERROR_LED >= 0
14078                 |         end
14078                 | 
14078                 |                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
14078                 |                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
14078                 |                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
14078                 | ' Configure and enable the Serial Host USB port.
14078     03 03 80 FD |                 jmp     #host_reset                     ' Initialize host and enter main processing loop
1407c                 | 
1407c                 | '------------------------------------------------------------------------------
1407c                 | ' Timing calculations happen before any interrupt(s) are enabled.
1407c                 | '------------------------------------------------------------------------------
1407c                 | ' On entry:
1407c                 | '   htmp - current CLKFREQ value.
1407c                 | '------------------------------------------------------------------------------
1407c                 | hinit_usb_timings
1407c                 | '                getct   htmp2
1407c     B9 59 02 F6 |                 mov     save_sysclk, htmp
14080     8D 5B 80 FF 
14084     2C 01 2A FD |                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
14088     18 32 63 FD |                 getqx   _12Mbps_
1408c     10 32 57 F0 |                 shr     _12Mbps_, #16           wc
14090     00 32 27 F1 |                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
14094     03 6E 07 F6 |                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
14098     0E 6E 67 F0 |                 shl     _usb_h_fs_nco_, #14
1409c     99 6F 03 F1 |                 add     _usb_h_fs_nco_, _12Mbps_
140a0     01 70 07 F6 |                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
140a4     0E 70 67 F0 |                 shl     _usb_d_fs_nco_, #14
140a8     99 71 03 F1 |                 add     _usb_d_fs_nco_, _12Mbps_
140ac     99 35 03 F6 |                 mov     _1_5Mbps_, _12Mbps_
140b0     03 34 47 F0 |                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
140b4     02 6A 07 F6 |                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
140b8     0E 6A 67 F0 |                 shl     _usb_h_ls_nco_, #14
140bc     9A 6B 03 F1 |                 add     _usb_h_ls_nco_, _1_5Mbps_
140c0     9A 6D 03 F6 |                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
140c4     80 00 00 FF 
140c8     00 58 06 FD |                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
140cc     18 2E 63 FD |                 getqx   _var_64_lower_
140d0     19 30 63 FD |                 getqy   _var_64_upper_
140d4     28 2E 63 FD |                 setq    _var_64_lower_
140d8     65 CD 1D FF 
140dc     00 30 27 FD |                 qfrac   _var_64_upper_, ##_1b
140e0     18 36 63 FD |                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
140e4     01 00 00 FF 
140e8     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
140ec     18 2E 63 FD |                 getqx   _var_64_lower_
140f0     19 30 63 FD |                 getqy   _var_64_upper_
140f4     28 2E 63 FD |                 setq    _var_64_lower_
140f8     A1 07 00 FF 
140fc     40 30 27 FD |                 qfrac   _var_64_upper_, ##_1m
14100     18 38 63 FD |                 getqx   _1us_                           ' 1us as 32,9 fixed point
14104     9C 7D 03 F6 |                 mov     hsave0, _1us_                   ' Save it to compute other us values
14108     09 38 57 F0 |                 shr     _1us_, #9               wc
1410c     00 38 27 F1 |                 addx    _1us_, #0                       ' Round to final value
14110     0A 7C 07 FD |                 qmul    hsave0, #10                     ' Calc 10us
14114     18 3A 63 FD |                 getqx   _10us_
14118     09 3A 57 F0 |                 shr     _10us_, #9              wc
1411c     00 3A 27 F1 |                 addx    _10us_, #0                      ' 10us
14120     21 7C 07 FD |                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
14124     18 3C 63 FD |                 getqx   _33us_
14128     09 3C 57 F0 |                 shr     _33us_, #9              wc
1412c     00 3C 27 F1 |                 addx    _33us_, #0                      ' 33us
14130     FA 7C 07 FD |                 qmul    hsave0, #250                    ' Calc 250us
14134     18 3E 63 FD |                 getqx   _txn_err_
14138     09 3E 57 F0 |                 shr     _txn_err_, #9           wc
1413c     00 3E 27 F1 |                 addx    _txn_err_, #0                   ' 250us
14140     F4 7D 07 FD |                 qmul    hsave0, #500                    ' Calc 500us
14144     18 40 63 FD |                 getqx   _500us_
14148     09 40 57 F0 |                 shr     _500us_, #9             wc
1414c     00 40 27 F1 |                 addx    _500us_, #0                     ' 500us
14150     01 00 00 FF 
14154     9A 7C 07 FD |                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
14158     18 42 63 FD |                 getqx   _txn_ok_ls_
1415c     09 42 57 F0 |                 shr     _txn_ok_ls_, #9         wc
14160     00 42 27 F1 |                 addx    _txn_ok_ls_, #0                 ' 666us
14164     01 00 00 FF 
14168     52 7D 07 FD |                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
1416c     18 44 63 FD |                 getqx   _txn_ok_fs_
14170     09 44 57 F0 |                 shr     _txn_ok_fs_, #9         wc
14174     00 44 27 F1 |                 addx    _txn_ok_fs_, #0                 ' 850us
14178     9B 47 03 F6 |                 mov     _ip_delay_ls_, _1ns16fp_
1417c     05 00 00 FF 
14180     80 46 07 FA |                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
14184     10 46 57 F0 |                 shr     _ip_delay_ls_, #16      wc
14188     00 46 27 F1 |                 addx    _ip_delay_ls_, #0
1418c     9B 4B 03 F6 |                 mov     _tat_wait_ls_, _1ns16fp_
14190     1C 00 00 FF 
14194     C0 4B 07 FA |                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
14198     10 4A 57 F0 |                 shr     _tat_wait_ls_, #16      wc
1419c     00 4A 27 F1 |                 addx    _tat_wait_ls_, #0
141a0     9B 49 03 F6 |                 mov     _ip_delay_fs_, _1ns16fp_
141a4     00 00 00 FF 
141a8     4E 49 07 FA |                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
141ac     10 48 57 F0 |                 shr     _ip_delay_fs_, #16      wc
141b0     00 48 27 F1 |                 addx    _ip_delay_fs_, #0
141b4     9B 4D 03 F6 |                 mov     _tat_wait_fs_, _1ns16fp_
141b8     04 00 00 FF 
141bc     23 4D 07 FA |                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
141c0     10 4C 57 F0 |                 shr     _tat_wait_fs_, #16      wc
141c4     00 4C 27 F1 |                 addx    _tat_wait_fs_, #0
141c8     8D 5B 00 FF 
141cc     00 59 16 FD |                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
141d0     18 4E 63 FD |                 getqx   _preamble_wait_
141d4     08 4E 87 F1 |                 sub     _preamble_wait_,# 9 - 1
141d8     01 00 00 FF 
141dc     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
141e0     18 2E 63 FD |                 getqx   _var_64_lower_
141e4     19 30 63 FD |                 getqy   _var_64_upper_
141e8     28 2E 63 FD |                 setq    _var_64_lower_
141ec     01 00 00 FF 
141f0     E8 31 27 FD |                 qfrac   _var_64_upper_, ##_1thou
141f4     18 50 63 FD |                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
141f8     09 50 57 F0 |                 shr     _1ms_, #9               wc
141fc     00 50 27 F1 |                 addx    _1ms_, #0                       ' 1ms
14200     FF FF 7F FF 
14204     F2 69 07 F6 |                 mov     _frame1ms_clks_, ##-14
14208     A8 69 43 F1 |                 adds    _frame1ms_clks_, _1ms_
1420c     A8 53 03 F6 |                 mov     _2ms_, _1ms_
14210     01 52 67 F0 |                 shl     _2ms_, #1                       ' 2ms
14214     A8 55 03 F6 |                 mov     _suspend_wait_, _1ms_
14218     A8 55 03 F1 |                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
1421c     A8 57 03 F6 |                 mov     _4ms_, _1ms_
14220     02 56 67 F0 |                 shl     _4ms_, #2                       ' 4ms
14224     AB 59 03 F6 |                 mov     _xfer_wait_, _4ms_
14228     A8 59 03 F1 |                 add     _xfer_wait_, _1ms_              ' 5ms
1422c     AC 5D 03 F6 |                 mov     _reset_hold_, _xfer_wait_       ' 5ms
14230     AE 5F 03 F6 |                 mov     _resume_hold_, _reset_hold_
14234     02 5E 67 F0 |                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
14238     AF 63 03 F6 |                 mov     _100ms_, _resume_hold_          ' 20ms
1423c     01 62 67 F0 |                 shl     _100ms_, #1                     ' 40ms
14240     A8 5B 03 F6 |                 mov     _8ms_, _1ms_
14244     03 5A 67 F0 |                 shl     _8ms_, #3                       ' 8ms
14248     01 5C 67 F0 |                 shl     _reset_hold_, #1                ' 10ms
1424c     AE 63 03 F1 |                 add     _100ms_, _reset_hold_           ' 50ms
14250     AC 5D 03 F1 |                 add     _reset_hold_, _xfer_wait_       ' 15ms
14254     AC 61 03 F6 |                 mov     _21ms_, _xfer_wait_             ' 5ms
14258     02 60 67 F0 |                 shl     _21ms_, #2                      ' 20ms
1425c     A8 61 03 F1 |                 add     _21ms_, _1ms_                   ' 21ms
14260     B1 65 03 F6 |                 mov     _500ms_, _100ms_                ' 50ms
14264     01 62 67 F0 |                 shl     _100ms_, #1                     ' 100ms
14268     03 64 67 F0 |                 shl     _500ms_, #3                     ' 400ms
1426c     B1 65 03 01 |         _ret_   add     _500ms_, _100ms_                ' 500ms
14270                 | '        _ret_   mov     _1sec_, save_sysclk
14270                 | '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
14270                 | '                ret
14270                 | {
14270                 | }
14270                 | 
14270                 | '------------------------------------------------------------------------------
14270                 | ' Parse a configuration descriptor chain to see if the device is a recognized
14270                 | ' one. If it is, start the task progression that will configure the device for
14270                 | ' use.
14270                 | '------------------------------------------------------------------------------
14270                 | ' On entry:
14270                 | '   hconfig_base - start address of the cached config descriptor chain.
14270                 | ' On exit:
14270                 | '------------------------------------------------------------------------------
14270                 | hparse_con_desc
14270     28 F3 03 F6 |                 mov     ptrb, dev_desc_buff_p
14274     82 73 07 FB |                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
14278     61 5B 86 F9 |                 altr    hdev_port,#hdev_id
1427c     4E 72 FF F9 |                 movbyts htmp,#%%1032
14280     86 D3 E6 FA |                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
14284                 |                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
14284                 | 
14284     02 EC 07 F6 |                 mov     pa, #CON_wTotalLen
14288     6E ED 03 F1 |                 add     pa, hconfig_base
1428c     F6 DF E2 FA |                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
14290                 |                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
14290                 | ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
14290                 | ' that defines a keyboard and/or mouse.
14290     6E EB C2 FA |                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
14294                 | .next_intf
14294     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
14298     B8 01 90 3D |         if_ae   jmp     #hset_config
1429c     6E F3 03 F6 |                 mov     ptrb, hconfig_base
142a0     75 F3 03 F1 |                 add     ptrb, hnext_desc
142a4     81 73 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
142a8     04 72 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
142ac     0C 00 90 AD |         if_z    jmp     #.intf
142b0     80 73 C7 FA |                 rdbyte  htmp, ptrb
142b4     B9 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
142b8     D8 FF 9F FD |                 jmp     #.next_intf
142bc                 | .intf
142bc     00 90 07 F6 |                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
142c0     00 92 07 F6 |                 mov     hpar3, #0
142c4     82 E1 C6 FA |                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
142c8     85 E3 C6 FA |                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
142cc     86 E5 C6 FA |                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
142d0     87 E7 C6 FA |                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
142d4                 |                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
142d4                 | 
142d4                 | .endp
142d4     80 73 C7 FA |                 rdbyte  htmp, ptrb
142d8     B9 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
142dc     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
142e0     78 00 90 3D |         if_ae   jmp     #.get_device
142e4     6E F3 03 F6 |                 mov     ptrb, hconfig_base
142e8     75 F3 03 F1 |                 add     ptrb, hnext_desc
142ec     81 73 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
142f0     04 72 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
142f4     64 00 90 AD |         if_z    jmp     #.get_device
142f8     05 72 0F F2 |                 cmp     htmp, #TYPE_ENDPOINT    wz
142fc     04 00 90 AD |         if_z    jmp     #.get_ep
14300     D0 FF 9F FD |                 jmp     #.endp
14304                 | .get_ep
14304     82 89 C7 FA |                 rdbyte  hr1, ptrb[ENDP_bAddress]
14308     07 88 17 F4 |                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
1430c     0F 88 67 F0 |                 shl     hr1, #8 + 7
14310     6C 73 03 F6 |                 mov     htmp, hctrl_ep_addr
14314     3F 00 00 FF 
14318     00 73 07 F5 |                 and     htmp, ##ADDR_MASK
1431c     C4 73 43 F5 |                 or      htmp, hr1                       ' endpoint address
14320     00 90 0F F2 |                 cmp     hpar2, #0               wz
14324     0C 00 90 8D |  if_z_and_c     jmp     #.in_ep
14328     00 92 0F F2 |                 cmp     hpar3, #0               wz
1432c     18 00 90 2D |  if_z_and_nc    jmp     #.out_ep
14330     A0 FF 9F FD |                 jmp     #.endp
14334                 | .in_ep
14334     B9 91 03 F6 |                 mov     hpar2, htmp                     ' IN endpoint
14338     84 8B C7 FA |                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
1433c                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
1433c     86 87 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
14340     C3 8B DB F8 |                 setbyte hr2, hr0, #3
14344     8C FF 9F FD |                 jmp     #.endp
14348                 | .out_ep
14348     B9 93 03 F6 |                 mov     hpar3, htmp                     ' OUT endpoint
1434c     84 8D C7 FA |                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
14350                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
14350     86 87 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
14354     C3 8D DB F8 |                 setbyte hr3, hr0, #3
14358     78 FF 9F FD |                 jmp     #.endp
1435c                 | 
1435c                 | .get_device
1435c     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
14360     5D E4 0E A2 |         if_z    cmp     hdev_subclass, #$5D     wz
14364     01 E6 0E A2 |         if_z    cmp     hdev_protocol, #$01     wz
14368     64 00 90 AD |         if_z    jmp     #.gamepad
1436c     09 E2 0E F2 |                 cmp     hdev_class, #CLASS_HUB  wz
14370     A8 00 90 AD |         if_z    jmp     #.hub
14374     03 E2 0E F2 |                 cmp     hdev_class, #CLASS_HID              wz
14378     18 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No HID class, ignore
1437c     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
14380     4C 00 90 AD |         if_z    jmp     #.gamepad
14384     01 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
14388     08 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
1438c                 | .keyboard
1438c     01 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
14390                 |         if HAVE_MOUSE
14390     1C 00 90 5D |         if_nz  jmp      #.mouse                         ' No Keyboard
14394                 |         else
14394                 |         end
14394     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0    wz
14398     F8 FE 9F 5D |         if_nz   jmp     #.next_intf
1439c     70 6F E2 F8 |                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
143a0     C5 71 FA F8 |                 getbyte kb_interval, hr2, #3
143a4     C5 73 E2 F8 |                 getbyte kb_in_max_pkt, hr2, #0
143a8     C8 F3 02 F6 |                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
143ac                 |                 'debug(udec(kb_intf_num))
143ac                 |                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
143ac     E4 FE 9F FD |                 jmp     #.next_intf
143b0                 | if HAVE_MOUSE
143b0                 | .mouse
143b0     02 E6 0E F2 |                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
143b4     DC FE 9F 5D |         if_nz   jmp     #.next_intf                     ' No Mouse
143b8     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0      wz
143bc     D4 FE 9F 5D |         if_nz   jmp     #.next_intf
143c0     70 6B E2 F8 |                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
143c4                 |                 'getbyte ms_interval, hr2, #3
143c4     C5 6D E2 F8 |                 getbyte ms_in_max_pkt, hr2, #0
143c8     C8 F5 02 F6 |                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
143cc                 |                 'debug(udec(kb_intf_num))
143cc                 |                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
143cc     C4 FE 9F FD |                 jmp     #.next_intf
143d0                 | end
143d0                 | .gamepad
143d0     79 73 03 F6 |                 mov     htmp, hkbd_ep_addr
143d4     C8 73 63 F5 |                 xor     htmp, hpar2
143d8     3F 00 00 FF 
143dc     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
143e0     B0 FE 9F AD |         if_z    jmp     #.next_intf
143e4                 |         if HAVE_MOUSE
143e4     7A 73 03 F6 |                 mov     htmp, hmouse_ep_addr
143e8     C8 73 63 F5 |                 xor     htmp, hpar2
143ec     3F 00 00 FF 
143f0     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
143f4     9C FE 9F AD |         if_z    jmp     #.next_intf
143f8                 |         end
143f8     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
143fc     00 00 0C F2 |                 cmp     0-0, #0                 wz      ' |
14400     90 FE 9F 5D |         if_nz   jmp     #.next_intf
14404                 | 
14404     70 79 E2 F8 |                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
14408     C5 7B FA F8 |                 getbyte gp_interval, hr2, #3
1440c     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
14410     C8 01 00 F6 |                 mov     0-0, hpar2                      ' IN endpoint address
14414     C9 0B 03 F6 |                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
14418                 |                 'debug(udec(gp_intf_num))
14418                 |                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
14418     78 FE 9F FD |                 jmp     #.next_intf
1441c                 | .hub
1441c     00 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
14420     70 FE 9F 5D |         if_nz   jmp     #.next_intf
14424     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
14428     02 E6 0E 52 |         if_nz   cmp     hdev_protocol, #2                   wz
1442c     64 FE 9F 5D |         if_nz   jmp     #.next_intf
14430     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
14434     5C FE 9F 5D |         if_nz   jmp     #.next_intf
14438     70 63 E2 F8 |                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
1443c     6C ED 02 F6 |                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
14440     C8 BD 02 F6 |                 mov     ep_addr_pid, hpar2              ' IN endpoint address
14444     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
14448     5E EF 02 F6 |                 mov     hhub_ep_addr, ep_addr_pid
1444c     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
14450                 |                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
14450     40 FE 9F FD |                 jmp     #.next_intf
14454                 | 
14454                 | '------------------------------------------------------------------------------
14454                 | ' If a newly-connected device is recognized, do whatever is needed to configure
14454                 | ' it according to its function, or functions. In the case of this boot protocol
14454                 | ' keyboard/mouse class driver:
14454                 | ' - SetConfiguration(config_num)
14454                 | ' - SetProtocol(boot)
14454                 | ' - SetIdle(indefinite)
14454                 | ' - Enter the device interrupt IN polling task stage.
14454                 | '------------------------------------------------------------------------------
14454                 | ' On entry:
14454                 | ' On exit:
14454                 | '------------------------------------------------------------------------------
14454                 | hset_config
14454                 | '                mov     hkbd_ep_addr, #0                ' DEBUG
14454                 | '                mov     hmouse_ep_addr, #0              ' DEBUG
14454     02 76 07 F6 |                 mov     htmp2, #DEV_UNKNOWN
14458     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
1445c     00 00 0C F2 |                 cmp     0-0, #0                 wz
14460     00 F2 0E A2 |         if_z    cmp     hkbd_ep_addr, #0        wz
14464                 |         if HAVE_MOUSE
14464     00 F4 0E A2 |         if_z    cmp     hmouse_ep_addr, #0      wz
14468                 |         end
14468     00 EE 0E A2 |         if_z    cmp     hhub_ep_addr, #0        wz
1446c     60 03 90 AD |         if_z    jmp     #.notify_client                 ' No known device
14470                 | .set_config
14470     74 0E D0 FE |                 loc     ptra, #set_config
14474     05 EC 07 F6 |                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
14478     6E ED 03 F1 |                 add     pa, hconfig_base
1447c     F6 8F C3 FA |                 rdbyte  hpar1, pa
14480                 |                 debug("SetConfiguration: ",udec_(hpar1))
14480     01 8F 57 FC |                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
14484     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
14488     00 EE 07 F6 |                 mov     pb, #0                          ' SetConfiguration() has no data stage
1448c     A0 02 A0 FD |                 call    #control_write
14490     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14494     2D 00 64 5D |         if_nz   ret
14498                 | .kbd_config
14498     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0        wz
1449c     98 00 90 AD |         if_z    jmp     #.mouse_config                  ' No keyboard
144a0                 | 
144a0     79 73 03 F6 |                 mov     htmp, hkbd_ep_addr
144a4     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
144a8     3F 00 00 FF 
144ac     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
144b0     84 00 90 5D |         if_nz   jmp     #.mouse_config                  ' No keyboard
144b4                 | 
144b4     37 73 E3 F8 |                 getbyte htmp, kb_intf_num, #0
144b8     3C 0E D0 FE |                 loc     ptra, #set_protocol
144bc     01 01 5C FC |                 wrword  #BOOT_PROTOCOL, ptra[wValue]
144c0     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
144c4     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
144c8     A0 02 A0 FD |                 call    #control_write
144cc     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
144d0     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
144d4     F8 02 90 5D |         if_nz   jmp     #.notify_client
144d8     00 8E 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
144dc     37 91 E3 F8 |                 getbyte hpar2, kb_intf_num, #0
144e0     44 03 B0 FD |                 call    #hset_idle
144e4                 |                 'cmp     retval, #PID_ACK        wz
144e4                 |         'if_nz   mov     hkbd_ep_addr, #0
144e4                 |         'if_nz   jmp     #.notify_client
144e4     A9 99 02 F6 |                 mov     hctwait, _2ms_
144e8     EF 02 A0 FD |                 call    #poll_waitx
144ec     00 76 06 F6 |                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
144f0                 |         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
144f0                 |         end
144f0     3B F9 02 F6 |                 mov     hkbd_ledstates, kb_led_states
144f4     A0 17 90 FE |                 loc     pa, #hkbd_led_rep
144f8     F6 F9 42 FC |                 wrbyte  hkbd_ledstates,pa
144fc     40 03 B0 FD |                 call    #hset_kbdled_report
14500     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14504     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
14508     C4 02 90 5D |         if_nz   jmp     #.notify_client
1450c     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
14510     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
14514     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
14518     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
1451c     5E F3 02 F6 |                 mov     hkbd_ep_addr, ep_addr_pid
14520     6C F1 02 F6 |                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
14524     1F F0 46 F4 |                 bitc    hkbd_ctrl_ep, #31
14528     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
1452c     00 F6 06 F6 |                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
14530     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
14534     03 76 07 F6 |                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
14538                 |         if !!HAVE_MOUSE
14538                 |         end
14538                 | 
14538                 | .mouse_config
14538                 | if HAVE_MOUSE
14538     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0        wz
1453c     AC 00 90 AD |         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
14540     7A 73 03 F6 |                 mov     htmp, hmouse_ep_addr
14544     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
14548     3F 00 00 FF 
1454c     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
14550     98 00 90 5D |         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
14554                 | 
14554                 |                 debug("mouse passed addr check")
14554                 | 
14554     B8 0D D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
14558     00 00 80 FF 
1455c     03 01 5E FC |                 wrword  ##HID_DESCR_LEN, ptra[wLength]
14560     02 6B 56 FC |                 wrword  ms_intf_num,ptra[wIndex]
14564     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14568     55 02 A0 FD |                 call    #control_read
1456c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14570     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
14574     58 02 90 5D |         if_nz   jmp     #.notify_client
14578     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
1457c     56 01 00 F6 |                 mov     0-0, total_data
14580     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14584                 |                 debug(uhex(pb),uhex_byte_array(pb,total_data))
14584                 | 
14584     35 73 E3 F8 |                 getbyte htmp, ms_intf_num, #0
14588     6C 0D D0 FE |                 loc     ptra, #set_protocol
1458c     01 03 5C FC |                 wrword  #MOUSE_FULL_PROTOCOL ? REPORT_PROTOCOL : BOOT_PROTOCOL, ptra[wValue]
14590     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
14594     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
14598     A0 02 A0 FD |                 call    #control_write
1459c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
145a0     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
145a4     28 02 90 5D |         if_nz   jmp     #.notify_client
145a8                 |                 debug("mouse passed SetProtocol")
145a8     00 8E 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
145ac     35 91 E3 F8 |                 getbyte hpar2, ms_intf_num, #0
145b0     74 02 B0 FD |                 call    #hset_idle
145b4                 |                 'cmp     retval, #PID_ACK        wz
145b4                 |         'if_nz   mov     hmouse_ep_addr, #0
145b4                 |         'if_nz   jmp     #.notify_client
145b4                 |                 debug("mouse passed SetIdle")
145b4     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
145b8     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
145bc     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
145c0     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
145c4     5E F5 02 F6 |                 mov     hmouse_ep_addr, ep_addr_pid
145c8     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
145cc     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
145d0     79 77 03 F6 |                 mov     htmp2, hkbd_ep_addr
145d4     7A 77 63 F5 |                 xor     htmp2, hmouse_ep_addr
145d8     3F 00 00 FF 
145dc     00 77 0F F5 |                 and     htmp2, ##ADDR_MASK              wz
145e0     05 76 07 A6 |         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
145e4     04 76 07 56 |         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
145e8     E4 01 90 FD |                 jmp     #.notify_client
145ec                 | end
145ec                 | .gamepad_config
145ec                 | if _HAVE_GAMEPAD
145ec     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
145f0     00 00 0C F2 |                 cmp     0-0, #0                 wz
145f4     6C 01 90 AD |         if_z    jmp     #.hub_config                    ' No gamepad
145f8     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
145fc     00 72 03 F6 |                 mov     htmp, 0-0
14600     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
14604     3F 00 00 FF 
14608     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
1460c     54 01 90 5D |         if_nz   jmp     #.hub_config                    ' No gamepad
14610                 | 
14610     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
14614     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
14618     69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
1461c     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
14620     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
14624     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
14628     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
1462c     5E 01 00 F6 |                 mov     0-0, ep_addr_pid
14630     85 BD 0A F6 |                 mov     ep_addr_pid, hdev_out_addr  wz
14634     E1 BC C6 58 |         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
14638     BE 00 A0 5D |         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
1463c     09 68 16 54 |         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
14640     1F BC 46 54 |         if_nz   bitc    ep_addr_pid, #31
14644     5E 0B 03 56 |         if_nz   mov     hdev_out_addr, ep_addr_pid
14648     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
1464c                 | 
1464c                 |                 if EMUPAD_MAX_PLAYER > 0
1464c                 |                 
1464c                 | .rule_loop           
1464c                 |                 end
1464c                 | 
1464c     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
14650     5C 00 90 AD |         if_e    jmp     #.xinput
14654     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
14658     00 72 03 F6 |                 mov     htmp,0-0
1465c     01 A6 02 FF 
14660     68 72 0F F2 |                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
14664     8C 00 90 AD |         if_e    jmp     #.ps3
14668                 | 
14668     A4 0C D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
1466c     00 5A 0E F2 |                 cmp     hdev_port,#0            wz
14670     00 00 80 5F 
14674     03 01 5E 5C |         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
14678     03 00 80 AF 
1467c     03 01 5E AC |         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
14680     02 01 5C FC |                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
14684     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14688     55 02 A0 FD |                 call    #control_read
1468c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14690     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
14694     00 00 04 56 |         if_nz   mov     0-0, #0
14698     34 01 90 5D |         if_nz   jmp     #.notify_client
1469c     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
146a0     56 01 00 F6 |                 mov     0-0, total_data
146a4     1B 01 A0 FD |                 call    #get_hid_descr_buffer
146a8                 |                 debug(uhex(pb),udec(total_data),uhex_byte_array(pb,total_data))
146a8                 | 
146a8     06 76 07 F6 |                 mov     htmp2, #HID_READY               ' Standard gamepad
146ac     20 01 90 FD |                 jmp     #.notify_client
146b0                 | .xinput
146b0     B8 0C D0 FE |                 loc     ptra, #xinp_led_cmd             ' Turn on LED
146b4     2D EF 03 F6 |                 mov     pb,hdev_port
146b8     01 EE E7 F2 |                 cmpsub  pb,#1 ' root device is also player 1
146bc     03 EE 27 F3 |                 fle     pb,#3
146c0     06 EE 07 F1 |                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
146c4     02 EF 47 FC |                 wrbyte  pb, ptra[2]
146c8                 | 
146c8     03 B0 06 F6 |                 mov     pkt_data, #3
146cc     03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB
146d0     85 BD 02 F6 |                 mov     ep_addr_pid, hdev_out_addr
146d4                 |                 debug("XInput LED set ",uhex_long(ep_addr_pid),uhex_byte(pb))
146d4     5A 00 A0 FD |                 call    #txn_out
146d8     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr
146dc                 | 
146dc     97 0C D0 FE |                 loc     ptra, #xinp_fix_8bitdo
146e0     27 EF 03 F6 |                 mov     pb, urx_buff_p          ' We don't actually care where it goes
146e4     55 02 A0 FD |                 call    #control_read           ' Execute GetDeviceDescriptor()
146e8                 |                 debug("8bitdo weird fix... ",uhex(retval))
146e8     D2 BE 06 F6 |                 mov retval,#PID_ACK             ' If we don't do this something else becomes sad (TODO fix?)
146ec                 | 
146ec                 | 
146ec     07 76 07 F6 |                 mov     htmp2, #XINPUT_READY
146f0     DC 00 90 FD |                 jmp     #.notify_client
146f4                 | .ps3
146f4     44 0C D0 FE |                 loc     ptra, #ps3_command_buff         ' Turn on LED
146f8     2D EF 03 F6 |                 mov     pb,hdev_port
146fc     01 EE 07 F3 |                 fge     pb,#1 ' root device is also player 1
14700     04 EE 27 F3 |                 fle     pb,#4
14704     F7 EF C3 F9 |                 decod   pb
14708     09 EF 47 FC |                 wrbyte  pb, ptra[9]
1470c                 | 
1470c     3C 73 E3 F8 |                 getbyte htmp, gp_intf_num, #0
14710     F4 0B D0 FE |                 loc     ptra, #set_report
14714     01 00 80 FF 
14718     01 03 5C FC |                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
1471c     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
14720     03 61 5C FC |                 wrword  #48, ptra[wLength]
14724     14 0C B0 FE |                 loc     pb, #ps3_command_buff
14728     A0 02 A0 FD |                 call    #control_write
1472c                 | 
1472c     3C 73 E3 F8 |                 getbyte htmp, gp_intf_num, #0
14730     D4 0B D0 FE |                 loc     ptra, #set_report
14734     01 00 80 FF 
14738     01 E9 5F FC |                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
1473c     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
14740     03 09 5C FC |                 wrword  #4, ptra[wLength]
14744     F0 0B B0 FE |                 loc     pb, #ps3_enable_cmd             ' Enable PS3
14748     A0 02 A0 FD |                 call    #control_write
1474c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK    wz
14750     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
14754     00 00 04 56 |         if_nz   mov     0-0, #0
14758     74 00 90 5D |         if_nz   jmp     #.notify_client
1475c                 | 
1475c     08 76 07 F6 |                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
14760     6C 00 90 FD |                 jmp     #.notify_client
14764                 | end
14764                 | 
14764                 | .hub_config
14764     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
14768     64 00 90 AD |         if_z    jmp     #.notify_client                 ' No HUB
1476c     77 73 03 F6 |                 mov     htmp, hhub_ep_addr
14770     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
14774     3F 00 00 FF 
14778     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
1477c     50 00 90 5D |         if_nz   jmp     #.notify_client                 ' No HUB
14780                 | 
14780     94 0B D0 FE |                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
14784     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]
14788     26 EF 03 F6 |                 mov     pb, hub_descr_p
1478c     55 02 A0 FD |                 call    #control_read
14790     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14794     00 EE 06 56 |         if_nz   mov     hhub_ep_addr, #0
14798     34 00 90 5D |         if_nz   jmp     #.notify_client
1479c                 |                 debug(uhex_byte_array(hub_descr_p,total_data))
1479c                 | 
1479c     26 F1 03 F6 |                 mov     ptra, hub_descr_p
147a0     02 79 C7 FA |                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
147a4     07 78 27 F3 |                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
147a8                 |                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
147a8                 | .pwr_loop
147a8     74 0B D0 FE |                 loc     ptra, #set_port_feat            ' Power on ports
147ac     01 11 5C FC |                 wrword  #HUB_PORT_POWER, ptra[wValue]
147b0     02 79 57 FC |                 wrword  htmp3, ptra[wIndex]
147b4     A0 02 A0 FD |                 call    #control_write
147b8     FB 79 6F FB |                 djnz    htmp3, #.pwr_loop
147bc                 | 
147bc     B2 99 02 F6 |                 mov     hctwait, _500ms_
147c0     B1 99 02 F1 |                 add     hctwait, _100ms_
147c4     EF 02 A0 FD |                 call    #poll_waitx
147c8                 | 
147c8     09 76 07 F6 |                 mov     htmp2, #HUB_READY               ' Hub ready
147cc     00 00 90 FD |                 jmp     #.notify_client
147d0                 | 
147d0                 | .notify_client
147d0     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
147d4     BB 01 C0 F8 |                 setbyte htmp2                           ' Save device ready
147d8                 |                 debug(uhex_long(hdev_type,hdev_type+1))
147d8                 |         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
147d8     2D 00 64 FD |                 ret
147dc                 | 
147dc                 | '------------------------------------------------------------------------------
147dc                 | ' Initialize the keyboard/mouse data area to start-up values.
147dc                 | '------------------------------------------------------------------------------
147dc                 | ' On entry:
147dc                 | ' On exit:
147dc                 | '------------------------------------------------------------------------------
147dc                 | init_kbdm_data
147dc     00 F2 06 F6 |                 mov     hkbd_ep_addr, #0
147e0     00 FA 06 F6 |                 mov     hdev_ep_addr, #0
147e4                 | 
147e4     2A F1 03 F6 |                 mov     ptra, cache_start_p         ' Clear cached data buffers
147e8     2B ED 03 F6 |                 mov     pa, cache_end_p
147ec                 | .loop
147ec     61 01 4C FC |                 wrbyte  #0, ptra++
147f0     F6 F1 1B F2 |                 cmp     ptra, pa                wcz
147f4     F4 FF 9F CD |         if_b    jmp     #.loop
147f8                 |         
147f8                 |         if EMUPAD_MAX_PLAYER > 0
147f8                 |         end
147f8                 | 
147f8                 | 
147f8     2D ED 07 F6 |                 mov     pa, #hdev_init_start        ' Clear device data registers
147fc                 | .regloop
147fc     00 EC 8F F9 |                 altd    pa
14800     00 00 04 F6 |                 mov     0-0, #0
14804     01 EC 07 F1 |                 add     pa, #1
14808     47 ED 0F F2 |                 cmp     pa, #hdev_init_end      wz
1480c     EC FF 9F 5D |         if_nz   jmp     #.regloop
14810                 | 
14810     E1 E1 61 FF 
14814     C3 5D 06 F6 |                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
14818     2E 5F 02 F6 |                 mov     hdev_next_datax + 1,hdev_next_datax
1481c     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0
14820     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1
14824                 | 
14824     C3 64 06 06 |         _ret_   mov     hub_next_datax, #PID_DATA0
14828                 | 
14828                 | '------------------------------------------------------------------------------
14828                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
14828                 | ' function.
14828                 | '------------------------------------------------------------------------------
14828                 | ' On entry:
14828                 | '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
14828                 | '   hpar2 - index number of the target interface.
14828                 | ' On exit:
14828                 | '------------------------------------------------------------------------------
14828                 | hset_idle
14828     A9 99 02 F6 |                 mov     hctwait, _2ms_
1482c     EF 02 A0 FD |                 call    #poll_waitx
14830     CC 0A D0 FE |                 loc     ptra, #set_idle
14834     01 8F 57 FC |                 wrword  hpar1, ptra[wValue]
14838     02 91 57 FC |                 wrword  hpar2, ptra[wIndex]
1483c     A0 02 80 FD |                 jmp     #control_write
14840                 | 
14840                 | '------------------------------------------------------------------------------
14840                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
14840                 | ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
14840                 | '------------------------------------------------------------------------------
14840                 | ' On entry:
14840                 | '   ep_addr_pid - device address and enpoint for the request.
14840                 | ' On exit:
14840                 | '   retval - transaction result.
14840                 | '------------------------------------------------------------------------------
14840                 | hset_kbdled_report
14840     37 73 E3 F8 |                 getbyte htmp, kb_intf_num, #0
14844     C0 0A D0 FE |                 loc     ptra, #set_report
14848     01 00 80 FF 
1484c     01 01 5C FC |                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
14850     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
14854     03 03 5C FC |                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
14858     27 EF 03 F6 |                 mov     pb, urx_buff_p
1485c     F7 77 42 FC |                 wrbyte  kb_led_states, pb
14860     A0 02 80 FD |                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
14864                 | 
14864                 | '------------------------------------------------------------------------------
14864                 | ' Execute an IN interrupt transaction to poll for keyboard activity.
14864                 | '------------------------------------------------------------------------------
14864                 | ' On entry:
14864                 | ' On exit:
14864                 | '------------------------------------------------------------------------------
14864                 | hget_kbd_in_report
14864     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
14868     27 91 03 F6 |                 mov     hpar2, urx_buff_p
1486c     30 93 E3 F8 |                 getbyte hpar3, kbm_next_datax, #0
14870     39 93 2B F9 |                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
14874     CF 02 A0 FD |                 call    #do_int_in
14878     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1487c     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
14880                 | 
14880     00 92 0F F2 |                 cmp     hpar3, #0               wz
14884     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
14888                 | 
14888     30 73 E3 F8 |                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
1488c     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
14890     4B 60 C6 A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
14894     C3 60 C6 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
14898                 | 
14898     C9 75 02 F6 |                 mov     kb_max_index, hpar3             ' Save actual bytes read
1489c     18 00 B0 FD |                 call    #hkbd_compare
148a0                 |         if EMUPAD_MAX_PLAYER > 0
148a0                 |         end
148a0                 | 
148a0                 | .led_check
148a0     3B 73 03 F6 |                 mov     htmp, kb_led_states
148a4     B9 F9 0A F2 |                 cmp     hkbd_ledstates, htmp    wz
148a8     2D 00 64 AD |         if_z    ret                                     ' No toggle key indicator changes, so we're done
148ac     7C 77 02 F6 |                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
148b0     78 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ctrl_ep
148b4     88 FF 9F FD |                 jmp     #hset_kbdled_report             ' Set report and ignore errors
148b8                 | 
148b8                 | '------------------------------------------------------------------------------
148b8                 | ' Compare current and previous keyboard data buffers for keypress changes.
148b8                 | '------------------------------------------------------------------------------
148b8                 | hkbd_compare
148b8     27 F1 03 F6 |                 mov     ptra, urx_buff_p
148bc     D0 13 F0 FE |                 loc     ptrb, #hkbd_report
148c0     61 75 07 FB |                 rdlong  htmp1, ptra++
148c4     E1 77 07 FB |                 rdlong  htmp2, ptrb++
148c8     BB 75 0B F2 |                 cmp     htmp1, htmp2    wz
148cc     61 75 07 FB |                 rdlong  htmp1, ptra++
148d0     E1 77 07 FB |                 rdlong  htmp2, ptrb++
148d4     BB 75 0B A2 |         if_z    cmp     htmp1, htmp2    wz
148d8     2D 00 64 AD |         if_z    ret
148dc                 | 
148dc     B0 13 D0 FE |                 loc     ptra, #hkbd_report
148e0                 | 
148e0                 |                 ' Handle modifiers
148e0     27 91 C3 FA |                 rdbyte  hpar2, urx_buff_p
148e4     00 89 C7 FA |                 rdbyte  hr1, ptra
148e8     C8 89 43 F9 |                 rolword hr1,hpar2,#0
148ec     63 88 63 FD |                 mergew  hr1
148f0     08 EC 07 F6 |                 mov     pa,#8
148f4                 | .modloop
148f4     6A 88 7B FD |                 rczr    hr1     wcz ' New value in C, old value in Z
148f8     E8 8E 07 F6 |                 mov     hpar1,#$E8
148fc     F6 8F 83 F1 |                 sub     hpar1,pa
14900     A0 00 B0 6D |       if_c_ne_z call    #hkbd_translate
14904     FB ED 6F FB |                 djnz    pa,#.modloop
14908                 | 
14908     6F E0 75 FD | .release        modc    _set    wc
1490c                 |                 'alts    hdev_port, #hid_report_p
1490c                 |                 'mov     ptra, hid_report_p
1490c     02 F0 07 F1 |                 add     ptra, #2
14910     06 EC 07 F6 |                 mov     pa, #6
14914     61 8F CF FA | .rl1            rdbyte  hpar1, ptra++   wz
14918     20 00 90 AD |         if_z    jmp     #.rl3
1491c     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
14920     02 F2 07 F1 |                 add     ptrb, #2
14924     06 EE 07 F6 |                 mov     pb, #6
14928     E1 73 C7 FA | .rl2            rdbyte  htmp, ptrb++
1492c     B9 8F 0B F2 |                 cmp     hpar1, htmp     wz
14930     08 00 90 AD |         if_z    jmp     #.rl3
14934     FC EF 6F FB |                 djnz    pb, #.rl2
14938     68 00 B0 FD |                 call    #hkbd_translate
1493c     F5 ED 6F FB | .rl3            djnz    pa, #.rl1
14940                 | 
14940     00 92 07 F6 |                 mov     hpar3, #0
14944     1F 92 27 F4 |                 bith    hpar3, #31
14948                 | 
14948     6F 00 74 FD | .press          modc    _clr    wc
1494c     27 F1 03 F6 |                 mov     ptra, urx_buff_p
14950     02 F0 07 F1 |                 add     ptra, #2
14954     06 EC 07 F6 |                 mov     pa, #6
14958     61 8F CF FA | .pl1            rdbyte  hpar1, ptra++   wz
1495c     20 00 90 AD |         if_z    jmp     #.pl3
14960     2C 13 F0 FE |                 loc     ptrb, #hkbd_report
14964     02 F2 07 F1 |                 add     ptrb, #2
14968     06 EE 07 F6 |                 mov     pb, #6
1496c     E1 73 C7 FA | .pl2            rdbyte  htmp, ptrb++
14970     B9 8F 0B F2 |                 cmp     hpar1, htmp     wz
14974     08 00 90 AD |         if_z    jmp     #.pl3
14978     FC EF 6F FB |                 djnz    pb, #.pl2
1497c     24 00 B0 FD |                 call    #hkbd_translate
14980     F5 ED 6F FB | .pl3            djnz    pa, #.pl1
14984                 | 
14984     27 F1 03 F6 | .copy           mov     ptra, urx_buff_p
14988     04 13 F0 FE |                 loc     ptrb, #hkbd_report
1498c     28 02 64 FD |                 setq #1
14990     61 75 07 FB |                 rdlong  htmp1, ptra++
14994     28 02 64 FD |                 setq #1
14998     E1 75 67 FC |                 wrlong  htmp1, ptrb++
1499c     E1 F9 46 FC |                 wrbyte  hkbd_ledstates,ptrb++
149a0                 | 
149a0     2D 00 64 FD |                 ret
149a4                 | 
149a4                 | '------------------------------------------------------------------------------
149a4                 | ' Translate keyboard scancode to ASCII
149a4                 | '------------------------------------------------------------------------------
149a4                 | ' On entry:
149a4                 | '   hpar1 - scancode
149a4                 | '   hpar2 - key modifiers state
149a4                 | '       c - pressed (0) or released (1) flag
149a4                 | ' On exit:
149a4                 | '   hpar1 - bit     31 = 0 pressed, 1 released
149a4                 | '               30..17 = unused
149a4                 | '                   18 = scroll-lock state 
149a4                 | '                   17 = caps-lock state
149a4                 | '                   16 = num-lock state 
149a4                 | '                15..8 = key modifiers state
149a4                 | '                 7..0 = scancode
149a4                 | '------------------------------------------------------------------------------
149a4                 | hkbd_translate
149a4     39 8E 0F F2 |                 cmp     hpar1, #KEY_CAPSLOCK    wz
149a8     01 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
149ac     53 8E 0F F2 |                 cmp     hpar1, #KEY_NUMLOCK     wz
149b0     00 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
149b4     47 8E 0F F2 |                 cmp     hpar1, #KEY_SCROLLLOCK  wz
149b8     02 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
149bc                 | 
149bc                 |         if EMUPAD_MAX_PLAYER > 0
149bc                 | 
149bc                 |         if EMUPAD_BT0_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT1_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT2_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT3_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT4_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT5_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT6_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT7_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT8_BIT >= 0
149bc                 |         end
149bc                 |         if EMUPAD_BT9_BIT >= 0
149bc                 |         end
149bc                 | 
149bc                 |         end
149bc     C8 8F CB F8 |                 setbyte hpar1, hpar2, #1
149c0     7C 8F D3 F8 |                 setbyte hpar1, hkbd_ledstates,#2
149c4     1F 8E 47 F4 |                 bitc    hpar1, #31
149c8                 |         if KEYQUEUE_SIZE > 0
149c8     C0 09 B0 FE |                 loc pb,#keyq_head
149cc     F7 73 E3 FA |                 rdword htmp,pb
149d0     B9 75 EB F8 |                 getbyte htmp1,htmp,#1 ' tail
149d4     B9 73 E3 F8 |                 getbyte htmp,htmp,#0 ' head
149d8     B9 77 03 F6 |                 mov htmp2,htmp
149dc     04 76 07 FA |                 mul htmp2,#4
149e0     F7 77 03 F1 |                 add htmp2,pb
149e4     02 76 07 F1 |                 add htmp2,#2
149e8     7F 72 07 F7 |                 incmod htmp,#KEYQUEUE_SIZE - 1
149ec     B9 75 0B F2 |                 cmp htmp1,htmp wz ' check buffer overflow
149f0     BB 8F 63 5C |         if_nz   wrlong hpar1,htmp2
149f4     F7 73 43 5C |         if_nz   wrbyte htmp,pb
149f8                 |         end
149f8     2D 00 7C FD |                 ret wcz
149fc                 | 
149fc                 | if HAVE_MOUSE
149fc                 | '------------------------------------------------------------------------------
149fc                 | ' Execute an IN interrupt transaction to poll for mouse activity.
149fc                 | '------------------------------------------------------------------------------
149fc                 | ' On entry:
149fc                 | ' On exit:
149fc                 | '------------------------------------------------------------------------------
149fc                 | hget_mouse_in_report
149fc     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
14a00     27 91 03 F6 |                 mov     hpar2, urx_buff_p
14a04     30 93 EB F8 |                 getbyte hpar3, kbm_next_datax, #1
14a08     36 93 2B F9 |                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
14a0c     CF 02 A0 FD |                 call    #do_int_in
14a10     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14a14     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
14a18                 | 
14a18     00 92 0F F2 |                 cmp     hpar3, #0               wz
14a1c     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
14a20                 | 
14a20     30 73 EB F8 |                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
14a24     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
14a28     4B 60 CE A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
14a2c     C3 60 CE 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
14a30                 | 
14a30                 |         'debug(uhex_byte_array(urx_buff_p,hpar3))
14a30                 | 
14a30                 |         if MOUSE_FULL_PROTOCOL
14a30     C8 00 B0 FD |                 call #hid_decode
14a34                 |         else
14a34                 |         end
14a34                 | 
14a34     48 09 90 FE |                 loc     pa, #mouse_limits
14a38     5D 13 F0 FE |                 loc     ptrb, #mouse_xacc
14a3c                 | 
14a3c                 |                 ' load xacc,yacc,zacc
14a3c     28 04 64 FD |                 setq    #3-1
14a40     80 89 07 FB |                 rdlong  hr1,ptrb
14a44                 |                 ' load limits and outptr
14a44     28 04 64 FD |                 setq    #3-1
14a48     F6 75 03 FB |                 rdlong  htmp1,pa
14a4c                 | 
14a4c                 |         if MOUSE_FULL_PROTOCOL
14a4c     8C 19 47 FC |                 wrbyte  hidr_buttons, ptrb[12]
14a50                 |         else
14a50                 |                 { ' Currently not used
14a50                 |                 '}
14a50                 |         end
14a50                 | 
14a50                 |         if MOUSE_FULL_PROTOCOL
14a50     88 73 33 F9 |                 getword htmp, hidr_axis+0, #0
14a54     0F 72 67 F7 |                 signx   htmp, #15
14a58                 |         else
14a58                 |         end
14a58     B9 89 03 F1 |                 add     hr1,htmp
14a5c     00 74 0F F2 |                 cmp     htmp1,#0 wz
14a60     BA 89 63 53 |         if_ne   fles    hr1,htmp1
14a64     00 88 47 53 |         if_ne   fges    hr1,#0
14a68                 | 
14a68                 |         if MOUSE_FULL_PROTOCOL
14a68     88 73 3B F9 |                 getword htmp, hidr_axis+0, #1
14a6c     0F 72 67 F7 |                 signx   htmp, #15
14a70                 |         else
14a70                 |         end
14a70     B9 8B 03 F1 |                 add     hr2,htmp
14a74     00 76 0F F2 |                 cmp     htmp2,#0 wz
14a78     BB 8B 63 53 |         if_ne   fles    hr2,htmp2
14a7c     00 8A 47 53 |         if_ne   fges    hr2,#0
14a80                 |                 
14a80                 |         if MOUSE_FULL_PROTOCOL
14a80     8B 73 3B F9 |                 getword htmp, hidr_axis+3, #1           ' Mouse wheel is actually on the "wheel axis"
14a84     0F 72 67 F7 |                 signx   htmp, #15
14a88     B9 8D 03 F1 |                 add     hr3, htmp
14a8c                 |         else    
14a8c                 |         end
14a8c                 | 
14a8c     90 73 CF FA |                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
14a90     2D 00 64 5D |         if_nz   ret                                     ' If so, don't write results
14a94                 | 
14a94                 |                 ' write back accumulators
14a94     28 04 64 FD |                 setq    #3-1
14a98     80 89 67 FC |                 wrlong  hr1,ptrb
14a9c                 |                 ' if outptr set, write X/Y words
14a9c     00 78 0F F2 |                 cmp htmp3,#0                    wz
14aa0     C5 89 2B 59 |         if_nz   setword hr1,hr2,#1
14aa4     BC 89 63 5C |         if_nz   wrlong hr1,htmp3
14aa8     2D 00 64 FD |                 ret
14aac                 | end
14aac                 | 
14aac                 | '------------------------------------------------------------------------------
14aac                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
14aac                 | '------------------------------------------------------------------------------
14aac                 | ' On entry:
14aac                 | ' On exit:
14aac                 | '------------------------------------------------------------------------------
14aac                 | if _HAVE_GAMEPAD
14aac                 | hget_gp_in_report
14aac     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
14ab0     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
14ab4                 | 
14ab4     27 91 03 F6 |                 mov     hpar2, urx_buff_p
14ab8     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax
14abc     00 92 E3 F8 |                 getbyte hpar3
14ac0     FF 92 2F F9 |                 setword hpar3, #255, #1                 ' Always ask for max report size
14ac4     CF 02 A0 FD |                 call    #do_int_in
14ac8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14acc     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
14ad0                 | 
14ad0     00 92 0F F2 |                 cmp     hpar3, #0               wz
14ad4     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
14ad8                 |                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
14ad8                 | 
14ad8     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
14adc     00 72 E3 F8 |                 getbyte htmp                            ' |
14ae0     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
14ae4     4B 72 07 A6 |         if_z    mov     htmp, #PID_DATA1                ' |
14ae8     C3 72 07 56 |         if_nz   mov     htmp, #PID_DATA0                ' |
14aec     2E 5B 66 F9 |                 altsb   hdev_port, #hdev_next_datax     ' |
14af0     B9 01 C0 F8 |                 setbyte htmp                            ' |
14af4                 | 
14af4                 | ' Note: the following code compares the current and previous reports
14af4                 | ' and process the data if there are changes to ease the debug output.
14af4                 | ' Actual implementations should remove this block, along with hid_pre_rpt_p and
14af4                 | ' gpPreReport buffer.
14af4                 | 
14af4                 |                 ' ----- start of block to remove
14af4                 |                 {
14af4                 |                 }
14af4                 |                 ' ----- end of block to remove
14af4     14 05 90 FE |                 loc pa,#hpad_translate
14af8     2A EC 63 FD |                 push pa
14afc                 | 
14afc                 |                 ' FALL THROUGH !!!!
14afc                 | end
14afc                 | if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
14afc                 | '------------------------------------------------------------------------------
14afc                 | ' Decode controller report
14afc                 | '------------------------------------------------------------------------------
14afc                 | hid_decode
14afc                 |                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
14afc     28 20 64 FD |                 setq #(hidr_end-hidr_start)-1
14b00     00 04 00 FF 
14b04     00 0C 07 FB |                 rdlong  hidr_start,##$8_0000
14b08                 | 
14b08     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
14b0c                 | 
14b0c     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
14b10     00 1C E3 F8 |                 getbyte hidr_type
14b14                 |         if _HAVE_GAMEPAD
14b14     07 1C 0F F2 |                 cmp     hidr_type, #XINPUT_READY        wz
14b18     08 03 90 AD |         if_z    jmp     #hpad_xinput
14b1c     08 1C 0F F2 |                 cmp     hidr_type, #PS3_READY           wz
14b20     EC 03 90 AD |         if_z    jmp     #hpad_ps3
14b24                 |         end
14b24     05 1C 0F F2 |                 cmp     hidr_type, #KBM_READY           wz
14b28     04 1C 07 A6 |         if_z    mov     hidr_type,#M_READY
14b2c     04 1C 0F F2 |                 cmp     hidr_type, #M_READY             wz
14b30                 |                 
14b30                 | 
14b30                 | '------------------------------------------------------------------------------
14b30                 | ' Handle HID controller (or mouse now
14b30                 | ' On entry:
14b30                 | '   ptrb - controller report
14b30                 | '------------------------------------------------------------------------------
14b30                 | hpad_hid
14b30     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14b34     F7 F1 03 F6 |                 mov     ptra, pb
14b38     3F 5B 96 F9 |                 alts    hdev_port, #gp_descr_len
14b3c     00 EC 03 F6 |                 mov     pa, 0-0
14b40                 |                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
14b40     19 2A 3B FF 
14b44     10 0C 07 F6 |                 mov     hidr_usage, ##$76543210
14b48                 | 
14b48                 | .next
14b48     00 EC 5F F2 |                 cmps    pa, #0      wcz
14b4c     2D 00 7C ED |         if_be   ret     wcz
14b50                 | 
14b50     61 8F C7 FA |                 rdbyte  hpar1, ptra++
14b54     01 EC 87 F1 |                 sub     pa, #1
14b58     00 90 07 F6 |                 mov     hpar2, #0
14b5c                 | 
14b5c     C7 73 03 F6 |                 mov     htmp, hpar1
14b60     03 72 07 F5 |                 and     htmp, #$03
14b64     01 72 0F F2 |                 cmp     htmp, #1    wz
14b68     61 91 C7 AA |         if_z    rdbyte  hpar2, ptra++
14b6c     07 90 67 A7 |         if_z    signx   hpar2,#7
14b70     01 EC 87 A1 |         if_z    sub     pa, #1
14b74     02 72 0F F2 |                 cmp     htmp, #2    wz
14b78     61 91 E7 AA |         if_z    rdword  hpar2, ptra++
14b7c     0F 90 67 A7 |         if_z    signx   hpar2,#15
14b80     02 EC 87 A1 |         if_z    sub     pa, #2
14b84     03 72 0F F2 |                 cmp     htmp, #3    wz
14b88     61 91 07 AB |         if_z    rdlong  hpar2, ptra++
14b8c     04 EC 87 A1 |         if_z    sub     pa, #4
14b90                 | 
14b90     FC 8E 07 F5 |                 and     hpar1, #$FC
14b94                 |                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
14b94                 | 
14b94     84 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_ID   wz
14b98     18 01 90 AD |         if_z    jmp     #.report_id
14b9c     04 8E 0F F2 |                 cmp     hpar1, #HID_USAGE_PAGE  wz
14ba0     30 01 90 AD |         if_z    jmp     #.usage_page
14ba4     08 8E 0F F2 |                 cmp     hpar1, #HID_USAGE       wz
14ba8     38 01 90 AD |         if_z    jmp     #.usage
14bac     14 8E 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MIN wz
14bb0     C8 2B 2B A9 |         if_z    setword hidr_lminmax, hpar2, #1
14bb4     24 8E 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MAX wz
14bb8     C8 2B 23 A9 |         if_z    setword hidr_lminmax, hpar2, #0
14bbc     34 8E 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MIN wz
14bc0     C8 2D 2B A9 |         if_z    setword hidr_pminmax, hpar2, #1
14bc4     44 8E 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MAX wz
14bc8     C8 2D 23 A9 |         if_z    setword hidr_pminmax, hpar2, #0
14bcc     74 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_SIZE wz
14bd0     C8 27 03 A6 |         if_z    mov     hidr_size, hpar2
14bd4     94 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_COUNT wz
14bd8     C8 29 03 A6 |         if_z    mov     hidr_count, hpar2
14bdc     B4 8E 1F F2 |                 cmp     hpar1, #HID_POP wcz
14be0     A4 8E 0F 52 |         if_nz   cmp     hpar1, #HID_PUSH wz
14be4     64 01 90 AD |         if_z    jmp     #.pushpop ' Entering with C set if PUSH  
14be8     80 8E 0F F2 |                 cmp     hpar1, #HID_INPUT       wz
14bec     58 FF 9F 5D |         if_nz   jmp     #.next
14bf0                 | 
14bf0     D5 25 A7 FB |                 tjf     hidr_state,#.next
14bf4                 | 
14bf4     03 90 07 F5 |                 and     hpar2, #$03
14bf8     02 90 0F F2 |                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
14bfc     18 00 90 5D |         if_nz   jmp     #.skip
14c00                 | 
14c00     02 24 0F F2 |                 cmp     hidr_state, #2  wz
14c04     20 00 90 AD |         if_z    jmp     #.axes
14c08     03 24 0F F2 |                 cmp     hidr_state, #3  wz
14c0c     5C 00 90 AD |         if_z    jmp     #.hats
14c10     04 24 0F F2 |                 cmp     hidr_state, #4  wz
14c14     70 00 90 AD |         if_z    jmp     #.buttons
14c18                 | .skip
14c18     93 73 03 F6 |                 mov     htmp, hidr_size
14c1c     94 73 03 FA |                 mul     htmp, hidr_count
14c20     B9 21 03 F1 |                 add     hidr_offset, htmp
14c24     20 FF 9F FD |                 jmp     #.next
14c28                 | .axes
14c28                 |                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count),uhex_long(hidr_flags))
14c28     87 87 53 F8 |                 getnib  hr0, hidr_flags, #2
14c2c     94 89 03 F6 |                 mov     hr1, hidr_count
14c30                 | .l1
14c30     90 8F 03 F6 |                 mov     hpar1, hidr_offset
14c34     93 91 03 F6 |                 mov     hpar2, hidr_size
14c38     28 01 B0 FD |                 call    #hpad_getbits
14c3c     88 01 B0 FD |                 call    #hpad_normalize
14c40     08 86 1F F2 |                 cmp     hr0, #8         wcz
14c44     86 87 5F C9 |         if_b    altgn   hr0, #hidr_usage
14c48     00 8A 43 C8 |         if_b    getnib  hr2
14c4c     88 8B 77 C9 |         if_b    altsw   hr2, #hidr_axis
14c50     5F 01 20 C9 |         if_b    setword retval
14c54     01 86 07 C1 |         if_b    add     hr0, #1
14c58     93 21 03 F1 |                 add     hidr_offset, hidr_size
14c5c     F4 89 6F FB |                 djnz    hr1, #.l1
14c60                 | 
14c60     C3 0F 13 F8 |                 setnib  hidr_flags, hr0, #2
14c64     01 24 07 F6 |                 mov     hidr_state, #1
14c68     DC FE 9F FD |                 jmp     #.next
14c6c                 | .hats
14c6c                 |                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
14c6c     90 8F 03 F6 |                 mov     hpar1, hidr_offset
14c70     93 91 03 F6 |                 mov     hpar2, hidr_size
14c74     EC 00 B0 FD |                 call    #hpad_getbits
14c78     5F 1B C3 F8 |                 setbyte hidr_hats, retval, #0
14c7c     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
14c80     01 24 07 F6 |                 mov     hidr_state, #1
14c84     90 FF 9F FD |                 jmp     #.skip
14c88                 | .buttons
14c88                 |                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
14c88     90 8F 03 F6 |                 mov     hpar1, hidr_offset
14c8c     93 91 03 F6 |                 mov     hpar2, hidr_size
14c90     94 91 03 FA |                 mul     hpar2, hidr_count
14c94     CC 00 B0 FD |                 call    #hpad_getbits
14c98     87 73 E3 F8 |                 getbyte htmp, hidr_flags, #0
14c9c     B9 BF 62 F0 |                 shl     retval, htmp
14ca0     5F 19 43 F5 |                 or      hidr_buttons, retval
14ca4     94 73 03 F1 |                 add     htmp, hidr_count
14ca8     B9 0F C3 F8 |                 setbyte hidr_flags, htmp, #0
14cac     01 24 07 F6 |                 mov     hidr_state, #1
14cb0     64 FF 9F FD |                 jmp     #.skip
14cb4                 | .report_id
14cb4     00 1E 0F F2 |                 cmp     hidr_id, #0     wz
14cb8     2D 00 7C 5D |         if_nz   ret     wcz
14cbc     E1 73 C7 FA |                 rdbyte  htmp, ptrb++
14cc0                 |                 'debug(".report_id",udec(htmp,hpar2))
14cc0     C8 73 0B F2 |                 cmp     htmp, hpar2     wz
14cc4     B9 1F 03 A6 |         if_z    mov     hidr_id, htmp
14cc8     01 24 67 56 |         if_nz   neg     hidr_state,#1
14ccc     01 F2 87 51 |         if_nz   sub     ptrb,#1
14cd0     74 FE 9F FD |                 jmp     #.next
14cd4                 | .usage_page
14cd4     09 90 0F F2 |                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
14cd8     01 24 0F A2 |         if_z    cmp     hidr_state, #1  wz
14cdc     04 24 07 A6 |         if_z    mov     hidr_state, #4
14ce0     64 FE 9F FD |                 jmp     #.next
14ce4                 | .usage
14ce4     04 90 0F F2 |                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
14ce8     05 90 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
14cec     06 1C 0F A2 |         if_z    cmp     hidr_type,#HID_READY        wz
14cf0     01 24 07 A6 |         if_z    mov     hidr_state, #1
14cf4     50 FE 9F AD |         if_z    jmp     #.next
14cf8     02 90 0F F2 |                 cmp     hpar2, #HID_USAGE_MOUSE     wz
14cfc     04 1C 0F A2 |         if_z    cmp     hidr_type,#M_READY          wz
14d00     01 24 07 A6 |         if_z    mov     hidr_state, #1
14d04     40 FE 9F AD |         if_z    jmp     #.next
14d08     30 90 17 F2 |                 cmp     hpar2, #HID_USAGE_X     wc
14d0c     38 90 97 32 |         if_nc   cmpr    hpar2, #HID_USAGE_WHEEL wc   
14d10     10 00 90 3D |         if_nc   jmp     #.usage_axis
14d14     39 90 0F F2 |                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
14d18     01 24 0F A2 |         if_z    cmp     hidr_state, #1      wz
14d1c     03 24 07 A6 |         if_z    mov     hidr_state, #3
14d20     24 FE 9F FD |                 jmp     #.next
14d24                 | .usage_axis
14d24     01 24 57 F2 |                 cmps    hidr_state, #1          wc
14d28     1C FE 9F CD |         if_b    jmp     #.next
14d2c     37 90 27 F3 |                 fle     hpar2, #HID_USAGE_DIAL   ' Let's just say wheel and dial are the same to keep sane
14d30     86 23 57 F9 |                 altsn   hidr_usage_idx, #hidr_usage
14d34     C8 01 00 F8 |                 setnib  hpar2
14d38                 | 
14d38     20 90 87 F1 |                 sub     hpar2, #HID_USAGE_X - 16
14d3c     C8 0F 23 F4 |                 bith    hidr_flags, hpar2
14d40                 | 
14d40     01 22 07 F1 |                 add     hidr_usage_idx, #1
14d44     02 24 07 F6 |                 mov     hidr_state, #2
14d48     FC FD 9F FD |                 jmp     #.next
14d4c                 | .pushpop
14d4c                 |                 ' Entering with C set if PUSH  
14d4c     4C 0F B0 FE |                 loc     pb, #hid_stack
14d50     28 08 64 CD |         if_c    setq    #(hidr_end-hidr_state)-1
14d54     F7 25 63 CC |         if_c    wrlong  hidr_state, pb
14d58     28 08 64 3D |         if_nc   setq    #(hidr_end-hidr_state)-1
14d5c     F7 25 03 3B |         if_nc   rdlong  hidr_state, pb
14d60     E4 FD 9F FD |                 jmp     #.next
14d64                 | 
14d64                 | '------------------------------------------------------------------------------
14d64                 | ' Read bits from report data buffer
14d64                 | '------------------------------------------------------------------------------
14d64                 | ' On entry:
14d64                 | '   PTRB - report buffer
14d64                 | '   hpar1 - start bit
14d64                 | '   hpar2 - number of bits
14d64                 | ' On exit:
14d64                 | '   retval - bits
14d64                 | '------------------------------------------------------------------------------
14d64                 | hpad_getbits
14d64     C7 73 03 F6 |                 mov     htmp, hpar1
14d68     03 72 47 F0 |                 shr     htmp, #3        ' byte offset
14d6c     F9 73 03 F1 |                 add     htmp, ptrb
14d70     B9 BF 02 FB |                 rdlong  retval, htmp
14d74                 | 
14d74     C7 75 03 F6 |                 mov     htmp1, hpar1
14d78     07 74 07 F5 |                 and     htmp1, #$07     ' shift
14d7c     BA BF 42 F0 |                 shr     retval, htmp1
14d80                 | 
14d80     18 90 1F F2 |                 cmp     hpar2, #24      wcz
14d84     10 00 90 1D |         if_a    jmp     #.l1
14d88                 | 
14d88     C8 91 C3 F9 |                 decod   hpar2
14d8c     01 90 87 F1 |                 sub     hpar2, #1
14d90     C8 BF 02 F5 |                 and     retval, hpar2
14d94     2D 00 64 FD |                 ret
14d98                 | .l1
14d98     FF 7F 00 FF 
14d9c     FF BF 06 F5 |                 and     retval, ##$00_FFFFFF
14da0     03 72 07 F1 |                 add     htmp, #3
14da4     B9 77 03 FB |                 rdlong  htmp2, htmp
14da8     18 90 87 F1 |                 sub     hpar2, #24
14dac     C8 91 C3 F9 |                 decod   hpar2
14db0     01 90 87 F1 |                 sub     hpar2, #1
14db4     BA 77 43 F0 |                 shr     htmp2, htmp1
14db8     C8 77 03 F5 |                 and     htmp2, hpar2
14dbc     18 76 67 F0 |                 shl     htmp2, #24
14dc0     BB BF 42 F5 |                 or      retval, htmp2
14dc4     2D 00 64 FD |                 ret
14dc8                 | 
14dc8                 | '------------------------------------------------------------------------------
14dc8                 | ' Normalize value to signed word (-32768 / 32767)
14dc8                 | '------------------------------------------------------------------------------
14dc8                 | ' On entry:
14dc8                 | '   retval - value to normalize
14dc8                 | '   hidr_lminmax - min (word 1) max (word 0) value range
14dc8                 | '   - or -
14dc8                 | '   hidr_pminmax - min (word 1) max (word 0) value range
14dc8                 | '   hidr_size - value bits length
14dc8                 | ' On exit:
14dc8                 | '   retval - normalized value
14dc8                 | '------------------------------------------------------------------------------
14dc8                 | hpad_normalize
14dc8     95 73 0B F6 |                 mov     htmp, hidr_lminmax  wz
14dcc     96 73 0B A6 |         if_z    mov     htmp, hidr_pminmax  wz
14dd0     2D 00 64 AD |         if_z    ret
14dd4     B9 75 3B F9 |                 getword htmp1, htmp, #1     ' htmp1 = min
14dd8     B9 73 33 F9 |                 getword htmp, htmp, #0      ' htmp = max
14ddc     0F 74 77 F7 |                 signx   htmp1, #15      wc
14de0     FF 27 97 C9 |         if_c    alts    hidr_size, #511
14de4     00 BE 66 C7 |         if_c    signx   retval, #0-0
14de8                 |                 ' slightly crappy hack: if in mouse mode, don't normalize
14de8     04 1C 0F F2 |                 cmp     hidr_type, #M_READY wz
14dec     2D 00 64 AD |         if_z    ret
14df0     BA 73 C3 F1 |                 subs    htmp, htmp1         ' htmp = (max - min)
14df4     BA BF C2 F1 |                 subs    retval, htmp1       ' retval = (retval - min)
14df8     10 BE 66 F0 |                 shl     retval, #16         ' retval = (retval - min) << 16
14dfc     01 BE C6 F1 |                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
14e00     B9 73 53 F6 |                 abs     htmp            wc
14e04     1F BE 0E F4 |                 testb   retval, #31     wz
14e08     5F BF 42 F6 |                 abs     retval
14e0c     B9 BF 12 FD |                 qdiv    retval, htmp
14e10     18 BE 62 FD |                 getqx   retval
14e14     5F BF 62 66 |     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
14e18     C0 FF 7F FF 
14e1c     00 BE 46 F1 |                 adds    retval, ##$8000 signx 15
14e20     2D 00 64 FD |                 ret
14e24                 | end
14e24                 | 
14e24                 | if _HAVE_GAMEPAD
14e24                 | '------------------------------------------------------------------------------
14e24                 | ' Handle XInput controller
14e24                 | ' On entry:
14e24                 | '   ptrb - controller report
14e24                 | '------------------------------------------------------------------------------
14e24                 | '   Default implementation translates the report to a pseudo-defacto hid
14e24                 | '   standard and jumps to hpad_translate for actions.
14e24                 | '   Implementors may take specific actions for this kind of controller.
14e24                 | '------------------------------------------------------------------------------
14e24                 | hpad_xinput
14e24     80 73 CF FA |                 rdbyte  htmp, ptrb      wz
14e28     2D 00 64 5D |         if_nz   ret                         ' Ignore message type <> $00
14e2c     81 73 C7 FA |                 rdbyte  htmp, ptrb[1]
14e30     14 72 0F F2 |                 cmp     htmp, #$14      wz
14e34     2D 00 64 5D |         if_nz   ret                         ' Ignore report length <> $14 (20)
14e38                 | 
14e38                 |                 'debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
14e38                 | 
14e38     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
14e3c     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
14e40                 | 
14e40     83 11 E7 FA |                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
14e44     84 BF E6 FA |                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
14e48     5F BF 22 F6 |                 not     retval
14e4c     5F 11 2B F9 |                 setword hidr_axis, retval, #1
14e50     85 13 E7 FA |                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
14e54     86 BF E6 FA |                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
14e58     5F BF 22 F6 |                 not     retval
14e5c     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
14e60                 | 
14e60     FF 2A 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
14e64     84 BF C6 FA |                 rdbyte  retval, ptrb[4]     ' left analog trigger
14e68     C0 BE 1E F2 |                 cmp     retval, #192    wcz
14e6c     06 18 27 34 |         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
14e70     54 FF BF FD |                 call    #hpad_normalize
14e74     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
14e78     85 BF C6 FA |                 rdbyte  retval, ptrb[5]     ' right analog trigger
14e7c     C0 BE 1E F2 |                 cmp     retval, #192    wcz
14e80     07 18 27 34 |         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
14e84     40 FF BF FD |                 call    #hpad_normalize
14e88     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
14e8c                 | 
14e8c     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
14e90     81 BF E6 FA |                 rdword  retval, ptrb[1]
14e94     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
14e98     00 18 47 F4 |                 bitc    hidr_buttons, #0
14e9c     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
14ea0     01 18 47 F4 |                 bitc    hidr_buttons, #1
14ea4     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
14ea8     02 18 47 F4 |                 bitc    hidr_buttons, #2
14eac     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
14eb0     03 18 47 F4 |                 bitc    hidr_buttons, #3
14eb4     08 BE 16 F4 |                 testb   retval, #8      wc  ' LB
14eb8     04 18 47 F4 |                 bitc    hidr_buttons, #4
14ebc     09 BE 16 F4 |                 testb   retval, #9      wc  ' RB
14ec0     05 18 47 F4 |                 bitc    hidr_buttons, #5
14ec4     05 BE 16 F4 |                 testb   retval, #5      wc  ' SELECT
14ec8     08 18 47 F4 |                 bitc    hidr_buttons, #8
14ecc     04 BE 16 F4 |                 testb   retval, #4      wc  ' START
14ed0     09 18 47 F4 |                 bitc    hidr_buttons, #9
14ed4     06 BE 16 F4 |                 testb   retval, #6      wc  ' L3
14ed8     0A 18 47 F4 |                 bitc    hidr_buttons, #10
14edc     07 BE 16 F4 |                 testb   retval, #7      wc  ' R3
14ee0     0B 18 47 F4 |                 bitc    hidr_buttons, #11
14ee4     0A BE 16 F4 |                 testb   retval, #10     wc  ' XBOX
14ee8     0C 18 47 F4 |                 bitc    hidr_buttons, #12
14eec                 | 
14eec     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
14ef0     5F 73 43 F8 |                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
14ef4     7A BB 7A FF 
14ef8     0F 74 07 F6 |                 mov     htmp1, ##$F576_F40F
14efc     F9 FF 7F FF 
14f00     12 77 07 F6 |                 mov     htmp2, ##$FFFF_F312
14f04     BA 73 5F F9 |                 altgn   htmp, #htmp1
14f08     00 72 43 F8 |                 getnib  htmp
14f0c     B9 1B C3 08 |         _ret_   setbyte hidr_hats, htmp, #0
14f10                 | 
14f10                 | '------------------------------------------------------------------------------
14f10                 | ' Handle PS3 controller
14f10                 | ' On entry:
14f10                 | '   ptrb - controller report
14f10                 | '------------------------------------------------------------------------------
14f10                 | '   Default implementation translates the report to a pseudo-defacto hid
14f10                 | '   standard and jumps to hpad_translate for actions.
14f10                 | '   Implementors may take specific actions for this kind of controller.
14f10                 | '------------------------------------------------------------------------------
14f10                 | hpad_ps3
14f10     E1 73 C7 FA |                 rdbyte  htmp, ptrb++
14f14     01 72 0F F2 |                 cmp     htmp, #$01      wz
14f18     2D 00 64 5D |         if_nz   ret                         ' Ignore report ID <> $01
14f1c                 | 
14f1c                 |                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
14f1c                 | 
14f1c     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
14f20     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
14f24                 | 
14f24     FF 2A 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
14f28     85 BF C6 FA |                 rdbyte  retval, ptrb[5]         ' X = left stick X
14f2c     98 FE BF FD |                 call    #hpad_normalize
14f30     5F 11 23 F9 |                 setword hidr_axis, retval, #0
14f34     86 BF C6 FA |                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
14f38     8C FE BF FD |                 call    #hpad_normalize
14f3c     5F 11 2B F9 |                 setword hidr_axis, retval, #1
14f40     87 BF C6 FA |                 rdbyte  retval, ptrb[7]         ' Z = right stick X
14f44     80 FE BF FD |                 call    #hpad_normalize
14f48     5F 13 23 F9 |                 setword hidr_axis+1, retval, #0
14f4c     88 BF C6 FA |                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
14f50     74 FE BF FD |                 call    #hpad_normalize
14f54     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
14f58     91 BF C6 FA |                 rdbyte  retval, ptrb[17]        ' RX = L2 analog
14f5c     68 FE BF FD |                 call    #hpad_normalize
14f60     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
14f64     92 BF C6 FA |                 rdbyte  retval, ptrb[18]        ' RY = R2 analog
14f68     5C FE BF FD |                 call    #hpad_normalize
14f6c     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
14f70                 | 
14f70     08 8E 07 F6 |                 mov     hpar1, #8
14f74     13 90 07 F6 |                 mov     hpar2, #19
14f78     E8 FD BF FD |                 call    #hpad_getbits
14f7c                 | 
14f7c     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
14f80     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
14f84     00 18 47 F4 |                 bitc    hidr_buttons, #0
14f88     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
14f8c     01 18 47 F4 |                 bitc    hidr_buttons, #1
14f90     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
14f94     02 18 47 F4 |                 bitc    hidr_buttons, #2
14f98     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
14f9c     03 18 47 F4 |                 bitc    hidr_buttons, #3
14fa0     0A BE 16 F4 |                 testb   retval, #10     wc  ' L1
14fa4     04 18 47 F4 |                 bitc    hidr_buttons, #4
14fa8     0B BE 16 F4 |                 testb   retval, #11     wc  ' R1
14fac     05 18 47 F4 |                 bitc    hidr_buttons, #5
14fb0     08 BE 16 F4 |                 testb   retval, #8      wc  ' L2
14fb4     06 18 47 F4 |                 bitc    hidr_buttons, #6
14fb8     09 BE 16 F4 |                 testb   retval, #9      wc  ' R2
14fbc     07 18 47 F4 |                 bitc    hidr_buttons, #7
14fc0     00 BE 16 F4 |                 testb   retval, #0      wc  ' SELECT
14fc4     08 18 47 F4 |                 bitc    hidr_buttons, #8
14fc8     03 BE 16 F4 |                 testb   retval, #3      wc  ' START
14fcc     09 18 47 F4 |                 bitc    hidr_buttons, #9
14fd0     01 BE 16 F4 |                 testb   retval, #1      wc  ' LEFT STICK
14fd4     0A 18 47 F4 |                 bitc    hidr_buttons, #10
14fd8     02 BE 16 F4 |                 testb   retval, #2      wc  ' RIGHT STICK
14fdc     0B 18 47 F4 |                 bitc    hidr_buttons, #11
14fe0     10 BE 16 F4 |                 testb   retval, #16     wc  ' HOME
14fe4     0C 18 47 F4 |                 bitc    hidr_buttons, #12
14fe8                 | 
14fe8     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
14fec     5F 73 4B F8 |                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
14ff0     09 FA 79 FF 
14ff4     0F 74 07 F6 |                 mov     htmp1, ##$F3F4_120F
14ff8     FF FA 7F FF 
14ffc     76 77 07 F6 |                 mov     htmp2, ##$FFF5_FF76
15000     BA 73 5F F9 |                 altgn   htmp, #htmp1
15004     00 72 43 F8 |                 getnib  htmp
15008     B9 1B C3 08 |         _ret_   setbyte hidr_hats, htmp, #0
1500c                 | 
1500c                 | 
1500c                 | '------------------------------------------------------------------------------
1500c                 | ' Perform controller actions
1500c                 | ' On entry:
1500c                 | '    hidr_id        report id
1500c                 | '    hidr_axis      axis value (signed word, 2 axes per long)
1500c                 | '                      X = hidr_axis+0, #0
1500c                 | '                      Y = hidr_axis+0, #1
1500c                 | '                      Z = hidr_axis+1, #0
1500c                 | '                     RX = hidr_axis+1, #1
1500c                 | '                     RY = hidr_axis+2, #0
1500c                 | '                     RZ = hidr_axis+2, #1
1500c                 | '                     Sl = hidr_axis+3, #0
1500c                 | '                     Wh = hidr_axis+3, #1
1500c                 | '    hidr_buttons   buttons state (bits 0 to 31)
1500c                 | '    hidr_hats      hats state (byte 0, 1, 2, 3)
1500c                 | '
1500c                 | '                     -------3 -------2 -------1 -------0 byte
1500c                 | '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
1500c                 | '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
1500c                 | '                              hlzyx||| |||||||| ++++++++ n. buttons
1500c                 | '                              |||||||| ||||++++--------- n. axes
1500c                 | '                              |||||||| ++++------------- n. hats
1500c                 | '                              ++++++++------------------ valid axes
1500c                 | '------------------------------------------------------------------------------
1500c                 | hpad_translate
1500c                 | 
1500c                 | 
1500c                 |         if HAVE_HIDPAD
1500c     A0 0C F0 FE |                 loc     ptrb,#hidpad_report
15010     2D 73 0B F6 |                 mov     htmp,hdev_port          wz
15014     8F 73 03 A6 |         if_z    mov     htmp,hidr_id
15018     01 72 E7 F2 |                 cmpsub  htmp,#1
1501c     07 1E 17 A2 |         if_z    cmp     hidr_id, #MAX_DEVICES   wc
15020     02 1E 17 52 |         if_nz   cmp     hidr_id, #2             wc
15024     2D 00 7C 3D |         if_ae   ret     wcz
15028     20 72 07 FA |                 mul     htmp, #HIDPAD_REPORT_SIZE
1502c     B9 F3 03 F1 |                 add     ptrb,htmp
15030     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
15034     00 0C 03 F6 |                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
15038     28 0E 64 FD |                 setq    #8-1
1503c     80 0D 67 FC |                 wrlong  hidr_usage,ptrb
15040                 |         end
15040                 | 
15040                 | 
15040                 |         if EMUPAD_MAX_PLAYER > 0
15040                 | .emupad_no_hat
15040                 |         if EMUPAD_BT0_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT1_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT2_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT3_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT4_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT5_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT6_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT7_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT8_BIT >= 0
15040                 |         end
15040                 |         if EMUPAD_BT9_BIT >= 0
15040                 |         end
15040                 | .emupad_slot_over
15040                 |         end
15040                 | 
15040                 |         if 0
15040                 |                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
15040                 | 
15040                 |                 debug("    btn: ", ubin_long_(hidr_buttons))
15040                 | 
15040                 |         end
15040     2D 00 64 FD |                 ret
15044                 | end
15044                 | 
15044                 | if EMUPAD_MAX_PLAYER > 0
15044                 | '------------------------------------------------------------------------------
15044                 | ' Clear EmuPad state
15044                 | '------------------------------------------------------------------------------
15044                 | emupad_reset
15044                 | 
15044                 | '------------------------------------------------------------------------------
15044                 | ' Get EmuPad Player number for current device (into retval)
15044                 | ' Z flag is also set if current device is valid
15044                 | ' (Value may be larger than EMUPAD_MAX_PLAYER !)
15044                 | '------------------------------------------------------------------------------
15044                 | emupad_getnum
15044                 | .loop
15044                 | '------------------------------------------------------------------------------
15044                 | ' Handle disconnect of device (call after emupad_getnum returns with Z set)
15044                 | '------------------------------------------------------------------------------
15044                 | emupad_discon
15044                 | .loop         
15044                 |         
15044                 |         ' FALL THROUGH!!!
15044                 | 
15044                 | '------------------------------------------------------------------------------
15044                 | ' Update EmuPad reports (all of them...)
15044                 | '------------------------------------------------------------------------------
15044                 | emupad_write_reports
15044                 | .devloop
15044                 | 
15044                 | end
15044                 | 
15044                 | 
15044                 | '------------------------------------------------------------------------------
15044                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
15044                 | '------------------------------------------------------------------------------
15044                 | ' On entry:
15044                 | ' On exit:
15044                 | '------------------------------------------------------------------------------
15044                 | hget_hub_status
15044     77 BD 02 F6 |                 mov     ep_addr_pid, hhub_ep_addr
15048     27 91 03 F6 |                 mov     hpar2, urx_buff_p
1504c     32 93 23 F9 |                 setword hpar3, hub_next_datax, #0
15050     01 92 2F F9 |                 setword hpar3, #1, #1
15054     CF 02 A0 FD |                 call    #do_int_in
15058     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1505c     0C 00 90 AD |         if_z    jmp     #.data
15060     5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
15064     1A 01 80 5D |         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
15068     2D 00 64 FD |                 ret
1506c                 | .data
1506c     00 92 0F F2 |                 cmp     hpar3, #0               wz
15070     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
15074                 | 
15074     C3 64 0E F2 |                 cmp     hub_next_datax, #PID_DATA0  wz
15078     4B 64 06 A6 |         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
1507c     C3 64 06 56 |         if_nz   mov     hub_next_datax, #PID_DATA0
15080     27 67 02 FB |                 rdlong  hub_status_chg, urx_buff_p
15084                 |                 debug(ubin_long(hub_status_chg))
15084                 | 
15084     01 5A 06 F6 |                 mov     hdev_port, #1
15088                 | .loop
15088     2D 67 0A F4 |                 testb   hub_status_chg, hdev_port wz
1508c     0C 00 B0 AD |         if_x1   call    #hub_port_handler
15090     07 5A 1E F7 |                 incmod  hdev_port, #7           wcz
15094     F0 FF 9F 3D |         if_nc   jmp     #.loop
15098     2D 00 64 FD |                 ret
1509c                 | 
1509c                 | hub_port_handler
1509c     76 BD 02 F6 |                 mov     ep_addr_pid, hhub_ctrl_ep
150a0     8C 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
150a4     27 EF 03 F6 |                 mov     pb, urx_buff_p
150a8     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
150ac     55 02 A0 FD |                 call    #control_read
150b0     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
150b4                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
150b4                 | 
150b4     10 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
150b8     50 01 90 5D |         if_x0   jmp     #.other
150bc     68 02 D0 FE |                 loc     ptra, #clr_port_feat
150c0     01 21 5C FC |                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
150c4     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
150c8     A0 02 A0 FD |                 call    #control_write
150cc     00 68 0E F4 |                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
150d0     7C 01 90 5D |         if_x0   jmp     #.disconnect
150d4     B1 99 02 F6 |                 mov     hctwait, _100ms_
150d8     EF 02 A0 FD |                 call    #poll_waitx
150dc                 | 
150dc     40 02 D0 FE |                 loc     ptra, #set_port_feat            ' reset port
150e0     01 09 5C FC |                 wrword  #HUB_PORT_RESET, ptra[wValue]
150e4     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
150e8     A0 02 A0 FD |                 call    #control_write
150ec                 | 
150ec     02 78 07 F6 |                 mov     htmp3, #2
150f0                 | .wait_reset
150f0     AD 99 02 F6 |                 mov     hctwait, _8ms_
150f4     EF 02 A0 FD |                 call    #poll_waitx
150f8     34 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
150fc     27 EF 03 F6 |                 mov     pb, urx_buff_p
15100     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
15104     55 02 A0 FD |                 call    #control_read
15108     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
1510c     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
15110     F7 79 6F 5B |         if_x0   djnz    htmp3, #.wait_reset
15114                 | 
15114     10 02 D0 FE |                 loc     ptra, #clr_port_feat
15118     01 29 5C FC |                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
1511c     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
15120     A0 02 A0 FD |                 call    #control_write
15124                 | 
15124     24 72 07 F6 |                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
15128                 | .wait_recover
15128     A8 99 02 F6 |                 mov     hctwait, _1ms_
1512c     EF 02 A0 FD |                 call    #poll_waitx
15130     FD 73 6F FB |                 djnz    htmp,#.wait_recover
15134                 | 
15134     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
15138     07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
1513c     0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
15140                 | 
15140     00 08 00 FF 
15144     00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
15148     8C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
1514c     03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
15150     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
15154     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
15158     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1515c     48 01 90 5D |         if_nz   jmp     #.done
15160                 | .get_dev_desc
15160     28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
15164     07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
15168     F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
1516c     80 01 D0 FE |                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
15170     2D 73 03 F6 |                 mov     htmp, hdev_port             ' Address is hub port number
15174     01 73 57 FC |                 wrword  htmp, ptra[wValue]
15178     A0 02 A0 FD |                 call    #control_write                  ' Execute SetAddress()
1517c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15180     24 01 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
15184     AD 99 02 F6 |                 mov     hctwait, _8ms_
15188     EF 02 A0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
1518c     2D BD 02 F6 |                 mov     ep_addr_pid, hdev_port
15190     08 BC 66 F0 |                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
15194     BE 00 A0 FD |                 call    #calc_crc5
15198     3C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
1519c     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
151a0     F7 AD C2 FA |                 rdbyte  total_data, pb
151a4     03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
151a8     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
151ac     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
151b0     F4 00 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
151b4     5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
151b8     28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
151bc                 |                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
151bc     A0 99 02 F6 |                 mov     hctwait, _500us_
151c0     EF 02 A0 FD |                 call    #poll_waitx
151c4     18 01 D0 FE |                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
151c8     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
151cc     29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
151d0     55 02 A0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
151d4     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
151d8     CC 00 90 5D |         if_nz   jmp     #.done
151dc     29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
151e0     F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
151e4     61 87 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
151e8     61 89 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
151ec     00 73 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
151f0     09 86 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
151f4     02 88 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
151f8     56 73 1B A2 |         if_z    cmp     htmp, total_data        wcz
151fc     0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
15200     A4 00 90 CD |         if_b    jmp     #.done
15204     68 F0 BF FD |                 call    #hparse_con_desc
15208     9C 00 90 FD |                 jmp     #.done
1520c                 | 
1520c                 | .other
1520c     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz
15210     01 29 5C AC |         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
15214     28 00 90 AD |         if_x1   jmp     #.reset_feature
15218     11 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
1521c     01 23 5C AC |         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
15220     1C 00 90 AD |         if_x1   jmp     #.reset_feature
15224     12 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
15228     01 25 5C AC |         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
1522c     10 00 90 AD |         if_x1   jmp     #.reset_feature
15230     13 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
15234     01 27 5C AC |         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
15238     04 00 90 AD |         if_x1   jmp     #.reset_feature
1523c     68 00 90 FD |                 jmp     #.done
15240                 | .reset_feature
15240     E4 00 D0 FE |                 loc     ptra, #clr_port_feat
15244     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
15248     A0 02 A0 FD |                 call    #control_write
1524c     58 00 90 FD |                 jmp     #.done
15250                 | .disconnect
15250                 | 
15250     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
15254     00 72 E3 F8 |                 getbyte htmp
15258     03 72 0F F2 |                 cmp     htmp,#KB_READY wz
1525c     05 72 0F 52 |         if_nz   cmp     htmp,#KBM_READY wz
15260     00 F2 06 A6 |         if_z    mov     hkbd_ep_addr, #0
15264     00 F0 06 A6 |         if_z    mov     hkbd_ctrl_ep, #0
15268     00 76 06 A6 |         if_z    mov     kb_led_states, #0
1526c     3B F9 02 A6 |         if_z    mov     hkbd_ledstates, kb_led_states
15270                 |         if EMUPAD_MAX_PLAYER > 0
15270                 |         end
15270                 |         if HAVE_MOUSE
15270     04 72 0F F2 |                 cmp     htmp, #M_READY          wz
15274     05 72 0F 52 |         if_nz   cmp     htmp, #KBM_READY        wz
15278     00 F4 06 A6 |         if_z    mov     hmouse_ep_addr, #0
1527c                 |         end
1527c                 |         if HAVE_HIDPAD
1527c     30 0A F0 FE |                 loc ptrb,#hidpad_report
15280     2D 73 03 F6 |                 mov htmp,hdev_port
15284     01 72 E7 F2 |                 cmpsub htmp,#1
15288     20 72 07 FA |                 mul htmp,#HIDPAD_REPORT_SIZE
1528c     B9 F3 03 F1 |                 add ptrb,htmp
15290     28 0E 64 FD |                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
15294     80 01 6C FC |                 wrlong #0,ptrb
15298                 |         end
15298                 | 
15298     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
1529c     00 00 C4 F8 |                 setbyte #0
152a0     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
152a4     00 00 04 F6 |                 mov     0-0, #0
152a8                 | 
152a8                 | .done
152a8     0E 6A 1F F4 |                 bitl    _usb_h_ls_nco_, #14     wcz
152ac     07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
152b0     22 6F 13 CC |         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
152b4     40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
152b8     A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
152bc     A4 9B 02 F6 |                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
152c0                 | 
152c0     6C 00 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
152c4     27 EF 03 F6 |                 mov     pb, urx_buff_p
152c8     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
152cc     55 02 A0 FD |                 call    #control_read
152d0     00 69 06 FB |                 rdlong  hub_port_status, ptra
152d4                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
152d4     2D 00 64 FD |                 ret
152d8                 | 
152d8                 | '------------------------------------------------------------------------------
152d8                 | ' Partially populated SETUP packets
152d8                 | '------------------------------------------------------------------------------
152d8     80          | get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
152d9     06          |                 byte    REQ_GET_DESC
152da     00 01       |                 word    TYPE_DEVICE << 8
152dc     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
152de     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
152e0     80          | get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
152e1     06          |                 byte    REQ_GET_DESC
152e2     00 02       |                 word    TYPE_CONFIG << 8
152e4     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
152e6     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
152e8     00          | set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
152e9     09          |                 byte    REQ_SET_CONFIG
152ea     00 00       |                 word    0       ' Configuration value
152ec     00 00       |                 word    0       ' Zero
152ee     00 00       |                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
152f0     00          | set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
152f1     05          |                 byte    REQ_SET_ADDR
152f2     00 00       |                 word    0       ' Zero
152f4     00 00       |                 word    0       ' Zero
152f6     00 00       |                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
152f8                 | '------------------------------------------------------------------------------
152f8                 | ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
152f8                 | ' wValue field dictates which protocol should be used.
152f8                 | '
152f8                 | ' When initialized, all devices default to report protocol. However the host
152f8                 | ' should not make any assumptions about the device state and should set the
152f8                 | ' desired protocol whenever initializing a device.
152f8                 | '------------------------------------------------------------------------------
152f8     21          | set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
152f9     0B          |                 byte    HID_SET_PROTO
152fa     00 00       |                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
152fc                 |                                                 ' (HID 1.11 Section 7.2.6).
152fc     00 00       |                 word    0               ' Interface index number.
152fe     00 00       |                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
15300                 | '------------------------------------------------------------------------------
15300     21          | set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
15301     0A          |                 byte    HID_SET_IDLE
15302     00 00       |                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
15304                 |                                         ' reporting until a change is detected in the report data
15304                 | 
15304                 |                                         ' (HID 1.11 Section 7.2.4).
15304     00 00       |                 word    0       ' Interface index number.
15306     00 00       |                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
15308     21          | set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
15309     09          |                 byte    HID_SET_REPORT
1530a     00 00       |                 word    0       ' Byte1 = report type, byte0 = ReportID.
1530c                 |                                         ' (HID 1.11 Section 7.2.2).
1530c     00 00       |                 word    0       ' Interface index number.
1530e     00 00       |                 word    0       ' Size of the report, in bytes.
15310     81          | get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
15311     06          |                 byte    REQ_GET_DESC
15312     00 22       |                 word    TYPE_REPORT << 8
15314     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
15316     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
15318                 | '------------------------------------------------------------------------------
15318     A0          | get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
15319     06          |                 byte    REQ_GET_DESC
1531a     00 29       |                 word    TYPE_HUB << 8
1531c     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
1531e     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
15320     23          | set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
15321     03          |                 byte    REQ_SET_FEATURE
15322     00 00       |                 word    0       ' port power
15324     01 00       |                 word    1       ' Port index number (1+)
15326     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
15328     23          | clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
15329     01          |                 byte    REQ_CLEAR_FEATURE
1532a     00 00       |                 word    0       ' port power
1532c     01 00       |                 word    1       ' Port index number (1+)
1532e     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
15330     A3          | get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
15331     00          |                 byte    REQ_GET_STATUS
15332     00 00       |                 word    0
15334     01 00       |                 word    1       ' Port index number (1+)
15336     04 00       |                 word    4       ' Number of bytes to transfer if there is a data stage
15338                 | '------------------------------------------------------------------------------
15338                 | if _HAVE_GAMEPAD
15338     42 0C 00 00 | ps3_enable_cmd  byte    $42, $0C, $00, $00
1533c                 | ps3_command_buff
1533c     00 00 00 00 
15340     00          |                 byte    $00, $00, $00, $00, $00
15341     00 00 00 00 
15345     02          |                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
15346     FF 27 10 00 
1534a     32          |                 byte    $FF, $27, $10, $00, $32
1534b     FF 27 10 00 
1534f     32          |                 byte    $FF, $27, $10, $00, $32
15350     FF 27 10 00 
15354     32          |                 byte    $FF, $27, $10, $00, $32
15355     FF 27 10 00 
15359     32          |                 byte    $FF, $27, $10, $00, $32
1535a     00 00 00 00 
1535e     00          |                 byte    $00, $00, $00, $00, $00
1535f     00 00 00 00 
15363     00          |                 byte    $00, $00, $00, $00, $00
15364     00 00 00 00 
15368     00          |                 byte    $00, $00, $00, $00, $00
15369     00 00 00    |                 byte    $00, $00, $00
1536c                 | '------------------------------------------------------------------------------
1536c     01 03 06    | xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
1536f                 |                                         ' 0x01 All blinking
1536f                 |                                         ' 0x02 1 flashes, then on
1536f                 |                                         ' 0x03 2 flashes, then on
1536f                 |                                         ' 0x04 3 flashes, then on
1536f                 |                                         ' 0x05 4 flashes, then on
1536f                 |                                         ' 0x06 1 on
1536f                 |                                         ' 0x07 2 on
1536f                 |                                         ' 0x08 3 on
1536f                 |                                         ' 0x09 4 on
1536f                 |                                         ' 0x0A Rotating (e.g. 1-2-4-3)
1536f                 |                                         ' 0x0B Blinking*
1536f                 |                                         ' 0x0C Slow blinking*
1536f                 |                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
1536f     00 08 00    | xinp_rumble_cmd byte    $00, $08, $00
15372     00          |                 byte    $00             ' Left rumble
15373     00          |                 byte    $00             ' Right rumble
15374     00 00 00    |                 byte    $00, $00, $00
15377                 | 
15377                 | xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
15377                 |                 '' of certain wired 8bitdo gamepads.
15377     80          |                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
15378     06          |                 byte    REQ_GET_DESC
15379     04 03       |                 word    TYPE_STRING << 8 + 4
1537b     09 04       |                 word    $0409   ' Zero or Language ID (Section 9.6.7)
1537d     02 00       |                 word    2       ' Number of bytes to transfer if there is a data stage
1537f     00          | end
15380                 | alignl
15380                 | 
15380                 | if HAVE_MOUSE
15380     00 00 00 00 
15384     00 00 00 00 | mouse_limits long 0[2]
15388     00 00 00 00 | mouse_outptr long 0
1538c                 | end
1538c                 | 
1538c                 | if KEYQUEUE_SIZE > 0
1538c     00          | keyq_head byte 0
1538d     00          | keyq_tail byte 0
1538e     00 00 00 00 
      ...             
1558a     00 00 00 00 
1558e     00 00       | keyq_data long 0[KEYQUEUE_SIZE]
15590                 | alignl
15590                 | end
15590                 | 
15590                 | if EMUPAD_MAX_PLAYER > 0
15590                 | emupad_rule_buffer
15590                 | if EMUPAD_BUILTIN_RULES
15590                 | file "padmap_builtin.dat"
15590                 | end
15590                 | byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
15590                 | '' Default rule directly follows!
15590                 | byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
15590                 | end
15590                 | 
15590                 | '------------------------------------------------------------------------------
15590                 | ' The USB data cache area gets zero-filled at every device disconnect
15590                 | '------------------------------------------------------------------------------
15590                 | usb_cache_start
15590                 | 
15590                 | ' HID descriptor and report buffers
15590                 | if !!OVERLAP_MEMORY
15590     00 00 00 00 
      ...             
15c88     00 00 00 00 
15c8c     00 00 00 00 | hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
15c90                 | end
15c90     00 00 00 00 
15c94     00 00 00 00 | hkbd_report     byte    0[8]
15c98     00 00 00 00 | hkbd_led_rep    byte    0
15c9c                 | alignl
15c9c                 | 
15c9c     00 00 00 00 
15ca0     00 00 00 00 
15ca4     00 00 00 00 
15ca8     00 00 00 00 
15cac     00 00 00 00 | hid_stack       long 0[(hidr_end - hidr_state) * 1]
15cb0                 | 
15cb0                 | if HAVE_HIDPAD
15cb0     00 00 00 00 
      ...             
15d88     00 00 00 00 
15d8c     00 00 00 00 | hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
15d90                 | end
15d90                 | 
15d90                 | ' HUB descriptor
15d90     00          | hub_descr       byte    0   ' bDescLength
15d91     00          |                 byte    0   ' bDescriptorType
15d92     00          |                 byte    0   ' bNbrPorts
15d93     00 00       |                 word    0   ' wHubCharacteristics
15d95     00          |                 byte    0   ' bPwrOn2PwrGood
15d96     00          |                 byte    0   ' bHubContrCurrent
15d97     00          |                 byte    0   ' DeviceRemoveable
15d98     00          |                 byte    0   ' PortPwrCtrlMask
15d99                 | 
15d99                 | usb_cache_end
15d99                 | 
15d99                 | if HAVE_MOUSE
15d99     00 00 00 00 | mouse_xacc      long 0
15d9d     00 00 00 00 | mouse_yacc      long 0
15da1     00 00 00 00 | mouse_zacc      long 0
15da5     00          | mouse_bstate    byte 0
15da6     00          | mouse_lpending  byte 0
15da7     00          | mouse_rpending  byte 0
15da8     00          | mouse_mpending  byte 0
15da9     00          | mouse_lock      byte 0
15daa     00 00 00    |                 byte 0[3] ' padding
15dad                 | end
15dad                 | 
15dad     00 00 00 00 
      ...             
15e25     00 00 00 00 
15e29     00 00 00 00 | urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
15e2d     00 00 00 00 
15e31     00 00 00 00 
15e35     00 00 00 00 
15e39     00 00 00 00 
15e3d     00 00       | dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
15e3f     00 00 00 00 
      ...             
15f37     00 00 00 00 
15f3b     00 00 00 00 | con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
15f3f                 | 
15f3f     00          | driver_cog      byte    0                       ' Current driver cog + 1
15f40                 | 	alignl
15f40                 | _Audio2_004_spin2_dat_
15f40                 | 
15f40                 | audio       	org     0
15f40                 | 
15f40     61 79 05 FB |             	rdlong  mailbox2, ptra++     	' get start address of all mailboxes
15f44     61 B1 05 FB |             	rdlong  scbase, ptra++       	' get start address of scope buffer
15f48     61 BD 05 FB |             	rdlong  hubptr, ptra++       	' get start address of PSRAM cache
15f4c                 | 
15f4c     01 EC 63 FD |             	cogid   pa                   	' compute cogid
15f50     0C EC 07 FA |             	mul     pa, #12              	' and mailbox spacing
15f54     F6 79 01 F1 |             	add     mailbox2, pa         	' add offset to find this COG's mailbox
15f58     BC 76 01 F6 |             	mov     mailbox, mailbox2     	' we need 2 copies of this to enable switching between hub and psram
15f5c                 | 
15f5c     0E BA 05 FC |             	wrpin   dac2,#left           	' PWM DACs at 44100@339 MHz
15f60     0E BE 15 FC |             	wxpin   sr44100,#left      	' 30*256
15f64     0F BA 05 FC |             	wrpin   dac2,#right
15f68     0F BE 15 FC |             	wxpin   sr44100,#right    
15f6c     41 9C 64 FD |             	dirh    #left addpins 1
15f70     20 9C 64 FD |             	setse1  #%001<<6 + left      	' Set the event - DAC empty
15f74                 |   'debug(uhex(mailbox))
15f74                 |             
15f74                 | '---------------------------------------------------------------------------------        
15f74                 | '----------------- The main loop -------------------------------------------------
15f74                 | '---------------------------------------------------------------------------------
15f74                 | 
15f74     0F A8 05 F6 | loop       	mov 	    cn,#15 '7
15f78                 |               					'   waitx ##3300000  		'for debug
15f78                 |             
15f78                 | '----------------------------------------------------------------------------------
15f78                 | '------------- Get parameters and execute commands if any -------------------------
15f78                 | '----------------------------------------------------------------------------------
15f78                 | 
15f78                 | 
15f78     1A F6 61 FD | p401        	getct ct1
15f7c     D4 70 01 F6 |                 mov     channeladd,cn             	' compute the pointer to channel parameters block
15f80     06 70 65 F0 |             	shl     channeladd,#6
15f84     B8 F0 03 F1 |             	add     ptra,channeladd
15f88                 | 
15f88     28 1A 64 FD |             	setq    #13                       	' read parameters
15f8c     00 7F 05 FB |             	rdlong  pointer0,ptra
15f90     1F 92 1D F4 | p408        	bitl    command0,#31 wcz	      	' bit #31 command - set the DAC sample rate
15f94     2C 00 90 3D |     	if_nc   jmp     #p404                     	' if not set, proceed
15f98     C9 72 01 F6 |             	mov     qq,command0             	' get the new rate
15f9c     4E 72 15 FC |             	wxpin   qq,#left addpins 1        	' and program the pins
15fa0     B9 72 E1 F8 |             	getbyte qq,qq,#0 		      	' check if the rate is n*256
15fa4     00 72 0D F2 |             	cmp     qq,#0 wz                         
15fa8     4E BA 05 AC |     	if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
15fac     4E B8 05 5C |     	if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
15fb0                 |                 
15fb0     1E 88 1D F4 |                	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
15fb4     00 7E 05 A6 |     	if_z    mov     pointer0, #0  
15fb8     00 80 05 A6 |     	if_z    mov     pointer0h, #0  
15fbc     00 86 05 A6 |     	if_z    mov     envph0, #0  
15fc0     05 89 65 AC |     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
15fc4                 |     	
15fc4     C4 72 01 F6 | p404        	mov     qq,sstart0		     	' check if start>$80000
15fc8     FF FF 03 FF 
15fcc     FF 73 05 F5 | 		and 	qq,##$7FFFFFF 
15fd0     00 04 00 FF 
15fd4     00 72 1D F2 |                 cmp 	qq,##$80000 wcz
15fd8     BC 76 01 36 |     	if_ge   mov     mailbox,mailbox2          	' if yes, use PSRAM
15fdc     00 76 05 C6 |     	if_lt   mov     mailbox,#0                	' if not, use HUB 
15fe0                 |  ''debug(uhex(sstart0,mailbox))
15fe0     C7 A4 39 F9 | p405           	getword apan0,volpan0,#1          	' extract vol,pan from longs 
15fe4     C7 A2 31 F9 |     	    	getword avol0,volpan0,#0
15fe8                 |     	'   debug(uhex(pointer0,pointer0h,sstart0)) 	
15fe8                 | '----------------------------------------------------------------------------------
15fe8                 | '------------- Compute the envelope, if exists ------------------------------------
15fe8                 | '----------------------------------------------------------------------------------
15fe8                 |             
15fe8     00 94 1D F2 |             	cmp     envptr0,#0 wcz     		' read the pointer
15fec     20 00 00 AF 
15ff0     00 F0 05 A6 |     	if_z    mov     envs1,##$4000			' if 0, no envelope, load $4000=1 for scas
15ff4     54 00 90 AD |     	if_z    jmp     #p410				' and run away	
15ff8                 | 
15ff8     CB 86 01 F1 |            	add     envph0,envspd0			' envelope PA update
15ffc                 |            	           
15ffc     C3 EC 01 F6 |       	    	mov     envhi, envph0			' move phase acc to high part of env pointer
16000     06 EC 45 F0 | 		shr     envhi,#6			' leave 10 bits in hi
16004     F6 EE 31 F9 | 	   	getword envlo,envhi,#0              	' and 16 bit in lo
16008     10 EC 45 F0 | 	    	shr     envhi,#16			' move 10 bits of hi to the lower word
1600c     CC EC 19 F2 | 	    	cmp     envhi,envlen0 wcz		' compare this to envelope length
16010                 | 	    											'debug(udec(envhi,envlen0))
16010     CC EC 01 36 |     	if_ge  	mov     envhi,envlen0			' if greater than, set it at envlen
16014     00 EE 05 36 |     	if_ge   mov     envlo,#0
16018     CC 86 01 36 |     	if_ge   mov     envph0,envlen0             	' and set envph0 at the end of the envelope
1601c     16 86 65 30 |     	if_ge   shl     envph0,#22
16020                 | 
16020     F6 F0 01 F6 |             	mov 	envs1,envhi			' 10 high bits of PA is the offset to the envelope entry
16024     01 F0 65 F0 |             	shl 	envs1,#1                        ' these entries are 16 bit so multiply the offset by 2
16028     CA F0 01 F1 |             	add 	envs1,envptr0                   ' and add it to the pointer
1602c     F8 F0 01 FB |             	rdlong 	envs1,envs1			' and then read 2 entries in one rdlong
16030     F8 F2 39 F9 |             	getword envs2,envs1,#1			' then separate them		
16034     F8 F0 31 F9 |            	getword envs1,envs1,#0
16038     F7 F2 01 FA |             	mul     envs2,envlo                     ' and do linear interpolation based on lower bits of the offset
1603c     F7 EE 21 F6 |             	not     envlo
16040     F7 F0 01 FA |             	mul     envs1,envlo
16044     F9 F0 01 F1 |             	add     envs1,envs2
16048     12 F0 45 F0 |             	shr     envs1,#18			' we need only 14 bits for scas
1604c                 |               
1604c                 | '----------------------------------------------------------------------------------
1604c                 | '------------- Generate the noise if bit 27 of the pointer is set -----------------
1604c                 | '----------------------------------------------------------------------------------
1604c                 | 
1604c                 | 
1604c                 |     	
1604c                 | '----------------------------------------------------------------------------------
1604c                 | '------------- Get the sample -----------------------------------------------------
1604c                 | '----------------------------------------------------------------------------------    	
1604c                 |  
1604c     C0 A6 01 F6 | p410  		mov	oldptrh,pointer0h
16050     C8 A0 F9 F8 |            	getbyte	afreq0,freqskip0,#3         	' the frequency is in 8:24 format, so get integer in afreq0
16054     08 90 65 F0 |            	shl	freqskip0,#8                	' and keep the fractional in freqskip0
16058     C8 7E 19 F1 |            	add     pointer0,freqskip0 wcz      	' compute the pointer to the next sample   
1605c     D0 80 21 F1 |            	addx	pointer0h,afreq0  
16060                 |           	
16060     1B 88 0D F4 |    	   	testb   sstart0, #27 wz
16064     10 00 90 5D |     	if_nz	jmp #p412   	
16068     1B 74 61 CD |    	if_c  	getrnd  spl
1606c     BA 84 41 C9 |    	if_c	rolword rawspl0,spl,#0	
16070     C2 74 31 F9 |    		getword spl,rawspl0,#0
16074     90 00 90 FD |       	        jmp     #p406          	
16078                 |            	
16078                 |            	
16078     D3 80 19 F2 | p412 		cmp	pointer0h,oldptrh wcz
1607c     58 00 90 AD |  	if_e 	jmp 	#p411				' if the pointer didn't change, no sample has to be read
16080                 |      	
16080     1F 88 0D F4 |             	testb   sstart0,#31 wz       	   	' bit 31 : 16 bit sample  
16084     01 80 65 A0 |      	if_z    shl     pointer0h,#1        
16088     1C 88 0D F4 |             	testb   sstart0,#28 wz  		' bit 28 : interleaved sample         
1608c     01 80 65 A0 |      	if_z    shl     pointer0h,#1        
16090                 | 												
16090     C6 80 19 F2 |             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
16094     C6 80 81 31 |    	if_ge   sub     pointer0h,lend0       
16098     C5 80 01 31 |         if_ge   add     pointer0h,lstart0
1609c     C6 80 19 F2 |             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
160a0     C6 80 01 36 |         if_ge   mov	pointer0h,lend0	
160a4                 |  
160a4     C0 72 01 F6 |              	mov     qq,pointer0h              	' compute place in the memory from where the sample will be loaded
160a8     C4 72 01 F1 |            	add     qq,sstart0            
160ac     FF FF 00 FF 
160b0     FF 73 05 F5 |            	and  	qq,##$1FF_FFFF
160b4     FF 77 5D F2 |            	cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
160b8     B9 74 E1 EA |     	if_le   rdword  spl,qq                      	' if not, use HUB RAM for samples
160bc     00 01 B0 1D |     	if_gt   call    #cache_read
160c0     1F 88 0D F4 |                 testb   sstart0,#31 wz 
160c4     08 74 65 50 |     	if_nz   shl     spl,#8				' convert 8 to 16 bit if needed
160c8     01 80 45 A0 |         if_z    shr     pointer0h,#1
160cc     1C 88 0D F4 |                 testb   sstart0,#28 wz            
160d0     01 80 45 A0 |     	if_z    shr     pointer0h,#1    
160d4     BA 84 41 F9 |                 rolword rawspl0,spl,#0			' now rawspl0 has oldsample:newsample in it
160d8                 |               
160d8     C2 74 31 F9 | p411	      	getword spl,rawspl0,#0
160dc     C2 9E 39 F9 | 		getword oldspl,rawspl0,#1		' then separate them		
160e0                 | 
160e0                 |           '  debug(uhex(pointer0h,pointer0,spl,oldspl))
160e0                 | 
160e0                 | 
160e0     BF EE 01 F6 | 		mov	envlo,pointer0
160e4     12 EE 45 F0 | 		shr 	envlo,#18
160e8                 | 	
160e8     F7 74 31 FA |             	scas    spl,envlo                   	' and do linear interpolation
160ec     00 74 01 F6 |             	mov 	spl,0-0
160f0     F7 EE 21 F6 |             	not     envlo
160f4     1F 00 00 FF 
160f8     FF EF 05 F5 |           	and     envlo,##$3FFF
160fc     F7 9E 31 FA |            	scas    oldspl,envlo
16100     00 9E 01 F6 |             	mov     oldspl,0-0
16104     CF 74 01 F1 |                 add     spl, oldspl
16108                 | 	 
16108     F8 74 31 FA | p406        	scas    spl, envs1
1610c     00 74 01 F6 |             	mov     spl,0-0
16110     D1 74 31 FA |             	scas    spl,avol0                 	' apply volume
16114     00 74 01 F6 |             	mov     spl,0-0
16118                 |  
16118     D2 74 31 FA |             	scas    spl,apan0                 	' apply pan
1611c     00 AA 01 F6 |             	mov     ls0,0-0
16120     20 00 00 FF 
16124     00 72 05 F6 |             	mov     qq,##16384
16128     D2 72 81 F1 |             	sub     qq,apan0
1612c     B9 74 31 FA |             	scas    spl,qq
16130     00 AC 01 F6 |             	mov     rs0, 0-0
16134                 |       
16134     D6 82 29 F9 |                 setword sample0,rs0,#1           	' pack samples into long
16138     D5 82 21 F9 |                 setword sample0,ls0,#0
1613c                 |                 
1613c     D5 7A 01 F1 |                 add  lsample,ls0
16140     D6 7C 01 F1 |                 add  rsample,rs0
16144                 |              
16144     1E 88 1D F4 |             	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
16148     00 7E 05 A6 |     	if_z    mov     pointer0, #0  
1614c     00 80 05 A6 |     	if_z    mov     pointer0h, #0  
16150     00 86 05 A6 |     	if_z    mov     envph0, #0  
16154     05 89 65 AC |     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
16158                 |             
16158     28 08 64 FD | p403        	setq #4                          	' write new pointer, sample values and env pointer to the hub
1615c     00 7F 65 FC | 	       	wrlong  pointer0,ptra
16160     B8 F0 83 F1 |             	sub     ptra, channeladd         	' reset the pointer to channel parameters
16164                 | 
16164     84 A9 7D FB |             	djnf    cn, #p401
16168                 | 
16168     0F 7C E5 F4 |             	bitnot rsample, #15
1616c     0F 7A E5 F4 |             	bitnot lsample, #15
16170     1A F8 61 FD |   							           	getct ct2  	'debug
16174     FB F8 81 F1 |   							          	sub ct2,ct1
16178                 |   							          	debug(udec(ct2))
16178     24 28 60 FD |             	waitse1
1617c                 |           
1617c     0E 7A 25 FC |            	wypin   lsample, #left              
16180     0F 7C 25 FC |                 wypin   rsample, #right        
16184                 | 
16184     BD AE 21 F9 | 		setword oldsample, lsample,#0		' for oscilloscope
16188     BE AE 29 F9 | 		setword oldsample, rsample,#1
1618c                 | 		
1618c     00 7C 05 F6 |             	mov rsample, #0
16190     00 7A 05 F6 |             	mov lsample, #0
16194                 | 
16194                 | '----------------------------------------------------------------------------------
16194                 | '------------- Oscilloscope  -----------------------------------------------------
16194                 | '----------------------------------------------------------------------------------   
16194                 | 		
16194     00 B0 0D F2 | 	    	cmp     scbase,#0 wz
16198     20 00 90 AD |     	if_z    jmp #p302	   
1619c                 |  
1619c     01 B6 15 F7 |             	incmod  scope,#1 wc            		'  todo: scope speed instead of const  
161a0     D9 B4 01 C6 |     	if_c    mov scptr2,scptr
161a4     02 B4 65 C0 |     	if_c    shl scptr2,#2
161a8     D8 B4 01 C1 |     	if_c    add scptr2,scbase     
161ac     60 B4 65 FC |             	wrlong scptr2,#$60
161b0     DA AE 61 CC |     	if_c    wrlong oldsample,scptr2
161b4     01 00 00 CF 
161b8     7F B2 05 C7 |     	if_c    incmod scptr,##639
161bc                 |             
161bc     B4 FD 9F FD |  p302           jmp     #loop            'loop
161c0                 | 
161c0                 | '----------------------------------------------------------------------------------
161c0                 | '------------- This is the end of the main loop -----------------------------------
161c0                 | '----------------------------------------------------------------------------------
161c0                 | 
161c0                 | '----------------------------------------------------------------------------------
161c0                 | '------------- PSRAM cache ----------- --------------------------------------------
161c0                 | '----------------------------------------------------------------------------------
161c0                 | 
161c0                 | ' There are 16 cache pointers for 16 channels
161c0                 | ' if 24 higher bits of address=cache, then get a word from the cache
161c0                 | ' else load the cache from PSRAM, update the pointer, then read a sample
161c0                 | 
161c0                 | 
161c0     B9 E6 E1 F8 | cache_read  	getbyte addrlo,qq,#0 			' when this is called, qq is the addres of the sample			
161c4                 |          '   debug ("cache")
161c4     B9 E8 01 F6 | 	   	mov     addrhi,qq		
161c8     08 E8 45 F0 | 	    	shr     addrhi,#8		        ' get 24 upper bits
161cc     E0 A8 95 F9 | 	    	alts    cn,#cache1            
161d0     00 E8 09 F2 | 	    	cmp	addrhi,0-0 wz               	' and compare with the cache pointer for the channel
161d4     34 00 90 AD |    	if_z    jmp     #p701	    			' if equal, cache hit, read the sample from it
161d8                 | 
161d8     E0 A8 8D F9 | p702	    	altd    cn,#cache1			' cache miss. 
161dc     F4 00 00 F6 | 	    	mov     0-0,addrhi                  	' update the pointer
161e0                 | 	    ''	 debug(uhex(addrhi))
161e0     F4 E0 01 F6 | 	    	mov     cmd,addrhi			' prepare the mailbox
161e4     08 E0 65 F0 | 	    	shl     cmd,#8
161e8     0B E0 3D F8 |             	setnib  cmd, #%1011, #7             	' read burst from the external memory
161ec     D4 E2 01 F6 |             	mov     hubaddr,cn                  	' to the channel cache
161f0     08 E2 65 F0 |             	shl     hubaddr,#8                  	'
161f4     DE E2 01 F1 |             	add     hubaddr,hubptr 
161f8     00 E5 05 F6 |             	mov     count,#256                  	' 256 bytes
161fc     28 04 64 FD |             	setq    #2                          	' write 3 longs
16200     BB E0 61 FC |             	wrlong  cmd, mailbox                	' run it
16204     BB E0 01 FB | poll1       	rdlong  cmd, mailbox                	' poll mailbox for result
16208     FE E1 B5 FB |             	tjs     cmd, #poll1                 	' retry until valid 
1620c                 |             
1620c                 | 	
1620c     D4 72 01 F6 | p701	    	mov     qq,cn				' cache hit
16210     08 72 65 F0 | 	    	shl     qq,#8				' compute the cache start
16214     DE 72 01 F1 | 	    	add     qq,hubptr
16218     F3 72 01 F1 | 	    	add	qq,addrlo			' add 8 lower bits to the cache addredd
1621c     B9 74 E1 0A |     	_ret_   rdword  spl,qq                      	' read a long from the cache
16220                 |           
16220                 |   
16220                 | 
16220                 | 
16220                 | '---------------------------------------------------------------------------
16220                 | '------- Variables ---------------------------------------------------------
16220                 | '---------------------------------------------------------------------------
16220                 | 
16220                 | ' constants
16220                 | 
16220     00 00 00 00 | channeladd 	long 0
16224                 | 
16224                 | ' temporary variables 
16224                 | 
16224     00 00 00 00 | qq          	long 0
16228     00 00 00 00 | spl         	long 0
1622c     00 00 00 00 | mailbox     	long 0
16230     00 00 00 00 | mailbox2    	long 0
16234     00 00 00 00 | lsample     	long 0
16238     00 00 00 00 | rsample     	long 0
1623c                 | 
1623c                 | ' channel parameter block
1623c                 | 
1623c     00 00 00 00 | pointer0    	long 0   
16240     00 00 00 00 | pointer0h   	long 0  
16244     00 00 00 00 | sample0     	long 0
16248     00 00 00 00 | rawspl0	    	long 0
1624c     00 00 00 00 | envph0	    	long 0
16250     00 00 00 00 | sstart0     	long 0     ' start pointer and type at bit 31
16254     00 00 00 00 | lstart0     	long 0
16258     00 00 00 00 | lend0       	long 0
1625c     00 00 00 00 | volpan0     	long 0
16260     00 00 00 00 | freqskip0   	long 0
16264     00 00 00 00 | command0    	long 0
16268     00 00 00 00 | envptr0	    	long 0
1626c     00 00 00 00 | envspd0	    	long 0
16270     00 00 00 00 | envlen0	    	long 0
16274     00 00 00 00 | res5	    	long 0
16278     00 00 00 00 | res6	    	long 0
1627c                 | 
1627c     00 00 00 00 | oldspl		long 0
16280     00 00 00 00 | afreq0      	long 0
16284                 | 
16284     00 00 00 00 | avol0       	long 0
16288     00 00 00 00 | apan0       	long 0
1628c     00 00 00 00 | oldptrh	    	long 0
16290     00 00 00 00 | cn          	long 0
16294                 | 
16294                 | ' Samples
16294                 | 
16294     00 00 00 00 | ls0         	long 0
16298     00 00 00 00 | rs0         	long 0
1629c                 | 
1629c     00 00 00 00 | oldsample   	long 0
162a0                 | 
162a0     00 00 00 00 | scbase 		long 0
162a4     00 00 00 00 | scptr 		long 0
162a8     00 00 00 00 | scptr2		long 0
162ac     00 00 00 00 | scope 		long 0
162b0                 | 
162b0     44 00 17 00 | dac         	long %10111_00000000_01_00010_0     	'random dither
162b4     46 00 17 00 | dac2        	long %10111_00000000_01_00011_0     	'pwm
162b8                 | 
162b8     00 18 07 00 | hubptr      	long $71800
162bc     00 1E 00 00 | sr44100     	long 30*256
162c0                 | 
162c0     00 00 00 00 | cache1      	long 0
162c4     00 00 00 00 | cache2      	long 0
162c8     00 00 00 00 | cache3      	long 0
162cc     00 00 00 00 | cache4      	long 0
162d0     00 00 00 00 | cache5      	long 0
162d4     00 00 00 00 | cache6      	long 0
162d8     00 00 00 00 | cache7      	long 0
162dc     00 00 00 00 | cache8      	long 0
162e0     00 00 00 00 | cache9      	long 0
162e4     00 00 00 00 | cachea      	long 0
162e8     00 00 00 00 | cacheb      	long 0
162ec     00 00 00 00 | cachec      	long 0
162f0     00 00 00 00 | cached      	long 0
162f4     00 00 00 00 | cachee      	long 0
162f8     00 00 00 00 | cachef      	long 0
162fc     00 00 00 00 | cache0      	long 0
16300                 | 
16300     00 00 00 00 | cmd         	long 0
16304     00 00 00 00 | hubaddr    	long 0
16308     00 01 00 00 | count       	long 256
1630c                 | 
1630c     00 00 00 00 | addrlo 		long 0
16310     00 00 00 00 | addrhi 		long 0
16314     00 00 00 00 | pointer00 	long 0
16318     00 00 00 00 | envhi 		long 0
1631c     00 00 00 00 | envlo 		long 0
16320     00 00 00 00 | envs1 		long 0
16324     00 00 00 00 | envs2 		long 0
16328     00 00 00 00 | noise0 		long 0
1632c                 | 
1632c     00 00 00 00 |  ct1 		long 0
16330     00 00 00 00 |  ct2 		long 0
16334                 | 
16334                 | 		fit 256		'todo: maybe the better interpolation. Or all params in cog
16334                 | 		fit 256		'todo: maybe the better interpolation. Or all params in cog
16334     00 00 00 00 
16338     00 00 00 00 | null  			long 	0,0           ' for channel reset
1633c                 | 	alignl
1633c                 | __system__dat_
1633c     00 00 00 00 
16340     00 00 00 00 | 	byte	$00[8]
16344     03 00 00 00 
16348     00 00 00 00 
1634c     00 00 00 00 
16350     00 00 00 00 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
16354     00 00 00 00 
      ...             
165e0     00 00 00 00 
165e4     00 00 00 00 | 	byte	$00[660]
165e8     00 00 80 00 | 	long	(8 {__system____root_opendir})<<20
165ec     00 00 90 00 | 	long	(9 {__system____root_closedir})<<20
165f0     00 00 A0 00 | 	long	(10 {__system____root_readdir})<<20
165f4     00 00 B0 00 | 	long	(11 {__system____root_stat})<<20
165f8     00 00 00 00 
      ...             
1661c     00 00 00 00 
16620     00 00 00 00 | 	byte	$00[44]
16624     01 80 00 00 
16628     00 00 00 00 
1662c     00 00 00 00 
16630     00 00 00 00 | 	byte	$01, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
16634     00 00 00 00 | 	byte	$00, $00, $00, $00
16638     00 00 90 02 | 	long	(41 {__system___tx})<<20
1663c     00 00 A0 02 | 	long	(42 {__system___rx})<<20
16640     00 00 00 00 | 	byte	$00, $00, $00, $00
16644     00 00 B0 02 | 	long	(43 {__system___rxtxioctl_0227})<<20
16648     00 00 C0 02 | 	long	(44 {__system____dummy_flush_0228})<<20
1664c     00 00 00 00 
16650     00 00 00 00 | 	byte	$00[8]
16654     01 00 00 00 
16658     02 80 00 00 
1665c     00 00 00 00 
16660     00 00 00 00 | 	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
16664     00 00 00 00 
16668     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
1666c     00 00 90 02 | 	long	(41 {__system___tx})<<20
16670     00 00 A0 02 | 	long	(42 {__system___rx})<<20
16674     00 00 00 00 | 	byte	$00, $00, $00, $00
16678     00 00 B0 02 | 	long	(43 {__system___rxtxioctl_0227})<<20
1667c     00 00 C0 02 | 	long	(44 {__system____dummy_flush_0228})<<20
16680     00 00 00 00 
16684     00 00 00 00 | 	byte	$00[8]
16688     01 00 00 00 
1668c     02 80 00 00 
16690     00 00 00 00 
16694     00 00 00 00 | 	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
16698     00 00 00 00 
1669c     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
166a0     00 00 90 02 | 	long	(41 {__system___tx})<<20
166a4     00 00 A0 02 | 	long	(42 {__system___rx})<<20
166a8     00 00 00 00 | 	byte	$00, $00, $00, $00
166ac     00 00 B0 02 | 	long	(43 {__system___rxtxioctl_0227})<<20
166b0     00 00 C0 02 | 	long	(44 {__system____dummy_flush_0228})<<20
166b4     00 00 00 00 
      ...             
16820     00 00 00 00 
16824     00 00 00 00 | 	byte	$00[372]
16828                 | 	alignl
16828                 | _fatfs_cc_dat_
16828     C7 00 FC 00 
1682c     E9 00 E2 00 
16830     E4 00 E0 00 
16834     E5 00 E7 00 | 	byte	$c7, $00, $fc, $00, $e9, $00, $e2, $00, $e4, $00, $e0, $00, $e5, $00, $e7, $00
16838     EA 00 EB 00 
1683c     E8 00 EF 00 
16840     EE 00 EC 00 
16844     C4 00 C5 00 | 	byte	$ea, $00, $eb, $00, $e8, $00, $ef, $00, $ee, $00, $ec, $00, $c4, $00, $c5, $00
16848     C9 00 E6 00 
1684c     C6 00 F4 00 
16850     F6 00 F2 00 
16854     FB 00 F9 00 | 	byte	$c9, $00, $e6, $00, $c6, $00, $f4, $00, $f6, $00, $f2, $00, $fb, $00, $f9, $00
16858     FF 00 D6 00 
1685c     DC 00 F8 00 
16860     A3 00 D8 00 
16864     D7 00 92 01 | 	byte	$ff, $00, $d6, $00, $dc, $00, $f8, $00, $a3, $00, $d8, $00, $d7, $00, $92, $01
16868     E1 00 ED 00 
1686c     F3 00 FA 00 
16870     F1 00 D1 00 
16874     AA 00 BA 00 | 	byte	$e1, $00, $ed, $00, $f3, $00, $fa, $00, $f1, $00, $d1, $00, $aa, $00, $ba, $00
16878     BF 00 AE 00 
1687c     AC 00 BD 00 
16880     BC 00 A1 00 
16884     AB 00 BB 00 | 	byte	$bf, $00, $ae, $00, $ac, $00, $bd, $00, $bc, $00, $a1, $00, $ab, $00, $bb, $00
16888     91 25 92 25 
1688c     93 25 02 25 
16890     24 25 C1 00 
16894     C2 00 C0 00 | 	byte	$91, $25, $92, $25, $93, $25, $02, $25, $24, $25, $c1, $00, $c2, $00, $c0, $00
16898     A9 00 63 25 
1689c     51 25 57 25 
168a0     5D 25 A2 00 
168a4     A5 00 10 25 | 	byte	$a9, $00, $63, $25, $51, $25, $57, $25, $5d, $25, $a2, $00, $a5, $00, $10, $25
168a8     14 25 34 25 
168ac     2C 25 1C 25 
168b0     00 25 3C 25 
168b4     E3 00 C3 00 | 	byte	$14, $25, $34, $25, $2c, $25, $1c, $25, $00, $25, $3c, $25, $e3, $00, $c3, $00
168b8     5A 25 54 25 
168bc     69 25 66 25 
168c0     60 25 50 25 
168c4     6C 25 A4 00 | 	byte	$5a, $25, $54, $25, $69, $25, $66, $25, $60, $25, $50, $25, $6c, $25, $a4, $00
168c8     F0 00 D0 00 
168cc     CA 00 CB 00 
168d0     C8 00 31 01 
168d4     CD 00 CE 00 | 	byte	$f0, $00, $d0, $00, $ca, $00, $cb, $00, $c8, $00, $31, $01, $cd, $00, $ce, $00
168d8     CF 00 18 25 
168dc     0C 25 88 25 
168e0     84 25 A6 00 
168e4     CC 00 80 25 | 	byte	$cf, $00, $18, $25, $0c, $25, $88, $25, $84, $25, $a6, $00, $cc, $00, $80, $25
168e8     D3 00 DF 00 
168ec     D4 00 D2 00 
168f0     F5 00 D5 00 
168f4     B5 00 FE 00 | 	byte	$d3, $00, $df, $00, $d4, $00, $d2, $00, $f5, $00, $d5, $00, $b5, $00, $fe, $00
168f8     DE 00 DA 00 
168fc     DB 00 D9 00 
16900     FD 00 DD 00 
16904     AF 00 B4 00 | 	byte	$de, $00, $da, $00, $db, $00, $d9, $00, $fd, $00, $dd, $00, $af, $00, $b4, $00
16908     AD 00 B1 00 
1690c     17 20 BE 00 
16910     B6 00 A7 00 
16914     F7 00 B8 00 | 	byte	$ad, $00, $b1, $00, $17, $20, $be, $00, $b6, $00, $a7, $00, $f7, $00, $b8, $00
16918     B0 00 A8 00 
1691c     B7 00 B9 00 
16920     B3 00 B2 00 
16924     A0 25 A0 00 | 	byte	$b0, $00, $a8, $00, $b7, $00, $b9, $00, $b3, $00, $b2, $00, $a0, $25, $a0, $00
16928     61 00 1A 03 
1692c     E0 00 17 03 
16930     F8 00 07 03 
16934     FF 00 01 00 | 	byte	$61, $00, $1a, $03, $e0, $00, $17, $03, $f8, $00, $07, $03, $ff, $00, $01, $00
16938     78 01 00 01 
1693c     30 01 32 01 
16940     06 01 39 01 
16944     10 01 4A 01 | 	byte	$78, $01, $00, $01, $30, $01, $32, $01, $06, $01, $39, $01, $10, $01, $4a, $01
16948     2E 01 79 01 
1694c     06 01 80 01 
16950     4D 00 43 02 
16954     81 01 82 01 | 	byte	$2e, $01, $79, $01, $06, $01, $80, $01, $4d, $00, $43, $02, $81, $01, $82, $01
16958     82 01 84 01 
1695c     84 01 86 01 
16960     87 01 87 01 
16964     89 01 8A 01 | 	byte	$82, $01, $84, $01, $84, $01, $86, $01, $87, $01, $87, $01, $89, $01, $8a, $01
16968     8B 01 8B 01 
1696c     8D 01 8E 01 
16970     8F 01 90 01 
16974     91 01 91 01 | 	byte	$8b, $01, $8b, $01, $8d, $01, $8e, $01, $8f, $01, $90, $01, $91, $01, $91, $01
16978     93 01 94 01 
1697c     F6 01 96 01 
16980     97 01 98 01 
16984     98 01 3D 02 | 	byte	$93, $01, $94, $01, $f6, $01, $96, $01, $97, $01, $98, $01, $98, $01, $3d, $02
16988     9B 01 9C 01 
1698c     9D 01 20 02 
16990     9F 01 A0 01 
16994     A0 01 A2 01 | 	byte	$9b, $01, $9c, $01, $9d, $01, $20, $02, $9f, $01, $a0, $01, $a0, $01, $a2, $01
16998     A2 01 A4 01 
1699c     A4 01 A6 01 
169a0     A7 01 A7 01 
169a4     A9 01 AA 01 | 	byte	$a2, $01, $a4, $01, $a4, $01, $a6, $01, $a7, $01, $a7, $01, $a9, $01, $aa, $01
169a8     AB 01 AC 01 
169ac     AC 01 AE 01 
169b0     AF 01 AF 01 
169b4     B1 01 B2 01 | 	byte	$ab, $01, $ac, $01, $ac, $01, $ae, $01, $af, $01, $af, $01, $b1, $01, $b2, $01
169b8     B3 01 B3 01 
169bc     B5 01 B5 01 
169c0     B7 01 B8 01 
169c4     B8 01 BA 01 | 	byte	$b3, $01, $b3, $01, $b5, $01, $b5, $01, $b7, $01, $b8, $01, $b8, $01, $ba, $01
169c8     BB 01 BC 01 
169cc     BC 01 BE 01 
169d0     F7 01 C0 01 
169d4     C1 01 C2 01 | 	byte	$bb, $01, $bc, $01, $bc, $01, $be, $01, $f7, $01, $c0, $01, $c1, $01, $c2, $01
169d8     C3 01 C4 01 
169dc     C5 01 C4 01 
169e0     C7 01 C8 01 
169e4     C7 01 CA 01 | 	byte	$c3, $01, $c4, $01, $c5, $01, $c4, $01, $c7, $01, $c8, $01, $c7, $01, $ca, $01
169e8     CB 01 CA 01 
169ec     CD 01 10 01 
169f0     DD 01 01 00 
169f4     8E 01 DE 01 | 	byte	$cb, $01, $ca, $01, $cd, $01, $10, $01, $dd, $01, $01, $00, $8e, $01, $de, $01
169f8     12 01 F3 01 
169fc     03 00 F1 01 
16a00     F4 01 F4 01 
16a04     F8 01 28 01 | 	byte	$12, $01, $f3, $01, $03, $00, $f1, $01, $f4, $01, $f4, $01, $f8, $01, $28, $01
16a08     22 02 12 01 
16a0c     3A 02 09 00 
16a10     65 2C 3B 02 
16a14     3B 02 3D 02 | 	byte	$22, $02, $12, $01, $3a, $02, $09, $00, $65, $2c, $3b, $02, $3b, $02, $3d, $02
16a18     66 2C 3F 02 
16a1c     40 02 41 02 
16a20     41 02 46 02 
16a24     0A 01 53 02 | 	byte	$66, $2c, $3f, $02, $40, $02, $41, $02, $41, $02, $46, $02, $0a, $01, $53, $02
16a28     40 00 81 01 
16a2c     86 01 55 02 
16a30     89 01 8A 01 
16a34     58 02 8F 01 | 	byte	$40, $00, $81, $01, $86, $01, $55, $02, $89, $01, $8a, $01, $58, $02, $8f, $01
16a38     5A 02 90 01 
16a3c     5C 02 5D 02 
16a40     5E 02 5F 02 
16a44     93 01 61 02 | 	byte	$5a, $02, $90, $01, $5c, $02, $5d, $02, $5e, $02, $5f, $02, $93, $01, $61, $02
16a48     62 02 94 01 
16a4c     64 02 65 02 
16a50     66 02 67 02 
16a54     97 01 96 01 | 	byte	$62, $02, $94, $01, $64, $02, $65, $02, $66, $02, $67, $02, $97, $01, $96, $01
16a58     6A 02 62 2C 
16a5c     6C 02 6D 02 
16a60     6E 02 9C 01 
16a64     70 02 71 02 | 	byte	$6a, $02, $62, $2c, $6c, $02, $6d, $02, $6e, $02, $9c, $01, $70, $02, $71, $02
16a68     9D 01 73 02 
16a6c     74 02 9F 01 
16a70     76 02 77 02 
16a74     78 02 79 02 | 	byte	$9d, $01, $73, $02, $74, $02, $9f, $01, $76, $02, $77, $02, $78, $02, $79, $02
16a78     7A 02 7B 02 
16a7c     7C 02 64 2C 
16a80     7E 02 7F 02 
16a84     A6 01 81 02 | 	byte	$7a, $02, $7b, $02, $7c, $02, $64, $2c, $7e, $02, $7f, $02, $a6, $01, $81, $02
16a88     82 02 A9 01 
16a8c     84 02 85 02 
16a90     86 02 87 02 
16a94     AE 01 44 02 | 	byte	$82, $02, $a9, $01, $84, $02, $85, $02, $86, $02, $87, $02, $ae, $01, $44, $02
16a98     B1 01 B2 01 
16a9c     45 02 8D 02 
16aa0     8E 02 8F 02 
16aa4     90 02 91 02 | 	byte	$b1, $01, $b2, $01, $45, $02, $8d, $02, $8e, $02, $8f, $02, $90, $02, $91, $02
16aa8     B7 01 7B 03 
16aac     03 00 FD 03 
16ab0     FE 03 FF 03 
16ab4     AC 03 04 00 | 	byte	$b7, $01, $7b, $03, $03, $00, $fd, $03, $fe, $03, $ff, $03, $ac, $03, $04, $00
16ab8     86 03 88 03 
16abc     89 03 8A 03 
16ac0     B1 03 11 03 
16ac4     C2 03 02 00 | 	byte	$86, $03, $88, $03, $89, $03, $8a, $03, $b1, $03, $11, $03, $c2, $03, $02, $00
16ac8     A3 03 A3 03 
16acc     C4 03 08 03 
16ad0     CC 03 03 00 
16ad4     8C 03 8E 03 | 	byte	$a3, $03, $a3, $03, $c4, $03, $08, $03, $cc, $03, $03, $00, $8c, $03, $8e, $03
16ad8     8F 03 D8 03 
16adc     18 01 F2 03 
16ae0     0A 00 F9 03 
16ae4     F3 03 F4 03 | 	byte	$8f, $03, $d8, $03, $18, $01, $f2, $03, $0a, $00, $f9, $03, $f3, $03, $f4, $03
16ae8     F5 03 F6 03 
16aec     F7 03 F7 03 
16af0     F9 03 FA 03 
16af4     FA 03 30 04 | 	byte	$f5, $03, $f6, $03, $f7, $03, $f7, $03, $f9, $03, $fa, $03, $fa, $03, $30, $04
16af8     20 03 50 04 
16afc     10 07 60 04 
16b00     22 01 8A 04 
16b04     36 01 C1 04 | 	byte	$20, $03, $50, $04, $10, $07, $60, $04, $22, $01, $8a, $04, $36, $01, $c1, $04
16b08     0E 01 CF 04 
16b0c     01 00 C0 04 
16b10     D0 04 44 01 
16b14     61 05 26 04 | 	byte	$0e, $01, $cf, $04, $01, $00, $c0, $04, $d0, $04, $44, $01, $61, $05, $26, $04
16b18     00 00 7D 1D 
16b1c     01 00 63 2C 
16b20     00 1E 96 01 
16b24     A0 1E 5A 01 | 	byte	$00, $00, $7d, $1d, $01, $00, $63, $2c, $00, $1e, $96, $01, $a0, $1e, $5a, $01
16b28     00 1F 08 06 
16b2c     10 1F 06 06 
16b30     20 1F 08 06 
16b34     30 1F 08 06 | 	byte	$00, $1f, $08, $06, $10, $1f, $06, $06, $20, $1f, $08, $06, $30, $1f, $08, $06
16b38     40 1F 06 06 
16b3c     51 1F 07 00 
16b40     59 1F 52 1F 
16b44     5B 1F 54 1F | 	byte	$40, $1f, $06, $06, $51, $1f, $07, $00, $59, $1f, $52, $1f, $5b, $1f, $54, $1f
16b48     5D 1F 56 1F 
16b4c     5F 1F 60 1F 
16b50     08 06 70 1F 
16b54     0E 00 BA 1F | 	byte	$5d, $1f, $56, $1f, $5f, $1f, $60, $1f, $08, $06, $70, $1f, $0e, $00, $ba, $1f
16b58     BB 1F C8 1F 
16b5c     C9 1F CA 1F 
16b60     CB 1F DA 1F 
16b64     DB 1F F8 1F | 	byte	$bb, $1f, $c8, $1f, $c9, $1f, $ca, $1f, $cb, $1f, $da, $1f, $db, $1f, $f8, $1f
16b68     F9 1F EA 1F 
16b6c     EB 1F FA 1F 
16b70     FB 1F 80 1F 
16b74     08 06 90 1F | 	byte	$f9, $1f, $ea, $1f, $eb, $1f, $fa, $1f, $fb, $1f, $80, $1f, $08, $06, $90, $1f
16b78     08 06 A0 1F 
16b7c     08 06 B0 1F 
16b80     04 00 B8 1F 
16b84     B9 1F B2 1F | 	byte	$08, $06, $a0, $1f, $08, $06, $b0, $1f, $04, $00, $b8, $1f, $b9, $1f, $b2, $1f
16b88     BC 1F CC 1F 
16b8c     01 00 C3 1F 
16b90     D0 1F 02 06 
16b94     E0 1F 02 06 | 	byte	$bc, $1f, $cc, $1f, $01, $00, $c3, $1f, $d0, $1f, $02, $06, $e0, $1f, $02, $06
16b98     E5 1F 01 00 
16b9c     EC 1F F3 1F 
16ba0     01 00 FC 1F 
16ba4     4E 21 01 00 | 	byte	$e5, $1f, $01, $00, $ec, $1f, $f3, $1f, $01, $00, $fc, $1f, $4e, $21, $01, $00
16ba8     32 21 70 21 
16bac     10 02 84 21 
16bb0     01 00 83 21 
16bb4     D0 24 1A 05 | 	byte	$32, $21, $70, $21, $10, $02, $84, $21, $01, $00, $83, $21, $d0, $24, $1a, $05
16bb8     30 2C 2F 04 
16bbc     60 2C 02 01 
16bc0     67 2C 06 01 
16bc4     75 2C 02 01 | 	byte	$30, $2c, $2f, $04, $60, $2c, $02, $01, $67, $2c, $06, $01, $75, $2c, $02, $01
16bc8     80 2C 64 01 
16bcc     00 2D 26 08 
16bd0     41 FF 1A 03 
16bd4     00 00 01 03 | 	byte	$80, $2c, $64, $01, $00, $2d, $26, $08, $41, $ff, $1a, $03, $00, $00, $01, $03
16bd8     05 07 09 0E 
16bdc     10 12 14 16 
16be0     18 1C 1E 43 
16be4     55 45 41 41 | 	byte	$05, $07, $09, $0e, $10, $12, $14, $16, $18, $1c, $1e, $43, $55, $45, $41, $41
16be8     41 41 43 45 
16bec     45 45 49 49 
16bf0     49 41 41 45 
16bf4     92 92 4F 4F | 	byte	$41, $41, $43, $45, $45, $45, $49, $49, $49, $41, $41, $45, $92, $92, $4f, $4f
16bf8     4F 55 55 59 
16bfc     4F 55 4F 9C 
16c00     4F 9E 9F 41 
16c04     49 4F 55 A5 | 	byte	$4f, $55, $55, $59, $4f, $55, $4f, $9c, $4f, $9e, $9f, $41, $49, $4f, $55, $a5
16c08     A5 A6 A7 A8 
16c0c     A9 AA AB AC 
16c10     AD AE AF B0 
16c14     B1 B2 B3 B4 | 	byte	$a5, $a6, $a7, $a8, $a9, $aa, $ab, $ac, $ad, $ae, $af, $b0, $b1, $b2, $b3, $b4
16c18     41 41 41 B8 
16c1c     B9 BA BB BC 
16c20     BD BE BF C0 
16c24     C1 C2 C3 C4 | 	byte	$41, $41, $41, $b8, $b9, $ba, $bb, $bc, $bd, $be, $bf, $c0, $c1, $c2, $c3, $c4
16c28     C5 41 41 C8 
16c2c     C9 CA CB CC 
16c30     CD CE CF D1 
16c34     D1 45 45 45 | 	byte	$c5, $41, $41, $c8, $c9, $ca, $cb, $cc, $cd, $ce, $cf, $d1, $d1, $45, $45, $45
16c38     49 49 49 49 
16c3c     D9 DA DB DC 
16c40     DD 49 DF 4F 
16c44     E1 4F 4F 4F | 	byte	$49, $49, $49, $49, $d9, $da, $db, $dc, $dd, $49, $df, $4f, $e1, $4f, $4f, $4f
16c48     4F E6 E8 E8 
16c4c     55 55 55 59 
16c50     59 EE EF F0 
16c54     F1 F2 F3 F4 | 	byte	$4f, $e6, $e8, $e8, $55, $55, $55, $59, $59, $ee, $ef, $f0, $f1, $f2, $f3, $f4
16c58     F5 F6 F7 F8 
16c5c     F9 FA FB FC 
16c60     FD FE FF 00 
16c64     00 00 00 00 | 	byte	$f5, $f6, $f7, $f8, $f9, $fa, $fb, $fc, $fd, $fe, $ff, $00, $00, $00, $00, $00
16c68     00 00 00 00 
16c6c     FF FF FF FF 
16c70     1F 00 00 00 
16c74     1C 00 00 00 | 	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $1f, $00, $00, $00, $1c, $00, $00, $00
16c78     1F 00 00 00 
16c7c     1E 00 00 00 
16c80     1F 00 00 00 
16c84     1E 00 00 00 | 	byte	$1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00
16c88     1F 00 00 00 
16c8c     1F 00 00 00 
16c90     1E 00 00 00 
16c94     1F 00 00 00 | 	byte	$1f, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00
16c98     1E 00 00 00 
16c9c     1F 00 00 00 
16ca0     00 00 00 00 
16ca4     1F 00 00 00 | 	byte	$1e, $00, $00, $00, $1f, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00
16ca8     3B 00 00 00 
16cac     5A 00 00 00 
16cb0     78 00 00 00 
16cb4     97 00 00 00 | 	byte	$3b, $00, $00, $00, $5a, $00, $00, $00, $78, $00, $00, $00, $97, $00, $00, $00
16cb8     B5 00 00 00 
16cbc     D4 00 00 00 
16cc0     F3 00 00 00 
16cc4     11 01 00 00 | 	byte	$b5, $00, $00, $00, $d4, $00, $00, $00, $f3, $00, $00, $00, $11, $01, $00, $00
16cc8     30 01 00 00 
16ccc     4E 01 00 00 
16cd0     6D 01 00 00 
16cd4     FF FF FF FF | 	byte	$30, $01, $00, $00, $4e, $01, $00, $00, $6d, $01, $00, $00, $ff, $ff, $ff, $ff
16cd8     00 00 00 00 
      ...             
16cf4     00 00 00 00 
16cf8     00 00 00 00 | 	byte	$00[36]
16cfc     1A 6D 01 00 | 	long	@@@_fatfs_cc_dat_ + 1266
16d00     1E 6D 01 00 | 	long	@@@_fatfs_cc_dat_ + 1270
16d04     00 00 00 00 
16d08     00 00 00 00 
16d0c     00 00 00 00 
16d10     00 00 00 00 
16d14     00 00       | 	byte	$00[18]
16d16     3F 3F 3F 00 
16d1a     55 43 54 00 
16d1e     55 43 54 00 
16d22     00 00 00 00 | 	byte	$3f, $3f, $3f, $00, $55, $43, $54, $00, $55, $43, $54, $00, $00, $00, $00, $00
16d26     00 00 00 00 
16d2a     00 00 00    | 	byte	$00[7]
16d2d     CA 9A 3B 00 
16d31     00 00 00 01 
16d35     01 01 01 01 
16d39     01 01 01 01 | 	byte	$ca, $9a, $3b, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01
16d3d     91 11 11 11 
16d41     11 01 01 01 
16d45     01 01 01 01 
16d49     01 01 01 01 | 	byte	$91, $11, $11, $11, $11, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
16d4d     01 01 01 01 
16d51     01 01 01    | 	byte	$01[7]
16d54     90 20 20 20 
16d58     20 20 20 20 
16d5c     20 20 20 20 
16d60     20 20 20 20 | 	byte	$90, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
16d64     42 42 42 42 
16d68     42 42 42 42 
16d6c     42 42       | 	byte	$42[10]
16d6e     20 20 20 20 
16d72     20 20 20    | 	byte	$20[7]
16d75     44 44 44 44 
16d79     44 44       | 	byte	$44[6]
16d7b     04 04 04 04 
16d7f     04 04 04 04 
16d83     04 04 04 04 
16d87     04 04 04 04 
16d8b     04 04 04 04 | 	byte	$04[20]
16d8f     20 20 20 20 
16d93     20 20       | 	byte	$20[6]
16d95     48 48 48 48 
16d99     48 48       | 	byte	$48[6]
16d9b     08 08 08 08 
16d9f     08 08 08 08 
16da3     08 08 08 08 
16da7     08 08 08 08 
16dab     08 08 08 08 | 	byte	$08[20]
16daf     20 20 20 20 
16db3     01 00 00 00 
16db7     00          | 	byte	$20, $20, $20, $20, $01, $00, $00, $00, $00
16db8                 | __methodtable__
16db8     00 00 00 00 | 	long	0
16dbc     98 18 00 00 | 	long	@_hg010b_spin2_putchar
16dc0     0C DE 00 00 | 	long	@__system___struct___bas_wrap_sender_tx_
16dc4     50 DE 00 00 | 	long	@__system___struct___bas_wrap_sender_rx_
16dc8     98 DE 00 00 | 	long	@__system___struct___bas_wrap_sender_close_
16dcc     3C DD 00 00 | 	long	@__system___struct__s_vfs_file_t_putchar_
16dd0     AC DD 00 00 | 	long	@__system___struct__s_vfs_file_t_getchar_
16dd4     F4 DC 00 00 | 	long	@__system____strs_cl_pfunc_
16dd8     08 5C 00 00 | 	long	@__system____root_opendir
16ddc     A4 5C 00 00 | 	long	@__system____root_closedir
16de0     20 5C 00 00 | 	long	@__system____root_readdir
16de4     AC 5C 00 00 | 	long	@__system____root_stat
16de8     9C 57 00 00 | 	long	@__system____default_putc
16dec     18 57 00 00 | 	long	@__system____default_getc
16df0     48 58 00 00 | 	long	@__system____default_flush
16df4     5C D0 00 00 | 	long	@_fatfs_cc_v_close
16df8     44 D3 00 00 | 	long	@_fatfs_cc_v_read
16dfc     D0 D3 00 00 | 	long	@_fatfs_cc_v_write
16e00     48 D4 00 00 | 	long	@_fatfs_cc_v_lseek
16e04     E4 D4 00 00 | 	long	@_fatfs_cc_v_ioctl
16e08     10 D6 00 00 | 	long	@_fatfs_cc_v_flush
16e0c     38 D5 00 00 | 	long	@_fatfs_cc_v_open
16e10     C8 CF 00 00 | 	long	@_fatfs_cc_v_creat
16e14     98 D0 00 00 | 	long	@_fatfs_cc_v_opendir
16e18     0C D1 00 00 | 	long	@_fatfs_cc_v_closedir
16e1c     4C D1 00 00 | 	long	@_fatfs_cc_v_readdir
16e20     18 D2 00 00 | 	long	@_fatfs_cc_v_stat
16e24     F8 D4 00 00 | 	long	@_fatfs_cc_v_mkdir
16e28     18 D5 00 00 | 	long	@_fatfs_cc_v_rmdir
16e2c     08 D5 00 00 | 	long	@_fatfs_cc_v_remove
16e30     28 D5 00 00 | 	long	@_fatfs_cc_v_rename
16e34     5C D6 00 00 | 	long	@_fatfs_cc_v_init
16e38     64 D6 00 00 | 	long	@_fatfs_cc_v_deinit
16e3c     5C 74 00 00 | 	long	@_sdmm_cc_v_read
16e40     68 74 00 00 | 	long	@_sdmm_cc_v_write
16e44     44 75 00 00 | 	long	@_sdmm_cc_v_close
16e48     74 74 00 00 | 	long	@_sdmm_cc_v_ioctl
16e4c     3C 75 00 00 | 	long	@_sdmm_cc_v_flush
16e50     98 74 00 00 | 	long	@_sdmm_cc_v_lseek
16e54     6C 75 00 00 | 	long	@_sdmm_cc_v_putc
16e58     B8 75 00 00 | 	long	@_sdmm_cc_v_getc
16e5c     E0 2D 00 00 | 	long	@__system___tx
16e60     20 2E 00 00 | 	long	@__system___rx
16e64     8C 63 00 00 | 	long	@__system___rxtxioctl_0227
16e68     E4 63 00 00 | 	long	@__system____dummy_flush_0228
16e6c                 | __heap_base
16e6c     00 00 00 00 
      ...             
2e56c     00 00 00 00 
2e570     00 00 00 00 | 	long	0[24002]
2e574                 | objmem
2e574     00 00 00 00 
      ...             
318c4     00 00 00 00 
318c8     00 00 00 00 | 	long	0[3286]
318cc                 | stackspace
318cc     00 00 00 00 | 	long	0[1]
318d0 13e             | 	org	COG_BSS_START
318d0 13e             | _var01
318d0 13e             | 	res	1
318d0 13f             | _var02
318d0 13f             | 	res	1
318d0 140             | _var03
318d0 140             | 	res	1
318d0 141             | _var04
318d0 141             | 	res	1
318d0 142             | _var05
318d0 142             | 	res	1
318d0 143             | _var06
318d0 143             | 	res	1
318d0 144             | _var07
318d0 144             | 	res	1
318d0 145             | _var08
318d0 145             | 	res	1
318d0 146             | _var09
318d0 146             | 	res	1
318d0 147             | _var10
318d0 147             | 	res	1
318d0 148             | arg01
318d0 148             | 	res	1
318d0 149             | arg02
318d0 149             | 	res	1
318d0 14a             | arg03
318d0 14a             | 	res	1
318d0 14b             | arg04
318d0 14b             | 	res	1
318d0 14c             | arg05
318d0 14c             | 	res	1
318d0 14d             | arg06
318d0 14d             | 	res	1
318d0 14e             | arg07
318d0 14e             | 	res	1
318d0 14f             | arg08
318d0 14f             | 	res	1
318d0 150             | arg09
318d0 150             | 	res	1
318d0 151             | arg10
318d0 151             | 	res	1
318d0 152             | arg11
318d0 152             | 	res	1
318d0 153             | local01
318d0 153             | 	res	1
318d0 154             | local02
318d0 154             | 	res	1
318d0 155             | local03
318d0 155             | 	res	1
318d0 156             | local04
318d0 156             | 	res	1
318d0 157             | local05
318d0 157             | 	res	1
318d0 158             | local06
318d0 158             | 	res	1
318d0 159             | local07
318d0 159             | 	res	1
318d0 15a             | local08
318d0 15a             | 	res	1
318d0 15b             | local09
318d0 15b             | 	res	1
318d0 15c             | local10
318d0 15c             | 	res	1
318d0 15d             | local11
318d0 15d             | 	res	1
318d0 15e             | local12
318d0 15e             | 	res	1
318d0 15f             | local13
318d0 15f             | 	res	1
318d0 160             | local14
318d0 160             | 	res	1
318d0 161             | local15
318d0 161             | 	res	1
318d0 162             | local16
318d0 162             | 	res	1
318d0 163             | local17
318d0 163             | 	res	1
318d0 164             | local18
318d0 164             | 	res	1
318d0 165             | local19
318d0 165             | 	res	1
318d0 166             | local20
318d0 166             | 	res	1
318d0 167             | local21
318d0 167             | 	res	1
318d0 168             | local22
318d0 168             | 	res	1
318d0 169             | local23
318d0 169             | 	res	1
318d0 16a             | local24
318d0 16a             | 	res	1
318d0 16b             | local25
318d0 16b             | 	res	1
318d0 16c             | local26
318d0 16c             | 	res	1
318d0 16d             | local27
318d0 16d             | 	res	1
318d0 16e             | local28
318d0 16e             | 	res	1
318d0 16f             | local29
318d0 16f             | 	res	1
318d0 170             | local30
318d0 170             | 	res	1
318d0 171             | local31
318d0 171             | 	res	1
318d0 172             | local32
318d0 172             | 	res	1
318d0 173             | local33
318d0 173             | 	res	1
318d0 174             | local34
318d0 174             | 	res	1
318d0 175             | local35
318d0 175             | 	res	1
318d0 176             | local36
318d0 176             | 	res	1
318d0 177             | local37
318d0 177             | 	res	1
318d0 178             | local38
318d0 178             | 	res	1
318d0 179             | local39
318d0 179             | 	res	1
318d0 17a             | local40
318d0 17a             | 	res	1
318d0 17b             | local41
318d0 17b             | 	res	1
318d0 17c             | muldiva_
318d0 17c             | 	res	1
318d0 17d             | muldivb_
318d0 17d             | 	res	1
318d0 17e             | 	fit	480
318d0 17e             | 
