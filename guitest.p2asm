con
	_clkfreq = 338695652
	_clkmode = 28773115
	fbReadOnly = 1
	fbHidden = 2
	fbSystem = 4
	fbDirectory = 16
	fbArchive = 32
	fbNormal = 33
	HEAPSIZE = 96000
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 338695652
	long	0 ' clock mode: will default to $1b70afb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##28773112
	waitx	##200000
	mov	pa, ##28773115
	hubset	pa
	wrlong	pa, #24
	wrlong	##338695652, #20
	jmp	#skip_clock_set_
	orgf	192
skip_clock_set_
	call	#_program
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

divide_
       abs     muldivb_,muldivb_     wcz      'abs(y)
       wrc     itmp2_                         'store sign of y
       abs     muldiva_,muldiva_     wc       'abs(x)
       qdiv    muldiva_, muldivb_             'queue divide
 if_c  xor     itmp2_,#1                      'store sign of x
       getqx   muldivb_                       'get quotient
       getqy   muldiva_                       'get remainder
       negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
       testb   itmp2_,#0             wc       'restore sign, division result
 _ret_ negc    muldivb_,muldivb_     
__pc long 0
__setjmp
    pop __pc
    mov result1, #0
    mov result2, #0
    mov abortchain, arg01
    wrlong fp, arg01
    add arg01, #4
    wrlong ptra, arg01
    add arg01, #4
    wrlong objptr, arg01
    add arg01, #4
    wrlong __pc, arg01
    jmp __pc
__unwind_pc long 0
__unwind_stack
   pop  __unwind_pc
__unwind_loop
   cmp  arg01, arg02 wz
  if_z jmp #__unwind_stack_ret
   mov   ptra, arg01
   call  #popregs_
   mov   arg01, fp
   jmp   #__unwind_loop
__unwind_stack_ret
   jmp  __unwind_pc
__longjmp
    pop __pc
    cmp    arg01, #0 wz
 if_z jmp #nocatch
    mov result1, arg02
    mov result2, #1
    rdlong arg02, arg01
    add arg01, #4
    rdlong ptra, arg01
    add arg01, #4
    rdlong objptr, arg01
    add arg01, #4
    rdlong __pc, arg01
    mov arg01, fp
    call #__unwind_stack
__longjmp_ret
    jmp  __pc
nocatch
    cmp arg03, #0 wz
 if_z jmp #cogexit
    jmp #__longjmp_ret

__heap_ptr
	long	@__heap_base
__methods__
	long	@__methodtable__
abortchain
	long	0
itmp1_
	long	0
itmp2_
	long	0
objptr
	long	@objmem
ptr__Audio2_004_spin2_dat__
	long	@_Audio2_004_spin2_dat_
ptr___system__dat__
	long	@__system__dat_
ptr__dat__
	long	@_dat_
ptr__fatfs_cc_dat__
	long	@_fatfs_cc_dat_
ptr__hg010b_spin2_dat__
	long	@_hg010b_spin2_dat_
ptr__psram16drv_spin2_dat__
	long	@_psram16drv_spin2_dat_
ptr__psram_spin2_dat__
	long	@_psram_spin2_dat_
ptr__usbnew_spin2_dat__
	long	@_usbnew_spin2_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
result3
	long	2
COG_BSS_START
	fit	480
	orgh
hubentry

' trackbar1.create(v,100,100,16,300)
' window1.create(v,200,200,300,300,"Window test 1234567890")
' 
' 
' sub startpsram
_startpsram
	mov	arg01, #0
	decod	arg02, #10
	mov	arg03, #11
	mov	arg04, #7
	add	objptr, ##5876
	call	#_psram_spin2_startx
	sub	objptr, ##5864
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	result2, objptr
	sub	objptr, #16
_startpsram_ret
	ret

' 
' function startvideo(mode=64, pin=0, mb=0) 'todo return a cog#
_startvideo
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, #16
	rdlong	arg04, objptr
	mov	arg01, arg02
	mov	arg02, arg04
	add	objptr, #20
	call	#_hg010b_spin2_start
	sub	objptr, #16
	wrlong	result1, objptr
' 
' videocog=v.start(pin,mbox)
' for thecog=0 to 7:psram.setQos(thecog, 80 << 16) :next thecog
	mov	local01, #0
	add	objptr, ##5856
LR__0001
	mov	arg01, local01
	mov	arg02, ##5242880
	call	#_psram_spin2_setQos
	add	local01, #1
	cmps	local01, #8 wc
 if_b	jmp	#LR__0001
	sub	objptr, ##5856
	rdlong	arg01, objptr
	mov	arg02, ##67171328
	add	objptr, ##5856
	call	#_psram_spin2_setQos
' psram.setQoS(videocog, $0400f400) 
' open SendRecvDevice(@v.putchar, nil, nil) as #0
	sub	objptr, ##5840
	mov	arg02, objptr
	sub	objptr, #36
	bith	arg02, #20
	mov	arg03, #0
	mov	arg04, #0
	mov	arg01, #0
	call	#__system___basic_open
' return videocog
	add	objptr, #20
	rdlong	result1, objptr
	sub	objptr, #20
	mov	ptra, fp
	call	#popregs_
_startvideo_ret
	ret

_program
	mov	COUNT_, #1
	call	#pushregs_
	call	#_startpsram
	add	objptr, #16
	rdlong	arg01, objptr
	mov	arg02, #0
	mov	arg03, ##516096
	add	objptr, ##5860
	call	#_Audio2_004_spin2_start
	sub	objptr, ##5876
	mov	arg10, result2
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	arg10, objptr
	sub	objptr, #4
	mov	arg01, #50
	call	#__system___waitms
	call	#_usbnew_spin2_start
	add	objptr, #8
	wrlong	result1, objptr
	sub	objptr, #8
	mov	arg01, #64
	mov	arg02, #0
	mov	arg03, #0
	call	#_startvideo
'   mouse_limits[0] := xlim
	add	ptr__usbnew_spin2_dat__, ##7880
	wrlong	##1023, ptr__usbnew_spin2_dat__
'   mouse_limits[1] := ylim
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	##599, ptr__usbnew_spin2_dat__
	mov	arg01, objptr
	add	arg01, #509
'   mouse_outptr := ptr
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	arg01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7888
	mov	arg02, ptr__dat__
	add	arg02, ##512
	mov	arg01, #16
	add	objptr, #36
	call	#_hg010b_spin2_setspriteptr
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_hg010b_spin2_setspritesize
	sub	objptr, #36
	decod	arg01, #9
	mov	arg02, #300
	call	#_usbnew_spin2_mouse_move
	add	objptr, #24
	wrlong	#147, objptr
	add	objptr, #4
	wrlong	#154, objptr
	add	objptr, #4
	wrlong	#4, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	add	objptr, #12
	call	#_hg010b_spin2_cls
	sub	objptr, #4
	rdlong	arg01, objptr
	add	objptr, #4
	call	#_hg010b_spin2_setfontfamily
' 
' leading_spaces:=amount
	add	objptr, ##698
	wrlong	#2, objptr
	sub	objptr, ##734
	mov	local01, ##@LR__2172
	mov	arg01, #61
	mov	arg02, #60
	mov	arg03, #59
	mov	arg04, #58
	call	#__system___vfs_open_sdcardx
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___mount
	mov	arg01, ##@LR__2173
	call	#__system___chdir
	mov	local01, ##@LR__2174
	add	objptr, ##7264
	wrlong	local01, objptr
	sub	objptr, ##7264
' print: print "kwas"
	mov	arg01, #0
	call	#__system___getiolock_0133
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0133
	wrlong	#0, result1
	mov	arg01, #0
	call	#__system___getiolock_0133
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__2175
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0133
	wrlong	#0, result1
	mov	arg02, #0
	test	arg02, #1 wc
	drvc	#38
	test	arg02, #1 wc
	drvc	#39
	add	objptr, #36
	mov	arg01, objptr
	mov	arg11, ##@LR__2176
	mov	arg02, #100
	mov	arg03, #100
	mov	arg04, #16
	mov	arg05, #300
	mov	arg06, #0
	mov	arg07, #10
	mov	arg08, #11
	mov	arg09, #244
	mov	arg10, #248
	add	objptr, ##7232
	call	#_trackbar_create
	sub	objptr, ##7232
	mov	arg01, objptr
	mov	arg06, ##@LR__2177
	mov	arg02, #200
	mov	arg03, #200
	mov	arg04, #300
	mov	arg05, #300
	mov	arg07, #10
	mov	arg08, #15
	mov	arg09, #120
	add	objptr, ##13116
	call	#_window_create
	sub	objptr, ##13152
	mov	ptra, fp
	call	#popregs_
_program_ret
	ret

' '' this is not a main program.
' 
' '****************************************************************************************************************
' '                                                                                                             	*
' 'Start the driver  at pins 'base'                            					rev 20230829 	*
' '                                                                                                            	*
' ' base - HDMI base pin												*
' ' mb - PSRAM mailbox pointer, 0 if no PSRAM									*
' '														*
' '														*
' '****************************************************************************************************************
' 
' pub start(base,mb):result |i
_hg010b_spin2_start
' 
' '--------------------------- initialize pointers and variables
' 
' border_ptr:=@bordercolor					' Initial border color pointer, can be changed via DL
	add	objptr, #52
	mov	result1, objptr
	sub	objptr, #40
	wrlong	result1, objptr
' 'font_ptr:=@amiga_font						' Initial 8x16 font definition
' hdmibase:=base							' HDMI base pin, 8*n
	add	objptr, #24
	wrlong	arg01, objptr
' mailbox_ptr:=mb		
	add	objptr, #4
	wrlong	arg02, objptr
' mailbox0:=mb				' PSRAM mailbox pointer
	add	objptr, #453
	wrlong	arg02, objptr
' sprite_ptr:=@spr1ptr
	sub	objptr, #216
	mov	result1, objptr
	sub	objptr, #233
	wrlong	result1, objptr
' 
' 		'
' word[spr1ptr+17*12+4]:=8				' spr18w
	add	objptr, #233
	rdlong	result1, objptr
	add	result1, #208
	wrword	#8, result1
' word[spr1ptr+17*12+6]:=16				' for a blinking cursor
	rdlong	arg03, objptr
	add	arg03, #210
	wrword	#16, arg03
' leading_spaces:=0				'
	add	objptr, #421
	wrlong	#0, objptr
' 
' emptydl[0]:=%0100_0000_0000_0000_0000_0000_0000_0111
	sub	objptr, #153
	wrlong	##1073741831, objptr
' emptydl[1]:=0
	add	objptr, #4
	wrlong	#0, objptr
' 
' '---------------------------- the mode has to be set here to enable computing the buffer length
' 
' s_debug:=debugger						' check if debug mode defined (eats 16 kB upper RAM so don't use it)					' 
	sub	objptr, #296
	wrlong	#1, objptr
' if s_debug<>0
'   s_debug:=16384						' the buffers adresses will be corrected to not interfere with the debugger
	wrlong	##16384, objptr
	sub	objptr, #253
' setmode()							' set the mode, see below
	call	#_hg010b_spin2_setmode
' vblank_ptr:=@vblank						' set pointers before starting the driver
	add	objptr, #73
	mov	result1, objptr
	sub	objptr, #53
	wrlong	result1, objptr
' cursor_ptr:=@cursor_x						
	add	objptr, #40
	mov	arg03, objptr
	sub	objptr, #44
	wrlong	arg03, objptr
' fontnum:=0  							' start with a PC type font 
	add	objptr, #85
	wrlong	#0, objptr
' bytemove(@colors,@vgacolors,16)					' prepare standard DOS VGA colors
	add	objptr, #28
	mov	arg01, objptr
	sub	objptr, #129
	mov	arg02, ptr__hg010b_spin2_dat__
	add	arg02, ##14464
	mov	arg03, #16
	call	#__system____builtin_memmove
' leading_spaces:=0
	add	objptr, ##698
	wrlong	#0, objptr
	sub	objptr, ##698
' '---------------------------- initialize a cursor (MSDOS type)
' 
' initcursor(154)
	mov	arg01, #154
	call	#_hg010b_spin2_initcursor
' font_family8:=6
	add	objptr, #153
	wrlong	#6, objptr
' 
' '---------------------------- start the cog
' 
' cog:=coginit(16,@hdmi, @vblank_ptr)				' start the driver cog			
	mov	arg02, ptr__hg010b_spin2_dat__
	add	arg02, ##14480
	sub	objptr, #133
	mov	result1, #16
	setq	objptr
	coginit	result1, arg02 wc
 if_b	neg	result1, #1
	add	objptr, #28
	wrlong	result1, objptr
	sub	objptr, #48
' waitms(40)							' wait for stabilize
	mov	arg01, #40
	call	#__system___waitms
' return cog							' return the driver's cog #
	add	objptr, #48
	rdlong	result1, objptr
	sub	objptr, #48
_hg010b_spin2_start_ret
	ret

' 
' '---------------------------- initialize a cursor (MSDOS type)
' pub initcursor(color) |i
_hg010b_spin2_initcursor
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' cursor_x:=0							' place the cursor at 0:0
	add	objptr, #60
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' repeat i from 0 to 111
	mov	local02, #0
	add	objptr, #508
	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
LR__0010
'   cursor[i]:=0
	mov	local03, local02
	add	local03, objptr
	wrbyte	#0, local03
	add	local02, #1
	cmps	local02, #112 wc
 if_b	jmp	#LR__0010
LR__0011
' repeat i from 112 to 127
	mov	local02, #112
	callpa	#(@LR__0013-@LR__0012)>>2,fcache_load_ptr_
LR__0012
'   cursor[i]:=color  
	mov	local03, local02
	add	local03, objptr
	wrbyte	local01, local03
	add	local02, #1
	cmp	local02, #128 wc
 if_b	jmp	#LR__0012
LR__0013
	sub	objptr, ##570
' 'repeat i from 0 to 127
' '  if ((i/8)//2)
' '    cursor[i]:=15
' '  else
' '    cursor[i]:=0
' '  if i>=120    
' '    cursor[i]:=40
' setspriteptr(17,@cursor)
	mov	arg02, objptr
	add	arg02, ##570
	mov	arg01, #17
	call	#_hg010b_spin2_setspriteptr
' setspritesize(17,8,16)
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
' setspritepos(17,0,0)
	mov	arg01, #17
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritepos
' cursorshape:=14
	add	objptr, ##5834
	wrlong	#14, objptr
' cursorcolor:=color
	sub	objptr, #4
	wrlong	local01, objptr
	sub	objptr, ##5830
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_initcursor_ret
	ret

' 
' pub setcursorcolor(color) | i
_hg010b_spin2_setcursorcolor
' 
' cursorcolor:=color
	add	objptr, ##5830
	wrlong	arg01, objptr
' repeat i from 0 to (8*cursorshape)-1
	mov	arg01, #0
	add	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #3
	sub	_var01, #1
	cmps	_var01, #0 wc
	negc	_var02, #1
	mov	_var03, _var02
	add	_var01, _var02
	sub	objptr, ##5264
	callpa	#(@LR__0021-@LR__0020)>>2,fcache_load_ptr_
LR__0020
'   cursor[i]:=0
	mov	_var02, arg01
	add	_var02, objptr
	wrbyte	#0, _var02
	add	arg01, _var03
	cmp	arg01, _var01 wz
 if_ne	jmp	#LR__0020
LR__0021
' repeat i from 8*cursorshape to 127
	add	objptr, ##5264
	rdlong	_var03, objptr
	mov	arg01, _var03
	shl	arg01, #3
	sub	objptr, ##5834
	shl	_var03, #3
	cmps	_var03, #128 wc
	negnc	_var02, #1
	mov	_var01, #127
	add	_var01, _var02
	callpa	#(@LR__0023-@LR__0022)>>2,fcache_load_ptr_
LR__0022
'   cursor[i]:=cursorcolor
	mov	_var03, arg01
	add	objptr, ##570
	add	_var03, objptr
	add	objptr, ##5260
	rdlong	_var04, objptr
	sub	objptr, ##5830
	wrbyte	_var04, _var03
	add	arg01, _var02
	cmp	arg01, _var01 wz
 if_ne	jmp	#LR__0022
LR__0023
_hg010b_spin2_setcursorcolor_ret
	ret

'   
'   
'   
' pub setmode() | i', 'xzoom, yzoom, azoom
_hg010b_spin2_setmode
	mov	COUNT_, #2
	call	#pushregs_
' 
' 
' dl_ptr:=@emptydl[0]
	add	objptr, ##545
	mov	arg05, objptr
	sub	objptr, ##513
	wrlong	arg05, objptr
' 
' if cog>0 
	add	objptr, #16
	rdlong	arg05, objptr
	sub	objptr, #48
	cmps	arg05, #1 wc
'    waitvbl(1)						    	' if the driver is active, wait for vblank to set the new mode and DL	
 if_ae	mov	arg01, #1
 if_ae	call	#_hg010b_spin2_waitvbl
' xres:=1024
	add	objptr, ##554
	wrlong	##1024, objptr
' yres:=600
	add	objptr, #4
	wrlong	##600, objptr
' ppl:=(timings[3])
	add	ptr__hg010b_spin2_dat__, ##14412
	rdlong	arg05, ptr__hg010b_spin2_dat__
	sub	objptr, #337
	wrlong	arg05, objptr
' cpl:=timings[7]<<1                                      	' now cpl is longs per line
	add	ptr__hg010b_spin2_dat__, #16
	rdlong	local01, ptr__hg010b_spin2_dat__
	shl	local01, #1
	sub	objptr, #132
	wrlong	local01, objptr
' cpl1:=cpl '' todo remove
	add	objptr, #4
	wrlong	local01, objptr
' palette_ptr:=@ataripalette				    	' use 256-colors palettr
	sub	ptr__hg010b_spin2_dat__, ##2076
	sub	objptr, #65
	wrlong	ptr__hg010b_spin2_dat__, objptr
' repeat i from 0 to 3
	mov	local02, #0
	add	ptr__hg010b_spin2_dat__, ##2048
	add	objptr, #8
	callpa	#(@LR__0031-@LR__0030)>>2,fcache_load_ptr_
LR__0030
'   timings[i]:=timings[i]+hdmibase<<17+ timingsxxt          	' add a streamer config (imm->pins) to horizontal timings 
	mov	local01, local02
	shl	local01, #2
	add	local01, ptr__hg010b_spin2_dat__
	rdlong	arg05, objptr
	shl	arg05, #17
	rdlong	local01, local01
	add	local01, arg05
	add	local01, ##1887502336
	mov	arg05, local02
	shl	arg05, #2
	add	arg05, ptr__hg010b_spin2_dat__
	wrlong	local01, arg05
	add	local02, #1
	cmps	local02, #4 wc
 if_b	jmp	#LR__0030
LR__0031
	sub	objptr, #36
	sub	ptr__hg010b_spin2_dat__, ##14400
' 'clkfreq:=timings[9]					    	' set the clock frequency for the mode
' 'hubset(timings[10])
' waitms(1)                                                   	' wait for stabilization
	mov	arg01, #1
	call	#__system___waitms
	add	ptr__hg010b_spin2_dat__, ##14444
	rdlong	local02, ptr__hg010b_spin2_dat__
	add	objptr, #97
	wrlong	local02, objptr
	abs	local01, local02 wc
	shr	local01, #4
	negc	local01, local01
	add	objptr, #160
	wrlong	local01, objptr
	sub	objptr, #168
	rdlong	local02, objptr
	add	objptr, #8
	rdlong	local01, objptr
	qmul	local02, local01
' lines:=timings[11]
' t_lines:=lines/16
' buflen:=cpl*lines						' framebuffer length in longs
	sub	objptr, #41
	decod	local01, #25
	sub	ptr__hg010b_spin2_dat__, #16
	getqx	local02
	wrlong	local02, objptr
	sub	objptr, #56
	shl	local02, #2
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #257
	rdlong	local02, objptr
	rdlong	arg05, ptr__hg010b_spin2_dat__
	qmul	local02, arg05
' buf_ptr:=$2000000-4*buflen                          	     	' todo: get a PSRAM real himem 
' textbuf_ptr:=buf_ptr-t_lines*timings[7]
	sub	objptr, #253
' mode_ptr:=@timings						' set pointers to timings
	sub	ptr__hg010b_spin2_dat__, #28
' graphmode:=1024+512+192+48							' det global variable
' makedl(graphmode)							' make a DL for the mode
	mov	arg01, ##1776
	getqx	local02
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #20
	wrlong	ptr__hg010b_spin2_dat__, objptr
	add	objptr, #121
	wrlong	##1776, objptr
	sub	objptr, #145
	sub	ptr__hg010b_spin2_dat__, ##14400
	call	#_hg010b_spin2_makedl
' s_buf_ptr:=buf_ptr						' secondary copies of main framebuffer parameters 
	rdlong	local01, objptr
	add	objptr, #225
	wrlong	local01, objptr
' s_font_ptr:=font_ptr
	sub	objptr, #217
	rdlong	local01, objptr
	add	objptr, #221
	wrlong	local01, objptr
' s_lines:=lines
	sub	objptr, #132
	rdlong	local01, objptr
	add	objptr, #136
	wrlong	local01, objptr
' s_buflen:=buflen
	sub	objptr, #177
	rdlong	local01, objptr
	add	objptr, #185
	wrlong	local01, objptr
' s_cpl:=cpl
	sub	objptr, #152
	rdlong	local01, objptr
	add	objptr, #148
	wrlong	local01, objptr
' s_cpl1:=cpl
	sub	objptr, #148
	rdlong	local01, objptr
	add	objptr, #156
	wrlong	local01, objptr
' st_lines:=t_lines
	add	objptr, #12
	rdlong	local01, objptr
	add	objptr, #4
	wrlong	local01, objptr
' ppl:=ppl/xzoom  
	sub	objptr, #40
	rdlong	muldiva_, objptr
	add	objptr, #44
	rdlong	muldivb_, objptr
	sub	objptr, #265
	call	#divide_
	add	objptr, #221
	wrlong	muldivb_, objptr
' s_ppl:=ppl
	add	objptr, #28
	wrlong	muldivb_, objptr
	sub	objptr, #249
' waitms(20)							' wait 
	mov	arg01, #20
	call	#__system___waitms
' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	arg03, arg01
	mov	arg02, #32
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5840
	call	#_psram_spin2_fill
	sub	objptr, ##5840
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_setmode_ret
	ret

' 
' '****************************************************************************************************************
' '                                                                                                             	*
' '  Make a display list for simple standard modes                                             	rev.20220319    *
' '                                                                                                             	*
' '****************************************************************************************************************
' 
' pub makedl(mode) |i,vzoom,border,psbuf,lines2
_hg010b_spin2_makedl
' 
' psbuf:=$80000-s_debug-1024                                                     ' HUB line buffer on the top of HUB RAM (-16 kB if debug enabled)
' vzoom:=1<<((mode>>2) & 3)                                                      ' real vzoom from mode#
' repeat i from 0 to 11                                                           ' clear DL
	mov	_var01, #0
	add	objptr, #497
	callpa	#(@LR__0041-@LR__0040)>>2,fcache_load_ptr_
LR__0040
'   displaylist[i]:=0 
	mov	_var02, _var01
	shl	_var02, #2
	add	_var02, objptr
	wrlong	#0, _var02
	add	_var01, #1
	cmps	_var01, #12 wc
 if_b	jmp	#LR__0040
LR__0041
'                         ' 
' displaylist[0]:=lines<<20+(0)<<16+%0001+ (0+(cpl1<<2)) <<4             
	sub	objptr, #400
	rdlong	_var02, objptr
	shl	_var02, #20
	add	_var02, #1
	sub	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #6
	add	_var02, _var01
	add	objptr, #404
	wrlong	_var02, objptr
	sub	objptr, #497
' displaylist[1]:=buf_ptr<<4+%10  
	rdlong	_var02, objptr
	shl	_var02, #4
	add	_var02, #2
	add	objptr, #501
	wrlong	_var02, objptr
' dl_ptr:=@displaylist[0] 						      ' tell the driver where to find the DL
	sub	objptr, #4
	mov	_var02, objptr
	sub	objptr, #465
	wrlong	_var02, objptr
	sub	objptr, #32
_hg010b_spin2_makedl_ret
	ret

' 
' 
' '****************************************************************************************************************
' '                                                                        					*
' '  Graphic primitives                                                    					*
' '                                                                        					*
' '****************************************************************************************************************
' 
' pub setspriteptr(num,ptr)
_hg010b_spin2_setspriteptr
' long[@spr1ptr+12*num]:=ptr
	mov	_var01, objptr
	add	_var01, #277
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	wrlong	arg02, _var01
_hg010b_spin2_setspriteptr_ret
	ret

' 
' pub setspritepos(num,x,y)
_hg010b_spin2_setspritepos
' if y>601
	cmps	arg03, ##602 wc
'   y:=601
 if_ae	mov	arg03, ##601
' if x>1024
	cmps	arg02, ##1025 wc
'   x:=1024
 if_ae	decod	arg02, #10
' word[@spr1ptr+12*num+4]:=x
	add	objptr, #277
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #4
	wrword	arg02, _var01
' word[@spr1ptr+12*num+6]:=y
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #6
	wrword	arg03, _var01
	sub	objptr, #277
_hg010b_spin2_setspritepos_ret
	ret

' 
' pub setspritesize(num,w,h)
_hg010b_spin2_setspritesize
' word[@spr1ptr+12*num+8]:=w
	add	objptr, #277
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #8
	wrword	arg02, _var01
' word[@spr1ptr+12*num+10]:=h
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #10
	wrword	arg03, _var01
	sub	objptr, #277
_hg010b_spin2_setspritesize_ret
	ret

' 
' 
' ''---------- putpixel - put a pixel on the screen - a mother of all graphic functions ---------------------------
' 
' 
' pub putpixel(x,y,c)
_hg010b_spin2_putpixel
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' if ((x>=0) & (x<4*s_cpl) & (y>=0) & (y<s_lines))
	mov	local02, #0
	cmps	local01, #0 wc
 if_ae	neg	local02, #1
	add	objptr, #237
	rdlong	arg05, objptr
	shl	arg05, #2
	cmps	local01, arg05 wc
	subx	local03, local03
	and	local02, local03
	mov	local03, #0
	cmps	arg02, #0 wc
 if_ae	neg	local03, #1
	and	local02, local03
	sub	objptr, #4
	rdlong	local03, objptr
	sub	objptr, #233
	cmps	arg02, local03 wc
	subx	local04, local04
	test	local02, local04 wz
 if_e	jmp	#LR__0050
	add	objptr, #225
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	local04, objptr
	shl	local04, #2
	qmul	local04, arg02
'   ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
	mov	arg02, arg03
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local04
	add	local04, local01
	add	arg01, local04
	call	#_psram_spin2_fill
	sub	objptr, ##5840
LR__0050
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putpixel_ret
	ret

'   
' '----------- A line drawing family. BASIC doesn't like the name, so it is named "draw" and aliased  -----------------------------
' 
' pub fastline(x1,x2,y,c)									' a fast 8bpp horizontal line
_hg010b_spin2_fastline
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' if y<0 || y>=yres || (x1<0 && x2<0) || (x1>xres && x2>xres)
	cmps	arg03, #0 wc
 if_b	jmp	#LR__0060
	add	objptr, ##558
	rdlong	arg05, objptr
	sub	objptr, ##558
	cmps	arg03, arg05 wc
 if_ae	jmp	#LR__0060
	cmps	local01, #0 wc
 if_b	cmps	local02, #0 wc
 if_b	jmp	#LR__0060
	add	objptr, ##554
	rdlong	arg05, objptr
	sub	objptr, ##554
	cmps	local01, arg05 wcz
 if_a	add	objptr, ##554
 if_a	rdlong	arg01, objptr
 if_a	sub	objptr, ##554
 if_a	cmps	local02, arg01 wcz
'   return
 if_a	jmp	#LR__0060
	cmps	local01, local02 wcz
 if_a	mov	arg05, local01
 if_a	mov	local01, local02
 if_a	mov	local02, arg05
	cmps	local01, #0 wc
 if_b	mov	local01, #0
	add	objptr, ##554
	rdlong	arg05, objptr
	sub	objptr, ##554
	cmps	local02, arg05 wc
 if_ae	add	objptr, ##554
 if_ae	rdlong	local02, objptr
 if_ae	sub	objptr, ##554
	add	objptr, #225
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	arg05, objptr
	shl	arg05, #2
	qmul	arg05, arg03
' if x1>x2
'   x1,x2:=x2,x1
' if x1<0 
'   x1:=0
' if x2>=xres
'   x2:=xres-1  
 if_ae	sub	local02, #1
' ram.fill(s_buf_ptr+(4*s_cpl1*y+x1),c,1+x2-x1,0,1)
	mov	arg03, #1
	add	arg03, local02
	sub	arg03, local01
	mov	arg02, arg04
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local02
	add	local02, local01
	add	arg01, local02
	call	#_psram_spin2_fill
	sub	objptr, ##5840
LR__0060
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_fastline_ret
	ret

' 
' pub draw(x1,y1,x2,y2,c) | d,dx,dy,ai,bi,xi,yi,x,y					' I had to rename the function for BASIC	
_hg010b_spin2_draw
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' if (y1==y2)
	cmp	local02, local04 wz
 if_ne	jmp	#LR__0070
'   fastline(x1,x2,y1,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local02
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
	jmp	#LR__0076
LR__0070
' else  
'   x:=x1
	mov	local06, local01
'   y:=y1
	mov	local07, local02
' 
'   if (x1<x2) 
	cmps	local01, local03 wc
'     xi:=1
 if_b	mov	local08, #1
'     dx:=x2-x1
 if_b	mov	local09, local03
 if_b	sub	local09, local01
'   else
'     xi:=-1
 if_ae	neg	local08, #1
'     dx:=x1-x2
 if_ae	sub	local01, local03
 if_ae	mov	local09, local01
'   
'   if (y1<y2) 
	cmps	local02, local04 wc
'     yi:=1
 if_b	mov	local10, #1
'     dy:=y2-y1
 if_b	mov	local11, local04
 if_b	sub	local11, local02
'   else
'     yi:=-1
 if_ae	neg	local10, #1
'     dy:=y1-y2
 if_ae	sub	local02, local04
 if_ae	mov	local11, local02
' 
'   putpixel(x,y,c)
	mov	arg03, local05
	mov	arg01, local06
	mov	arg02, local07
	call	#_hg010b_spin2_putpixel
' 
'   if (dx>dy)
	cmps	local09, local11 wcz
 if_be	jmp	#LR__0072
'     ai:=(dy-dx)*2
	mov	local12, local11
	sub	local12, local09
	shl	local12, #1
'     bi:=dy*2
	shl	local11, #1
	mov	local13, local11
'     d:= bi-dx
	mov	local14, local13
	sub	local14, local09
'     repeat while (x<>x2) 
LR__0071
	cmp	local06, local03 wz
 if_e	jmp	#LR__0075
'       if (d>=0) 
	cmps	local14, #0 wc
'         x+=xi
 if_ae	add	local06, local08
'         y+=yi
 if_ae	add	local07, local10
'         d+=ai
 if_ae	add	local14, local12
'       else
'         d+=bi
 if_b	add	local14, local13
'         x+=xi
 if_b	add	local06, local08
'       putpixel(x,y,c)
	mov	arg01, local06
	mov	arg02, local07
	mov	arg03, local05
	call	#_hg010b_spin2_putpixel
	jmp	#LR__0071
LR__0072
'   else
'     ai:=(dx-dy)*2
	mov	local12, local09
	sub	local12, local11
	shl	local12, #1
'     bi:=dx*2
	shl	local09, #1
	mov	local13, local09
'     d:=bi-dy
	mov	local14, local13
	sub	local14, local11
'     repeat while (y<>y2)
LR__0073
	cmp	local07, local04 wz
 if_e	jmp	#LR__0074
'       if (d>=0)
	cmps	local14, #0 wc
'         x+=xi
 if_ae	add	local06, local08
'         y+=yi
 if_ae	add	local07, local10
'         d+=ai
 if_ae	add	local14, local12
'       else
'         d+=bi
 if_b	add	local14, local13
'         y+=yi
 if_b	add	local07, local10
'       putpixel(x, y,c)
	mov	arg01, local06
	mov	arg02, local07
	mov	arg03, local05
	call	#_hg010b_spin2_putpixel
	jmp	#LR__0073
LR__0074
LR__0075
LR__0076
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_draw_ret
	ret

'     
' '-- A frame (an empty rectangle) ---------------------------------------
' 
' pub frame(x1,y1,x2,y2,c)
_hg010b_spin2_frame
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' fastline(x1,x2,y1,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local02
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
' fastline(x1,x2,y2,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
' line(x1,y1,x1,y2,c)
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local01
	mov	arg04, local04
	mov	arg05, local05
' draw(x1,y1,x2,y2,c)
	call	#_hg010b_spin2_draw
' line(x2,y1,x2,y2,c)
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local03
	mov	arg04, local04
	mov	arg05, local05
' draw(x1,y1,x2,y2,c)
	call	#_hg010b_spin2_draw
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_frame_ret
	ret

' 
' '-- A box (a filled rectangle) ----------------------------------------
' 
' pub box(x1,y1,x2,y2,c) |yy
_hg010b_spin2_box
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' repeat yy from y1 to y2
	cmps	local04, local02 wc
	negc	local06, #1
	add	local04, local06
LR__0080
'   fastline(x1,x2,yy,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg04, local05
	mov	arg03, local02
	call	#_hg010b_spin2_fastline
	add	local02, local06
	cmp	local02, local04 wz
 if_ne	jmp	#LR__0080
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_box_ret
	ret

'     
' '****************************************************************************************************************
' '                                                                       		 			*
' '  Characters on graphic screen                                          					*
' '                                                                       					*
' '****************************************************************************************************************    
' 
' ' ------  Transparent character
' 
' pub putcharxycf(x,y,achar,f) |xx, yy, bb
_hg010b_spin2_putcharxycf
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
' 
' repeat yy from 0 to 15
	mov	local05, #0
LR__0090
'   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
	mov	arg04, ptr__hg010b_spin2_dat__
	add	objptr, #149
	rdlong	arg03, objptr
	sub	objptr, #149
	shl	arg03, #10
	add	arg04, arg03
	mov	arg03, local03
	shl	arg03, #4
	add	arg04, arg03
	add	arg04, local05
	rdbyte	local06, arg04
'   repeat xx from 0 to 7
	mov	local07, #0
LR__0091
'     if (bb&(1<<xx))<>0
	decod	arg04, local07
	test	local06, arg04 wz
 if_e	jmp	#LR__0092
'       putpixel(xx+x,yy+y,f)
	mov	arg01, local07
	add	arg01, local01
	mov	arg02, local05
	add	arg02, local02
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
LR__0092
	add	local07, #1
	cmps	local07, #8 wc
 if_b	jmp	#LR__0091
	add	local05, #1
	cmps	local05, #16 wc
 if_b	jmp	#LR__0090
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putcharxycf_ret
	ret

'       
' pub putcharxycgf(x,y,achar,f,b) |xx, yy,bb,c1,c2
_hg010b_spin2_putcharxycgf
' 
'  
' repeat yy from 0 to 15
	mov	_var01, #0
	callpa	#(@LR__0102-@LR__0100)>>2,fcache_load_ptr_
LR__0100
' 
'   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
	add	objptr, #149
	rdlong	_var02, objptr
	shl	_var02, #10
	mov	_var03, ptr__hg010b_spin2_dat__
	add	_var03, _var02
	mov	_var02, arg03
	shl	_var02, #4
	add	_var03, _var02
	add	_var03, _var01
	rdbyte	_var03, _var03
'   asm
	testb	_var03, #0 wz
 if_e	setbyte	_var04, arg04, #0
 if_ne	setbyte	_var04, arg05, #0
	testb	_var03, #1 wz
 if_e	setbyte	_var04, arg04, #1
 if_ne	setbyte	_var04, arg05, #1
	testb	_var03, #2 wz
 if_e	setbyte	_var04, arg04, #2
 if_ne	setbyte	_var04, arg05, #2
	testb	_var03, #3 wz
 if_e	setbyte	_var04, arg04, #3
 if_ne	setbyte	_var04, arg05, #3
	testb	_var03, #4 wz
 if_e	setbyte	_var05, arg04, #0
 if_ne	setbyte	_var05, arg05, #0
	testb	_var03, #5 wz
 if_e	setbyte	_var05, arg04, #1
 if_ne	setbyte	_var05, arg05, #1
	testb	_var03, #6 wz
 if_e	setbyte	_var05, arg04, #2
 if_ne	setbyte	_var05, arg05, #2
	testb	_var03, #7 wz
 if_e	setbyte	_var05, arg04, #3
 if_ne	setbyte	_var05, arg05, #3
'   
'   ccc[0]:=c1
	add	objptr, #413
	wrlong	_var04, objptr
'   ccc[1]:=c2 
	add	objptr, #4
	wrlong	_var05, objptr
'   long[mailbox0][2]:=8
	sub	objptr, #73
	rdlong	_var03, objptr
	add	_var03, #8
	wrlong	#8, _var03
'   long[mailbox0][1]:=@ccc
	mov	_var03, objptr
	add	_var03, #69
	rdlong	_var02, objptr
	add	_var02, #4
	wrlong	_var03, _var02
'   long[mailbox0]:= s_buf_ptr+((y+yy)<<10+x<<2)+$f0000000   
	sub	objptr, #268
	rdlong	_var03, objptr
	mov	_var02, arg02
	add	_var02, _var01
	shl	_var02, #10
	mov	_var06, arg01
	shl	_var06, #2
	add	_var02, _var06
	add	_var03, _var02
	add	_var03, ##-268435456
	add	objptr, #268
	rdlong	_var06, objptr
	wrlong	_var03, _var06
'   repeat
LR__0101
	rdlong	_var03, objptr
	rdlong	_var02, _var03
	cmps	_var02, #0 wc
 if_b	jmp	#LR__0101
	sub	objptr, #493
	add	_var01, #1
	cmps	_var01, #16 wc
 if_b	jmp	#LR__0100
LR__0102
_hg010b_spin2_putcharxycgf_ret
	ret

'   
' pub outtextxycf(x,y,text,f) | iii,c
_hg010b_spin2_outtextxycf
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
' 
' repeat iii from 0 to strsize(text)-1
	mov	local05, #0
	mov	arg01, local03
	mov	local06, arg01
	callpa	#(@LR__0111-@LR__0110)>>2,fcache_load_ptr_
LR__0110
	rdbyte	result1, local06 wz
 if_ne	add	local06, #1
 if_ne	jmp	#LR__0110
LR__0111
	sub	local06, arg01
	sub	local06, #1
	cmps	local06, #0 wc
	negc	local07, #1
	add	local06, local07
LR__0112
'   putcharxycf(x+8*iii,y,byte[text+iii],f)
	mov	arg01, local01
	mov	arg04, local05
	shl	arg04, #3
	add	arg01, arg04
	mov	arg02, local02
	mov	arg04, local03
	add	arg04, local05
	rdbyte	arg03, arg04
	mov	arg04, local04
	call	#_hg010b_spin2_putcharxycf
	add	local05, local07
	cmp	local05, local06 wz
 if_ne	jmp	#LR__0112
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_outtextxycf_ret
	ret

' 
' 
' '**********************************************************************r***
' '                                                                        *
' ' Font related functions                                                 *
' '                                                                        *
' '*************************************************************************
' 
' ''--------- Set a font offset. TODO: remove, use byte#1 instead
' 
' pub setfontfamily(afontnum)
_hg010b_spin2_setfontfamily
' 
' font_family:=afontnum
	add	objptr, #149
	wrlong	arg01, objptr
	sub	objptr, #149
' 'if afontnum==8
' '  font_ptr:=@amiga_font
' 
' if afontnum==4
	cmp	arg01, #4 wz
'   font_ptr:=@st_font
 if_e	mov	_var01, ptr__hg010b_spin2_dat__
 if_e	add	_var01, ##4096
 if_e	add	objptr, #8
 if_e	wrlong	_var01, objptr
 if_e	sub	objptr, #8
' if afontnum==0
	cmp	arg01, #0 wz
'   font_ptr:=@vga_font
 if_e	add	objptr, #8
 if_e	wrlong	ptr__hg010b_spin2_dat__, objptr
 if_e	sub	objptr, #8
_hg010b_spin2_setfontfamily_ret
	ret

' 
' '*************************************************************************
' '                                                                        *
' '  VBlank functions                                                      *
' '                                                                        *
' '*************************************************************************
' 
' pub waitvbl(amount) | i
_hg010b_spin2_waitvbl
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' ''---------- Wait for start of vblank. Amount=delay in frames
' 
' repeat i from 1 to amount
	mov	local02, #1
	cmps	local01, #1 wc
	negc	local03, #1
	add	local01, local03
LR__0120
'   repeat until vblank==0
LR__0121
	add	objptr, #73
	rdlong	arg01, objptr wz
	sub	objptr, #73
 if_e	jmp	#LR__0122
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__0121
LR__0122
'   repeat until vblank==1
LR__0123
	add	objptr, #73
	rdlong	arg01, objptr
	sub	objptr, #73
	cmp	arg01, #1 wz
 if_e	jmp	#LR__0124
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__0123
LR__0124
	add	local02, local03
	cmp	local02, local01 wz
 if_ne	jmp	#LR__0120
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_waitvbl_ret
	ret

' 
' 
' pub cls(fc,bc)   :c,i
_hg010b_spin2_cls
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' c:=bc
' ram.fill(s_buf_ptr,c,4*buflen,0,1)  
	add	objptr, #225
	rdlong	arg01, objptr
	sub	objptr, #169
	rdlong	arg03, objptr
	shl	arg03, #2
	mov	arg02, local02
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5784
	call	#_psram_spin2_fill
' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
	sub	objptr, ##5836
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	arg03, arg01
	mov	arg02, #32
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5840
	call	#_psram_spin2_fill
' setwritecolors(fc,bc)
' 
' write_color:=ff
	sub	objptr, ##5775
	wrlong	local01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	local02, objptr
' cursor_x:=0
	sub	objptr, #9
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	sub	objptr, #60
	mov	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
' setcursorcolor(fc)
	mov	arg01, local01
	call	#_hg010b_spin2_setcursorcolor
	mov	result1, local02
	mov	result2, #0
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_cls_ret
	ret

' 
' ''---------- Output a char at the cursor position, move the cursor 
' 
' pub putchar(achar) | c,x,y,l,newcpl
_hg010b_spin2_putchar
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' if achar==10
	cmp	local01, #10 wz
'   crlf()
 if_e	call	#_hg010b_spin2_crlf
' if achar==9
	cmp	local01, #9 wz
 if_ne	jmp	#LR__0130
'   cursor_x:=(cursor_x& %11110000)+16
	add	objptr, #60
	rdword	arg03, objptr
	and	arg03, #240
	add	arg03, #16
	wrword	arg03, objptr
	sub	objptr, #60
LR__0130
'   
' if (achar<>9) && (achar<>10) 
	cmp	local01, #9 wz
 if_ne	cmp	local01, #10 wz
 if_e	jmp	#LR__0131
'   putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
	add	objptr, #60
	rdword	arg01, objptr
	add	objptr, #2
	rdbyte	arg02, objptr
	shl	arg02, #4
	add	arg02, #4
	add	objptr, #3
	rdlong	arg04, objptr
	add	objptr, #4
	rdlong	arg05, objptr
	sub	objptr, #69
	mov	arg03, local01
	call	#_hg010b_spin2_putcharxycgf
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	arg03, ptr__hg010b_spin2_dat__
	add	objptr, #58
	rdbyte	arg05, objptr
	qmul	arg03, arg05
'   ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
	sub	ptr__hg010b_spin2_dat__, ##14428
	sub	objptr, #2
	rdword	local02, objptr
	shr	local02, #1
	mov	arg02, local01
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5780
	getqx	local01
	add	local01, local02
	add	arg01, local01
	call	#_psram_spin2_fill
'   cursor_x+=2
	sub	objptr, ##5780
	rdword	local02, objptr
	add	local02, #2
	wrword	local02, objptr
	sub	objptr, #60
LR__0131
' 
' if cursor_x>=256
	add	objptr, #60
	rdword	local02, objptr
	sub	objptr, #60
	cmps	local02, #256 wc
 if_b	jmp	#LR__0133
'   cursor_x:=0
	add	objptr, #60
	wrword	#0, objptr
'   cursor_y+=1
	add	objptr, #2
	rdbyte	local02, objptr
	add	local02, #1
	wrbyte	local02, objptr
'   if cursor_y>st_lines-1
	add	objptr, #199
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #199
	rdbyte	arg03, objptr
	sub	objptr, #62
	cmps	arg03, local02 wcz
 if_be	jmp	#LR__0132
'     scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup2
'     cursor_y:=st_lines-1
	add	objptr, #261
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #199
	wrbyte	local02, objptr
	sub	objptr, #62
LR__0132
LR__0133
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putchar_ret
	ret

'    
' ' a version for text scrolling in Basic shifted 4 lines down
' 
' pub scrollup2(start=0, end=600 , amount=16) | i
_hg010b_spin2_scrollup2
	mov	COUNT_, #3
	call	#pushregs_
' 	
' repeat i from 4 to 579 
	mov	local01, #4
LR__0140
	add	objptr, #225
	rdlong	arg02, objptr
	mov	arg05, local01
	add	arg05, #16
	shl	arg05, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg05, arg03
'   ram.read1($7E800, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
	shl	arg03, #2
	mov	arg01, ##518144
	add	objptr, ##5595
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_read1
	sub	objptr, ##5615
	rdlong	arg02, objptr
	mov	arg05, local01
	shl	arg05, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg05, arg03
'   ram.write($7E800, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
	shl	arg03, #2
	mov	arg01, ##518144
	add	objptr, ##5595
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_write
	sub	objptr, ##5840
	add	local01, #1
	cmp	local01, ##580 wc
 if_b	jmp	#LR__0140
' 
' repeat i from 580 to 599
	mov	local01, ##580
LR__0141
'    fastline(0,1023,i,write_background)   
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_hg010b_spin2_fastline
	add	local01, #1
	cmp	local01, ##600 wc
 if_b	jmp	#LR__0141
' repeat i from 0 to 3
	mov	local01, #0
LR__0142
'    fastline(0,1023,i,write_background)      
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_hg010b_spin2_fastline
	add	local01, #1
	cmps	local01, #4 wc
 if_b	jmp	#LR__0142
' 
' repeat i from 0 to 35
	mov	local01, #0
LR__0143
	mov	arg05, local01
	add	arg05, #1
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	arg03, ptr__hg010b_spin2_dat__
	qmul	arg05, arg03
'   ram.read1($7E800, textbuf_ptr+(i+1)*timings[7], timings[7])
	add	objptr, #4
	rdlong	arg02, objptr
	sub	ptr__hg010b_spin2_dat__, ##14428
	mov	arg01, ##518144
	add	objptr, ##5836
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_read1
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	arg03, ptr__hg010b_spin2_dat__
	qmul	local01, arg03
'   ram.write($7E800, textbuf_ptr+i*timings[7], timings[7])
	sub	objptr, ##5836
	rdlong	arg02, objptr
	sub	ptr__hg010b_spin2_dat__, ##14428
	mov	arg01, ##518144
	add	objptr, ##5836
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_write
	sub	objptr, ##5840
	add	local01, #1
	cmps	local01, #36 wc
 if_b	jmp	#LR__0143
' repeat i from 0 to timings[7]-1
	mov	local01, #0
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	local02, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##14428
	sub	local02, #1
	cmps	local02, #0 wc
	negc	local03, #1
	add	local02, local03
LR__0144
'   ram.fill(textbuf_ptr+(36*timings[7]+i),32,1,0,1) 
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	arg05, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##14428
	mov	arg04, arg05
	shl	arg04, #3
	add	arg04, arg05
	shl	arg04, #2
	add	arg04, local01
	add	arg01, arg04
	mov	arg02, #32
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5836
	call	#_psram_spin2_fill
	sub	objptr, ##5840
	add	local01, local03
	cmp	local01, local02 wz
 if_ne	jmp	#LR__0144
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_scrollup2_ret
	ret

' 
' ''----------- Set cursor at the first character in a new line, scroll if needed 
' 
' pub crlf()
_hg010b_spin2_crlf
' 
' cursor_x:=leading_spaces*2
	add	objptr, ##698
	rdlong	arg03, objptr
	shl	arg03, #1
	sub	objptr, ##638
	wrword	arg03, objptr
' cursor_y+=1
	add	objptr, #2
	rdbyte	arg03, objptr
	add	arg03, #1
	wrbyte	arg03, objptr
' if cursor_y>st_lines-1
	add	objptr, #199
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #199
	rdbyte	arg02, objptr
	sub	objptr, #62
	cmps	arg02, arg03 wcz
 if_be	jmp	#LR__0150
'   scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup2
'   cursor_y:=st_lines-1
	add	objptr, #261
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #199
	wrbyte	arg03, objptr
	sub	objptr, #62
LR__0150
' setspritepos(17,4*cursor_x,16*cursor_y+4 )  
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
_hg010b_spin2_crlf_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB startx(freq, burst, delay, desiredcog) : cog,mail | driverAddr
_psram_spin2_startx
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	mov	local03, arg04
'     stop() ' restart driver if required
	call	#_psram_spin2_stop
	cmp	local01, #0 wz
 if_e	rdlong	local01, #20
	abs	arg02, local01 wc
	qdiv	arg02, ##1000000
' 
'     ' use current frequency if none specified
' 
'     if freq == 0 
'         freq := clkfreq 
' 
'     ' compute the device burst size including overheads to keep CS low time below 8us
' 
'     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
'     if burst < 0
'         return ERR_TOO_SLOW,0 ' P2 frequency is too low for any 8us transfers
	getqx	arg02
	negc	arg04, arg02
	shl	arg04, #3
	sub	arg04, #132
	shr	arg04, #4
	shl	arg04, #4
	cmps	arg04, #0 wc
 if_b	mov	result2, #0
 if_b	neg	result1, #14
 if_b	jmp	#LR__0164
' 
'     ' compute the input delay
' 
'     if delay <= 0
	cmps	local02, #1 wc
 if_ae	jmp	#LR__0160
'         delay := lookupDelay(freq)
	mov	arg01, local01
	call	#_psram_spin2_lookupDelay
	mov	local02, result1
	jmp	#LR__0161
LR__0160
'     else
'         delay <#= $f ' limit to 15
	fles	local02, #15
LR__0161
' 
'     ' create our lock
' 
'     driverlock := LOCKNEW()  
	mov	result1, #0
	locknew	result1
	add	ptr__psram_spin2_dat__, #260
	wrlong	result1, ptr__psram_spin2_dat__
'     if driverlock == -1
	sub	ptr__psram_spin2_dat__, #260
	cmp	result1, ##-1 wz
'         return ERR_NO_LOCK,0
 if_e	mov	result2, #0
 if_e	neg	result1, #26
 if_e	jmp	#LR__0164
' 
'     ' patch in the proper data and HUB addresses to the startup structure
' 
'     long[@startupData][0]:=clkfreq
	rdlong	local01, #20
	add	ptr__psram_spin2_dat__, #296
	wrlong	local01, ptr__psram_spin2_dat__
' '    long[@startupData][1]:=$1000_0000
'     long[@startupData][5]:=@deviceData
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #32
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #20
	wrlong	local01, arg02
'     long[@startupData][6]:=@qosData
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #160
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #24
	wrlong	local01, arg02
' 
' 
'     long[@startupData][7]:=mailbox
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #28
	wrlong	##507648, local01
'   
'     ' setup some default bank and QoS parameter values
' 
'     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
	add	ptr__psram_spin2_dat__, #32
	mov	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #328
	shl	arg04, #16
	shl	local02, #12
	or	arg04, local02
	or	arg04, #24
	mov	arg02, arg04
	mov	arg03, #2
	call	#\builtin_longfill_
'     longfill(@qosData, $FFFF0000, 8)
	mov	arg01, ptr__psram_spin2_dat__
	add	arg01, #456
	mov	arg03, #7
	setq	arg03
	wrlong	##-65536, arg01
' 
'     ' get the address of the PSRAM memory driver so we can start it
' 
'     driverAddr:= driver.getDriverAddr()
'     return @driver_start
	mov	arg02, ptr__psram16drv_spin2_dat__
	add	arg02, #32
' 
'     ' start the PSRAM memory driver and wait for it to complete initialization
' 
'     if desiredcog < 0
	cmps	local03, #0 wc
'         desiredcog := NEWCOG
 if_b	mov	local03, #16
'     drivercog := coginit(desiredcog, driverAddr, @startupData)
	mov	arg03, ptr__psram_spin2_dat__
	add	arg03, #296
	mov	local04, local03
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
	add	ptr__psram_spin2_dat__, #256
	wrlong	local04, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	callpa	#(@LR__0163-@LR__0162)>>2,fcache_load_ptr_
'     repeat until long[@startupData] == 0 
LR__0162
	mov	local04, ptr__psram_spin2_dat__
	add	local04, #296
	rdlong	local04, local04 wz
 if_ne	jmp	#LR__0162
LR__0163
' 
'     return drivercog,long[@startupData][7]
	add	ptr__psram_spin2_dat__, #256
	rdlong	result1, ptr__psram_spin2_dat__
	add	ptr__psram_spin2_dat__, #40
	mov	local04, ptr__psram_spin2_dat__
	add	local04, #28
	rdlong	result2, local04
	sub	ptr__psram_spin2_dat__, #296
LR__0164
	mov	ptra, fp
	call	#popregs_
_psram_spin2_startx_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB stop() : i
_psram_spin2_stop
	mov	_var01, #0
'     if drivercog <> -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	arg01, ##-1 wz
 if_e	jmp	#LR__0173
'         cogstop(drivercog) ' a rather brutal stop
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cogstop	arg01
	callpa	#(@LR__0172-@LR__0170)>>2,fcache_load_ptr_
'         repeat i from 0 to 7
LR__0170
'             if long[mailbox][i*3] < 0
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##507648
	rdlong	result1, result1
	cmps	result1, #0 wc
 if_ae	jmp	#LR__0171
'                 long[mailbox][i*3] := -ERR_ABORTED ' abort request
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##507648
	wrlong	#16, result1
LR__0171
	add	_var01, #1
	cmps	_var01, #8 wc
 if_b	jmp	#LR__0170
LR__0172
'         drivercog := -1
	add	ptr__psram_spin2_dat__, #256
	wrlong	##-1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__0173
'     if driverlock <> -1
	add	ptr__psram_spin2_dat__, #260
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	cmp	_var02, ##-1 wz
'         LOCKRET(driverlock)
 if_ne	add	ptr__psram_spin2_dat__, #260
 if_ne	rdlong	arg01, ptr__psram_spin2_dat__
 if_ne	lockret	arg01
'         driverlock := -1
 if_ne	wrlong	##-1, ptr__psram_spin2_dat__
 if_ne	sub	ptr__psram_spin2_dat__, #260
	mov	result1, _var01
_psram_spin2_stop_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB read1(dstHubAddr, srcAddr, count) : result | mailbox1
_psram_spin2_read1
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0181
'     if count == 0 ' don't even bother reading
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__0181
'     mailbox1 := mailbox + cogid()*12     ' compute COG's mailbox address
	mov	_var02, ##507648
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	add	_var02, _var01
'     if long[mailbox1] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__0181
'     long[mailbox1][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox1][1] := dstHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox1] := driver.R_READBURST + (srcAddr & $1ffffff) ' trigger burst read operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-1342177280
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__0180
'         result := long[mailbox1]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__0180
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__0181
_psram_spin2_read1_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB write(srcHubAddr, dstAddr, count) : result | mailbox1
_psram_spin2_write
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0191
'     if count == 0 ' don't even bother writing
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__0191
'     mailbox1 := mailbox + cogid()*12     ' compute COG's mailbox address
	mov	_var02, ##507648
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, ##507648
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__0191
'     long[mailbox1][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox1][1] := srcHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox1] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-268435456
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__0190
'         result := long[mailbox1]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__0190
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__0191
_psram_spin2_write_ret
	ret

' 
' ' generalized fill
' PUB fill(addr, pattern, count, listPtr, datasize) : r | mailbox1, req
_psram_spin2_fill
	mov	_var01, arg01
	mov	_var02, arg02
	mov	_var03, arg03
	mov	_var04, arg05
'     case datasize 
	sub	_var04, #1
	fle	_var04, #4
	jmprel	_var04
LR__0200
	jmp	#LR__0201
	jmp	#LR__0202
	jmp	#LR__0204
	jmp	#LR__0203
	jmp	#LR__0204
LR__0201
'         1: req := driver.R_WRITEBYTE
	mov	_var05, ##-1073741824
	jmp	#LR__0205
LR__0202
'         2: req := driver.R_WRITEWORD
	mov	_var05, ##-805306368
	jmp	#LR__0205
LR__0203
'         4: req := driver.R_WRITELONG
	mov	_var05, ##-536870912
	jmp	#LR__0205
LR__0204
'         other : return ERR_INVALID
	neg	result1, #6
	jmp	#LR__0207
LR__0205
'     if count == 0   ' nothing to do
	cmp	_var03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__0207
'     if drivercog == -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var04, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var04, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0207
'     mailbox1 := mailbox + 12*cogid() ' get mailbox base address for this COG
	mov	_var06, ##507648
	mov	result1, #0
	cogid	result1
	mov	_var04, result1
	shl	_var04, #1
	add	_var04, result1
	shl	_var04, #2
	add	_var06, _var04
'     if long[mailbox] < 0
	rdlong	_var04, ##507648
	cmps	_var04, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__0207
'     long[mailbox1][2] := count
	add	_var06, #8
	wrlong	_var03, _var06
'     long[mailbox1][1] := pattern
	sub	_var06, #4
	wrlong	_var02, _var06
	sub	_var06, #4
'     long[mailbox1] := req + (addr & $1ffffff)
	mov	_var07, _var05
	mov	_var08, _var01
	bitl	_var08, #217
	add	_var07, _var08
	wrlong	_var07, _var06
'     repeat
LR__0206
'         r := long[mailbox1]
	rdlong	_var08, _var06
	cmps	_var08, #0 wc
 if_b	jmp	#LR__0206
'     while r < 0
'     return -r                  ' return 0 for success or negated error code
	neg	result1, _var08
LR__0207
_psram_spin2_fill_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB setQos(cog, qos) : result | mailbox1
_psram_spin2_setQos
	mov	_var01, arg01
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var02, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0214
'     if cog < 0 or cog > 7 ' enforce cog id range
	cmps	_var01, #0 wc
 if_b	jmp	#LR__0210
	cmps	_var01, #8 wc
 if_b	jmp	#LR__0211
LR__0210
'         return ERR_INVALID
	neg	result1, #6
	jmp	#LR__0214
LR__0211
'     long[@qosData][cog] := qos & !$1ff
	andn	arg02, #511
	add	ptr__psram_spin2_dat__, #456
	shl	_var01, #2
	add	_var01, ptr__psram_spin2_dat__
	wrlong	arg02, _var01
'     mailbox1 := mailbox + drivercog*12
	mov	_var03, ##507648
	sub	ptr__psram_spin2_dat__, #200
	rdlong	_var04, ptr__psram_spin2_dat__
	mov	_var05, _var04
	shl	_var05, #1
	add	_var05, _var04
	shl	_var05, #2
	add	_var03, _var05
'     repeat until LOCKTRY(driverlock)
	add	ptr__psram_spin2_dat__, #4
LR__0212
	rdlong	arg01, ptr__psram_spin2_dat__
	locktry	arg01 wc
 if_ae	jmp	#LR__0212
	sub	ptr__psram_spin2_dat__, #260
'     long[mailbox1] := driver.R_CONFIG + cogid()
	mov	_var05, #0
	cogid	_var05
	mov	_var02, ##-268435456
	add	_var02, _var05
	wrlong	_var02, _var03
'     repeat while long[mailbox1] < 0
LR__0213
	rdlong	_var02, _var03
	cmps	_var02, #0 wc
 if_b	jmp	#LR__0213
'     LOCKREL(driverlock)
	add	ptr__psram_spin2_dat__, #260
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	lockrel	arg01 wc
	mov	result1, #0
LR__0214
_psram_spin2_setQos_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PRI lookupDelay(freq) : delay | profile
_psram_spin2_lookupDelay
'     profile := @delayTable
	mov	_var01, ptr__psram_spin2_dat__
	add	_var01, #264
'     delay := long[profile][0]
	rdlong	_var02, _var01
	callpa	#(@LR__0221-@LR__0220)>>2,fcache_load_ptr_
'     repeat while long[profile][1] 
LR__0220
	add	_var01, #4
	rdlong	result1, _var01 wz
	sub	_var01, #4
 if_e	jmp	#LR__0222
'         if freq +< long[profile][1] 
	add	_var01, #4
	rdlong	result1, _var01
	sub	_var01, #4
	cmp	arg01, result1 wc
'             quit
'         profile += 4
 if_ae	add	_var01, #4
'         delay++
 if_ae	add	_var02, #1
 if_ae	jmp	#LR__0220
LR__0221
LR__0222
	mov	result1, _var02
_psram_spin2_lookupDelay_ret
	ret

' 
' PUB start() : r
_usbnew_spin2_start
	mov	_var01, #0
'   ifnot driver_cog
	add	ptr__usbnew_spin2_dat__, ##10887
	rdbyte	_var02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##10887
 if_ne	jmp	#LR__0230
'     r := coginit(COGEXEC_NEW,@usb_host_start,0)
	mov	arg02, ptr__usbnew_spin2_dat__
	mov	_var01, #16
	mov	arg03, #0
	setq	arg03
	coginit	_var01, arg02 wc
 if_b	neg	_var01, #1
'     if r >= 0
	cmps	_var01, #0 wc
'       driver_cog := r+1
 if_ae	mov	_var02, _var01
 if_ae	add	_var02, #1
 if_ae	add	ptr__usbnew_spin2_dat__, ##10887
 if_ae	wrbyte	_var02, ptr__usbnew_spin2_dat__
 if_ae	sub	ptr__usbnew_spin2_dat__, ##10887
LR__0230
	mov	result1, _var01
_usbnew_spin2_start_ret
	ret

' 
' '' Emulate mouse movement
' PUB mouse_move(x,y)
_usbnew_spin2_mouse_move
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'   mouse_lock := 1
	add	ptr__usbnew_spin2_dat__, ##10481
	wrbyte	#1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10481
'   waitus(2) ' hope driver is now done
	mov	arg01, #2
	call	#__system___waitus
'   mouse_xacc := x
	add	ptr__usbnew_spin2_dat__, ##10465
	wrlong	local01, ptr__usbnew_spin2_dat__
'   mouse_yacc := y
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	local02, ptr__usbnew_spin2_dat__
'   if mouse_outptr
	sub	ptr__usbnew_spin2_dat__, ##2581
	rdlong	arg02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##7888
 if_e	jmp	#LR__0240
'     long[mouse_outptr] := y << 16 | x & $FFFF
	shl	local02, #16
	getword	local01, local01, #0
	or	local02, local01
	add	ptr__usbnew_spin2_dat__, ##7888
	rdlong	local01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7888
	wrlong	local02, local01
LR__0240
'   mouse_lock := 0
	add	ptr__usbnew_spin2_dat__, ##10481
	wrbyte	#0, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10481
	mov	ptra, fp
	call	#popregs_
_usbnew_spin2_mouse_move_ret
	ret

' 
' '--------------------------------------------------------------
' '---------- Init the variables, start the cog. ----------------
' '--------------------------------------------------------------
' 
' pub start(mbox,scope,cache) :cog,base | iii
_Audio2_004_spin2_start
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' ' mbox: PSRAM mailbox or 0 if no PSRAM
' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
' 
' mailboxaddr:=mbox 
	wrlong	local01, objptr
' scope_ptr:=scope
	add	objptr, #4
	wrlong	arg02, objptr
' cache_ptr:=cache
	add	objptr, #4
	wrlong	arg03, objptr
' base:=@channel0[0]
	add	objptr, #4
	mov	local02, objptr
' 
' repeat iii from 0 to 15
	mov	local03, #0
	sub	objptr, #12
	callpa	#(@LR__0251-@LR__0250)>>2,fcache_load_ptr_
LR__0250
'   long[base+64*iii]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	wrlong	#0, local01
'   long[base+64*iii+4]:=0  		
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	add	local01, #4
	wrlong	#0, local01
'   long[base+64*iii+8]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #8
	wrlong	#0, local04
'   long[base+64*iii+12]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #12
	wrlong	#0, local04
'   long[base+64*iii+16]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #16
	wrlong	#0, local04
'   long[base+64*iii+20]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #20
	wrlong	#0, local04
'   long[base+64*iii+24]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #24
	wrlong	#0, local04
'   long[base+64*iii+28]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #28
	wrlong	#0, local04
'   word[base+64*iii+32]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #32
	wrword	##8192, local04
'   word[base+64*iii+34]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #34
	wrword	##8192, local04
'   long[base+64*iii+36]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #36
	wrlong	#0, local04
'   long[base+64*iii+40]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #40
	wrlong	#0, local04
'   long[base+64*iii+44]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #44
	wrlong	#0, local04
'   long[base+64*iii+48]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #48
	wrlong	#0, local04
'   long[base+64*iii+52]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #52
	wrlong	#0, local04
'   freqs[iii]:=440000
	mov	local04, local03
	shl	local04, #2
	add	objptr, ##1036
	add	local04, objptr
	wrlong	##440000, local04
'   delays[iii]:=0
	mov	local04, local03
	shl	local04, #1
	add	objptr, #64
	add	local04, objptr
	wrword	#0, local04
'   volumes[iii]:=4096
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	##4096, local04
'   waveforms[iii]:=0
	mov	local04, local03
	shl	local04, #2
	add	objptr, #32
	add	local04, objptr
	wrlong	#0, local04
'   envelopes[iii]:=0
	mov	local04, local03
	shl	local04, #2
	add	objptr, #64
	add	local04, objptr
	wrlong	#0, local04
'   lengths[iii]:=1000
	mov	local04, local03
	shl	local04, #1
	add	objptr, #64
	add	local04, objptr
	wrword	##1000, local04
'   pans[iii]:=8192
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	##8192, local04
'   sustains[iii]:=255
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	#255, local04
	add	local03, #1
	cmps	local03, #16 wc
	sub	objptr, ##1356
 if_b	jmp	#LR__0250
LR__0251
'   
' cog:=coginit(16,@audio,@mailboxaddr)
	mov	arg02, ptr__Audio2_004_spin2_dat__
	mov	arg03, objptr
	mov	local04, #16
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
' waitms(10)
	mov	arg01, #10
	call	#__system___waitms
' return cog,base
	mov	result2, local02
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_Audio2_004_spin2_start_ret
	ret

' 
' sub create(avdrv as vdrv,ax=0,ay=0,aw=16,ah=128,alabel$="",ac1=10,ac2=15, ac3=120 )
_window_create
	add	objptr, #4
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	arg05, objptr
	add	objptr, #16
	wrlong	arg07, objptr
	add	objptr, #4
	wrlong	arg08, objptr
	add	objptr, #4
	wrlong	arg09, objptr
	add	objptr, #4
	wrlong	arg06, objptr
	add	objptr, #8
	mov	arg02, arg01
	mov	arg01, objptr
	mov	arg03, ##5840
	sub	objptr, #52
	call	#__system____builtin_memmove
	call	#_window_draw
_window_create_ret
	ret

' 
' 
' sub draw
_window_draw
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, #4
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	mov	arg03, arg01
	add	objptr, #4
	rdlong	result1, objptr
	add	arg03, result1
	sub	arg03, #1
	mov	arg04, arg02
	add	objptr, #4
	rdlong	result1, objptr
	add	arg04, result1
	sub	arg04, #1
	add	objptr, #16
	rdlong	arg05, objptr
	add	objptr, #20
	call	#_hg010b_spin2_frame
	sub	objptr, #48
	rdlong	arg01, objptr
	add	arg01, #1
	add	objptr, #4
	rdlong	arg02, objptr
	add	arg02, #1
	sub	objptr, #4
	rdlong	arg03, objptr
	add	objptr, #8
	rdlong	result1, objptr
	add	arg03, result1
	sub	arg03, #2
	sub	objptr, #4
	rdlong	arg04, objptr
	add	objptr, #8
	rdlong	result1, objptr
	add	arg04, result1
	sub	arg04, #2
	add	objptr, #20
	rdlong	arg05, objptr
	add	objptr, #16
	call	#_hg010b_spin2_box
	sub	objptr, #48
	rdlong	arg01, objptr
	add	arg01, #2
	add	objptr, #4
	rdlong	arg02, objptr
	add	arg02, #2
	sub	objptr, #4
	rdlong	arg03, objptr
	add	objptr, #8
	rdlong	result1, objptr
	add	arg03, result1
	sub	arg03, #3
	sub	objptr, #4
	rdlong	arg04, objptr
	add	arg04, #20
	add	objptr, #32
	rdlong	arg05, objptr
	add	objptr, #12
	call	#_hg010b_spin2_box
	sub	objptr, #48
	rdlong	arg05, objptr
	add	arg05, #2
	add	objptr, #8
	rdlong	result1, objptr
	abs	arg04, result1 wc
	shr	arg04, #1
	sumc	arg05, arg04
	add	objptr, #32
	rdlong	arg01, objptr
	sub	objptr, #44
	mov	local01, arg01
	callpa	#(@LR__0261-@LR__0260)>>2,fcache_load_ptr_
LR__0260
	rdbyte	result1, local01 wz
 if_ne	add	local01, #1
 if_ne	jmp	#LR__0260
LR__0261
	sub	local01, arg01
	mov	result1, local01
	shl	result1, #2
	sub	arg05, result1
	add	objptr, #8
	rdlong	arg02, objptr
	add	arg02, #3
	add	objptr, #36
	rdlong	arg03, objptr
	sub	objptr, #8
	rdlong	arg04, objptr
	mov	arg01, arg05
	add	objptr, #16
	call	#_hg010b_spin2_outtextxycf
	sub	objptr, #52
	mov	ptra, fp
	call	#popregs_
_window_draw_ret
	ret

' 
' sub create(avdrv as vdrv,ax=0,ay=0,aw=16,ah=128,amin=0,amax=10,aticks=11,ac1=244,ac2=248,alabel$="")
_trackbar_create
	add	objptr, #4
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	arg05, objptr
	add	objptr, #4
	wrlong	arg06, objptr
	add	objptr, #4
	wrlong	arg07, objptr
	add	objptr, #4
	wrlong	arg08, objptr
	add	objptr, #4
	wrlong	arg09, objptr
	add	objptr, #4
	wrlong	arg10, objptr
	add	objptr, #4
	wrlong	arg11, objptr
	add	objptr, #4
	mov	arg02, arg01
	mov	arg01, objptr
	mov	arg03, ##5840
	sub	objptr, #44
	call	#__system____builtin_memmove
	call	#_trackbar_draw
_trackbar_create_ret
	ret

' 
' 
' sub draw
_trackbar_draw
	mov	COUNT_, #9
	call	#pushregs_
	add	objptr, #4
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	mov	arg03, arg01
	add	objptr, #4
	rdlong	result1, objptr
	add	arg03, result1
	sub	arg03, #1
	mov	arg04, arg02
	add	objptr, #4
	rdlong	result1, objptr
	add	arg04, result1
	sub	arg04, #1
	add	objptr, #16
	rdlong	arg05, objptr
	add	objptr, #12
	call	#_hg010b_spin2_box
	sub	objptr, #40
	rdlong	arg01, objptr
	add	arg01, #3
	add	objptr, #4
	rdlong	arg02, objptr
	add	arg02, #3
	sub	objptr, #4
	rdlong	arg03, objptr
	add	objptr, #8
	rdlong	result1, objptr
	add	arg03, result1
	sub	arg03, #4
	sub	objptr, #4
	rdlong	arg04, objptr
	add	objptr, #8
	rdlong	result1, objptr
	add	arg04, result1
	sub	arg04, #4
	add	objptr, #20
	rdlong	arg05, objptr
	add	objptr, #8
	call	#_hg010b_spin2_box
	sub	objptr, #28
	rdlong	arg01, objptr
	sub	objptr, #16
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	local02, result1
	add	objptr, #28
	rdlong	arg01, objptr
	sub	objptr, #28
	sub	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	mov	local03, result1
	mov	arg01, #0
	call	#__system___getiolock_0133
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0133
	wrlong	#0, result1
	add	objptr, #24
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	local02, objptr
	sub	objptr, #20
	sub	arg01, local02
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	local02, result1
	add	objptr, #28
	rdlong	arg01, objptr
	sub	objptr, #28
	sub	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	mov	local04, result1
	mov	arg01, #0
	call	#__system___getiolock_0133
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local04
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0133
	wrlong	#0, result1
' 
' for i=0 to ticks-1: v.fastline(x,x+3,round(y+h-i*hr),0) : v.outtextxycf(x-8-4*len(str$(round(min+i*dv))),round(y+h-i*hr)-8,str$(round(min+i*dv)),c2):next i
	mov	local05, #0
	add	objptr, #28
	rdlong	local06, objptr
	sub	objptr, #28
LR__0270
	cmps	local05, local06 wc
 if_ae	jmp	#LR__0273
	add	objptr, #4
	rdlong	local07, objptr
	mov	local02, local07
	add	objptr, #4
	rdlong	arg01, objptr
	add	objptr, #8
	rdlong	arg05, objptr
	sub	objptr, #16
	add	arg01, arg05
	add	local07, #3
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	local08, result1
	abs	arg01, local05 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg01, result1
	mov	arg02, local03
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local08
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	arg03, result1
	mov	arg01, local02
	mov	arg02, local07
	mov	arg04, #0
	add	objptr, #44
	call	#_hg010b_spin2_fastline
	sub	objptr, #40
	rdlong	local02, objptr
	sub	local02, #8
	add	objptr, #16
	rdlong	arg01, objptr
	sub	objptr, #20
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	local08, result1
	abs	arg01, local05 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg01, result1
	mov	arg02, local04
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local08
	call	#__system___float_add
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	abs	arg01, result1 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg01, result1
	call	#__system__str_S
	mov	arg01, result1
	mov	local09, arg01
	callpa	#(@LR__0272-@LR__0271)>>2,fcache_load_ptr_
LR__0271
	rdbyte	result1, local09 wz
 if_ne	add	local09, #1
 if_ne	jmp	#LR__0271
LR__0272
	sub	local09, arg01
	mov	result1, local09
	shl	result1, #2
	sub	local02, result1
	add	objptr, #8
	rdlong	arg01, objptr
	add	objptr, #8
	rdlong	local08, objptr
	sub	objptr, #16
	add	arg01, local08
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	local08, result1
	abs	arg01, local05 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg01, result1
	mov	arg02, local03
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local08
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	sub	result1, #8
	mov	local07, result1
	add	objptr, #20
	rdlong	arg01, objptr
	sub	objptr, #20
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	local08, result1
	abs	arg01, local05 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg01, result1
	mov	arg02, local04
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local08
	call	#__system___float_add
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	abs	arg01, result1 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg01, result1
	call	#__system__str_S
	mov	arg03, result1
	add	objptr, #36
	rdlong	arg04, objptr
	mov	arg01, local02
	mov	arg02, local07
	add	objptr, #8
	call	#_hg010b_spin2_outtextxycf
	sub	objptr, #44
	add	local05, #1
	jmp	#LR__0270
LR__0273
	mov	ptra, fp
	call	#popregs_
_trackbar_draw_ret
	ret
hubexit
	jmp	#cogexit

__system___setbaud
	rdlong	muldiva_, #20
	mov	muldivb_, arg01
	call	#divide_
	callpa	#(@LR__0281-@LR__0280)>>2,fcache_load_ptr_
LR__0280
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__0280
LR__0281
	dirl	#62
	dirl	#63
	wrlong	muldivb_, ptr___system__dat__
	shl	muldivb_, #16
	mov	arg02, #7
	add	arg02, muldivb_
	wrpin	#124, #62
	wxpin	arg02, #62
	wrpin	#62, #63
	add	arg02, #20
	wxpin	arg02, #63
	dirh	#62
	dirh	#63
__system___setbaud_ret
	ret

__system___txraw
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	callpa	#(@LR__0291-@LR__0290)>>2,fcache_load_ptr_
LR__0290
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__0290
LR__0291
	rdlong	result1, ptr___system__dat__ wz
 if_e	mov	arg01, ##2000000
 if_e	call	#__system___setbaud
	drvl	#62
	wypin	local01, #62
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___txraw_ret
	ret

__system___rxraw
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, ptr___system__dat__ wz
 if_e	mov	arg01, ##2000000
 if_e	call	#__system___setbaud
	cmp	local01, #0 wz
 if_e	jmp	#LR__0300
	rdlong	local03, #20
	shr	local03, #10
	qmul	local01, local03
	getct	result1
	getqx	local04
	add	result1, local04
	mov	local05, result1
	jmp	#LR__0301
LR__0300
	mov	local05, #0
LR__0301
	neg	local06, #1
	mov	local07, #63
	mov	local08, #0
	add	ptr___system__dat__, #4
	rdlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
LR__0302
	testb	local09, #8 wc
	testbn	local09, #9 andc
	shr	local09, #10
 if_b	mov	local08, #1
 if_ae	testp	#63 wz
 if_nc_and_z	mov	local08, #1
 if_nc_and_z	rdpin	local09, #63
 if_nc_and_z	shr	local09, #4
LR__0303
	mov	local02, #0
	cmp	local08, #0 wz
 if_ne	neg	local02, #1
	mov	local10, #0
	mov	local03, #0
	cmp	local01, #0 wz
 if_ne	neg	local03, #1
	mov	local04, #0
	mov	local11, #0
	mov	local12, local05
	getct	result1
	mov	local13, result1
	sub	local12, local13
	cmps	local12, #0 wc
 if_b	not	local11, #0
	cmp	local11, #0 wz
 if_ne	not	local04, #0
	test	local03, local04 wz
 if_ne	not	local10, #0
	or	local02, local10 wz
 if_e	jmp	#LR__0302
	cmp	local08, #0 wz
 if_ne	mov	local06, local09
 if_ne	getbyte	local06, local06, #0
	add	ptr___system__dat__, #4
	wrlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___rxraw_ret
	ret

__system___getus
	getct	result2 wc
	getct	_var01
	add	ptr___system__dat__, #16
	rdlong	_var02, ptr___system__dat__ wz
	sub	ptr___system__dat__, #16
 if_ne	jmp	#LR__0310
	rdlong	_var02, #20
	qdiv	_var02, ##1000000
	add	ptr___system__dat__, #16
	getqx	result1
	mov	_var02, result1
	wrlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #16
LR__0310
	qdiv	result2, _var02
	getqy	result2
	setq	result2
	qdiv	_var01, _var02
	getqx	result1
__system___getus_ret
	ret

__system____builtin_memmove
	mov	_var01, arg01
	cmps	arg01, arg02 wc
 if_b	jmp	#LR__0320
	mov	_var02, arg02
	add	_var02, arg03
	cmps	arg01, _var02 wc
 if_b	jmp	#LR__0326
LR__0320
	mov	_var03, arg03
	shr	_var03, #2 wz
 if_e	jmp	#LR__0325
	callpa	#(@LR__0323-@LR__0321)>>2,fcache_load_ptr_
LR__0321
	rep	@LR__0324, _var03
LR__0322
	rdlong	_var03, arg02
	wrlong	_var03, arg01
	add	arg01, #4
	add	arg02, #4
LR__0323
LR__0324
LR__0325
	test	arg03, #2 wz
 if_ne	rdword	_var02, arg02
 if_ne	wrword	_var02, arg01
 if_ne	add	arg01, #2
 if_ne	add	arg02, #2
	test	arg03, #1 wz
 if_ne	rdbyte	_var02, arg02
 if_ne	wrbyte	_var02, arg01
	jmp	#LR__0332
LR__0326
	add	arg01, arg03
	add	arg02, arg03
	mov	_var04, arg03 wz
 if_e	jmp	#LR__0331
	callpa	#(@LR__0329-@LR__0327)>>2,fcache_load_ptr_
LR__0327
	rep	@LR__0330, _var04
LR__0328
	sub	arg01, #1
	sub	arg02, #1
	rdbyte	_var02, arg02
	wrbyte	_var02, arg01
LR__0329
LR__0330
LR__0331
LR__0332
	mov	result1, _var01
__system____builtin_memmove_ret
	ret

__system____builtin_strcpy
	mov	_var01, arg01
	callpa	#(@LR__0341-@LR__0340)>>2,fcache_load_ptr_
LR__0340
	rdbyte	result1, arg02 wz
	wrbyte	result1, arg01
	add	arg02, #1
	add	arg01, #1
 if_ne	jmp	#LR__0340
LR__0341
	mov	result1, _var01
__system____builtin_strcpy_ret
	ret

__system____topofstack
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	add	fp, #4
	wrlong	arg01, fp
	mov	result1, fp
	sub	fp, #4
	mov	ptra, fp
	call	#popregs_
__system____topofstack_ret
	ret

__system___lockmem
	mov	result1, #0
	cogid	result1
	add	result1, #256
LR__0350
	rdlong	_var01, arg01 wz
 if_e	wrlong	result1, arg01
 if_e	rdlong	_var01, arg01
 if_e	rdlong	_var01, arg01
	cmp	_var01, result1 wz
 if_ne	jmp	#LR__0350
__system___lockmem_ret
	ret

__system___tx
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	cmp	local01, #10 wz
 if_ne	jmp	#LR__0360
	add	ptr___system__dat__, #8
	rdlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	local02, #2 wz
 if_ne	mov	arg01, #13
 if_ne	call	#__system___txraw
LR__0360
	mov	arg01, local01
	call	#__system___txraw
	mov	ptra, fp
	call	#popregs_
__system___tx_ret
	ret

__system___rx
	mov	COUNT_, #1
	call	#pushregs_
LR__0370
	mov	arg01, #0
	call	#__system___rxraw
	mov	local01, result1
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__0370
	cmp	local01, #13 wz
 if_ne	jmp	#LR__0371
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	result1, #2 wz
 if_ne	mov	local01, #10
LR__0371
	add	ptr___system__dat__, #8
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	arg01, #1 wz
 if_e	jmp	#LR__0374
	cmp	local01, #127 wz
 if_ne	jmp	#LR__0372
	mov	arg01, #8
	call	#__system___tx
	jmp	#LR__0373
LR__0372
	mov	arg01, local01
	call	#__system___tx
LR__0373
LR__0374
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___rx_ret
	ret

__system___waitms
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__0381-@LR__0380)>>2,fcache_load_ptr_
LR__0380
	cmps	_var01, ##1000 wc
 if_b	jmp	#LR__0382
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000
	jmp	#LR__0380
LR__0381
LR__0382
	cmps	_var01, #1 wc
 if_b	jmp	#LR__0383
	qmul	_var01, _var03
	mov	arg03, ##1000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	arg01
	addct1	arg01, _var02
	waitct1
LR__0383
__system___waitms_ret
	ret

__system___waitus
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__0391-@LR__0390)>>2,fcache_load_ptr_
LR__0390
	cmps	_var01, ##1000000 wc
 if_b	jmp	#LR__0392
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000000
	jmp	#LR__0390
LR__0391
LR__0392
	cmps	_var01, #1 wc
 if_b	jmp	#LR__0393
	qmul	_var01, _var03
	mov	arg03, ##1000000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	result1
	addct1	_var02, result1
	waitct1
LR__0393
__system___waitus_ret
	ret

__system___mount
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	neg	local03, #1
 if_e	neg	result1, #1
 if_e	jmp	#LR__0415
	rdbyte	result1, local01
	cmp	result1, #47 wz
 if_ne	jmp	#LR__0402
	mov	arg01, local01
	mov	local04, arg01
	callpa	#(@LR__0401-@LR__0400)>>2,fcache_load_ptr_
LR__0400
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0400
LR__0401
	sub	local04, arg01
	mov	result1, local04
	cmps	result1, #16 wc
 if_b	jmp	#LR__0403
LR__0402
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__0415
LR__0403
	mov	local05, #0
LR__0404
	cmps	local05, #4 wc
 if_ae	jmp	#LR__0409
	mov	arg01, local05
	shl	arg01, #2
	mov	result1, ptr___system__dat__
	add	result1, #100
	add	arg01, result1
	rdlong	result1, arg01 wz
 if_e	cmps	local03, #0 wc
 if_c_and_z	mov	local03, local05
 if_c_and_z	jmp	#LR__0408
	mov	arg01, local05
	shl	arg01, #2
	mov	local04, ptr___system__dat__
	add	local04, #100
	add	arg01, local04
	rdlong	arg01, arg01
	mov	local04, arg01
	callpa	#(@LR__0406-@LR__0405)>>2,fcache_load_ptr_
LR__0405
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0405
LR__0406
	sub	local04, arg01
	mov	result1, local04
	mov	local06, result1
	mov	arg01, local06
	add	arg01, local01
	rdbyte	local04, arg01
	cmp	local04, #47 wz
 if_ne	mov	local07, local06
 if_ne	add	local07, local01
 if_ne	rdbyte	arg01, local07 wz
 if_ne	jmp	#LR__0407
	mov	local04, local05
	shl	local04, #2
	mov	arg03, ptr___system__dat__
	add	arg03, #100
	add	local04, arg03
	rdlong	arg02, local04
	mov	arg01, local01
	mov	arg03, local06
	call	#__system__strncmp
	cmp	result1, #0 wz
 if_e	mov	local03, local05
 if_e	jmp	#LR__0409
LR__0407
LR__0408
	add	local05, #1
	jmp	#LR__0404
LR__0409
	cmp	local03, ##-1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#11, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0415
	mov	local05, local03
	mov	local07, local05
	shl	local07, #2
	mov	local06, ptr___system__dat__
	add	local06, #116
	add	local07, local06
	rdlong	local06, local07 wz
 if_e	jmp	#LR__0410
	add	local06, #76
	rdlong	local07, local06 wz
	sub	local06, #76
 if_e	jmp	#LR__0410
	add	local06, #76
	rdlong	local07, local06
	mov	local04, local07
	zerox	local07, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	local06, local05
	shl	local06, #2
	mov	local03, ptr___system__dat__
	add	local03, #100
	add	local06, local03
	rdlong	arg01, local06
	mov	local06, objptr
	mov	objptr, local07
	call	local04
	mov	objptr, local06
LR__0410
	mov	local06, local05
	shl	local06, #2
	mov	local07, ptr___system__dat__
	add	local07, #116
	add	local06, local07
	wrlong	local02, local06
	cmp	local02, #0 wz
 if_ne	jmp	#LR__0411
	shl	local05, #2
	mov	local07, ptr___system__dat__
	add	local07, #100
	add	local05, local07
	wrlong	#0, local05
	jmp	#LR__0414
LR__0411
	mov	local08, local05
	shl	local08, #4
	mov	local07, ptr___system__dat__
	add	local07, #36
	add	local08, local07
	mov	arg01, local08
	mov	arg02, local01
	mov	arg03, #16
	call	#__system__strncpy
	add	local02, #72
	rdlong	local07, local02 wz
	sub	local02, #72
 if_e	jmp	#LR__0413
	add	local02, #72
	rdlong	local07, local02
	mov	local09, local07
	zerox	local07, #19
	shr	local09, #20
	shl	local09, #2
	add	local09, __methods__
	rdlong	local09, local09
	mov	arg01, local08
	mov	local06, objptr
	mov	objptr, local07
	call	local09
	mov	objptr, local06
	mov	arg01, result1 wz
 if_e	jmp	#LR__0412
	mov	local08, local05
	shl	local08, #2
	add	ptr___system__dat__, #116
	add	local08, ptr___system__dat__
	wrlong	#0, local08
	shl	local05, #2
	sub	ptr___system__dat__, #16
	add	local05, ptr___system__dat__
	wrlong	#0, local05
	neg	arg01, arg01 wz
	sub	ptr___system__dat__, #68
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__0415
LR__0412
LR__0413
	shl	local05, #2
	mov	local07, ptr___system__dat__
	add	local07, #100
	add	local05, local07
	wrlong	local08, local05
LR__0414
	mov	result1, #0
LR__0415
	mov	ptra, fp
	call	#popregs_
__system___mount_ret
	ret

__system___chdir
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #68
	mov	local01, arg01
	mov	arg02, fp
	add	arg02, #8
	mov	arg01, local01
	call	#__system__stat
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0422
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	and	arg01, ##61440
	cmp	arg01, ##4096 wz
 if_ne	add	ptr___system__dat__, #32
 if_ne	wrlong	#13, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__0422
	rdbyte	arg03, local01
	cmp	arg03, #47 wz
 if_ne	jmp	#LR__0420
	mov	arg01, ptr___system__dat__
	add	arg01, #132
	mov	arg02, local01
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__0421
LR__0420
	mov	local02, ptr___system__dat__
	add	local02, #388
	mov	arg02, ptr___system__dat__
	add	arg02, #132
	mov	arg01, local02
	mov	arg03, #256
	call	#__system__strncpy
	mov	arg03, ptr___system__dat__
	add	arg03, #132
	mov	arg01, local02
	mov	arg02, local01
	call	#__system____getvfsforfile
LR__0421
	mov	result1, #0
LR__0422
	mov	ptra, fp
	call	#popregs_
__system___chdir_ret
	ret

__system____getvfsforfile
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	callpa	#(@LR__0431-@LR__0430)>>2,fcache_load_ptr_
LR__0430
	rdbyte	result1, local02
	cmp	result1, #47 wz
 if_e	add	local02, #1
 if_e	rdbyte	local04, local02
 if_e	sub	local02, #1
 if_e	cmp	local04, #47 wz
 if_e	add	local02, #1
 if_e	jmp	#LR__0430
LR__0431
	rdbyte	local04, local02
	cmp	local04, #47 wz
 if_ne	jmp	#LR__0432
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__0434
LR__0432
	mov	arg02, ptr___system__dat__
	add	arg02, #132
	mov	arg01, local01
	mov	arg03, #256
	call	#__system__strncpy
	rdbyte	local04, local02 wz
 if_e	jmp	#LR__0433
	rdbyte	local04, local02
	cmp	local04, #46 wz
 if_e	add	local02, #1
 if_e	rdbyte	local05, local02
 if_e	sub	local02, #1
 if_e	mov	local06, local05
 if_e	zerox	local06, #7 wz
 if_e	jmp	#LR__0433
	rdbyte	local05, local01
	cmp	local05, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local04, local01
 if_e	sub	local01, #1
 if_e	cmps	local04, #0 wz
 if_ne	mov	arg02, ##@LR__2160
 if_ne	mov	arg01, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncat
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncat
LR__0433
LR__0434
	mov	arg01, local01
	call	#__system___normalizeName
	rdbyte	local04, local01 wz
 if_e	jmp	#LR__0435
	rdbyte	local04, local01
	cmp	local04, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #1
 if_e	cmps	local06, #0 wz
 if_ne	jmp	#LR__0436
LR__0435
	mov	result1, ptr___system__dat__
	add	result1, ##644
	jmp	#LR__0450
LR__0436
	mov	local07, #0
LR__0437
	cmps	local07, #4 wc
 if_ae	jmp	#LR__0449
	mov	local06, local07
	shl	local06, #2
	mov	local04, ptr___system__dat__
	add	local04, #100
	add	local06, local04
	rdlong	local06, local06 wz
 if_e	jmp	#LR__0448
	mov	local04, local07
	shl	local04, #2
	mov	local06, ptr___system__dat__
	add	local06, #100
	add	local04, local06
	rdlong	arg01, local04
	mov	local08, arg01
	callpa	#(@LR__0439-@LR__0438)>>2,fcache_load_ptr_
LR__0438
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0438
LR__0439
	sub	local08, arg01
	mov	local09, local08
	mov	local04, local09
	add	local04, local01
	rdbyte	local06, local04
	cmp	local06, #47 wz
 if_ne	mov	local10, local09
 if_ne	add	local10, local01
 if_ne	rdbyte	local05, local10 wz
 if_ne	jmp	#LR__0447
	mov	local04, local07
	shl	local04, #2
	mov	arg03, ptr___system__dat__
	add	arg03, #100
	add	local04, arg03
	rdlong	arg02, local04
	mov	arg03, local09
	mov	arg01, local01
	call	#__system__strncmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__0447
	mov	local11, local07
	shl	local11, #2
	mov	local04, ptr___system__dat__
	add	local04, #116
	add	local11, local04
	rdlong	local12, local11
	callpa	#(@LR__0441-@LR__0440)>>2,fcache_load_ptr_
LR__0440
	mov	local06, local09
	add	local06, #1
	add	local06, local01
	rdbyte	local11, local06
	cmp	local11, #46 wz
 if_ne	jmp	#LR__0442
	mov	local11, local09
	add	local11, #2
	add	local11, local01
	rdbyte	local10, local11
	cmp	local10, #47 wz
 if_ne	mov	local13, local09
 if_ne	add	local13, #2
 if_ne	add	local13, local01
 if_ne	rdbyte	local14, local13 wz
 if_e	add	local09, #1
 if_e	jmp	#LR__0440
LR__0441
LR__0442
	cmp	local03, #0 wz
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncpy
	mov	arg02, local01
	add	arg02, local09
	add	arg02, #1
	mov	arg01, local01
	call	#__system____builtin_strcpy
	mov	arg01, local01
	mov	local08, arg01
	callpa	#(@LR__0444-@LR__0443)>>2,fcache_load_ptr_
LR__0443
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0443
LR__0444
	sub	local08, arg01
	mov	local09, local08
LR__0445
	cmps	local09, #1 wc
 if_b	jmp	#LR__0446
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #47 wz
 if_e	mov	local11, local09
 if_e	add	local11, local01
 if_e	wrbyte	#0, local11
 if_e	sub	local09, #1
 if_e	jmp	#LR__0445
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #46 wz
 if_ne	jmp	#LR__0446
	cmps	local09, #2 wc
 if_b	jmp	#LR__0446
	mov	local14, local09
	sub	local14, #1
	add	local14, local01
	rdbyte	local05, local14
	cmp	local05, #47 wz
 if_ne	jmp	#LR__0446
	mov	local04, local09
	sub	local04, #1
	add	local04, local01
	wrbyte	#0, local04
	sub	local09, #2
	jmp	#LR__0445
LR__0446
	mov	result1, local12
	jmp	#LR__0450
LR__0447
LR__0448
	add	local07, #1
	jmp	#LR__0437
LR__0449
	add	ptr___system__dat__, ##1256
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##1256
LR__0450
	mov	ptra, fp
	call	#popregs_
__system____getvfsforfile_ret
	ret

__system___basic_open
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	mov	local04, #0
	call	#__system____getftab
	mov	local05, result1 wz
 if_ne	jmp	#LR__0460
	mov	arg01, abortchain
	mov	arg02, #12
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__0469
LR__0460
	add	local05, #8
	rdlong	result1, local05 wz
	sub	local05, #8
 if_ne	mov	arg01, local05
 if_ne	call	#__system___closeraw
	cmp	local01, #0 wz
 if_e	cmp	local02, #0 wz
 if_e	cmp	local03, #0 wz
 if_e	jmp	#LR__0462
	mov	arg01, #12
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_ne	jmp	#LR__0461
	mov	arg01, abortchain
	mov	arg02, #7
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__0469
LR__0461
	wrlong	#0, local04
	add	local04, #4
	wrlong	#0, local04
	sub	local04, #4
	wrlong	local04, local05
LR__0462
	cmp	local01, #0 wz
 if_e	jmp	#LR__0463
	wrlong	local01, local04
	mov	result1, local04
	bith	result1, #21
	add	local05, #28
	wrlong	result1, local05
	sub	local05, #28
	jmp	#LR__0464
LR__0463
	add	local05, #28
	wrlong	#0, local05
	sub	local05, #28
LR__0464
	cmp	local02, #0 wz
 if_e	jmp	#LR__0465
	add	local04, #4
	wrlong	local02, local04
	sub	local04, #4
	mov	result1, local04
	bith	result1, #52
	add	local05, #32
	wrlong	result1, local05
	sub	local05, #32
	jmp	#LR__0466
LR__0465
	add	local05, #32
	wrlong	#0, local05
	sub	local05, #32
LR__0466
	cmp	local03, #0 wz
 if_e	jmp	#LR__0467
	add	local04, #8
	wrlong	local03, local04
	sub	local04, #8
	bith	local04, #22
	add	local05, #36
	wrlong	local04, local05
	sub	local05, #36
	jmp	#LR__0468
LR__0467
	add	local05, #36
	wrlong	#0, local05
	sub	local05, #36
LR__0468
	add	local05, #8
	wrlong	##32771, local05
	mov	result1, #0
LR__0469
	mov	ptra, fp
	call	#popregs_
__system___basic_open_ret
	ret

__system___find_free_file
	mov	_var01, ptr___system__dat__
	add	_var01, ##736
	mov	_var02, #0
	callpa	#(@LR__0471-@LR__0470)>>2,fcache_load_ptr_
LR__0470
	cmps	_var02, #10 wc
 if_ae	jmp	#LR__0472
	qmul	_var02, #52
	getqx	result1
	add	result1, _var01
	add	result1, #8
	rdlong	result1, result1 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__0470
LR__0471
LR__0472
	cmp	_var02, #10 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#11, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_ne	mov	result1, _var02
__system___find_free_file_ret
	ret

__system___basic_print_char
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	call	#__system___gettxfunc
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0480
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local01
	mov	result1, #1
LR__0480
	mov	ptra, fp
	call	#popregs_
__system___basic_print_char_ret
	ret

__system___basic_print_string
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	call	#__system___gettxfunc
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0490
	cmp	local01, #0 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	call	#__system___fmtstr
LR__0490
	mov	ptra, fp
	call	#popregs_
__system___basic_print_string_ret
	ret

__system___fmtstr
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg04, local02, #0
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__0501-@LR__0500)>>2,fcache_load_ptr_
LR__0500
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0500
LR__0501
	sub	local04, arg01
	cmp	arg04, #0 wz
 if_ne	fles	local04, arg04 wcz
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #2
	call	#__system___fmtpad
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	mov	result1, local05
 if_b	jmp	#LR__0504
	cmps	local04, #1 wc
 if_b	jmp	#LR__0503
	mov	local06, local04
LR__0502
	mov	local07, local01
	mov	local08, local01
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	rdbyte	arg01, local03
	mov	local09, objptr
	mov	objptr, local07
	add	local03, #1
	call	local08
	mov	objptr, local09
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_b	jmp	#LR__0504
	add	local05, local09
	djnz	local06, #LR__0502
LR__0503
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #1
	call	#__system___fmtpad
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_ae	add	local05, local09
 if_ae	mov	result1, local05
LR__0504
	mov	ptra, fp
	call	#popregs_
__system___fmtstr_ret
	ret

__system___fmtfloat
	mov	COUNT_, #41
	call	#pushregs_
	add	ptra, #292
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, #10
	mov	local06, #0
	mov	local07, #0
	mov	local08, #2
	mov	local09, #0
	mov	local10, #0
	mov	local11, #0
	mov	local12, fp
	add	local12, #200
	mov	local13, local12
	mov	local14, local02
	shr	local14, #16
	and	local14, #63 wz
	mov	local15, local02
	shr	local15, #28
	and	local15, #1
 if_ne	jmp	#LR__0510
	cmp	local04, #97 wz
 if_e	mov	local14, #13
 if_e	mov	local07, #1
 if_e	jmp	#LR__0511
	mov	local14, #6
	jmp	#LR__0511
LR__0510
	sub	local14, #1
LR__0511
	mov	local16, local02
	shr	local16, #22
	and	local16, #3
	mov	local17, local02
	shr	local17, #29
	and	local17, #1
	getbyte	local18, local02, #1
	getbyte	local19, local02, #0
	cmp	local04, #101 wz
	wrz	local20
	mov	local21, local20
	cmp	local17, #0 wz
 if_ne	mov	local20, #69
 if_e	mov	local20, #101
	mov	local22, local20
	cmp	local04, #97 wz
 if_ne	jmp	#LR__0512
	mov	local21, #1
	cmp	local17, #0 wz
 if_ne	mov	local20, #80
 if_e	mov	local20, #112
	mov	local22, local20
	mov	local05, #2
	mov	local08, #1
	cmp	local17, #0 wz
 if_ne	mov	local20, #88
 if_e	mov	local20, #120
	mov	local09, local20
LR__0512
	cmp	local04, #35 wz
 if_ne	jmp	#LR__0513
	mov	local10, #1
	cmp	local15, #0 wz
 if_ne	mov	local04, #102
 if_ne	mov	local15, #0
 if_e	mov	local15, #1
LR__0513
	mov	local23, local02
	shr	local23, #26
	and	local23, #3
	mov	result1, local03
	shr	result1, #31 wz
 if_ne	mov	local06, #45
 if_ne	bitnot	local03, #31
 if_ne	jmp	#LR__0515
	cmp	local23, #1 wz
 if_e	mov	local06, #43
 if_e	jmp	#LR__0514
	cmp	local23, #2 wz
 if_e	mov	local06, #32
LR__0514
LR__0515
	mov	local24, local02
	shr	local24, #24
	and	local24, #3
	mov	local20, #0
	cmp	local06, #0 wz
 if_e	cmp	local05, #10 wz
 if_ne	mov	local20, #1
	mov	local25, local20 wz
 if_e	jmp	#LR__0517
	cmp	local24, #2 wz
 if_ne	jmp	#LR__0517
	cmp	local16, #2 wz
 if_e	jmp	#LR__0517
	mov	arg02, local06
	mov	local26, local09
	mov	arg01, local12
	mov	arg03, local26
	call	#__system__emitsign_0095
	mov	local27, result1
	cmps	local27, #0 wc
 if_b	mov	result1, local27
 if_b	jmp	#LR__0560
	mov	local28, local27
	add	local12, local27
	cmp	local18, #0 wz
 if_e	jmp	#LR__0516
	sub	local18, local27
	fges	local18, #0 wc
	bitl	local02, #232
	mov	local28, local18
	shl	local28, #8
	or	local02, local28
LR__0516
	mov	local25, #0
LR__0517
	mov	arg01, local03
	call	#__system____builtin_ilogb
	cmp	result1, ##2147483647 wz
 if_ne	jmp	#LR__0518
	cmp	local06, #0 wz
 if_ne	mov	local20, local12
 if_ne	add	local12, #1
 if_ne	wrbyte	local06, local20
	mov	arg02, ##@LR__2161
	mov	arg01, local12
	call	#__system____builtin_strcpy
	jmp	#LR__0550
LR__0518
	mov	arg01, local03
	call	#__system____builtin_ilogb
	mov	local20, result1
	cmp	local20, ##-2147483648 wz
 if_ne	jmp	#LR__0519
	cmp	local06, #0 wz
 if_ne	mov	local20, local12
 if_ne	add	local12, #1
 if_ne	wrbyte	local06, local20
	mov	arg01, local12
	mov	arg02, ##@LR__2162
	call	#__system____builtin_strcpy
	jmp	#LR__0550
LR__0519
	cmp	local04, #103 wz
 if_ne	cmp	local04, #35 wz
 if_ne	jmp	#LR__0524
	add	fp, #20
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	sub	fp, #32
	mov	arg04, local14
	mov	arg05, local05
	mov	arg01, local03
	call	#__system__disassemble_0093
	cmp	local04, #35 wz
 if_ne	jmp	#LR__0521
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, local14 wcz
 if_a	mov	local21, #1
 if_a	jmp	#LR__0527
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, #0 wc
 if_ae	jmp	#LR__0520
	neg	local20, local14
	add	fp, #32
	rdlong	local28, fp
	sub	fp, #32
	cmps	local28, local20 wcz
 if_be	mov	local21, #1
	jmp	#LR__0527
LR__0520
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, #1 wc
 if_ae	add	fp, #32
 if_ae	rdlong	local28, fp
 if_ae	sub	fp, #32
 if_ae	sub	local14, local28
	jmp	#LR__0527
LR__0521
	mov	local07, #0
	testbn	local02, #28 wz
 if_e	mov	local07, #1
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, local14 wc
 if_ae	jmp	#LR__0522
	add	fp, #32
	rdlong	local26, fp
	sub	fp, #32
	cmps	local26, ##-4 wc
 if_ae	jmp	#LR__0523
LR__0522
	mov	local21, #1
	jmp	#LR__0527
LR__0523
	add	fp, #32
	rdlong	local28, fp
	sub	local14, local28
	sub	fp, #12
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	sub	fp, #32
	neg	arg04, local14
	mov	arg01, local03
	mov	arg05, local05
	call	#__system__disassemble_0093
	jmp	#LR__0527
LR__0524
	cmp	local21, #0 wz
 if_e	jmp	#LR__0525
	add	fp, #20
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	sub	fp, #32
	mov	arg01, local03
	mov	arg04, local14
	mov	arg05, local05
	call	#__system__disassemble_0093
	jmp	#LR__0526
LR__0525
	add	fp, #20
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	sub	fp, #32
	mov	local28, local14
	add	local28, #1
	neg	arg04, local28
	mov	arg01, local03
	mov	arg05, local05
	call	#__system__disassemble_0093
LR__0526
LR__0527
	cmp	local05, #2 wz
 if_ne	jmp	#LR__0530
	mov	local05, #16
LR__0528
	add	fp, #20
	rdlong	local20, fp wz
	sub	fp, #20
 if_e	jmp	#LR__0529
	add	fp, #20
	rdlong	local26, fp
	sub	fp, #20
	cmp	local26, ##16777216 wc
 if_ae	jmp	#LR__0529
	add	fp, #20
	rdlong	local20, fp
	shl	local20, #1
	wrlong	local20, fp
	sub	fp, #20
	jmp	#LR__0528
LR__0529
LR__0530
	add	fp, #112
	mov	arg01, fp
	sub	fp, #92
	rdlong	arg02, fp
	sub	fp, #20
	mov	arg03, local05
	mov	arg04, #1
	mov	arg05, local17
	call	#__system___uitoa
	mov	local29, result1
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, #0 wc
 if_ae	jmp	#LR__0531
	mov	local11, #45
	add	fp, #176
	mov	arg01, fp
	sub	fp, #144
	rdlong	local26, fp
	sub	fp, #32
	neg	local28, local26
	mov	local26, #10
	mov	local30, local08
	mov	local31, local17
	mov	arg02, local28
	mov	arg03, #10
	mov	arg04, local30
	mov	arg05, local31
	call	#__system___uitoa
	mov	local32, result1
	jmp	#LR__0532
LR__0531
	mov	local11, #43
	add	fp, #176
	mov	arg01, fp
	sub	fp, #144
	rdlong	local28, fp
	sub	fp, #32
	mov	local26, #10
	mov	local30, local08
	mov	local31, local17
	mov	arg02, local28
	mov	arg03, #10
	mov	arg04, local30
	mov	arg05, local31
	call	#__system___uitoa
	mov	local32, result1
LR__0532
	cmp	local21, #0 wz
 if_ne	mov	local33, #0
 if_ne	mov	local34, #0
 if_ne	mov	local35, local14
 if_ne	add	local35, #1
 if_ne	jmp	#LR__0535
	add	fp, #32
	rdlong	local28, fp
	sub	fp, #32
	cmps	local28, #0 wc
 if_ae	jmp	#LR__0533
	add	fp, #32
	rdlong	local28, fp
	mov	local33, local28
	mov	local34, local33
	sub	fp, #32
	mov	local35, local28
	add	local35, local14
	add	local35, #1
	jmp	#LR__0534
LR__0533
	mov	local34, #0
	add	fp, #32
	rdlong	local33, fp
	sub	fp, #32
	mov	local35, local33
	add	local35, local14
	add	local35, #1
LR__0534
LR__0535
	mov	local20, local35
	sub	local20, local34
	add	local20, #1
	mov	local36, local20
	cmp	local06, #0 wz
 if_ne	mov	local20, local36
 if_ne	mov	local28, local36
 if_ne	add	local28, #1
 if_ne	mov	local36, local28
	cmp	local05, #16 wz
 if_e	add	local36, #2
	cmp	local21, #0 wz
 if_ne	mov	local28, #2
 if_ne	add	local28, local32
 if_ne	add	local36, local28
	cmps	local36, #65 wc
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__0560
	cmp	local25, #0 wz
 if_e	jmp	#LR__0536
	mov	arg02, local06
	mov	arg01, local12
	mov	arg03, local09
	call	#__system__emitsign_0095
	mov	local37, result1
	cmps	local37, #0 wc
 if_b	mov	result1, local37
 if_b	jmp	#LR__0560
	mov	local28, local37
	add	local12, local37
LR__0536
	mov	local38, local34
	callpa	#(@LR__0541-@LR__0537)>>2,fcache_load_ptr_
LR__0537
	cmps	local38, local35 wc
 if_ae	jmp	#LR__0542
	cmps	local38, #0 wc
 if_b	jmp	#LR__0538
	cmps	local38, local29 wc
 if_ae	jmp	#LR__0538
	mov	local20, local12
	mov	local26, local38
	mov	local30, fp
	add	local30, #112
	add	local26, local30
	rdbyte	local31, local26
	wrbyte	local31, local20
	add	local12, #1
	jmp	#LR__0539
LR__0538
	mov	local20, local12
	mov	local26, #48
	wrbyte	#48, local20
	add	local12, #1
LR__0539
	cmp	local38, local33 wz
 if_ne	jmp	#LR__0540
	cmp	local15, #0 wz
 if_e	mov	local20, local35
 if_e	sub	local20, #1
 if_e	cmps	local38, local20 wc
 if_c_or_nz	mov	local20, local12
 if_c_or_nz	mov	local26, #46
 if_c_or_nz	wrbyte	#46, local20
 if_c_or_nz	add	local12, #1
LR__0540
	mov	local28, local38
	add	local28, #1
	mov	local38, local28
	jmp	#LR__0537
LR__0541
LR__0542
	cmp	local07, #0 wz
 if_e	jmp	#LR__0546
	sub	local12, #1
	callpa	#(@LR__0544-@LR__0543)>>2,fcache_load_ptr_
LR__0543
	cmps	local12, local13 wcz
 if_be	jmp	#LR__0545
	rdbyte	local20, local12
	cmp	local20, #48 wz
 if_e	sub	local12, #1
 if_e	jmp	#LR__0543
LR__0544
LR__0545
	rdbyte	local20, local12
	cmp	local20, #46 wz
 if_e	sub	local12, #1
	add	local12, #1
LR__0546
	cmp	local21, #0 wz
 if_e	jmp	#LR__0549
	wrbyte	local22, local12
	add	local12, #1
	wrbyte	local11, local12
	mov	local38, #0
	add	local12, #1
LR__0547
	cmps	local38, local32 wc
 if_ae	jmp	#LR__0548
	mov	local26, local38
	mov	local30, fp
	add	local30, #176
	add	local26, local30
	rdbyte	local31, local26
	wrbyte	local31, local12
	add	local38, #1
	add	local12, #1
	jmp	#LR__0547
LR__0548
LR__0549
	wrbyte	#0, local12
LR__0550
	cmp	local19, #0 wz
 if_ne	cmp	local10, #0 wz
 if_e	jmp	#LR__0559
	mov	arg01, local13
	mov	local39, arg01
	callpa	#(@LR__0552-@LR__0551)>>2,fcache_load_ptr_
LR__0551
	rdbyte	result1, local39 wz
 if_ne	add	local39, #1
 if_ne	jmp	#LR__0551
LR__0552
	sub	local39, arg01
	cmps	local39, local19 wcz
 if_be	jmp	#LR__0559
	mov	local40, local13
	cmp	local21, #0 wz
 if_ne	mov	local14, #0
 if_ne	mov	local41, local19
 if_e	sub	local19, #1
 if_e	sub	local19, local14
 if_e	mov	local41, local19
	cmp	local41, #0 wz
 if_e	jmp	#LR__0555
	callpa	#(@LR__0554-@LR__0553)>>2,fcache_load_ptr_
LR__0553
	wrbyte	#42, local40
	sub	local41, #1 wz
	add	local40, #1
 if_ne	jmp	#LR__0553
LR__0554
LR__0555
	cmp	local14, #0 wz
 if_e	jmp	#LR__0558
	mov	local20, local40
	wrbyte	#46, local20
	mov	local41, #0
	add	local40, #1
	callpa	#(@LR__0557-@LR__0556)>>2,fcache_load_ptr_
LR__0556
	cmps	local41, local14 wc
 if_b	mov	local20, local40
 if_b	add	local40, #1
 if_b	wrbyte	#42, local20
 if_b	add	local41, #1
 if_b	jmp	#LR__0556
LR__0557
LR__0558
	wrbyte	#0, local40
LR__0559
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local13
	call	#__system___fmtstr
LR__0560
	mov	ptra, fp
	call	#popregs_
__system___fmtfloat_ret
	ret

__system__str_S
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #16
	call	#__system___gc_alloc_managed
	mov	local02, result1 wz
 if_e	jmp	#LR__0570
	mov	arg01, ptra
	add	ptra, #8
	wrlong	local02, arg01
	add	arg01, #4
	wrlong	#0, arg01
	sub	arg01, #4
	bith	arg01, #84
	mov	arg02, #0
	mov	arg03, local01
	mov	arg04, #103
	call	#__system___fmtfloat
LR__0570
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system__str_S_ret
	ret

__system___int64_shl
	test	arg03, #32 wz
 if_ne	mov	arg02, arg01
 if_ne	mov	arg01, #0
	test	arg03, #31 wz
 if_e	jmp	#LR__0580
	shl	arg02, arg03
	mov	result1, arg01
	neg	result2, arg03
	shr	result1, result2
	or	arg02, result1
	shl	arg01, arg03
LR__0580
	mov	result2, arg02
	mov	result1, arg01
__system___int64_shl_ret
	ret

__system___int64_sar
	test	arg03, #32 wz
 if_ne	mov	arg01, arg02
 if_ne	sar	arg02, #31
	test	arg03, #31 wz
 if_e	jmp	#LR__0590
	shr	arg01, arg03
	mov	result1, arg02
	neg	result2, arg03
	shl	result1, result2
	or	arg01, result1
	sar	arg02, arg03
LR__0590
	mov	result2, arg02
	mov	result1, arg01
__system___int64_sar_ret
	ret

__system___usepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #20
	test	arg01, _var01 wz
 if_e	add	ptr___system__dat__, #24
 if_e	rdlong	_var02, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #24
 if_e	test	arg02, _var02 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___usepins_ret
	add	ptr___system__dat__, #20
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg01
	wrlong	_var02, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg02
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #24
	neg	result1, #1
__system___usepins_ret
	ret

__system___freepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg01
	wrlong	_var01, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg02
	wrlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #24
__system___freepins_ret
	ret

__system___float_fromuns
	mov	arg03, arg01 wz
 if_e	mov	result1, arg03
 if_e	jmp	#LR__0600
	encod	arg02, arg03 wc
 if_b	add	arg02, #1
	sub	arg02, #1
	mov	arg01, #31
	sub	arg01, arg02
	shl	arg03, arg01
	shr	arg03, #2
	mov	arg01, #0
	call	#__system___float_Pack
LR__0600
__system___float_fromuns_ret
	ret

__system___float_add
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	mov	local04, local01
	mov	local05, local04
	zerox	local05, #22
	mov	local06, local04
	shl	local06, #1
	shr	local06, #24
	shr	local04, #31
	mov	arg01, local02
	mov	result1, arg01
	mov	local07, result1
	mov	local08, local07
	zerox	local08, #22
	mov	local09, local07
	shl	local09, #1
	shr	local09, #24
	mov	local10, local09
	shr	local07, #31
	mov	local11, #0
	mov	local12, #0
	cmp	local06, local10 wc
 if_ae	cmp	local06, local10 wz
 if_a	jmp	#LR__0610
 if_ae	cmp	local05, local08 wc
 if_ae	jmp	#LR__0610
	mov	local13, local05
	mov	local05, local08
	mov	local08, local13
	mov	local13, local06
	mov	local06, local10
	mov	local10, local13
	mov	local13, local04
	mov	local04, local07
	mov	local07, local13
LR__0610
	cmp	local06, #255 wz
 if_e	jmp	#LR__0625
	cmp	local06, #0 wz
 if_e	jmp	#LR__0627
	bith	local05, #23
LR__0611
	cmp	local10, #0 wz
 if_e	jmp	#LR__0631
	bith	local08, #23
LR__0612
	sub	local06, #127
	sub	local10, #127
	mov	local14, local06
	sub	local14, local10
	callpa	#(@LR__0614-@LR__0613)>>2,fcache_load_ptr_
LR__0613
	cmps	local14, #32 wc
 if_b	jmp	#LR__0615
	mov	local09, local08
	cmp	local11, #0 wz
	wrnz	local11
	or	local09, local11
	mov	local11, local09
	mov	local08, #0
	sub	local14, #32
	jmp	#LR__0613
LR__0614
LR__0615
	cmp	local14, #0 wz
 if_e	jmp	#LR__0616
	mov	local13, local08
	mov	local10, #32
	sub	local10, local14
	shl	local13, local10
	mov	local10, local11
	mov	local09, #32
	sub	local09, local14
	shl	local10, local09 wz
	shr	local11, local14
	shr	local08, local14
	or	local11, local13
	mov	local15, #0
 if_ne	mov	local15, #1
	or	local11, local15
LR__0616
	mov	local15, local04
	xor	local15, local07
	test	local15, #1 wz
 if_e	jmp	#LR__0617
	not	local08, local08
	not	local11, local11
	add	local11, #1 wz
	mov	local15, #0
 if_e	mov	local15, #1
	add	local08, local15
LR__0617
	add	local12, local11 wc
	addx	local05, local08
	cmps	local05, #0 wc
 if_ae	jmp	#LR__0618
	xor	local04, #1
	not	local05, local05
	not	local12, local12
	add	local12, #1 wz
	mov	local15, #0
 if_e	mov	local15, #1
	add	local05, local15
LR__0618
	cmp	local05, ##16777216 wc
 if_b	jmp	#LR__0619
	add	local06, #1
	mov	local14, local12
	and	local14, #1
	shr	local12, #1
	mov	local15, local05
	shl	local15, #31
	or	local12, local15
	or	local12, local14
	shr	local05, #1
	jmp	#LR__0624
LR__0619
	cmp	local05, ##8388608 wc
 if_ae	jmp	#LR__0623
	cmp	local05, #0 wz
 if_e	cmp	local12, #0 wz
 if_e	or	local04, #8
 if_e	andn	local04, #1
 if_e	jmp	#LR__0622
LR__0620
	cmp	local05, ##8388608 wc
 if_ae	jmp	#LR__0621
	add	local12, local12 wc
	addx	local05, local05
	sub	local06, #1
	jmp	#LR__0620
LR__0621
LR__0622
LR__0623
LR__0624
	mov	arg01, local05
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	call	#__system__pack_0176
	jmp	#LR__0635
LR__0625
	cmp	local10, #255 wz
 if_ne	jmp	#LR__0626
	cmp	local07, local04 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__0635
LR__0626
	cmp	local05, #0 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__0635
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	or	arg04, #2
	mov	arg01, local05
	call	#__system__pack_0176
	jmp	#LR__0635
LR__0627
	cmp	local05, #0 wz
 if_e	jmp	#LR__0630
	shl	local05, #1
	callpa	#(@LR__0629-@LR__0628)>>2,fcache_load_ptr_
LR__0628
	cmp	local05, ##8388608 wc
 if_b	mov	local15, local06
 if_b	sub	local15, #1
 if_b	mov	local06, local15
 if_b	shl	local05, #1
 if_b	jmp	#LR__0628
LR__0629
	jmp	#LR__0611
LR__0630
	and	local04, local07
	mov	arg04, local04
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0176
	jmp	#LR__0635
LR__0631
	cmp	local08, #0 wz
 if_e	jmp	#LR__0634
	shl	local08, #1
	callpa	#(@LR__0633-@LR__0632)>>2,fcache_load_ptr_
LR__0632
	cmp	local08, ##8388608 wc
 if_b	mov	local15, local10
 if_b	sub	local15, #1
 if_b	mov	local10, local15
 if_b	shl	local08, #1
 if_b	jmp	#LR__0632
LR__0633
	jmp	#LR__0612
LR__0634
	sub	local06, #127
	mov	arg01, local05
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	call	#__system__pack_0176
LR__0635
	mov	ptra, fp
	call	#popregs_
__system___float_add_ret
	ret

__system___float_mul
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, local01
	mov	local04, local03
	zerox	local04, #22
	mov	local05, local03
	shl	local05, #1
	shr	local05, #24
	shr	local03, #31
	mov	result1, local02
	mov	local06, result1
	mov	local07, local06
	zerox	local07, #22
	mov	local08, local06
	shl	local08, #1
	shr	local08, #24
	shr	local06, #31
	xor	local03, local06
	cmp	local05, #255 wz
 if_e	jmp	#LR__0643
	cmp	local08, #255 wz
 if_e	jmp	#LR__0645
	cmp	local05, #0 wz
 if_e	jmp	#LR__0646
	bith	local04, #23
LR__0640
	cmp	local08, #0 wz
 if_e	jmp	#LR__0650
	bith	local07, #23
LR__0641
	mov	local02, local04
	shl	local02, #4
	mov	local06, local07
	shl	local06, #5
	qmul	local02, local06
	add	local05, local08
	sub	local05, #254
	mov	local09, local05
	shl	local04, #4
	shl	local07, #5
	getqx	local10
	qmul	local04, local07
	getqy	local11
	cmp	local11, ##16777216 wc
 if_b	jmp	#LR__0642
	add	local09, #1
	shr	local10, #1
	mov	local08, local11
	shl	local08, #31
	or	local10, local08
	shr	local11, #1
LR__0642
	mov	arg01, local11
	mov	arg02, local10
	mov	arg03, local09
	mov	arg04, local03
	call	#__system__pack_0176
	jmp	#LR__0654
LR__0643
	cmp	local04, #0 wz
 if_ne	mov	result1, local01
 if_ne	jmp	#LR__0654
	cmps	local08, #255 wc
 if_b	cmp	local08, #0 wz
 if_c_and_z	cmp	local07, #0 wz
 if_c_and_nz	jmp	#LR__0644
 if_b	mov	result1, ##2146435072
 if_b	jmp	#LR__0654
	cmp	local07, #0 wz
 if_ne	mov	result1, local02
 if_ne	jmp	#LR__0654
LR__0644
	or	local03, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, local05
	mov	arg04, local03
	call	#__system__pack_0176
	jmp	#LR__0654
LR__0645
	cmp	local05, #0 wz
 if_e	cmp	local04, #0 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__0654
	cmp	local07, #0 wz
 if_ne	mov	result1, local02
 if_ne	jmp	#LR__0654
	mov	arg03, local08
	mov	arg04, local03
	or	arg04, #2
	mov	arg01, #0
	mov	arg02, #0
	call	#__system__pack_0176
	jmp	#LR__0654
LR__0646
	cmp	local04, #0 wz
 if_e	jmp	#LR__0649
	shl	local04, #1
	callpa	#(@LR__0648-@LR__0647)>>2,fcache_load_ptr_
LR__0647
	cmp	local04, ##8388608 wc
 if_b	sub	local05, #1
 if_b	shl	local04, #1
 if_b	jmp	#LR__0647
LR__0648
	jmp	#LR__0640
LR__0649
	or	local03, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local03
	call	#__system__pack_0176
	jmp	#LR__0654
LR__0650
	cmp	local07, #0 wz
 if_e	jmp	#LR__0653
	shl	local07, #1
	callpa	#(@LR__0652-@LR__0651)>>2,fcache_load_ptr_
LR__0651
	cmp	local07, ##8388608 wc
 if_b	sub	local08, #1
 if_b	shl	local07, #1
 if_b	jmp	#LR__0651
LR__0652
	jmp	#LR__0641
LR__0653
	or	local03, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local03
	call	#__system__pack_0176
LR__0654
	mov	ptra, fp
	call	#popregs_
__system___float_mul_ret
	ret

__system___float_div
	mov	COUNT_, #14
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, local03
	mov	local06, local05
	zerox	local06, #22
	mov	local07, local05
	shl	local07, #1
	shr	local07, #24
	shr	local05, #31
	mov	result1, local04
	mov	local08, result1
	mov	local09, local08
	zerox	local09, #22
	mov	local10, local08
	shl	local10, #1
	shr	local10, #24
	shr	local08, #31
	xor	local05, local08
	cmp	local07, #255 wz
 if_e	jmp	#LR__0665
	cmp	local10, #255 wz
 if_e	jmp	#LR__0666
	cmp	local07, #0 wz
 if_e	jmp	#LR__0667
	bith	local06, #23
LR__0660
	cmp	local10, #0 wz
 if_e	jmp	#LR__0671
	bith	local09, #23
LR__0661
	sub	local07, local10
	mov	local11, local07
	mov	arg01, local06
	shr	arg01, #2
	shl	local06, #30
	mov	arg02, local06
	mov	arg03, local09
	setq	arg01
	qdiv	arg02, arg03
	mov	local12, #0
	getqx	local01
	getqy	result2
	mov	local02, result2
	mov	local13, local01
	cmps	local02, #0 wz
	mov	local14, local13
	shl	local14, #25
 if_ne	mov	local12, #1
	or	local14, local12
	shr	local13, #7
	cmp	local13, ##16777216 wc
 if_b	jmp	#LR__0662
	add	local11, #1
	shr	local14, #1
	mov	local12, local13
	shl	local12, #31
	or	local14, local12
	shr	local13, #1
	jmp	#LR__0664
LR__0662
	cmp	local13, ##8388608 wc
 if_ae	jmp	#LR__0663
	sub	local11, #1
	shl	local13, #1
	mov	local12, local14
	shr	local12, #31
	or	local13, local12
	shl	local14, #1
LR__0663
LR__0664
	mov	arg01, local13
	mov	arg02, local14
	mov	arg03, local11
	mov	arg04, local05
	call	#__system__pack_0176
	jmp	#LR__0675
LR__0665
	cmp	local06, #0 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__0675
	cmp	local10, #255 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__0675
	or	local05, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, local07
	mov	arg04, local05
	call	#__system__pack_0176
	jmp	#LR__0675
LR__0666
	cmp	local09, #0 wz
 if_ne	mov	result1, local04
 if_ne	jmp	#LR__0675
	mov	arg04, local05
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0176
	jmp	#LR__0675
LR__0667
	cmp	local06, #0 wz
 if_e	jmp	#LR__0670
	shl	local06, #1
	callpa	#(@LR__0669-@LR__0668)>>2,fcache_load_ptr_
LR__0668
	cmp	local06, ##8388608 wc
 if_b	sub	local07, #1
 if_b	shl	local06, #1
 if_b	jmp	#LR__0668
LR__0669
	jmp	#LR__0660
LR__0670
	cmp	local10, #0 wz
 if_e	cmp	local09, #0 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__0675
	mov	arg04, local05
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0176
	jmp	#LR__0675
LR__0671
	cmp	local09, #0 wz
 if_e	jmp	#LR__0674
	shl	local09, #1
	callpa	#(@LR__0673-@LR__0672)>>2,fcache_load_ptr_
LR__0672
	cmp	local09, ##8388608 wc
 if_b	sub	local10, #1
 if_b	shl	local09, #1
 if_b	jmp	#LR__0672
LR__0673
	jmp	#LR__0661
LR__0674
	or	local05, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local05
	call	#__system__pack_0176
LR__0675
	mov	ptra, fp
	call	#popregs_
__system___float_div_ret
	ret

__system___float_cmp
	cmps	arg01, ##2139095041 wc
 if_b	cmps	arg02, ##2139095041 wc
 if_ae	mov	result1, arg03
 if_ae	jmp	#__system___float_cmp_ret
	cmp	arg01, ##-8388607 wc
 if_b	cmp	arg01, ##-8388607 wc
 if_ae	mov	result1, arg03
 if_ae	jmp	#__system___float_cmp_ret
	cmps	arg01, #0 wc
 if_ae	jmp	#LR__0680
	cmps	arg02, #0 wc
 if_b	mov	result1, arg02
 if_b	sub	result1, arg01
 if_b	jmp	#__system___float_cmp_ret
	cmp	arg02, #0 wz
 if_e	cmp	arg01, ##-2147483648 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system___float_cmp_ret
	neg	result1, #1
	jmp	#__system___float_cmp_ret
LR__0680
	cmps	arg02, #0 wc
 if_ae	jmp	#LR__0681
	cmp	arg01, #0 wz
 if_e	cmp	arg02, ##-2147483648 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system___float_cmp_ret
	mov	result1, #1
	jmp	#__system___float_cmp_ret
LR__0681
	sub	arg01, arg02
	mov	result1, arg01
__system___float_cmp_ret
	ret

__system___float_tointeger
	mov	COUNT_, #2
	call	#pushregs_
	call	#__system___float_Unpack
	mov	local01, result1
	cmps	result2, #31 wc
 if_ae	cmp	local01, #0 wz
 if_a	decod	local02, #31
 if_nc_and_z	bmask	local02, #30
 if_ae	mov	result3, local02
 if_ae	jmp	#LR__0691
	cmps	result2, ##-1 wc
 if_b	mov	result3, #0
 if_b	jmp	#LR__0690
	shl	result3, #2
	mov	local02, #30
	sub	local02, result2
	shr	result3, local02
	add	result3, arg02
	shr	result3, #1
	cmp	local01, #0 wz
 if_ne	neg	result3, result3
LR__0690
LR__0691
	mov	result1, result3
	mov	ptra, fp
	call	#popregs_
__system___float_tointeger_ret
	ret

__system___float_Unpack
	mov	_var01, arg01
	shr	_var01, #31
	mov	_var02, arg01
	shl	_var02, #1
	shr	_var02, #24 wz
	bitl	arg01, #279
 if_ne	shl	arg01, #6
 if_ne	bith	arg01, #29
 if_ne	jmp	#LR__0700
	encod	_var03, arg01 wc
 if_b	add	_var03, #1
	sub	_var03, #23
	mov	_var02, _var03
	mov	result2, #7
	sub	result2, _var03
	shl	arg01, result2
LR__0700
	sub	_var02, #127
	mov	result3, arg01
	mov	result1, _var01
	mov	result2, _var02
__system___float_Unpack_ret
	ret

__system___float_Pack
	mov	_var01, #0
	cmp	arg03, #0 wz
 if_e	jmp	#LR__0711
	encod	_var02, arg03 wc
 if_b	add	_var02, #1
	mov	_var01, #33
	sub	_var01, _var02
	shl	arg03, _var01
	mov	_var02, #3
	sub	_var02, _var01
	add	arg02, _var02
	mov	_var03, arg02
	add	arg03, #256
	mov	_var02, arg03
	andn	_var02, #255 wz
 if_e	add	_var03, #1
	add	_var03, #127
	fges	_var03, ##-23
	fles	_var03, #255
	cmps	_var03, #1 wc
 if_ae	jmp	#LR__0710
	shr	arg03, #1
	decod	_var02, #31
	add	_var02, arg03
	neg	_var03, _var03
	shr	_var02, _var03
	mov	arg03, _var02
	mov	_var03, #0
LR__0710
	mov	result1, arg01
	shl	result1, #31
	mov	_var02, _var03
	shl	_var02, #23
	or	result1, _var02
	mov	_var04, arg03
	shr	_var04, #9
	or	result1, _var04
	jmp	#__system___float_Pack_ret
LR__0711
	mov	result1, _var01
__system___float_Pack_ret
	ret

__system___basic_print_float
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03 wz
	mov	local04, arg04
 if_ne	jmp	#LR__0720
	cmp	local04, #35 wz
 if_e	mov	local05, ##537198592
 if_ne	decod	local05, #29
	mov	local03, local05
LR__0720
	mov	arg01, local01
	call	#__system___gettxfunc
	mov	local05, result1 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local05
 if_ne	mov	arg02, local03
 if_ne	mov	arg03, local02
 if_ne	mov	arg04, local04
 if_ne	call	#__system___fmtfloat
	mov	ptra, fp
	call	#popregs_
__system___basic_print_float_ret
	ret

__system____builtin_ilogb
	call	#__system___float_Unpack
	cmp	result3, #0 wz
 if_e	mov	result1, ##-2147483647
 if_e	jmp	#LR__0731
	cmp	result2, #128 wz
 if_ne	jmp	#LR__0730
	cmp	result3, ##536870912 wz
 if_e	bmask	result1, #30
 if_e	jmp	#LR__0731
	decod	result1, #31
	jmp	#LR__0731
LR__0730
	mov	result1, result2
LR__0731
__system____builtin_ilogb_ret
	ret

__system___float_pow_n
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	cmps	local03, #0 wc
 if_ae	jmp	#LR__0740
	mov	local04, #1
	neg	local03, local03
	cmps	local03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__0748
	jmp	#LR__0741
LR__0740
	mov	local04, #0
LR__0741
	mov	local05, ##1065353216
LR__0742
	cmps	local03, #1 wc
 if_b	jmp	#LR__0744
	test	local03, #1 wz
 if_e	jmp	#LR__0743
	mov	arg01, local05
	mov	arg02, local02
	call	#__system___float_mul
	mov	local05, result1
LR__0743
	sar	local03, #1
	mov	arg01, local02
	mov	arg02, local02
	call	#__system___float_mul
	mov	local02, result1
	jmp	#LR__0742
LR__0744
	cmp	local04, #0 wz
 if_e	jmp	#LR__0745
	mov	arg01, local01
	mov	arg02, local05
	call	#__system___float_div
	mov	local05, result1
	jmp	#LR__0747
LR__0745
	mov	arg01, local01
	mov	arg02, ##1065353216
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0746
	mov	arg01, local01
	mov	arg02, local05
	call	#__system___float_mul
	mov	local05, result1
LR__0746
LR__0747
	mov	result1, local05
LR__0748
	mov	ptra, fp
	call	#popregs_
__system___float_pow_n_ret
	ret

__system___gc_ptrs
	mov	_var01, __heap_ptr
	mov	_var02, _var01
	add	_var02, ##95992
	rdlong	result2, _var01 wz
 if_ne	jmp	#LR__0750
	mov	result2, _var02
	sub	result2, _var01
	wrword	#1, _var01
	mov	result1, _var01
	add	result1, #2
	wrword	##27792, result1
	mov	result1, _var01
	add	result1, #4
	wrword	#0, result1
	mov	result1, _var01
	add	result1, #6
	wrword	#1, result1
	add	_var01, #16
	abs	result2, result2 wc
	shr	result2, #4
	negc	result2, result2
	wrword	result2, _var01
	mov	result2, _var01
	add	result2, #2
	wrword	##27791, result2
	mov	result2, _var01
	add	result2, #4
	wrword	#0, result2
	mov	result2, _var01
	add	result2, #6
	wrword	#0, result2
	sub	_var01, #16
LR__0750
	mov	result1, _var01
	mov	result2, _var02
__system___gc_ptrs_ret
	ret

__system___gc_tryalloc
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
	mov	local05, local03
	mov	local06, #0
	callpa	#(@LR__0761-@LR__0760)>>2,fcache_load_ptr_
LR__0760
	mov	local07, local05
	add	local05, #6
	rdword	arg02, local05 wz
	mov	arg01, local03
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local05, result1 wz
 if_ne	rdword	local06, local05
	cmp	local05, #0 wz
 if_ne	cmps	local05, local04 wc
 if_a	jmp	#LR__0762
 if_ne	cmps	local01, local06 wcz
 if_a	jmp	#LR__0760
LR__0761
LR__0762
	cmp	local05, #0 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__0765
	mov	result2, local05
	add	result2, #6
	rdword	local08, result2
	cmps	local01, local06 wc
 if_ae	jmp	#LR__0764
	wrword	local01, local05
	mov	arg01, local05
	mov	local08, local01
	shl	local08, #4
	add	arg01, local08
	sub	local06, local01
	wrword	local06, arg01
	mov	local08, arg01
	add	local08, #2
	wrword	##27791, local08
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, arg01
	add	local08, #4
	wrword	result1, local08
	mov	local08, local05
	add	local08, #6
	mov	arg02, arg01
	rdword	local08, local08
	add	arg02, #6
	wrword	local08, arg02
	mov	local09, arg01
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, result1
	rdword	local10, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local10, #4
 if_ne	add	arg01, local10
 if_ne	mov	result1, arg01
	mov	local11, result1 wz
 if_e	jmp	#LR__0763
	cmps	local11, local04 wc
 if_ae	jmp	#LR__0763
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local11, #4
	wrword	result1, local11
LR__0763
LR__0764
	add	local07, #6
	wrword	local08, local07
	mov	local09, ##27776
	or	local09, local02
	mov	result1, #0
	cogid	result1
	or	local09, result1
	mov	local11, local05
	add	local11, #2
	wrword	local09, local11
	mov	local09, local03
	add	local09, #8
	mov	local11, local05
	rdword	local09, local09
	add	local11, #6
	wrword	local09, local11
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local03, #8
	wrword	result1, local03
	add	local05, #8
	mov	result1, local05
LR__0765
	mov	ptra, fp
	call	#popregs_
__system___gc_tryalloc_ret
	ret

__system___gc_alloc_managed
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, #0
	call	#__system___gc_doalloc
	mov	arg02, result1 wz
 if_e	cmps	local01, #1 wc
 if_nc_and_z	mov	result1, #0
 if_c_or_nz	mov	result1, arg02
	mov	ptra, fp
	call	#popregs_
__system___gc_alloc_managed_ret
	ret

__system___gc_doalloc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
 if_e	mov	result1, #0
 if_e	jmp	#LR__0777
	add	local01, #23
	andn	local01, #15
	shr	local01, #4
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	call	#__system___lockmem
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1 wz
 if_ne	jmp	#LR__0770
	call	#__system___gc_docollect
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1
LR__0770
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	wrlong	#0, arg01
	cmp	local03, #0 wz
 if_e	jmp	#LR__0776
	shl	local01, #4
	sub	local01, #8
	abs	local04, local01 wc
	shr	local04, #2
	negc	local05, local04 wz
	mov	local06, local03
 if_e	jmp	#LR__0775
	callpa	#(@LR__0773-@LR__0771)>>2,fcache_load_ptr_
LR__0771
	rep	@LR__0774, local05
LR__0772
	wrlong	#0, local06
	add	local06, #4
LR__0773
LR__0774
LR__0775
LR__0776
	mov	result1, local03
LR__0777
	mov	ptra, fp
	call	#popregs_
__system___gc_doalloc_ret
	ret

__system___gc_isvalidptr
	bitl	arg03, #248
	sub	arg03, #8
	cmps	arg03, arg01 wc
 if_b	jmp	#LR__0780
	cmps	arg03, arg02 wc
 if_b	jmp	#LR__0781
LR__0780
	mov	result1, #0
	jmp	#__system___gc_isvalidptr_ret
LR__0781
	mov	_var01, arg03
	xor	_var01, arg01
	test	_var01, #15 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___gc_isvalidptr_ret
	mov	_var01, arg03
	add	_var01, #2
	rdword	_var01, _var01
	and	_var01, ##65472
	cmp	_var01, ##27776 wz
 if_ne	mov	result1, #0
 if_e	mov	result1, arg03
__system___gc_isvalidptr_ret
	ret

__system___gc_free
	mov	arg03, arg01
	call	#__system___gc_ptrs
	mov	arg01, result1
	mov	arg02, result2
	call	#__system___gc_isvalidptr
	mov	arg02, result1 wz
 if_e	jmp	#LR__0790
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	call	#__system___lockmem
	mov	arg01, arg02
	call	#__system___gc_dofree
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	wrlong	#0, arg01
LR__0790
__system___gc_free_ret
	ret

__system___gc_dofree
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	call	#__system___gc_ptrs
	mov	local02, result1
	mov	local03, result2
	mov	arg02, local01
	add	arg02, #2
	wrword	##27791, arg02
	mov	local04, local01
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	callpa	#(@LR__0801-@LR__0800)>>2,fcache_load_ptr_
LR__0800
	add	local04, #4
	rdword	arg02, local04 wz
	mov	arg01, local02
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_e	jmp	#LR__0802
	mov	arg01, local04
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__0800
LR__0801
LR__0802
	cmp	local04, #0 wz
 if_e	mov	local04, local02
	mov	arg02, local04
	add	arg02, #6
	mov	arg01, local01
	rdword	arg02, arg02
	add	arg01, #6
	wrword	arg02, arg01
	mov	arg02, local01 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local04
	add	arg02, #6
	wrword	result1, arg02
	cmp	local04, local02 wz
 if_e	jmp	#LR__0805
	mov	arg01, local04
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	cmp	result1, local01 wz
 if_ne	jmp	#LR__0804
	rdword	local06, local04
	rdword	arg02, local01
	add	local06, arg02
	wrword	local06, local04
	mov	local06, local01
	add	local06, #2
	wrword	#0, local06
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	cmps	local06, local03 wc
 if_ae	jmp	#LR__0803
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local06
	add	arg02, #4
	wrword	result1, arg02
LR__0803
	mov	arg02, local01
	add	arg02, #6
	mov	result2, local04
	rdword	arg02, arg02
	add	result2, #6
	wrword	arg02, result2
	add	local01, #6
	wrword	#0, local01
	mov	local01, local04
LR__0804
LR__0805
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	arg02, result1 wz
 if_e	jmp	#LR__0807
	cmps	arg02, local03 wc
 if_ae	jmp	#LR__0807
	mov	arg01, arg02
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__0807
	mov	local04, local01
	rdword	local06, local04
	mov	arg01, arg02
	rdword	local01, arg01
	add	local06, local01
	wrword	local06, local04
	mov	local06, arg01
	add	local06, #6
	mov	local01, local04
	rdword	local06, local06
	add	local01, #6
	wrword	local06, local01
	mov	local06, arg01
	add	local06, #2
	wrword	#170, local06
	mov	local06, arg01
	add	local06, #6
	wrword	#0, local06
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1 wz
 if_e	jmp	#LR__0806
	cmps	local06, local03 wc
 if_ae	jmp	#LR__0806
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local04, local06
	add	local04, #4
	wrword	result1, local04
LR__0806
LR__0807
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___gc_dofree_ret
	ret

__system___gc_docollect
	mov	COUNT_, #5
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result2
	mov	local02, result1
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
	mov	result1, #0
	cogid	result1
	mov	local05, result1
 if_e	jmp	#LR__0812
	callpa	#(@LR__0811-@LR__0810)>>2,fcache_load_ptr_
LR__0810
	cmps	local04, local01 wc
 if_ae	jmp	#LR__0812
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	andn	arg02, #32
	mov	arg01, local04
	add	arg01, #2
	wrword	arg02, arg01
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_ne	jmp	#LR__0810
LR__0811
LR__0812
	mov	local03, #0
	mov	arg01, #0
	call	#__system____topofstack
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___gc_markhub
	call	#__system___gc_markcog
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1 wz
 if_e	jmp	#LR__0816
LR__0813
	mov	local04, local02
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	test	arg02, #32 wz
 if_e	test	arg02, #16 wz
 if_ne	jmp	#LR__0815
	getnib	arg02, arg02, #0
	cmp	arg02, local05 wz
 if_ne	cmp	arg02, #14 wz
 if_ne	jmp	#LR__0814
	mov	arg01, local04
	call	#__system___gc_dofree
	mov	local02, result1
LR__0814
LR__0815
	cmp	local02, #0 wz
 if_ne	cmps	local02, local01 wc
 if_c_and_nz	jmp	#LR__0813
LR__0816
	mov	ptra, fp
	call	#popregs_
__system___gc_docollect_ret
	ret

__system___gc_markhub
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
LR__0820
	cmps	local01, local02 wc
 if_ae	jmp	#LR__0821
	rdlong	arg03, local01
	add	local01, #4
	mov	arg02, local04
	mov	arg01, local03
	call	#__system___gc_isvalidptr
	mov	arg03, result1 wz
 if_e	jmp	#LR__0820
	mov	arg01, arg03
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0820
	mov	result2, arg03
	add	result2, #2
	rdword	result2, result2
	andn	result2, #15
	or	result2, #46
	add	arg03, #2
	wrword	result2, arg03
	jmp	#LR__0820
LR__0821
	mov	ptra, fp
	call	#popregs_
__system___gc_markhub_ret
	ret

__system___gc_markcog
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result1
	mov	local02, result2
	mov	local03, #495
LR__0830
	'.live	local03
	alts	local03, #0
	mov	local04, local03
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local04
	call	#__system___gc_isvalidptr
	cmp	result1, #0 wz
 if_e	jmp	#LR__0831
	mov	local04, result1
	add	local04, #2
	rdword	local04, local04
	or	local04, #32
	add	result1, #2
	wrword	local04, result1
LR__0831
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__0830
	mov	ptra, fp
	call	#popregs_
__system___gc_markcog_ret
	ret

__system___get_vfs_file_handle
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system___find_free_file
	mov	local01, result1
	cmps	local01, #0 wc
 if_ae	qmul	local01, #52
 if_b	mov	result1, #0
 if_ae	mov	local01, ptr___system__dat__
 if_ae	add	local01, ##736
 if_ae	getqx	result1
 if_ae	add	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___get_vfs_file_handle_ret
	ret

__system___closeraw
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0842
	add	local01, #44
	rdlong	result1, local01 wz
	sub	local01, #44
 if_e	jmp	#LR__0840
	add	local01, #44
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #44
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
LR__0840
	add	local01, #36
	rdlong	local05, local01 wz
	sub	local01, #36
 if_e	jmp	#LR__0841
	add	local01, #36
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #36
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local02, result1
LR__0841
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	mov	result1, local02
LR__0842
	mov	ptra, fp
	call	#popregs_
__system___closeraw_ret
	ret

__system___vfs_open_fat_handle
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	mov	result1, #0
 if_e	jmp	#LR__0851
	mov	arg01, ##532
	call	#__system___gc_alloc_managed
	mov	local02, result1
	mov	arg01, ##564
	call	#__system___gc_alloc_managed
	mov	local03, objptr
	mov	objptr, local02
	add	objptr, ##528
	wrlong	local01, objptr
' #line 4 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/diskio.cc"
' 
' 
' vfs_file_t *fh;
' 
' DRESULT disk_sethandle(BYTE pdrv, vfs_file_t *fhandle) {
'     fh = fhandle;
'     return RES_OK;
	mov	arg02, ##@LR__2166
	mov	arg01, result1
	mov	arg03, #0
	mov	objptr, local02
	call	#_fatfs_cc_f_mount
	mov	objptr, local03
	mov	arg01, result1 wz
 if_e	jmp	#LR__0850
	neg	arg01, arg01 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__0851
LR__0850
	mov	arg01, local02
	mov	local03, objptr
	mov	objptr, local02
	call	#_fatfs_cc_get_vfs
	mov	objptr, local03
LR__0851
	mov	ptra, fp
	call	#popregs_
__system___vfs_open_fat_handle_ret
	ret

__system___vfs_open_sdcardx
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___sdmm_open
	mov	local01, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0861
	mov	arg01, local01
	call	#__system___vfs_open_fat_handle
	mov	local02, result1 wz
 if_ne	jmp	#LR__0860
	add	local01, #36
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #36
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local01
LR__0860
	mov	result1, local02
LR__0861
	mov	ptra, fp
	call	#popregs_
__system___vfs_open_sdcardx_ret
	ret

__system____default_getc
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #8
	rdlong	local03, local01
	sub	local01, #8
	test	local03, #8 wz
 if_ne	mov	arg01, local01
 if_ne	call	#__system____default_flush
	add	local01, #8
	rdlong	local03, local01
	or	local03, #4
	wrlong	local03, local01
	sub	local01, #8
	rdlong	local03, local02 wz
 if_ne	jmp	#LR__0870
	mov	arg01, local01
	call	#__system____default_filbuf
	mov	local03, result1
LR__0870
	cmps	local03, #1 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__0871
	sub	local03, #1
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	rdbyte	result1, local03
	add	local03, #1
	wrlong	local03, local02
LR__0871
	mov	ptra, fp
	call	#popregs_
__system____default_getc_ret
	ret

__system____default_putc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local02
	add	local02, #8
	rdlong	arg02, local02
	sub	local02, #8
	test	arg02, #4 wz
 if_ne	mov	arg01, local02
 if_ne	call	#__system____default_flush
	add	local02, #8
	rdlong	local04, local02
	or	local04, #8
	wrlong	local04, local02
	rdlong	local05, local03
	add	local03, #12
	rdlong	arg02, local03
	sub	local03, #12
	mov	result1, local05
	add	result1, arg02
	wrbyte	local01, result1
	getbyte	local01, local01, #0
	add	local05, #1
	wrlong	local05, local03
	sub	local02, #2
	rdword	local06, local02 wz
	sub	local02, #6
 if_ne	add	local03, #8
 if_ne	rdlong	local04, local03
 if_ne	cmp	local05, local04 wz
 if_e	jmp	#LR__0880
	cmp	local01, #10 wz
 if_e	cmp	local06, #1 wz
 if_ne	jmp	#LR__0881
LR__0880
	mov	arg01, local02
	call	#__system____default_flush
	cmp	result1, #0 wz
 if_ne	neg	local01, #1
LR__0881
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system____default_putc_ret
	ret

__system____default_flush
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #8 wz
 if_e	jmp	#LR__0892
	cmps	local03, #1 wc
 if_b	jmp	#LR__0894
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #128 wz
 if_e	jmp	#LR__0891
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #256 wz
 if_e	jmp	#LR__0890
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #256
	wrlong	local06, local01
	sub	local01, #8
LR__0890
LR__0891
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #12
	rdlong	arg02, local02
	sub	local02, #12
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__0894
LR__0892
	add	local01, #8
	rdlong	local06, local01
	sub	local01, #8
	test	local06, #4 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__0893
	neg	arg02, local03
	mov	arg03, arg02
	sar	arg03, #31
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg04, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__0893
LR__0894
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local01, #8
	rdlong	local07, local01
	andn	local07, #12
	wrlong	local07, local01
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_flush_ret
	ret

__system__stat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, ptr___system__dat__
	add	local02, #388
	mov	arg02, arg01
	mov	arg01, local02
	mov	arg03, #0
	call	#__system____getvfsforfile
	mov	local03, result1 wz
 if_e	jmp	#LR__0900
	add	local03, #52
	rdlong	arg03, local03 wz
	sub	local03, #52
 if_ne	jmp	#LR__0901
LR__0900
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__0902
LR__0901
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #52
	mov	local04, arg01
	call	#\builtin_bytefill_
	mov	result1, local04
	rdbyte	arg01, local02 wz
 if_e	add	local01, #8
 if_e	wrlong	##4607, local01
 if_e	mov	result1, #0
 if_e	jmp	#LR__0902
	add	local03, #52
	rdlong	local03, local03
	mov	local04, local03
	zerox	local03, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local02
	mov	arg02, local01
	mov	local02, objptr
	mov	objptr, local03
	call	local04
	mov	objptr, local02
LR__0902
	mov	ptra, fp
	call	#popregs_
__system__stat_ret
	ret

__system____getftab
	cmp	arg01, #10 wc
 if_b	qmul	arg01, #52
 if_ae	mov	result1, #0
 if_b	mov	arg01, ptr___system__dat__
 if_b	add	arg01, ##736
 if_b	getqx	result1
 if_b	add	result1, arg01
__system____getftab_ret
	ret

__system__strncpy
	mov	_var01, arg01
LR__0910
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__0911
	mov	result1, arg02
	add	result1, #1
	rdbyte	_var02, arg02
	mov	arg02, result1
	wrbyte	_var02, _var01
	getbyte	_var02, _var02, #0
	zerox	_var02, #7 wz
	add	_var01, #1
 if_ne	jmp	#LR__0910
LR__0911
	callpa	#(@LR__0913-@LR__0912)>>2,fcache_load_ptr_
LR__0912
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var03, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var03
 if_ae	jmp	#LR__0912
LR__0913
	mov	result1, arg01
__system__strncpy_ret
	ret

__system__strncat
	cmps	arg02, #0 wz
 if_e	jmp	#LR__0925
	cmp	arg03, #1 wc
 if_b	jmp	#LR__0925
	mov	_var01, arg01
	callpa	#(@LR__0921-@LR__0920)>>2,fcache_load_ptr_
LR__0920
	rdbyte	result1, _var01 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__0920
LR__0921
	mov	_var02, arg03
	callpa	#(@LR__0923-@LR__0922)>>2,fcache_load_ptr_
LR__0922
	rdbyte	_var03, arg02
	mov	_var04, _var03
	zerox	_var04, #7 wz
	add	arg02, #1
 if_e	jmp	#LR__0924
	sub	_var02, #1
	cmps	_var02, #0 wc
 if_ae	mov	_var04, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	_var03, _var04
 if_ae	jmp	#LR__0922
LR__0923
LR__0924
	wrbyte	#0, _var01
LR__0925
	mov	result1, arg01
__system__strncat_ret
	ret

__system__strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__0930
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#__system__strncmp_ret
LR__0930
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#__system__strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__0932-@LR__0931)>>2,fcache_load_ptr_
LR__0931
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__0933
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__0931
LR__0932
LR__0933
	cmps	_var03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#__system__strncmp_ret
	cmp	_var04, _var06 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system__strncmp_ret
	cmp	_var04, #0 wz
 if_e	neg	result1, #1
 if_e	jmp	#__system__strncmp_ret
	cmp	_var06, #0 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
__system__strncmp_ret
	ret

__system____root_opendir
	mov	result1, ptr___system__dat__
	add	result1, #100
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, #0
__system____root_opendir_ret
	ret

__system____root_readdir
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	add	local01, #4
	rdlong	local03, local01
	sub	local01, #4
LR__0940
	mov	arg03, ptr___system__dat__
	add	arg03, #116
	cmp	local03, arg03 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__0941
	rdlong	arg03, local03 wz
 if_e	add	local03, #4
 if_e	jmp	#LR__0940
	rdlong	arg02, local03
	add	arg02, #1
	mov	arg01, local02
	mov	arg03, #64
	call	#__system__strncpy
	add	local02, #80
	wrbyte	#1, local02
	sub	local02, #8
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local03, #4
	add	local01, #4
	wrlong	local03, local01
	mov	result1, #0
LR__0941
	mov	ptra, fp
	call	#popregs_
__system____root_readdir_ret
	ret

__system____root_closedir
	mov	result1, #0
__system____root_closedir_ret
	ret

__system____root_stat
	mov	_var01, arg02
	mov	arg01, _var01
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	add	_var01, #8
	wrlong	##4607, _var01
	mov	result1, #0
__system____root_stat_ret
	ret

__system___normalizeName
	mov	_var01, #0
	mov	_var02, arg01
	mov	_var03, _var02
LR__0950
	rdbyte	_var04, _var02 wz
 if_e	jmp	#LR__0969
	cmp	_var01, #0 wz
 if_ne	mov	_var04, _var03
 if_ne	add	_var03, #1
 if_ne	wrbyte	#47, _var04
 if_ne	mov	_var01, #0
	rdbyte	_var04, _var02
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__0962
	add	_var02, #1
	rdbyte	_var04, _var02
	sub	_var02, #1
	cmp	_var04, #47 wz
 if_e	jmp	#LR__0951
	add	_var02, #1
	rdbyte	_var05, _var02
	sub	_var02, #1
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__0952
LR__0951
	mov	_var07, _var02
	add	_var07, #1
	mov	_var02, _var07
	jmp	#LR__0966
LR__0952
	add	_var02, #1
	rdbyte	_var07, _var02
	sub	_var02, #1
	getbyte	_var04, _var07, #0
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__0961
	add	_var02, #2
	rdbyte	_var07, _var02
	sub	_var02, #2
	getbyte	_var04, _var07, #0
	cmp	_var04, #47 wz
 if_e	jmp	#LR__0953
	add	_var02, #2
	rdbyte	_var05, _var02
	sub	_var02, #2
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__0960
LR__0953
	add	_var02, #2
	cmps	_var03, arg01 wcz
 if_be	jmp	#LR__0959
	mov	_var08, _var03
	sub	_var08, #1
LR__0954
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__0955
	cmps	_var08, arg01 wcz
 if_a	sub	_var08, #1
 if_a	jmp	#LR__0954
LR__0955
	callpa	#(@LR__0957-@LR__0956)>>2,fcache_load_ptr_
LR__0956
	cmps	_var08, arg01 wcz
 if_be	jmp	#LR__0958
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	sub	_var08, #1
 if_ne	jmp	#LR__0956
LR__0957
LR__0958
	mov	_var03, _var08
LR__0959
	mov	_var01, #1
	jmp	#LR__0966
LR__0960
LR__0961
LR__0962
	callpa	#(@LR__0964-@LR__0963)>>2,fcache_load_ptr_
LR__0963
	rdbyte	_var04, _var02 wz
 if_ne	mov	_var07, _var04
 if_ne	cmp	_var07, #47 wz
 if_e	jmp	#LR__0965
	mov	_var06, _var02
	mov	_var05, _var02
	add	_var05, #1
	rdbyte	_var09, _var06
	mov	_var02, _var05
	wrbyte	_var09, _var03
	add	_var03, #1
	jmp	#LR__0963
LR__0964
LR__0965
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__0950
	mov	_var01, #1
LR__0966
	callpa	#(@LR__0968-@LR__0967)>>2,fcache_load_ptr_
LR__0967
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_e	mov	_var07, _var02
 if_e	add	_var07, #1
 if_e	mov	_var02, _var07
 if_e	jmp	#LR__0967
LR__0968
	jmp	#LR__0950
LR__0969
	wrbyte	#0, _var03
__system___normalizeName_ret
	ret

__system___strrev
	rdbyte	_var01, arg01 wz
 if_e	jmp	#__system___strrev_ret
	mov	_var02, arg01
	callpa	#(@LR__0971-@LR__0970)>>2,fcache_load_ptr_
LR__0970
	rdbyte	_var01, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__0970
LR__0971
	sub	_var02, #1
	callpa	#(@LR__0973-@LR__0972)>>2,fcache_load_ptr_
LR__0972
	cmps	_var02, arg01 wcz
 if_be	jmp	#LR__0974
	rdbyte	_var01, arg01
	rdbyte	_var03, _var02
	wrbyte	_var03, arg01
	wrbyte	_var01, _var02
	add	arg01, #1
	sub	_var02, #1
	jmp	#LR__0972
LR__0973
LR__0974
__system___strrev_ret
	ret

__system___fmtpad
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg01, local02, #1
	shr	local02, #22
	and	local02, #3 wz
	mov	local04, #0
 if_e	mov	local02, #1
	test	local02, arg04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0983
	subr	local03, arg01
	cmps	local03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__0983
	cmp	local02, #3 wz
 if_ne	jmp	#LR__0980
	cmp	arg04, #1 wz
	wrz	local02
	add	local03, local02
	abs	local03, local03 wc
	shr	local03, #1
	negc	local03, local03
LR__0980
	cmps	local03, #1 wc
 if_b	jmp	#LR__0982
	mov	local05, local03
LR__0981
	mov	local02, local01
	mov	local06, local01
	zerox	local02, #19
	shr	local06, #20
	shl	local06, #2
	add	local06, __methods__
	rdlong	local06, local06
	mov	arg01, #32
	mov	local03, objptr
	mov	objptr, local02
	call	local06
	mov	objptr, local03
	mov	local06, result1
	cmps	local06, #0 wc
 if_b	mov	result1, local06
 if_b	jmp	#LR__0983
	add	local04, local06
	djnz	local05, #LR__0981
LR__0982
	mov	result1, local04
LR__0983
	mov	ptra, fp
	call	#popregs_
__system___fmtpad_ret
	ret

__system___uitoa
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	cmps	arg05, #0 wz
	mov	arg05, local01
	mov	local02, #0
 if_ne	mov	local03, #55
 if_e	mov	local03, #87
LR__0990
	qdiv	arg02, arg03
	getqy	local04
	qdiv	arg02, arg03
	cmp	local04, #10 wc
 if_b	add	local04, #48
 if_ae	add	local04, local03
	wrbyte	local04, arg05
	add	arg05, #1
	add	local02, #1
	getqx	arg02
	cmp	arg02, #0 wz
 if_ne	jmp	#LR__0990
	cmp	local02, arg04 wc
 if_b	jmp	#LR__0990
	wrbyte	#0, arg05
	mov	arg01, local01
	call	#__system___strrev
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system___uitoa_ret
	ret

__system__disassemble_0093
	mov	COUNT_, #16
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	abs	arg01, local05 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	local07, result1
	mov	local08, #0
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	local09, #0
 if_e	wrlong	#0, local02
 if_e	wrlong	local09, local03
 if_e	jmp	#LR__1012
	mov	arg01, local01
	call	#__system____builtin_ilogb
	mov	local10, result1
	cmp	local05, #10 wz
 if_ne	jmp	#LR__1000
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	abs	local10, local09 wc
	qdiv	local10, #10
	mov	local11, #9
	getqx	local10
	negc	local10, local10
	jmp	#LR__1001
LR__1000
	mov	local11, #24
LR__1001
LR__1002
	cmps	local08, #8 wc
	add	local08, #1
 if_ae	jmp	#LR__1003
	mov	arg01, ##1065353216
	mov	arg02, local07
	mov	arg03, local10
	call	#__system___float_pow_n
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_div
	mov	local12, result1
	mov	arg01, local12
	mov	arg02, ##1065353216
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	sub	local10, #1
 if_b	jmp	#LR__1002
	mov	arg02, local07
	mov	arg01, local12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	add	local10, #1
 if_ae	jmp	#LR__1002
LR__1003
	mov	arg01, local12
	call	#__system____builtin_ilogb
	mov	local13, result1
	mov	local14, local12
	bitl	local14, #279
	bith	local14, #23
	shl	local14, local13
	cmp	local05, #2 wz
 if_e	shl	local04, #2
	mov	local15, #0
	cmps	local04, #0 wc
 if_ae	jmp	#LR__1004
	subr	local04, local10
	cmps	local04, #0 wc
 if_b	jmp	#LR__1011
	jmp	#LR__1005
LR__1004
	add	local04, #1
LR__1005
	fles	local04, local11 wcz
	mov	local16, #1
	callpa	#(@LR__1007-@LR__1006)>>2,fcache_load_ptr_
LR__1006
	cmp	local15, ##8388608 wc
 if_ae	jmp	#LR__1008
	cmps	local04, #1 wc
	sub	local04, #1
 if_b	jmp	#LR__1008
	qmul	local15, local05
	mov	local13, local14
	shr	local13, #23
	bitl	local14, #279
	getqx	local15
	qmul	local16, local05
	getqx	local16
	qmul	local14, local05
	add	local15, local13
	getqx	local14
	jmp	#LR__1006
LR__1007
LR__1008
	mov	local09, local05
	shl	local09, #23
	abs	local13, local09 wc
	shr	local13, #1
	negc	local13, local13
	cmp	local14, local13 wcz
 if_a	jmp	#LR__1009
	shl	local05, #23
	abs	local13, local05 wc
	shr	local13, #1
	negc	local13, local13
	cmp	local14, local13 wz
 if_ne	jmp	#LR__1010
	test	local15, #1 wz
 if_e	jmp	#LR__1010
LR__1009
	add	local15, #1
	cmp	local15, local16 wz
 if_e	add	local10, #1
LR__1010
LR__1011
	wrlong	local15, local02
	wrlong	local10, local03
LR__1012
	mov	ptra, fp
	call	#popregs_
__system__disassemble_0093_ret
	ret

__system__emitsign_0095
	mov	result1, #0
	cmp	arg02, #0 wz
 if_ne	mov	_var01, arg01
 if_ne	add	arg01, #1
 if_ne	wrbyte	arg02, _var01
 if_ne	mov	result1, #1
	cmp	arg03, #0 wz
 if_ne	wrbyte	#48, arg01
 if_ne	add	arg01, #1
 if_ne	wrbyte	arg03, arg01
 if_ne	add	result1, #2
__system__emitsign_0095_ret
	ret

__system___getiolock_0133
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__1020
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__1021
LR__1020
	mov	result1, ptr___system__dat__
	add	result1, ##732
	jmp	#LR__1022
LR__1021
	add	local01, #12
	mov	result1, local01
LR__1022
	mov	ptra, fp
	call	#popregs_
__system___getiolock_0133_ret
	ret

__system___gettxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__1030
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__1031
LR__1030
	mov	result1, #0
	jmp	#LR__1032
LR__1031
	or	local01, ##5242880
	mov	result1, local01
LR__1032
	mov	ptra, fp
	call	#popregs_
__system___gettxfunc_ret
	ret

__system__pack_0176
	mov	_var01, arg01
	add	arg03, #127
	test	arg04, #4 wz
 if_e	jmp	#LR__1040
	cmp	_var01, #0 wz
 if_e	decod	_var01, #22
	bith	_var01, #247
	jmp	#LR__1049
LR__1040
	test	arg04, #2 wz
 if_ne	mov	_var01, ##2139095040
 if_ne	mov	arg02, #0
 if_ne	jmp	#LR__1048
	test	arg04, #8 wz
 if_ne	mov	_var01, #0
 if_ne	jmp	#LR__1047
	cmps	arg03, #255 wc
 if_ae	mov	_var01, ##2139095040
 if_ae	mov	arg02, #0
 if_ae	jmp	#LR__1046
	cmps	arg03, #1 wc
 if_ae	jmp	#LR__1044
	shr	arg02, #1
	mov	_var02, _var01
	and	_var02, #1
	shl	_var02, #31
	or	arg02, _var02
	shr	_var01, #1
	callpa	#(@LR__1042-@LR__1041)>>2,fcache_load_ptr_
LR__1041
	cmps	arg03, #0 wc
 if_ae	jmp	#LR__1043
	cmp	_var01, #0 wz
 if_e	jmp	#LR__1043
	mov	arg01, arg02
	and	arg01, #1
	add	arg03, #1
	shr	arg02, #1
	mov	_var02, _var01
	and	_var02, #1
	shl	_var02, #31
	or	arg02, _var02
	or	arg02, arg01
	shr	_var01, #1
	jmp	#LR__1041
LR__1042
LR__1043
	cmps	arg03, #0 wc
 if_ae	jmp	#LR__1045
	cmp	arg02, #0 wz
	wrnz	arg02
	jmp	#LR__1045
LR__1044
	bitl	_var01, #279
	shl	arg03, #23
	or	_var01, arg03
LR__1045
LR__1046
LR__1047
LR__1048
LR__1049
	test	_var01, #1 wz
 if_ne	or	arg02, #1
	mov	arg03, arg02
	mov	_var02, #0
	add	arg02, ##2147483647
	cmp	arg02, arg03 wc
 if_b	mov	_var02, #1
	add	_var01, _var02
	test	arg04, #1 wz
 if_ne	bith	_var01, #31
	mov	result1, _var01
__system__pack_0176_ret
	ret

__system___rxtxioctl_0227
	cmp	arg02, #256 wz
 if_e	jmp	#LR__1050
	cmp	arg02, #257 wz
 if_e	jmp	#LR__1051
	jmp	#LR__1052
LR__1050
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	wrlong	result1, arg03
	mov	result1, #0
	jmp	#LR__1053
LR__1051
	rdlong	arg01, arg03
	add	ptr___system__dat__, #8
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	mov	result1, #0
	jmp	#LR__1053
LR__1052
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
LR__1053
__system___rxtxioctl_0227_ret
	ret

__system____dummy_flush_0228
	mov	result1, #0
__system____dummy_flush_0228_ret
	ret

__system___sdmm_open
	mov	COUNT_, #11
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, arg03
	mov	local06, arg04
	mov	arg01, #40
	call	#__system___gc_alloc_managed
	mov	local07, result1
	mov	arg04, local03
	sar	arg04, #31
	mov	arg03, local03
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local08, result2
	mov	arg04, local04
	sar	arg04, #31
	mov	arg03, local04
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local08, result2
	mov	arg04, local05
	sar	arg04, #31
	mov	arg03, local05
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local08, result2
	mov	arg04, local06
	sar	arg04, #31
	mov	arg03, local06
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	arg02, local08
	or	local01, result1
	or	result2, arg02
	mov	local02, result2
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___usepins
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1060
	mov	arg01, local07
	call	#__system___gc_free
	add	ptr___system__dat__, #32
	wrlong	#22, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__1063
LR__1060
	mov	local09, local01
	mov	arg05, local02
	add	local07, #32
	wrlong	local09, local07
	add	local07, #4
	wrlong	arg05, local07
	sub	local07, #36
	mov	arg04, local05
	mov	arg05, local06
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local04
	mov	local10, objptr
	mov	objptr, local07
	call	#_sdmm_cc_disk_setpins
	mov	objptr, local10
	mov	local11, result1 wz
 if_ne	jmp	#LR__1061
	mov	arg01, #0
	mov	local11, objptr
	mov	objptr, local07
	call	#_sdmm_cc_disk_initialize
	mov	objptr, local11
	getbyte	local11, result1, #0
LR__1061
	cmp	local11, #0 wz
 if_ne	jmp	#LR__1062
	call	#__system___get_vfs_file_handle
	mov	local11, result1 wz
 if_e	jmp	#LR__1062
	add	local11, #4
	wrword	#2, local11
	add	local11, #2
	wrword	#0, local11
	add	local11, #2
	wrlong	##32771, local11
	mov	result1, local07
	or	result1, ##34603008
	add	local11, #12
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##35651584
	add	local11, #4
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##36700160
	add	local11, #12
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##37748736
	add	local11, #4
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##38797312
	add	local11, #4
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##39845888
	add	local11, #4
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##40894464
	sub	local11, #20
	wrlong	result1, local11
	or	local07, ##41943040
	add	local11, #4
	wrlong	local07, local11
	sub	local11, #32
	mov	result1, local11
	jmp	#LR__1063
LR__1062
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___freepins
	mov	arg01, local07
	call	#__system___gc_free
	add	ptr___system__dat__, #32
	wrlong	#12, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
LR__1063
	mov	ptra, fp
	call	#popregs_
__system___sdmm_open_ret
	ret

__system____default_filbuf
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #8
	rdlong	result1, local02 wz
	sub	local02, #8
 if_ne	jmp	#LR__1070
	add	local02, #16
	mov	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	##1024, local02
	sub	local02, #8
LR__1070
	add	local01, #20
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #20
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	add	local02, #12
	rdlong	arg02, local02
	sub	local02, #4
	rdlong	arg03, local02
	sub	local02, #8
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__1071
	wrlong	local05, local02
	add	local02, #12
	rdlong	local03, local02
	sub	local02, #8
	wrlong	local03, local02
	add	local01, #8
	rdlong	local04, local01
	or	local04, #4
	wrlong	local04, local01
	mov	result1, local05
LR__1071
	mov	ptra, fp
	call	#popregs_
__system____default_filbuf_ret
	ret

_sdmm_cc_disk_initialize
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, ptra
	rdlong	local03, objptr
	add	objptr, #4
	rdlong	local04, objptr
	add	objptr, #4
	rdlong	local05, objptr
	add	objptr, #4
	rdlong	local06, objptr
	add	objptr, #8
	wrbyte	#1, objptr
	sub	objptr, #20
' #line 539 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
' 		return RES_NOTRDY;
	add	ptra, #12
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__1100
	mov	arg01, ##10000
	call	#__system___waitus
	mov	arg04, local03
	sub	arg04, local05
	abs	arg04, arg04
	cmps	arg04, #4 wc
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__1100
	mov	local07, local03
	sub	local07, local06
	abs	local07, local07
	cmps	local07, #4 wc
 if_ae	jmp	#LR__1080
	mov	local08, local03
	sub	local08, local06
	and	local08, #7
	shl	local08, #24
	or	local08, ##21114
	mov	local09, local06
	add	objptr, #12
	wrlong	local09, objptr
	add	objptr, #4
	wrlong	local09, objptr
	sub	objptr, #16
	jmp	#LR__1083
LR__1080
	cmps	local03, local06 wcz
 if_be	jmp	#LR__1081
	mov	local09, local03
	sub	local09, #3
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	add	local09, #1
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_ne	jmp	#LR__1082
	add	local09, #1
	jmp	#LR__1082
LR__1081
	mov	local09, local03
	add	local09, #3
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	sub	local09, #1
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	sub	local09, #1
LR__1082
	mov	local07, local06
	sub	local07, local09
	abs	local07, local07
	cmps	local07, #4 wc
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__1100
	mov	local08, local06
	sub	local08, local09
	and	local08, #7
	shl	local08, #28
	mov	local07, local03
	sub	local07, local09
	and	local07, #7
	shl	local07, #24
	or	local08, local07
	or	local08, #58
	add	objptr, #16
	wrlong	local06, objptr
	sub	objptr, #4
	wrlong	local09, objptr
	sub	objptr, #12
LR__1083
	wrpin	#0, local04
	drvh	local04
	mov	local10, ##1048608
	dirl	local03
	wrpin	##475208, local03
	wxpin	##1048608, local03
	wypin	#0, local03
	dirh	local03
	mov	local07, local03
	sub	local07, local05
	and	local07, #7
	shl	local07, #24
	mov	local11, #120
	or	local11, local07
	mov	arg02, local11
	bith	arg02, #16
	dirl	local05
	wrpin	arg02, local05
	wxpin	#31, local05
	wypin	##-1, local05
	dirh	local05
	wrpin	##20992, local06
	dirl	local09
	wrpin	local08, local09
	wxpin	#39, local09
	wypin	#0, local09
	dirh	local09
	mov	arg01, local02
	mov	arg02, #10
	call	#_sdmm_cc_rcvr_mmc_0287
	mov	arg01, #0
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0310
	call	#_sdmm_cc_deselect_0297
	mov	arg01, #100
	call	#__system___waitus
	mov	arg01, local02
	mov	arg02, #10
	call	#_sdmm_cc_rcvr_mmc_0287
	mov	local12, #0
	mov	arg01, #0
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0310
	getbyte	local07, result1, #0
	cmp	local07, #1 wz
 if_ne	jmp	#LR__1099
	mov	arg01, #8
	mov	arg02, #426
	call	#_sdmm_cc_send_cmd_0310
	getbyte	result1, result1, #0
	cmp	result1, #1 wz
 if_ne	jmp	#LR__1088
	mov	arg01, local02
	mov	arg02, #4
	call	#_sdmm_cc_rcvr_mmc_0287
	add	local02, #2
	rdbyte	local07, local02
	sub	local02, #2
	cmp	local07, #1 wz
 if_e	add	local02, #3
 if_e	rdbyte	local13, local02
 if_e	sub	local02, #3
 if_e	cmp	local13, #170 wz
 if_ne	jmp	#LR__1098
' 				for (tmr = 1000; tmr; tmr--) {
	mov	local14, ##1000
LR__1084
	mov	arg01, #169
	decod	arg02, #30
	call	#_sdmm_cc_send_cmd_0310
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__1085
	mov	arg01, ##1000
	call	#__system___waitus
	mov	local07, local14
	sub	local14, #1 wz
 if_ne	jmp	#LR__1084
LR__1085
	cmp	local14, #0 wz
 if_e	jmp	#LR__1086
	mov	arg01, #58
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0310
	mov	local07, result1
	zerox	local07, #7 wz
 if_ne	jmp	#LR__1086
	mov	arg01, local02
	mov	arg02, #4
	call	#_sdmm_cc_rcvr_mmc_0287
	rdbyte	local14, local02
	test	local14, #64 wz
 if_ne	mov	local07, #12
 if_e	mov	local07, #4
	mov	local12, local07
LR__1086
	rdlong	local14, #20
	cmp	local14, ##100000001 wc
 if_b	mov	local07, local11
 if_b	bith	local07, #27
 if_b	mov	local11, local07
 if_b	jmp	#LR__1087
	cmp	local14, ##200000001 wc
 if_b	or	local11, ##134283264
LR__1087
	cmp	local14, ##100000001 wc
 if_b	mov	local10, ##131076
 if_b	jmp	#LR__1098
	cmp	local14, ##150000001 wc
 if_b	mov	local10, ##196614
 if_b	jmp	#LR__1098
	cmp	local14, ##200000001 wc
 if_b	mov	local10, ##262152
 if_b	jmp	#LR__1098
	cmp	local14, ##250000001 wc
 if_b	mov	local10, ##327690
 if_b	jmp	#LR__1098
	mov	local10, ##393228
	jmp	#LR__1098
LR__1088
	mov	arg01, #169
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0310
	getbyte	local07, result1, #0
	cmp	local07, #2 wc
 if_b	mov	local12, #2
 if_b	mov	local15, #169
 if_ae	mov	local12, #1
 if_ae	mov	local15, #1
' 				ty =  0x01 ; cmd =  (1) ;
' 			}
' 			for (tmr = 1000; tmr; tmr--) {
	mov	local14, ##1000
LR__1089
	mov	arg01, local15
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0310
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__1090
	mov	arg01, ##1000
	call	#__system___waitus
	mov	local07, local14
	sub	local14, #1 wz
 if_ne	jmp	#LR__1089
LR__1090
	cmp	local14, #0 wz
 if_e	jmp	#LR__1091
	mov	arg01, #16
	decod	arg02, #9
	call	#_sdmm_cc_send_cmd_0310
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__1092
LR__1091
	mov	local12, #0
LR__1092
	rdlong	local14, #20
	cmp	local14, ##100000001 wc
 if_b	mov	local07, local11
 if_b	bith	local07, #27
 if_b	mov	local11, local07
 if_b	jmp	#LR__1093
	cmp	local14, ##200000001 wc
 if_b	or	local11, ##134283264
LR__1093
	cmp	local14, ##100000001 wc
 if_b	mov	local10, ##131076
 if_b	jmp	#LR__1097
	cmp	local14, ##150000001 wc
 if_b	mov	local10, ##196614
 if_b	jmp	#LR__1096
	cmp	local14, ##200000001 wc
 if_b	mov	local10, ##262152
 if_b	jmp	#LR__1095
	cmp	local14, ##250000001 wc
 if_b	mov	local10, ##327690
 if_b	jmp	#LR__1094
	cmp	local14, ##300000001 wc
 if_b	mov	local10, ##393228
 if_ae	mov	local10, ##458766
LR__1094
LR__1095
LR__1096
LR__1097
LR__1098
LR__1099
	add	objptr, #21
	wrbyte	local12, objptr
	cmp	local12, #0 wz
 if_ne	mov	local07, #0
 if_e	mov	local07, #1
	sub	objptr, #1
	wrbyte	local07, objptr
	sub	objptr, #20
	call	#_sdmm_cc_deselect_0297
	wxpin	local10, local03
	wrpin	local11, local05
' #line 682 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
' 		}
' 	}
' #line 687 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
' 	CardType = ty;
' 	s = ty ? 0 :  0x01 ;
' 	Stat = s;
' 
' 	deselect();
' 
' 
' 	_wxpin( PIN_CLK, ck_div );
' 	_wrpin( PIN_DI, spm_tx );
' #line 700 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
' 	return s;
	mov	result1, local07
LR__1100
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_initialize_ret
	ret

_sdmm_cc_disk_read
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #20
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #20
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__1112
	add	objptr, #21
	rdbyte	local04, objptr
	sub	objptr, #21
	test	local04, #8 wz
 if_e	shl	local02, #9
	cmp	local03, #2 wc
 if_ae	mov	local04, #18
 if_b	mov	local04, #17
	mov	arg02, local02
	mov	arg01, local04
	call	#_sdmm_cc_send_cmd_0310
	mov	local05, result1
	zerox	local05, #7 wz
 if_ne	jmp	#LR__1111
' 		do {
LR__1110
	mov	arg01, local01
	decod	arg02, #9
	call	#_sdmm_cc_rcvr_datablock_0305
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local03, #LR__1110
	getbyte	local04, local04, #0
	cmp	local04, #18 wz
 if_e	mov	arg01, #12
 if_e	mov	arg02, #0
 if_e	call	#_sdmm_cc_send_cmd_0310
LR__1111
	call	#_sdmm_cc_deselect_0297
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local03, #0 wz
 if_ne	mov	local05, #1
 if_e	mov	local05, #0
	mov	result1, local05
LR__1112
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_read_ret
	ret

_sdmm_cc_disk_write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg04
	mov	local03, arg03
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #20
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #20
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__1124
	add	objptr, #21
	rdbyte	arg03, objptr
	sub	objptr, #21
	test	arg03, #8 wz
 if_e	shl	local03, #9
	cmp	local02, #1 wz
 if_ne	jmp	#LR__1120
	mov	arg01, #24
	mov	arg02, local03
	call	#_sdmm_cc_send_cmd_0310
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__1123
	mov	arg01, local01
	mov	arg02, #254
	call	#_sdmm_cc_xmit_datablock_0307
	cmp	result1, #0 wz
 if_ne	mov	local02, #0
	jmp	#LR__1123
LR__1120
	add	objptr, #21
	rdbyte	local04, objptr
	sub	objptr, #21
	test	local04, #6 wz
 if_ne	mov	arg01, #151
 if_ne	mov	arg02, local02
 if_ne	call	#_sdmm_cc_send_cmd_0310
	mov	arg02, local03
	mov	arg01, #25
	call	#_sdmm_cc_send_cmd_0310
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__1122
' 			do {
LR__1121
	mov	arg01, local01
	mov	arg02, #252
	call	#_sdmm_cc_xmit_datablock_0307
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local02, #LR__1121
	mov	arg01, #0
	mov	arg02, #253
	call	#_sdmm_cc_xmit_datablock_0307
	cmp	result1, #0 wz
 if_e	mov	local02, #1
LR__1122
LR__1123
	call	#_sdmm_cc_deselect_0297
' 				count = 1;
' 		}
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local02, #0 wz
 if_ne	mov	local04, #1
 if_e	mov	local04, #0
	mov	result1, local04
LR__1124
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_write_ret
	ret

_sdmm_cc_disk_ioctl
	mov	COUNT_, #6
	call	#pushregs_
	add	ptra, #48
	mov	local01, arg02
	mov	local02, arg03
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #20
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #20
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__1137
	mov	local03, #1
' 
' 	res = RES_ERROR;
' 	switch (ctrl) {
	getbyte	local04, local01, #0
	fle	local04, #4
	jmprel	local04
LR__1130
	jmp	#LR__1131
	jmp	#LR__1132
	jmp	#LR__1135
	jmp	#LR__1134
	jmp	#LR__1135
LR__1131
	call	#_sdmm_cc_select_0301
	cmp	result1, #0 wz
 if_ne	mov	local03, #0
' 			break;
	jmp	#LR__1136
LR__1132
	mov	arg01, #9
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0310
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__1136
	mov	arg01, fp
	add	arg01, #24
	mov	arg02, #16
	call	#_sdmm_cc_rcvr_datablock_0305
	cmp	result1, #0 wz
 if_e	jmp	#LR__1136
	mov	arg01, fp
	add	arg01, #24
	mov	result1, arg01
	add	arg01, #6
	rdlong	local05, arg01
	movbyts	local05, #27
	rdbyte	arg01, result1
	shr	arg01, #6
	cmp	arg01, #1 wz
 if_e	bitl	local05, #310
 if_e	add	local05, #1
 if_e	mov	local06, #10
 if_e	jmp	#LR__1133
	shr	local05, #14
	zerox	local05, #11
	add	local05, #1
	add	result1, #5
	rdbyte	local06, result1
	getnib	local06, local06, #0
	add	result1, #4
	rdword	result1, result1
	movbyts	result1, #27
	shr	result1, #23
	and	result1, #7
	add	local06, result1
	sub	local06, #7
LR__1133
'         cs = (LBA_t)(cs>>14 & 0xfff)+1;
'         n = (csd[5] & 15) + (__builtin_bswap32(*(uint16_t*)(&csd[9]))>>23 & 0x7)+(2-9);
'     }
'     return (LBA_t)cs << n;
	shl	local05, local06
	wrlong	local05, local02
	mov	local03, #0
'                			*(LBA_t*)buff = disc_size(csd);
' 				res = RES_OK;
' 			}
' 			break;
	jmp	#LR__1136
LR__1134
	wrlong	#128, local02
	mov	local03, #0
' 			*(DWORD*)buff = 128;
' 			res = RES_OK;
' 			break;
	jmp	#LR__1136
LR__1135
	mov	local03, #4
LR__1136
	call	#_sdmm_cc_deselect_0297
' 			res = RES_PARERR;
' 	}
' 
' 	deselect();
' 
' 	return res;
	mov	result1, local03
LR__1137
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_ioctl_ret
	ret

_sdmm_cc_xmit_mmc_0280
	rdlong	_var01, objptr
	add	objptr, #8
	rdlong	_var02, objptr
	sub	objptr, #8
	dirl	_var02
	setq	#1
	rdlong	_var03, arg01
	rev	_var03
	movbyts	_var03, #27
	wypin	_var03, _var02
	mov	_var03, arg02
	shr	arg02, #2 wz
	shl	_var03, #3
	wypin	_var03, _var01
	dirh	_var02
	add	arg01, #8
	rev	_var04
	movbyts	_var04, #27
LR__1140
 if_ne	wypin	_var04, _var02
 if_ne	rdlong	_var04, arg01
 if_ne	add	arg01, #4
 if_ne	rev	_var04
 if_ne	movbyts	_var04, #27
LR__1141
 if_ne	testp	_var02 wc
 if_a	jmp	#LR__1141
 if_ne	djnz	arg02, #LR__1140
LR__1142
	testp	_var01 wc
 if_ae	jmp	#LR__1142
	dirl	_var02
	wypin	##-1, _var02
	dirh	_var02
_sdmm_cc_xmit_mmc_0280_ret
	ret

_sdmm_cc_rcvr_mmc_0287
	rdlong	_var01, objptr
	add	objptr, #12
	rdlong	_var02, objptr
	sub	objptr, #12
	akpin	_var02
	mov	_var03, arg02 wz
	shr	_var03, #2 wz
 if_e	jmp	#LR__1152
	mov	_var04, _var03
	shl	_var04, #5
	wypin	_var04, _var01
	wxpin	#63, _var02
LR__1150
LR__1151
	testp	_var02 wc
 if_ae	jmp	#LR__1151
	rdpin	_var04, _var02
	rev	_var04
	movbyts	_var04, #27
	wrlong	_var04, arg01
	add	arg01, #4
	djnz	_var03, #LR__1150
LR__1152
	and	arg02, #3 wz
 if_e	jmp	#LR__1155
	wxpin	#39, _var02
LR__1153
	wypin	#8, _var01
LR__1154
	testp	_var02 wc
 if_ae	jmp	#LR__1154
	rdpin	_var04, _var02
	rev	_var04
	wrbyte	_var04, arg01
	add	arg01, #1
	djnz	arg02, #LR__1153
LR__1155
_sdmm_cc_rcvr_mmc_0287_ret
	ret

_sdmm_cc_wait_ready_0291
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, ptra
	getct	local02
	rdlong	local03, #20
	shr	local03, #1
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 1;
' 	for(;;) {
	add	ptra, #4
LR__1160
	mov	arg01, local01
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0287
	rdbyte	arg02, local01
	cmp	arg02, #255 wz
 if_e	mov	result1, #1
 if_ne	getct	result1
 if_ne	sub	result1, local02
 if_ne	cmp	result1, local03 wc
 if_a	mov	result1, #0
 if_c_and_nz	jmp	#LR__1160
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_wait_ready_0291_ret
	ret

_sdmm_cc_deselect_0297
	mov	COUNT_, #0
	call	#pushregs_
	mov	arg02, ptra
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	add	ptra, #4
	drvh	arg01
	waitx	#16
	mov	arg01, arg02
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0287
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_deselect_0297_ret
	ret

_sdmm_cc_select_0301
	mov	COUNT_, #1
	call	#pushregs_
	mov	arg02, ptra
	add	objptr, #4
	rdlong	arg01, objptr
	add	objptr, #8
	rdlong	local01, objptr
	sub	objptr, #12
	add	ptra, #4
	fltl	local01
	drvl	arg01
	waitx	#16
	dirh	local01
	mov	arg01, arg02
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0287
	call	#_sdmm_cc_wait_ready_0291
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1170
	call	#_sdmm_cc_deselect_0297
' 
' 	deselect();
' 	return 0;
	mov	result1, #0
LR__1170
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_select_0301_ret
	ret

_sdmm_cc_rcvr_datablock_0305
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	getct	local04
	rdlong	local05, #20
	shr	local05, #3
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 3;
' 	for(;;) {
	add	ptra, #4
LR__1180
	mov	arg01, local03
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0287
	rdbyte	arg02, local03
	cmp	arg02, #255 wz
 if_e	getct	result1
 if_e	mov	arg02, result1
 if_e	sub	arg02, local04
 if_e	cmp	arg02, local05 wc
 if_c_and_z	jmp	#LR__1180
	rdbyte	local05, local03
	cmp	local05, #254 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__1181
	mov	arg01, local01
	mov	arg02, local02
	call	#_sdmm_cc_rcvr_mmc_0287
	mov	arg01, local03
	mov	arg02, #2
	call	#_sdmm_cc_rcvr_mmc_0287
' 
' 	rcvr_mmc(buff, btr);
' 	rcvr_mmc(d, 2);
' 
' 	return 1;
	mov	result1, #1
LR__1181
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_rcvr_datablock_0305_ret
	ret

_sdmm_cc_xmit_datablock_0307
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	add	ptra, #4
	call	#_sdmm_cc_wait_ready_0291
	cmp	result1, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__1191
	wrbyte	local02, local03
	mov	arg01, local03
	mov	arg02, #1
	call	#_sdmm_cc_xmit_mmc_0280
	getbyte	local02, local02, #0
	cmp	local02, #253 wz
 if_e	jmp	#LR__1190
	mov	arg01, local01
	decod	arg02, #9
	call	#_sdmm_cc_xmit_mmc_0280
	mov	arg01, local03
	mov	arg02, #2
	call	#_sdmm_cc_rcvr_mmc_0287
	mov	arg01, local03
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0287
	rdbyte	local03, local03
	and	local03, #31
	cmp	local03, #5 wz
' 			return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__1191
LR__1190
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__1191
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_xmit_datablock_0307_ret
	ret

_sdmm_cc_send_cmd_0310
	mov	COUNT_, #4
	call	#pushregs_
_sdmm_cc_send_cmd_0310_enter
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	getbyte	result1, local01, #0
	test	result1, #128 wz
	add	ptra, #8
 if_e	jmp	#LR__1200
	getbyte	local01, local01, #0
	and	local01, #127
	mov	arg01, #55
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0310
	getbyte	arg02, result1, #0
	cmp	arg02, #2 wc
 if_ae	jmp	#LR__1203
LR__1200
	getbyte	result1, local01, #0
	cmp	result1, #12 wz
 if_e	jmp	#LR__1201
	call	#_sdmm_cc_deselect_0297
	call	#_sdmm_cc_select_0301
	cmp	result1, #0 wz
 if_e	mov	result1, #255
 if_e	jmp	#LR__1203
LR__1201
	getbyte	arg02, local01, #0
	mov	result1, #64
	or	result1, arg02
	wrbyte	result1, local03
	mov	arg02, local03
	add	arg02, #1
	movbyts	local02, #27
	wrlong	local02, arg02
	mov	local04, #1
	mov	local02, local01
	zerox	local02, #7 wz
 if_e	mov	local04, #149
	getbyte	local02, local01, #0
	cmp	local02, #8 wz
 if_e	mov	local04, #135
	add	local03, #5
	wrbyte	local04, local03
	sub	local03, #5
	mov	arg01, local03
	mov	arg02, #6
	call	#_sdmm_cc_xmit_mmc_0280
	getbyte	local01, local01, #0
	cmp	local01, #12 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #6
 if_e	mov	arg02, #1
 if_e	call	#_sdmm_cc_rcvr_mmc_0287
	mov	local04, #10
' 	n = 10;
' 	do
LR__1202
	mov	arg01, local03
	add	arg01, #6
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0287
	add	local03, #6
	rdbyte	local02, local03
	sub	local03, #6
	test	local02, #128 wz
 if_ne	djnz	local04, #LR__1202
' 
' 	return buf[6];
	add	local03, #6
	rdbyte	result1, local03
LR__1203
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_send_cmd_0310_ret
	ret

_sdmm_cc_disk_setpins
	cmp	arg01, #0 wz
 if_ne	neg	result1, #1
 if_ne	jmp	#_sdmm_cc_disk_setpins_ret
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	arg05, objptr
	sub	objptr, #12
'     _pin_clk = pclk;
'     _pin_ss = pss;
'     _pin_di = pdi;
'     _pin_do = pdo;
' #line 848 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
'     return 0;
	mov	result1, #0
_sdmm_cc_disk_setpins_ret
	ret

_sdmm_cc_disk_deinitialize
	mov	COUNT_, #4
	call	#pushregs_
	cmps	arg01, #0 wz
	rdlong	local01, objptr
	add	objptr, #4
	rdlong	local02, objptr
	add	objptr, #4
	rdlong	local03, objptr
	add	objptr, #8
	rdlong	local04, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #12
' #line 865 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
'         return RES_NOTRDY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__1210
	fltl	arg01
	wrpin	#0, arg01
	fltl	local04
	wrpin	#0, local04
	fltl	local03
	wrpin	#0, local03
	fltl	local01
	wrpin	#0, local01
	fltl	local02
	wrpin	#0, local02
	mov	arg01, #10
	call	#__system___waitms
'     }
' #line 871 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
'     _pinclear(SMPIN_DO);
'     _pinclear(PIN_DO);
'     _pinclear(PIN_DI);
'     _pinclear(PIN_CLK);
'     _pinclear(PIN_SS);
' 
'     _waitms(10);
' 
'     return 0;
	mov	result1, #0
LR__1210
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_deinitialize_ret
	ret

_sdmm_cc_v_do_io
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg03
	mov	local02, arg04
	mov	local03, arg02
	add	objptr, #24
	rdlong	local04, objptr
	mov	arg04, #0
	and	local04, #511
	mov	local05, #0
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, #28
	mov	arg03, #9
	call	#__system___int64_sar
	mov	local06, result1
	cmp	local04, #0 wz
' 
' 
'         return -1;
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__1223
	mov	local07, local01
	shr	local07, #9
	cmp	local02, #0 wz
 if_e	jmp	#LR__1220
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local06
	mov	arg04, local07
	call	#_sdmm_cc_disk_write
	mov	local08, result1
	jmp	#LR__1221
LR__1220
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local06
	mov	arg04, local07
	call	#_sdmm_cc_disk_read
	mov	local08, result1
LR__1221
	cmp	local08, #0 wz
 if_ne	jmp	#LR__1222
	shl	local07, #9
	add	local05, local07
	add	objptr, #24
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	result2, objptr
	add	result1, local07 wc
	addx	result2, #0
	sub	objptr, #4
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	result2, objptr
	sub	objptr, #28
LR__1222
' 
' 
'     }
'     return bytes_io;
	mov	result1, local05
LR__1223
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_v_do_io_ret
	ret

_sdmm_cc_v_read
' {
'     return v_do_io(fil, buf, count,  (0) );
	mov	arg04, #0
	call	#_sdmm_cc_v_do_io
_sdmm_cc_v_read_ret
	ret

_sdmm_cc_v_write
' {
'     return v_do_io(fil, buf, count,  (1) );
	mov	arg04, #1
	call	#_sdmm_cc_v_do_io
_sdmm_cc_v_write_ret
	ret

_sdmm_cc_v_ioctl
	mov	arg01, #0
	call	#_sdmm_cc_disk_ioctl
	cmp	result1, #0 wz
'         return _seterror( 10 );
 if_ne	add	ptr___system__dat__, #32
 if_ne	wrlong	#10, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
'     return 0;
 if_e	mov	result1, #0
_sdmm_cc_v_ioctl_ret
	ret

_sdmm_cc_v_lseek
	mov	_var01, arg02
	mov	_var03, arg04 wz
 if_ne	jmp	#LR__1230
	mov	_var03, arg03
	add	objptr, #24
	wrlong	_var01, objptr
	add	objptr, #4
	wrlong	_var03, objptr
	sub	objptr, #28
	jmp	#LR__1233
LR__1230
	cmp	_var03, #1 wz
 if_ne	jmp	#LR__1231
	add	objptr, #24
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	result2, objptr
	add	result1, _var01 wc
	addx	result2, arg03
	sub	objptr, #4
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	result2, objptr
	sub	objptr, #28
	jmp	#LR__1232
LR__1231
	not	result1, _var01
	add	result1, #1 wz
	not	result2, arg03
	mov	arg02, #0
 if_e	neg	arg02, #1
	sub	result2, arg02
	add	objptr, #24
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	result2, objptr
	sub	objptr, #28
LR__1232
LR__1233
'         curpos = -off;
'     }
'     return curpos;
	add	objptr, #24
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	result2, objptr
	sub	objptr, #28
_sdmm_cc_v_lseek_ret
	ret

_sdmm_cc_v_flush
' {
'     return 0;
	mov	result1, #0
_sdmm_cc_v_flush_ret
	ret

_sdmm_cc_v_close
	mov	arg01, #0
	call	#_sdmm_cc_disk_deinitialize
	add	objptr, #32
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, #36
	call	#__system___freepins
' {
'     disk_deinitialize(0);
'     _freepins(f_pinmask);
'     return 0;
	mov	result1, #0
_sdmm_cc_v_close_ret
	ret

_sdmm_cc_v_putc
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	mov	arg01, arg02
	mov	arg02, fp
	mov	arg03, #1
	sub	fp, #4
' {
'     return v_do_io(fil, buf, count,  (1) );
	mov	arg04, #1
	call	#_sdmm_cc_v_do_io
	cmp	result1, #1 wz
 if_e	add	fp, #4
 if_e	rdlong	result1, fp
 if_e	sub	fp, #4
'     return -1;
 if_ne	neg	result1, #1
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_v_putc_ret
	ret

_sdmm_cc_v_getc
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#0, fp
	mov	arg02, fp
	sub	fp, #8
	mov	arg03, #1
' {
'     return v_do_io(fil, buf, count,  (0) );
	mov	arg04, #0
	call	#_sdmm_cc_v_do_io
	cmp	result1, #1 wz
 if_e	add	fp, #8
 if_e	rdlong	result1, fp
 if_e	sub	fp, #8
'     return -1;
 if_ne	neg	result1, #1
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_v_getc_ret
	ret

_fatfs_cc_ff_uni2oem
	mov	_var01, #0
	cmp	arg01, #128 wc
 if_b	mov	_var01, arg01
 if_b	jmp	#LR__1244
	cmp	arg01, ##65536 wc
 if_ae	jmp	#LR__1243
	getword	result1, arg02, #0
	cmp	result1, ##850 wz
 if_ne	jmp	#LR__1243
' 			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
	mov	_var01, #0
	callpa	#(@LR__1241-@LR__1240)>>2,fcache_load_ptr_
LR__1240
	getword	result1, _var01, #0
	cmp	result1, #128 wc
 if_ae	jmp	#LR__1242
	getword	result1, _var01, #0
	shl	result1, #1
	add	result1, ptr__fatfs_cc_dat__
	rdword	result1, result1
	cmp	arg01, result1 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__1240
LR__1241
LR__1242
	getword	_var01, _var01, #0
	add	_var01, #128
	getbyte	_var01, _var01, #0
LR__1243
LR__1244
' 			c = (c + 0x80) & 0xFF;
' 		}
' 	}
' 
' 	return c;
	mov	result1, _var01
_fatfs_cc_ff_uni2oem_ret
	ret

_fatfs_cc_ff_oem2uni
	mov	_var01, #0
	getword	result1, arg01, #0
	cmp	result1, #128 wc
 if_b	mov	_var01, arg01
 if_b	jmp	#LR__1251
	getword	arg02, arg02, #0
	cmp	arg02, ##850 wz
 if_ne	jmp	#LR__1250
	getword	result1, arg01, #0
	cmp	result1, #256 wc
 if_b	getword	arg01, arg01, #0
 if_b	sub	arg01, #128
 if_b	shl	arg01, #1
 if_b	add	arg01, ptr__fatfs_cc_dat__
 if_b	rdword	_var01, arg01
LR__1250
LR__1251
' 		}
' 	}
' 
' 	return c;
	mov	result1, _var01
_fatfs_cc_ff_oem2uni_ret
	ret

_fatfs_cc_ff_wtoupper
	mov	_var01, arg01
	cmp	_var01, ##65536 wc
 if_ae	jmp	#LR__1273
	mov	_var02, _var01
	getword	_var01, _var02, #0
	cmp	_var01, ##4096 wc
 if_b	mov	_var03, ptr__fatfs_cc_dat__
 if_b	add	_var03, #256
 if_ae	mov	_var03, ptr__fatfs_cc_dat__
 if_ae	add	_var03, ##754
	mov	_var04, _var03
' 		uc = (WORD)uni;
' 		p = uc < 0x1000 ? cvt1 : cvt2;
' 		for (;;) {
LR__1260
	rdword	_var05, _var04
	mov	_var03, _var05
	zerox	_var03, #15 wz
	add	_var04, #2
 if_e	jmp	#LR__1272
	getword	_var03, _var02, #0
	getword	_var01, _var05, #0
	cmp	_var03, _var01 wc
 if_b	jmp	#LR__1272
	rdword	_var06, _var04
	getword	_var07, _var06, #0
	shr	_var07, #8
	getword	_var06, _var06, #0
	getbyte	_var06, _var06, #0
	getword	_var08, _var02, #0
	getword	_var09, _var05, #0
	getword	_var03, _var06, #0
	add	_var09, _var03
	cmps	_var08, _var09 wc
	add	_var04, #2
 if_ae	jmp	#LR__1271
' 				switch (cmd) {
	getword	_var10, _var07, #0
	fle	_var10, #9
	jmprel	_var10
LR__1261
	jmp	#LR__1262
	jmp	#LR__1263
	jmp	#LR__1264
	jmp	#LR__1265
	jmp	#LR__1266
	jmp	#LR__1267
	jmp	#LR__1268
	jmp	#LR__1269
	jmp	#LR__1270
	jmp	#LR__1272
LR__1262
	getword	_var02, _var02, #0
	getword	_var05, _var05, #0
	sub	_var02, _var05
	shl	_var02, #1
	add	_var02, _var04
	rdword	_var02, _var02
	jmp	#LR__1272
LR__1263
	getword	_var08, _var02, #0
	getword	_var02, _var02, #0
	getword	_var05, _var05, #0
	sub	_var02, _var05
	and	_var02, #1
	subr	_var02, _var08
	jmp	#LR__1272
LR__1264
	getword	_var02, _var02, #0
	sub	_var02, #16
	jmp	#LR__1272
LR__1265
	getword	_var02, _var02, #0
	sub	_var02, #32
	jmp	#LR__1272
LR__1266
	getword	_var02, _var02, #0
	sub	_var02, #48
	jmp	#LR__1272
LR__1267
	getword	_var02, _var02, #0
	sub	_var02, #26
	jmp	#LR__1272
LR__1268
	getword	_var02, _var02, #0
	add	_var02, #8
	jmp	#LR__1272
LR__1269
	getword	_var02, _var02, #0
	sub	_var02, #80
	jmp	#LR__1272
LR__1270
	getword	_var02, _var02, #0
	sub	_var02, ##7264
' 				}
' 				break;
	jmp	#LR__1272
LR__1271
	zerox	_var07, #15 wz
 if_e	getword	_var06, _var06, #0
 if_e	shl	_var06, #1
 if_e	add	_var04, _var06
	jmp	#LR__1260
LR__1272
	getword	_var01, _var02, #0
LR__1273
' 		}
' 		uni = uc;
' 	}
' 
' 	return uni;
	mov	result1, _var01
_fatfs_cc_ff_wtoupper_ret
	ret

_fatfs_cc_strncpy
	mov	_var01, arg01
	callpa	#(@LR__1281-@LR__1280)>>2,fcache_load_ptr_
' 
' 	dscan = dst;
' 	sscan = src;
' 	count = n;
' 	while (--count >= 0 && (*dscan++ = *sscan++) != '\0')
LR__1280
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__1282
	mov	result1, arg02
	add	result1, #1
	rdbyte	_var02, arg02
	mov	arg02, result1
	wrbyte	_var02, _var01
	getbyte	_var02, _var02, #0
	zerox	_var02, #7 wz
' 		continue;
	add	_var01, #1
 if_ne	jmp	#LR__1280
LR__1281
LR__1282
	callpa	#(@LR__1284-@LR__1283)>>2,fcache_load_ptr_
' 	while (--count >= 0)
LR__1283
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var03, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var03
 if_ae	jmp	#LR__1283
LR__1284
' 		*dscan++ = '\0';
' 	return(dst);
	mov	result1, arg01
_fatfs_cc_strncpy_ret
	ret

_fatfs_cc_memcmp
' 	for (n = size; n > 0; n--)
	cmp	arg03, #0 wz
 if_e	jmp	#LR__1291
LR__1290
	rdbyte	_var01, arg01
	rdbyte	_var02, arg02
	cmp	_var01, _var02 wz
 if_e	add	arg01, #1
 if_e	add	arg02, #1
' 			return( ((unsigned char)(*scan1))  -  ((unsigned char)(*scan2)) );
 if_ne	rdbyte	result1, arg01
 if_ne	rdbyte	_var02, arg02
 if_ne	sub	result1, _var02
 if_ne	jmp	#_fatfs_cc_memcmp_ret
	djnz	arg03, #LR__1290
LR__1291
' 
' 	return(0);
	mov	result1, #0
_fatfs_cc_memcmp_ret
	ret

_fatfs_cc_strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__1300
' 		return scan2 ? -1 : 0;
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#_fatfs_cc_strncmp_ret
LR__1300
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__1302-@LR__1301)>>2,fcache_load_ptr_
' 	count = n;
' 	do {
LR__1301
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__1303
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__1301
LR__1302
LR__1303
	cmps	_var03, #0 wc
' 		return(0);
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, _var06 wz
' 		return(0);
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, #0 wz
' 		return(-1);
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var06, #0 wz
' 		return(1);
 if_e	mov	result1, #1
' 		return(c1 - c2);
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
_fatfs_cc_strncmp_ret
	ret

_fatfs_cc_strchr
' #line 16 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/libc/string/strchr.c"
' 	while ((c = *s++) != (char) charwanted)
LR__1310
	mov	_var01, arg01
	rdbyte	_var02, _var01
	getbyte	_var03, _var02, #0
	getbyte	_var04, arg02, #0
	cmp	_var03, _var04 wz
	add	arg01, #1
 if_e	jmp	#LR__1311
	mov	_var03, _var02
	zerox	_var03, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strchr_ret
	jmp	#LR__1310
LR__1311
' 	return((char *)--s);
	sub	arg01, #1
	mov	result1, arg01
_fatfs_cc_strchr_ret
	ret

_fatfs_cc_time
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	mov	local01, arg01
	mov	arg01, fp
	add	arg01, #8
	mov	arg02, #0
	call	#_fatfs_cc_gettimeofday
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	cmp	local01, #0 wz
 if_ne	wrlong	result1, local01
'         *tp = now;
'     return now;
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_time_ret
	ret

_fatfs_cc_mktime
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	add	local01, #20
	rdlong	arg01, local01
	sub	local01, #20
	cmps	arg01, #70 wc
'                 return (time_t) -1;
 if_b	neg	result1, #1
 if_b	jmp	#LR__1324
	mov	local02, ##1900
	add	local01, #20
	rdlong	result1, local01
	add	local02, result1
	sub	local01, #8
	rdlong	local03, local01
	sub	local03, #1
	add	local01, #4
	rdlong	arg01, local01
	sub	local01, #16
	shl	arg01, #2
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1144
	add	arg01, result1
	rdlong	result1, arg01
	add	local03, result1
	mov	arg01, local02
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_e	jmp	#LR__1320
	mov	local04, #0
	add	local01, #16
	rdlong	result1, local01
	sub	local01, #16
	cmps	result1, #2 wc
 if_ae	mov	local04, #1
	jmp	#LR__1321
LR__1320
	mov	local04, #0
LR__1321
	add	local01, #4
	rdlong	arg01, local01
	sub	local01, #4
	rdlong	local05, local01
	add	local01, #8
	rdlong	result1, local01
	qmul	result1, ##3600
	add	local03, local04
	mov	local04, arg01
	shl	local04, #4
	sub	local04, arg01
	shl	local04, #2
	add	local05, local04
	sub	local01, #8
	getqx	local04
	qmul	local03, ##86400
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1970
	getqx	local04
	qmul	local03, ##31536000
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1969
	abs	local06, local03 wc
	shr	local06, #2
	negc	local06, local06
	cmps	local02, ##2001 wc
	getqx	local04
	add	local05, local04
 if_b	jmp	#LR__1322
	sub	local02, ##2000
	abs	local04, local02 wc
	qdiv	local04, #100
	getqx	local04
	sumnc	local06, local04
LR__1322
	qmul	local06, ##86400
	getqx	local06
	add	local05, local06
	call	#_fatfs_cc__tzset
	add	ptr__fatfs_cc_dat__, ##1092
	rdlong	local06, ptr__fatfs_cc_dat__
	add	local05, local06
	add	ptr__fatfs_cc_dat__, #104
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1196
	cmp	local03, #1 wz
 if_ne	jmp	#LR__1323
	mov	arg01, local01
	call	#_fatfs_cc___indst
	cmp	result1, #0 wz
 if_ne	sub	local05, ##3600
LR__1323
'                 s -=  (3600L) ;
' 
'         return s;
	mov	result1, local05
LR__1324
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mktime_ret
	ret

_fatfs_cc__gmtime_r
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, arg01
	qdiv	local01, ##86400
	getqx	result1
	add	result1, #4
	qdiv	result1, #7
	add	arg02, #24
	cmp	local01, ##1325376000 wc
 if_ae	sub	local01, ##1325376000
 if_ae	mov	local02, ##2012
 if_b	mov	local02, ##1970
' 	  year = 1970;
' 	}
' 
' 	for(;;) {
	getqy	result1
	wrlong	result1, arg02
	sub	arg02, #24
LR__1330
	mov	arg01, local02
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, ##31622400
 if_e	mov	local03, ##31536000
	cmp	local01, local03 wc
' 	    break;
 if_ae	add	local02, #1
 if_ae	sub	local01, local03
 if_ae	jmp	#LR__1330
	qdiv	local01, ##86400
	mov	local03, local02
	sub	local03, ##1900
	add	arg02, #20
	wrlong	local03, arg02
	add	arg02, #8
	mov	arg01, local02
	getqx	local02
	wrlong	local02, arg02
	sub	arg02, #28
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, #29
 if_e	mov	local03, #28
	add	ptr__fatfs_cc_dat__, ##1100
	wrlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1100
' 
'         days_per_mth[1] = _is_leap_year(year) ? 29 : 28;
'         for (i = 0; mday >= days_per_mth[i]; i++)
	mov	arg01, #0
	callpa	#(@LR__1332-@LR__1331)>>2,fcache_load_ptr_
LR__1331
	mov	local03, arg01
	shl	local03, #2
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1096
	add	local03, result1
	rdlong	local03, local03
	cmps	local02, local03 wc
 if_b	jmp	#LR__1333
	mov	result1, arg01
	shl	result1, #2
	mov	local03, ptr__fatfs_cc_dat__
	add	local03, ##1096
	add	result1, local03
	rdlong	result1, result1
	sub	local02, result1
	add	arg01, #1
	jmp	#LR__1331
LR__1332
LR__1333
	qdiv	local01, ##86400
	add	arg02, #16
	wrlong	arg01, arg02
	add	local02, #1
	sub	arg02, #4
	wrlong	local02, arg02
	getqy	local01
	qdiv	local01, ##3600
	getqx	local03
	qdiv	local01, ##3600
	sub	arg02, #4
	wrlong	local03, arg02
	getqy	local01
	qdiv	local01, #60
	getqx	local03
	qdiv	local01, #60
	sub	arg02, #4
	wrlong	local03, arg02
	sub	arg02, #4
'         stm->tm_isdst = 0;
' 
' ;
'         return stm;
	mov	result1, arg02
	getqy	local03
	wrlong	local03, arg02
	add	arg02, #32
	wrlong	#0, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__gmtime_r_ret
	ret

_fatfs_cc__tzset
	mov	arg01, ##@LR__2167
	call	#_fatfs_cc_getenv
	mov	arg01, result1
	mov	arg02, ptr__fatfs_cc_dat__
	add	arg02, ##1196
	call	#_fatfs_cc___tzoffset
	add	ptr__fatfs_cc_dat__, ##1092
	wrlong	result1, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1092
_fatfs_cc__tzset_ret
	ret

_fatfs_cc_disk_read
	mov	COUNT_, #9
	call	#pushregs_
	mov	local05, arg02
	mov	local06, arg04
	mov	arg01, arg03
	mov	arg02, #0
	mov	arg03, #9
	mov	arg04, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local02, result2
	add	objptr, ##528
	rdlong	result2, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
 if_e	jmp	#LR__1340
	mov	arg02, local01
	mov	arg03, local02
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	arg04, arg01
	add	arg04, #48
	rdlong	local07, arg04
	mov	local08, local07
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	sub	objptr, ##528
	mov	arg04, #0
	mov	local09, objptr
	mov	objptr, local07
	call	local08
	mov	objptr, local09
	mov	local03, result1
	mov	local04, result2
	mov	arg01, local03
	mov	arg02, local04
	mov	arg03, local01
	mov	arg04, local02
	mov	result1, #0
	cmp	arg01, arg03 wcz
	cmpsx	arg02, arg04 wcz
 if_ne	negc	result1, #1
	cmp	result1, #0 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1340
	shl	local06, #9
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	local03, arg01
	add	local03, #20
	rdlong	local03, local03
	mov	local09, local03
	zerox	local09, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	sub	objptr, ##528
	mov	arg02, local05
	mov	arg03, local06
	mov	local08, objptr
	mov	objptr, local09
	call	local03
	mov	objptr, local08
	cmp	result1, local06 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
'     }
'     return RES_OK;
 if_e	mov	result1, #0
LR__1340
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_read_ret
	ret

_fatfs_cc_disk_write
	mov	COUNT_, #9
	call	#pushregs_
	mov	local05, arg02
	mov	local06, arg04
	mov	arg01, arg03
	mov	arg02, #0
	mov	arg03, #9
	mov	arg04, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local02, result2
	add	objptr, ##528
	rdlong	result2, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
 if_e	jmp	#LR__1350
	mov	arg02, local01
	mov	arg03, local02
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	arg04, arg01
	add	arg04, #48
	rdlong	local07, arg04
	mov	local08, local07
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	sub	objptr, ##528
	mov	arg04, #0
	mov	local09, objptr
	mov	objptr, local07
	call	local08
	mov	objptr, local09
	mov	local03, result1
	mov	local04, result2
	mov	arg01, local03
	mov	arg02, local04
	mov	arg03, local01
	mov	arg04, local02
	mov	result1, #0
	cmp	arg01, arg03 wcz
	cmpsx	arg02, arg04 wcz
 if_ne	negc	result1, #1
	cmp	result1, #0 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1350
	shl	local06, #9
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	local03, arg01
	add	local03, #24
	rdlong	local03, local03
	mov	local09, local03
	zerox	local09, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	sub	objptr, ##528
	mov	arg02, local05
	mov	arg03, local06
	mov	local08, objptr
	mov	objptr, local09
	call	local03
	mov	objptr, local08
	cmp	result1, local06 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
'     }
'     return RES_OK;
 if_e	mov	result1, #0
LR__1350
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_write_ret
	ret

_fatfs_cc_disk_ioctl
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, ##528
	rdlong	arg01, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
 if_e	jmp	#LR__1360
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	local01, arg01
	add	local01, #40
	rdlong	local01, local01
	mov	local02, local01
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	sub	objptr, ##528
	getbyte	arg02, arg02, #0
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	cmp	result1, #0 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
'     return RES_OK;
 if_e	mov	result1, #0
LR__1360
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_ioctl_ret
	ret

_fatfs_cc_tchar2uni
	rdlong	_var01, arg01
	mov	_var02, _var01
	add	_var01, #1
	mov	_var03, _var01
	rdbyte	_var04, _var02
	test	_var04, #128 wz
 if_e	jmp	#LR__1377
	mov	_var05, _var04
	and	_var05, #224
	cmp	_var05, #192 wz
 if_e	and	_var04, #31
 if_e	mov	_var06, #1
 if_e	jmp	#LR__1371
	mov	_var05, _var04
	and	_var05, #240
	cmp	_var05, #224 wz
 if_e	getnib	_var04, _var04, #0
 if_e	mov	_var06, #2
 if_e	jmp	#LR__1370
	mov	_var05, _var04
	and	_var05, #248
	cmp	_var05, #240 wz
 if_e	and	_var04, #7
 if_e	mov	_var06, #3
' 			return 0xFFFFFFFF;
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_tchar2uni_ret
LR__1370
LR__1371
' 		}
' 		do {
LR__1372
	rdbyte	_var07, _var03
	getbyte	_var05, _var07, #0
	and	_var05, #192
	cmp	_var05, #128 wz
	add	_var03, #1
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_tchar2uni_ret
	shl	_var04, #6
	getbyte	_var02, _var07, #0
	and	_var02, #63
	or	_var04, _var02
	djnz	_var06, #LR__1372
	cmp	_var04, #128 wc
 if_b	jmp	#LR__1374
	cmp	_var04, ##55296 wc
 if_b	jmp	#LR__1373
	cmp	_var04, ##57344 wc
 if_b	jmp	#LR__1374
LR__1373
	cmp	_var04, ##1114112 wc
 if_b	jmp	#LR__1375
LR__1374
	neg	result1, #1
	jmp	#_fatfs_cc_tchar2uni_ret
LR__1375
	cmp	_var04, ##65536 wc
 if_b	jmp	#LR__1376
	mov	_var02, _var04
	sub	_var02, ##65536
	shl	_var02, #6
	and	_var02, ##67043328
	mov	_var05, ##-671032320
	or	_var05, _var02
	zerox	_var04, #9
	or	_var04, _var05
LR__1376
LR__1377
	wrlong	_var03, arg01
' 	}
' #line 811 "ff.c"
' 	*str = p;
' 	return uc;
	mov	result1, _var04
_fatfs_cc_tchar2uni_ret
	ret

_fatfs_cc_put_utf
	cmp	arg01, #128 wc
 if_ae	jmp	#LR__1380
	cmp	arg03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	wrbyte	arg01, arg02
' 		*buf = (TCHAR)chr;
' 		return 1;
	mov	result1, #1
	jmp	#_fatfs_cc_put_utf_ret
LR__1380
	cmp	arg01, ##2048 wc
 if_ae	jmp	#LR__1381
	cmp	arg03, #2 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	mov	result1, arg01
	shr	result1, #6
	and	result1, #31
	mov	arg03, #192
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	arg01, #63
	mov	result1, #128
	or	result1, arg01
	wrbyte	result1, arg02
' 		*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 		return 2;
	mov	result1, #2
	jmp	#_fatfs_cc_put_utf_ret
LR__1381
	cmp	arg01, ##65536 wc
 if_ae	jmp	#LR__1384
	cmp	arg03, #3 wc
 if_b	jmp	#LR__1382
	cmp	arg01, ##55296 wc
 if_b	jmp	#LR__1383
	cmp	arg01, ##57344 wc
 if_ae	jmp	#LR__1383
LR__1382
	mov	result1, #0
	jmp	#_fatfs_cc_put_utf_ret
LR__1383
	getnib	result1, arg01, #3
	mov	arg03, #224
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, arg01
	shr	result1, #6
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	arg01, #63
	mov	result1, #128
	or	result1, arg01
	wrbyte	result1, arg02
' 		*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 		return 3;
	mov	result1, #3
	jmp	#_fatfs_cc_put_utf_ret
LR__1384
	cmp	arg03, #4 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	mov	_var01, arg01
	bitl	_var01, #480
	sub	_var01, ##-671088640
	shr	_var01, #6
	getword	arg01, arg01, #0
	sub	arg01, ##56320
	cmp	_var01, ##1048576 wc
 if_b	cmp	arg01, ##1024 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_put_utf_ret
	or	_var01, arg01
	add	_var01, ##65536
	mov	result1, _var01
	shr	result1, #18
	and	result1, #7
	mov	arg03, #240
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, _var01
	shr	result1, #12
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, _var01
	shr	result1, #6
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	_var01, #63
	mov	result1, #128
	or	result1, _var01
	wrbyte	result1, arg02
' 	chr = (hc | chr) + 0x10000;
' 	*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 	return 4;
	mov	result1, #4
_fatfs_cc_put_utf_ret
	ret

_fatfs_cc_sync_window
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #3
	rdbyte	result1, local01 wz
	sub	local01, #3
 if_e	jmp	#LR__1392
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #48
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1390
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #45
	rdlong	result1, local01
	sub	local01, #12
	rdlong	arg04, local01
	sub	result1, arg04
	sub	local01, #8
	rdlong	arg04, local01
	sub	local01, #28
	cmp	result1, arg04 wc
 if_ae	jmp	#LR__1391
	add	local01, #2
	rdbyte	arg04, local01
	sub	local01, #2
	cmp	arg04, #2 wz
 if_ne	jmp	#LR__1391
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #20
	rdlong	local01, local01
	add	arg03, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	jmp	#LR__1391
LR__1390
	mov	local02, #1
LR__1391
LR__1392
' 			res = FR_DISK_ERR;
' 		}
' 	}
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_window_ret
	ret

_fatfs_cc_move_window
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	add	local01, #48
	rdlong	arg04, local01
	sub	local01, #48
	cmp	local02, arg04 wz
 if_e	jmp	#LR__1401
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__1400
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	mov	arg03, local02
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	neg	local02, #1
 if_ne	mov	local03, #1
	sub	local01, #4
	wrlong	local02, local01
LR__1400
LR__1401
' 				sect = (LBA_t)0 - 1;
' 				res = FR_DISK_ERR;
' 			}
' 			fs->winsect = sect;
' 		}
' 	}
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_move_window_ret
	ret

_fatfs_cc_sync_fs
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	call	#_fatfs_cc_sync_window
	mov	local02, result1 wz
 if_ne	jmp	#LR__1411
	rdbyte	arg04, local01
	cmp	arg04, #3 wz
 if_e	add	local01, #4
 if_e	rdbyte	arg04, local01
 if_e	sub	local01, #4
 if_e	cmp	arg04, #1 wz
 if_ne	jmp	#LR__1410
	add	local01, #52
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	arg01, local01
	add	arg01, #510
	wrword	##43605, arg01
	wrlong	##1096897106, local01
	mov	arg01, local01
	add	arg01, #484
	wrlong	##1631679090, arg01
	mov	arg01, local01
	add	arg01, #488
	sub	local01, #32
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #32
	mov	arg01, local01
	add	arg01, #492
	sub	local01, #36
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #16
	rdlong	arg03, local01
	add	arg03, #1
	add	local01, #16
	wrlong	arg03, local01
	sub	local01, #47
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	sub	local01, #48
	wrbyte	#0, local01
	sub	local01, #4
LR__1410
	add	local01, #1
	rdbyte	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	call	#_fatfs_cc_disk_ioctl
	cmp	result1, #0 wz
 if_ne	mov	local02, #1
LR__1411
' 	}
' 
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_fs_ret
	ret

_fatfs_cc_clst2sect
	sub	arg02, #2
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #24
	sub	_var01, #2
	cmp	arg02, _var01 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_clst2sect_ret
	add	arg01, #10
	rdword	_var01, arg01
	qmul	_var01, arg02
' 	return fs->database + (LBA_t)fs->csize * clst;
	add	arg01, #34
	rdlong	result1, arg01
	getqx	_var01
	add	result1, _var01
_fatfs_cc_clst2sect_ret
	ret

_fatfs_cc_get_fat
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg02
	rdlong	local02, arg01
	cmp	local01, #2 wc
 if_b	jmp	#LR__1420
	add	local02, #24
	rdlong	local03, local02
	sub	local02, #24
	cmp	local01, local03 wc
 if_b	jmp	#LR__1421
LR__1420
	mov	local04, #1
	jmp	#LR__1428
LR__1421
	neg	local04, #1
' 		val = 0xFFFFFFFF;
' 
' 		switch (fs->fs_type) {
	rdbyte	local05, local02
	sub	local05, #1
	fle	local05, #3
	jmprel	local05
LR__1422
	jmp	#LR__1423
	jmp	#LR__1424
	jmp	#LR__1425
	jmp	#LR__1426
LR__1423
	mov	local05, local01
	mov	arg01, local01
	shr	arg01, #1
	add	local05, arg01
	mov	arg01, local02
	mov	local06, local05
	shr	local06, #9
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1427
	mov	local06, local05
	and	local06, #511
	mov	arg01, local02
	add	arg01, #52
	add	local06, arg01
	rdbyte	local07, local06
	mov	arg01, local02
	add	local05, #1
	mov	local06, local05
	shr	local06, #9
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1427
	and	local05, #511
	add	local02, #52
	add	local05, local02
	rdbyte	local06, local05
	shl	local06, #8
	or	local07, local06
	test	local01, #1 wz
 if_ne	shr	local07, #4
 if_ne	mov	local03, local07
 if_e	zerox	local07, #11
 if_e	mov	local03, local07
	mov	local04, local03
' 			wc |= fs->win[bc %  ((UINT) 512 ) ] << 8;
' 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
' 			break;
	jmp	#LR__1427
LR__1424
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #8
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1427
	add	local02, #52
	shl	local01, #1
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, local02
	getword	local04, result1, #0
' 			val = ld_word(fs->win + clst * 2 %  ((UINT) 512 ) );
' 			break;
	jmp	#LR__1427
LR__1425
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #7
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1427
	add	local02, #52
	shl	local01, #2
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local04, local02
	bitl	local04, #124
' 			val = ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0x0FFFFFFF;
' 			break;
	jmp	#LR__1427
LR__1426
	mov	local04, #1
LR__1427
LR__1428
' 			val = 1;
' 		}
' 	}
' 
' 	return val;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fat_ret
	ret

_fatfs_cc_put_fat
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, #2
	cmp	local02, #2 wc
 if_b	jmp	#LR__1437
	add	local01, #24
	rdlong	local05, local01
	sub	local01, #24
	cmp	local02, local05 wc
 if_ae	jmp	#LR__1437
' 		switch (fs->fs_type) {
	rdbyte	local06, local01
	sub	local06, #1
	fle	local06, #3
	jmprel	local06
LR__1430
	jmp	#LR__1431
	jmp	#LR__1434
	jmp	#LR__1435
	jmp	#LR__1436
LR__1431
	mov	local07, local02
	mov	local05, local02
	shr	local05, #1
	add	local07, local05
	mov	arg01, local01
	mov	local06, local07
	shr	local06, #9
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__1436
	mov	local08, local01
	add	local08, #52
	mov	local05, local07
	and	local05, #511
	add	local08, local05
	test	local02, #1 wz
	add	local07, #1
 if_e	jmp	#LR__1432
	rdbyte	local05, local08
	getnib	local05, local05, #0
	getbyte	local06, local03, #0
	shl	local06, #4
	or	local05, local06
	jmp	#LR__1433
LR__1432
	mov	local05, local03
LR__1433
	wrbyte	local05, local08
	add	local01, #3
	wrbyte	#1, local01
	sub	local01, #3
	mov	arg01, local01
	mov	local08, local07
	shr	local08, #9
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__1436
	mov	local08, local01
	add	local08, #52
	and	local07, #511
	add	local08, local07
	test	local02, #1 wz
 if_ne	shr	local03, #4
 if_ne	mov	local05, local03
 if_e	rdbyte	local05, local08
 if_e	and	local05, #240
 if_e	getbyte	local03, local03, #1
 if_e	getnib	local03, local03, #0
 if_e	or	local05, local03
	wrbyte	local05, local08
	add	local01, #3
	wrbyte	#1, local01
' 			p = fs->win + bc %  ((UINT) 512 ) ;
' 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__1436
LR__1434
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #8
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__1436
	add	local01, #52
	mov	arg01, local01
	shl	local02, #1
	and	local02, #511
	add	arg01, local02
	wrword	local03, arg01
	sub	local01, #49
	wrbyte	#1, local01
' 			st_word(fs->win + clst * 2 %  ((UINT) 512 ) , (WORD)val);
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__1436
LR__1435
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #7
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__1436
	bitl	local03, #124
	mov	arg01, local01
	add	arg01, #52
	mov	local08, local02
	shl	local08, #2
	and	local08, #511
	add	arg01, local08
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local08, arg01
	and	local08, ##-268435456
	or	local03, local08
	add	local01, #52
	mov	arg01, local01
	shl	local02, #2
	and	local02, #511
	add	arg01, local02
	wrlong	local03, arg01
	sub	local01, #49
	wrbyte	#1, local01
' 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0xF0000000);
' 			}
' 			st_dword(fs->win + clst * 4 %  ((UINT) 512 ) , val);
' 			fs->wflag = 1;
' 			break;
LR__1436
LR__1437
' 		}
' 	}
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_put_fat_ret
	ret

_fatfs_cc_remove_chain
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	rdlong	local04, local01
	cmp	local02, #2 wc
 if_b	jmp	#LR__1440
	add	local04, #24
	rdlong	result1, local04
	sub	local04, #24
	cmp	local02, result1 wc
 if_b	jmp	#LR__1441
LR__1440
	mov	result1, #2
	jmp	#LR__1446
LR__1441
	cmp	local03, #0 wz
 if_e	jmp	#LR__1442
	mov	arg02, local03
	mov	arg01, local04
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1446
LR__1442
' 	}
' 
' 
' 	do {
LR__1443
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1 wz
 if_e	jmp	#LR__1445
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__1446
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__1446
	mov	arg02, local02
	mov	arg01, local04
	mov	arg03, #0
	call	#_fatfs_cc_put_fat
	mov	local03, result1 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__1446
	add	local04, #24
	rdlong	local03, local04
	sub	local03, #2
	sub	local04, #4
	rdlong	local02, local04
	sub	local04, #20
	cmp	local02, local03 wc
 if_ae	jmp	#LR__1444
	add	local04, #20
	rdlong	local03, local04
	add	local03, #1
	wrlong	local03, local04
	sub	local04, #16
	rdbyte	local03, local04
	or	local03, #1
	wrbyte	local03, local04
	sub	local04, #4
LR__1444
	mov	local02, local05
	add	local04, #24
	rdlong	local05, local04
	sub	local04, #24
	cmp	local02, local05 wc
 if_b	jmp	#LR__1443
LR__1445
' #line 1500 "ff.c"
' 	return FR_OK;
	mov	result1, #0
LR__1446
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_remove_chain_ret
	ret

_fatfs_cc_create_chain
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	rdlong	local03, local01
 if_ne	jmp	#LR__1450
	add	local03, #16
	rdlong	local04, local03 wz
	sub	local03, #16
 if_ne	add	local03, #24
 if_ne	rdlong	local05, local03
 if_ne	sub	local03, #24
 if_ne	cmp	local04, local05 wc
 if_c_and_nz	jmp	#LR__1451
	mov	local04, #1
	jmp	#LR__1451
LR__1450
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, #2 wc
 if_b	mov	result1, #1
 if_b	jmp	#LR__1461
	cmp	local04, ##-1 wz
 if_e	mov	result1, local04
 if_e	jmp	#LR__1461
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local04, local05 wc
 if_b	mov	result1, local04
 if_b	jmp	#LR__1461
	mov	local04, local02
LR__1451
	add	local03, #20
	rdlong	local05, local03 wz
	sub	local03, #20
 if_e	mov	result1, #0
 if_e	jmp	#LR__1461
	mov	local06, #0
	cmp	local04, local02 wz
 if_ne	jmp	#LR__1454
	mov	local06, local04
	add	local06, #1
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #1 wz
 if_ne	cmp	local05, ##-1 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__1461
	cmp	local05, #0 wz
 if_e	jmp	#LR__1453
	add	local03, #16
	rdlong	local07, local03
	sub	local03, #16
	cmp	local07, #2 wc
 if_b	jmp	#LR__1452
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local07, local05 wc
 if_b	mov	local04, local07
LR__1452
	mov	local06, #0
LR__1453
LR__1454
	cmp	local06, #0 wz
 if_ne	jmp	#LR__1457
	mov	local06, local04
' 			ncl = scl;
' 			for (;;) {
LR__1455
	add	local06, #1
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
 if_ae	cmp	local06, local04 wcz
 if_a	mov	result1, #0
 if_a	jmp	#LR__1461
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local07, result1 wz
 if_e	jmp	#LR__1456
	cmp	local07, #1 wz
 if_ne	cmp	local07, ##-1 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__1461
	cmp	local06, local04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__1461
	jmp	#LR__1455
LR__1456
LR__1457
	mov	arg01, local03
	mov	arg02, local06
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	mov	local08, result1 wz
 if_ne	jmp	#LR__1458
	cmp	local02, #0 wz
 if_e	jmp	#LR__1458
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_put_fat
	mov	local08, result1
LR__1458
	cmp	local08, #0 wz
 if_ne	jmp	#LR__1459
	add	local03, #16
	wrlong	local06, local03
	add	local03, #8
	rdlong	local05, local03
	sub	local05, #2
	sub	local03, #4
	rdlong	local09, local03
	sub	local03, #20
	cmp	local09, local05 wcz
 if_be	add	local03, #20
 if_be	rdlong	local09, local03
 if_be	sub	local09, #1
 if_be	wrlong	local09, local03
 if_be	sub	local03, #20
	add	local03, #4
	rdbyte	local05, local03
	or	local05, #1
	wrbyte	local05, local03
	jmp	#LR__1460
LR__1459
	cmp	local08, #1 wz
	negz	local06, #1
LR__1460
' 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
' 	}
' 
' 	return ncl;
	mov	result1, local06
LR__1461
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_chain_ret
	ret

_fatfs_cc_dir_clear
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1472
	mov	arg01, local01
	mov	arg02, local02
	call	#_fatfs_cc_clst2sect
	mov	local03, result1
	add	local01, #48
	wrlong	local03, local01
	add	local01, #4
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	local04, local01
' #line 1667 "ff.c"
' 	{
' 		ibuf = fs->win; szb = 1;
' 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
	mov	local05, #0
	sub	local01, #52
LR__1470
	add	local01, #10
	rdword	local06, local01
	sub	local01, #10
	cmp	local05, local06 wc
 if_ae	jmp	#LR__1471
	add	local01, #1
	rdbyte	arg01, local01
	sub	local01, #1
	mov	arg02, local04
	mov	arg03, local03
	add	arg03, local05
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	add	local05, #1
 if_e	jmp	#LR__1470
LR__1471
' 	}
' 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
	add	local01, #10
	rdword	local04, local01
	cmp	local05, local04 wz
 if_e	mov	local06, #0
 if_ne	mov	local06, #1
	mov	result1, local06
LR__1472
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_clear_ret
	ret

_fatfs_cc_dir_sdi
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	cmp	local02, ##2097152 wc
 if_b	test	local02, #31 wz
' 		return FR_INT_ERR;
 if_nc_or_nz	mov	result1, #2
 if_nc_or_nz	jmp	#LR__1486
	add	local01, #16
	wrlong	local02, local01
	sub	local01, #8
	rdlong	local04, local01 wz
	sub	local01, #8
 if_e	rdbyte	local05, local03
 if_e	cmp	local05, #3 wc
 if_nc_and_z	add	local03, #40
 if_nc_and_z	rdlong	local04, local03
 if_nc_and_z	sub	local03, #40
	cmp	local04, #0 wz
 if_ne	jmp	#LR__1480
	mov	local05, local02
	shr	local05, #5
	add	local03, #8
	rdword	arg02, local03
	sub	local03, #8
	cmp	local05, arg02 wc
 if_ae	mov	result1, #2
 if_ae	jmp	#LR__1486
	add	local03, #40
	rdlong	local05, local03
	sub	local03, #40
	add	local01, #24
	wrlong	local05, local01
	sub	local01, #24
	jmp	#LR__1485
LR__1480
	add	local03, #10
	rdword	local06, local03
	sub	local03, #10
	shl	local06, #9
' 		csz = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 		while (ofs >= csz) {
LR__1481
	cmp	local02, local06 wc
 if_b	jmp	#LR__1484
	mov	arg01, local01
	mov	arg02, local04
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__1486
	cmp	local04, #2 wc
 if_b	jmp	#LR__1482
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local04, local05 wc
 if_b	jmp	#LR__1483
LR__1482
	mov	result1, #2
	jmp	#LR__1486
LR__1483
	sub	local02, local06
	jmp	#LR__1481
LR__1484
	mov	arg01, local03
	mov	arg02, local04
	call	#_fatfs_cc_clst2sect
	add	local01, #24
	wrlong	result1, local01
	sub	local01, #24
LR__1485
	add	local01, #20
	wrlong	local04, local01
	add	local01, #4
	rdlong	local05, local01 wz
	sub	local01, #24
 if_e	mov	result1, #2
 if_e	jmp	#LR__1486
	mov	local06, local02
	shr	local06, #9
	add	local01, #24
	rdlong	local05, local01
	add	local05, local06
	wrlong	local05, local01
	add	local03, #52
	and	local02, #511
	add	local03, local02
	add	local01, #4
	wrlong	local03, local01
' 	dp->sect += ofs /  ((UINT) 512 ) ;
' 	dp->dir = fs->win + (ofs %  ((UINT) 512 ) );
' 
' 	return FR_OK;
	mov	result1, #0
LR__1486
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_sdi_ret
	ret

_fatfs_cc_dir_next
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local01, #16
	rdlong	local04, local01
	sub	local01, #16
	add	local04, #32
	cmp	local04, ##2097152 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
 if_ae	sub	local01, #24
	add	local01, #24
	rdlong	arg02, local01 wz
	sub	local01, #24
 if_e	mov	result1, #4
 if_e	jmp	#LR__1495
	test	local04, #511 wz
 if_ne	jmp	#LR__1494
	add	local01, #24
	rdlong	arg02, local01
	add	arg02, #1
	wrlong	arg02, local01
	sub	local01, #4
	rdlong	arg02, local01 wz
	sub	local01, #20
 if_ne	jmp	#LR__1490
	mov	arg02, local04
	shr	arg02, #5
	add	local03, #8
	rdword	local02, local03
	sub	local03, #8
	cmp	arg02, local02 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
' 				dp->sect = 0; return FR_NO_FILE;
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__1495
	jmp	#LR__1493
LR__1490
	mov	arg01, local04
	shr	arg01, #9
	add	local03, #10
	rdword	arg02, local03
	sub	local03, #10
	sub	arg02, #1
	test	arg01, arg02 wz
 if_ne	jmp	#LR__1492
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #2 wc
 if_b	mov	result1, #2
 if_b	jmp	#LR__1495
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__1495
	add	local03, #24
	rdlong	arg02, local03
	sub	local03, #24
	cmp	local05, arg02 wc
 if_b	jmp	#LR__1491
	cmp	local02, #0 wz
 if_e	add	local01, #24
 if_e	wrlong	#0, local01
' 						dp->sect = 0; return FR_NO_FILE;
 if_e	mov	result1, #4
 if_e	jmp	#LR__1495
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_create_chain
	mov	local05, result1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__1495
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__1495
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__1495
	mov	arg02, local05
	mov	arg01, local03
	call	#_fatfs_cc_dir_clear
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1495
LR__1491
	add	local01, #20
	wrlong	local05, local01
	mov	arg01, local03
	mov	arg02, local05
	call	#_fatfs_cc_clst2sect
	add	local01, #4
	wrlong	result1, local01
	sub	local01, #24
LR__1492
LR__1493
LR__1494
	add	local01, #16
	wrlong	local04, local01
	add	local03, #52
	and	local04, #511
	add	local03, local04
	add	local01, #12
	wrlong	local03, local01
' #line 1771 "ff.c"
' 				}
' 				dp->clust = clst;
' 				dp->sect = clst2sect(fs, clst);
' 			}
' 		}
' 	}
' 	dp->dptr = ofs;
' 	dp->dir = fs->win + ofs %  ((UINT) 512 ) ;
' 
' 	return FR_OK;
	mov	result1, #0
LR__1495
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_next_ret
	ret

_fatfs_cc_dir_alloc
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1 wz
 if_ne	jmp	#LR__1504
	mov	local05, #0
' 		n = 0;
' 		do {
LR__1500
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local03
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__1503
	add	local01, #28
	rdlong	local06, local01
	sub	local01, #28
	rdbyte	local06, local06
	cmp	local06, #229 wz
 if_ne	add	local01, #28
 if_ne	rdlong	local07, local01
 if_ne	sub	local01, #28
 if_ne	rdbyte	local08, local07 wz
 if_ne	jmp	#LR__1501
	add	local05, #1
	cmp	local05, local02 wz
 if_e	jmp	#LR__1503
	jmp	#LR__1502
LR__1501
	mov	local05, #0
LR__1502
	mov	arg01, local01
	mov	arg02, #1
	call	#_fatfs_cc_dir_next
	mov	local04, result1 wz
 if_e	jmp	#LR__1500
LR__1503
LR__1504
	cmp	local04, #4 wz
 if_e	mov	local04, #7
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_alloc_ret
	ret

_fatfs_cc_ld_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	arg01, result1, #0
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
' {
' 
' 	return *((WORD*)ptr);
 if_e	rdword	result1, arg02
 if_e	shl	result1, #16
 if_e	or	arg01, result1
' 		cl |= (DWORD)ld_word(dir +  20 ) << 16;
' 	}
' 
' 	return cl;
	mov	result1, arg01
_fatfs_cc_ld_clust_ret
	ret

_fatfs_cc_st_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
	wrword	arg03, arg01
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
 if_e	shr	arg03, #16
 if_e	wrword	arg03, arg02
_fatfs_cc_st_clust_ret
	ret

_fatfs_cc_cmp_lfn
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__1516
	rdbyte	local02, arg02
	and	local02, #63
	sub	local02, #1
	qmul	local02, #13
' 
' 	i = ((dir[ 0 ] & 0x3F) - 1) * 13;
' 
' 	for (wc = 1, s = 0; s < 13; s++) {
	mov	local03, #1
	mov	local04, #0
	getqx	local05
LR__1510
	cmp	local04, #13 wc
 if_ae	jmp	#LR__1515
	mov	arg01, arg02
	mov	local02, local04
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##942
	add	local02, result1
	rdbyte	local02, local02
	add	arg01, local02
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local06, result1
	mov	local02, local03
	zerox	local02, #15 wz
 if_e	jmp	#LR__1513
	cmp	local05, #256 wc
 if_ae	jmp	#LR__1511
	getword	arg01, local06, #0
	call	#_fatfs_cc_ff_wtoupper
	mov	local02, result1
	mov	local03, local05
	shl	local03, #1
	add	local03, local01
	rdword	arg01, local03
	add	local05, #1
	call	#_fatfs_cc_ff_wtoupper
	cmp	local02, result1 wz
 if_e	jmp	#LR__1512
LR__1511
' 				return 0;
	mov	result1, #0
	jmp	#LR__1516
LR__1512
	mov	local03, local06
	jmp	#LR__1514
LR__1513
	getword	local06, local06, #0
	cmp	local06, ##65535 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__1516
LR__1514
	add	local04, #1
	jmp	#LR__1510
LR__1515
	rdbyte	local02, arg02
	test	local02, #64 wz
 if_ne	cmp	local03, #0 wz
 if_ne	shl	local05, #1
 if_ne	add	local05, local01
 if_ne	rdword	local07, local05 wz
 if_ne	mov	result1, #0
' 
' 	return 1;
 if_e	mov	result1, #1
LR__1516
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_cmp_lfn_ret
	ret

_fatfs_cc_pick_lfn
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__1525
	rdbyte	_var02, arg02
	andn	_var02, #64
	sub	_var02, #1
	qmul	_var02, #13
' 
' 	i = ((dir[ 0 ] & ~ 0x40 ) - 1) * 13;
' 
' 	for (wc = 1, s = 0; s < 13; s++) {
	mov	_var03, #1
	mov	_var04, #0
	getqx	_var05
LR__1520
	cmp	_var04, #13 wc
 if_ae	jmp	#LR__1523
	mov	arg01, arg02
	mov	_var02, _var04
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##942
	add	_var02, result1
	rdbyte	_var02, _var02
	add	arg01, _var02
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	_var06, result1
	mov	_var02, _var03
	zerox	_var02, #15 wz
 if_e	jmp	#LR__1521
	cmp	_var05, #256 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__1525
	mov	_var02, _var05
	shl	_var02, #1
	add	_var02, _var01
	mov	_var03, _var06
	wrword	_var03, _var02
	add	_var05, #1
	jmp	#LR__1522
LR__1521
	getword	_var06, _var06, #0
	cmp	_var06, ##65535 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__1525
LR__1522
	add	_var04, #1
	jmp	#LR__1520
LR__1523
	rdbyte	_var02, arg02
	test	_var02, #64 wz
 if_ne	mov	_var07, _var03
 if_ne	zerox	_var07, #15 wz
 if_e	jmp	#LR__1524
	cmp	_var05, #256 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__1525
	shl	_var05, #1
	add	_var05, _var01
	wrword	#0, _var05
LR__1524
' 		lfnbuf[i] = 0;
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__1525
_fatfs_cc_pick_lfn_ret
	ret

_fatfs_cc_put_lfn
	mov	_var01, arg02
	add	_var01, #13
	wrbyte	arg04, _var01
	getbyte	arg04, arg03, #0
	sub	arg04, #1
	qmul	arg04, #13
	mov	_var02, arg01
	sub	_var01, #2
	wrbyte	#15, _var01
	add	_var01, #1
	wrbyte	#0, _var01
	sub	_var01, #12
	mov	arg01, _var01
	add	arg01, #26
	wrword	#0, arg01
	mov	_var03, #0
	mov	_var04, #0
' 	BYTE* dir,
' 	BYTE ord,
' 	BYTE sum
' )
' {
' 	UINT i, s;
' 	WCHAR wc;
' 
' 
' 	dir[ 13 ] = sum;
' 	dir[ 11 ] =  0x0F ;
' 	dir[ 12 ] = 0;
' 	st_word(dir +  26 , 0);
' 
' 	i = (ord - 1) * 13;
' 	s = wc = 0;
' 	do {
	getqx	_var05
	callpa	#(@LR__1531-@LR__1530)>>2,fcache_load_ptr_
LR__1530
	getword	arg04, _var03, #0
	cmp	arg04, ##65535 wz
 if_ne	mov	arg01, _var05
 if_ne	add	_var05, #1
 if_ne	shl	arg01, #1
 if_ne	add	arg01, _var02
 if_ne	rdword	_var03, arg01
	mov	arg01, _var01
	mov	arg04, _var04
	mov	arg02, ptr__fatfs_cc_dat__
	add	arg02, ##942
	add	arg04, arg02
	rdbyte	arg04, arg04
	add	arg01, arg04
	wrword	_var03, arg01
	mov	arg04, _var03
	zerox	arg04, #15 wz
 if_e	bmask	_var03, #15
	add	_var04, #1
	cmp	_var04, #13 wc
 if_b	jmp	#LR__1530
LR__1531
	getword	_var03, _var03, #0
	cmp	_var03, ##65535 wz
 if_ne	shl	_var05, #1
 if_ne	add	_var05, _var02
 if_ne	rdword	_var05, _var05 wz
 if_e	getbyte	arg03, arg03, #0
 if_e	or	arg03, #64
	wrbyte	arg03, _var01
_fatfs_cc_put_lfn_ret
	ret

_fatfs_cc_gen_numname
	mov	COUNT_, #8
	call	#pushregs_
	add	ptra, #44
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #11
	call	#__system____builtin_memmove
	cmp	local04, #6 wc
 if_b	jmp	#LR__1545
	mov	local05, local04
	callpa	#(@LR__1543-@LR__1540)>>2,fcache_load_ptr_
' 		sreg = seq;
' 		while (*lfn) {
LR__1540
	rdword	local06, local03 wz
 if_e	jmp	#LR__1544
	rdword	local07, local03
' 			wc = *lfn++;
' 			for (i = 0; i < 16; i++) {
	add	local03, #2
	rep	@LR__1542, #16
LR__1541
	shl	local05, #1
	getword	local06, local07, #0
	and	local06, #1
	add	local05, local06
	getword	local07, local07, #0
	shr	local07, #1
	testbn	local05, #16 wz
 if_ne	xor	local05, ##69665
LR__1542
	jmp	#LR__1540
LR__1543
LR__1544
	mov	local04, local05
LR__1545
	mov	local07, #7
	callpa	#(@LR__1547-@LR__1546)>>2,fcache_load_ptr_
' 			}
' 		}
' 		seq = (UINT)sreg;
' 	}
' 
' 
' 	i = 7;
' 	do {
LR__1546
	getnib	local05, local04, #0
	add	local05, #48
	shr	local04, #4
	getbyte	local06, local05, #0
	cmp	local06, #58 wc
 if_ae	getbyte	local05, local05, #0
 if_ae	add	local05, #7
	mov	local06, local07
	sub	local07, #1 wz
	mov	local03, fp
	add	local03, #16
	add	local06, local03
	wrbyte	local05, local06
 if_ne	cmp	local04, #0 wz
 if_ne	jmp	#LR__1546
LR__1547
	mov	local06, local07
	mov	local05, fp
	add	local05, #16
	add	local06, local05
	wrbyte	#126, local06
' 	ns[i] = '~';
' 
' 
' 	for (j = 0; j < i && dst[j] != ' '; j++) {
	mov	local04, #0
	callpa	#(@LR__1550-@LR__1548)>>2,fcache_load_ptr_
LR__1548
	cmp	local04, local07 wc
 if_ae	jmp	#LR__1551
	mov	local05, local04
	add	local05, local01
	rdbyte	local06, local05
	cmp	local06, #32 wz
 if_e	jmp	#LR__1551
	mov	local03, local04
	add	local03, local01
	rdbyte	arg01, local03 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__1549
	mov	local03, local07
	sub	local03, #1
	cmp	local04, local03 wz
 if_e	jmp	#LR__1551
	add	local04, #1
LR__1549
	add	local04, #1
	jmp	#LR__1548
LR__1550
LR__1551
	callpa	#(@LR__1555-@LR__1552)>>2,fcache_load_ptr_
' 			j++;
' 		}
' 	}
' 	do {
LR__1552
	mov	local06, local04
	add	local06, local01
	cmp	local07, #8 wc
	add	local04, #1
 if_ae	jmp	#LR__1553
	mov	local05, local07
	mov	local03, fp
	add	local03, #16
	add	local05, local03
	rdbyte	local08, local05
	add	local07, #1
	jmp	#LR__1554
LR__1553
	mov	local08, #32
LR__1554
	wrbyte	local08, local06
	cmp	local04, #8 wc
 if_b	jmp	#LR__1552
LR__1555
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gen_numname_ret
	ret

_fatfs_cc_sum_sfn
	mov	_var01, #0
' )
' {
' 	BYTE sum = 0;
' 	UINT n = 11;
' 
' 	do {
	callpa	#(@LR__1562-@LR__1560)>>2,fcache_load_ptr_
LR__1560
	rep	@LR__1563, #11
LR__1561
	getbyte	result1, _var01, #0
	shr	result1, #1
	getbyte	_var01, _var01, #0
	shl	_var01, #7
	add	result1, _var01
	rdbyte	_var01, arg01
	add	_var01, result1
	add	arg01, #1
LR__1562
LR__1563
' 	return sum;
	mov	result1, _var01
_fatfs_cc_sum_sfn_ret
	ret

_fatfs_cc_dir_read
	mov	COUNT_, #12
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #4
	rdlong	local04, local01
	mov	local05, #255
	mov	local06, #255
' )
' {
' 	FRESULT res = FR_NO_FILE;
' 	FATFS *fs = dp->obj.fs;
' 	BYTE attr, b;
' 
' 	BYTE ord = 0xFF, sum = 0xFF;
' 
' 
' 	while (dp->sect) {
LR__1570
	add	local01, #24
	rdlong	result1, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__1580
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local04
	call	#_fatfs_cc_move_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__1580
	add	local01, #28
	rdlong	result1, local01
	sub	local01, #28
	rdbyte	local07, result1
	mov	result1, local07
	zerox	result1, #7 wz
 if_e	mov	local03, #4
' 			res = FR_NO_FILE; break;
 if_e	jmp	#LR__1580
	add	local01, #28
	rdlong	local08, local01
	add	local08, #11
	rdbyte	local09, local08
	and	local09, #63
	sub	local01, #22
	wrbyte	local09, local01
	sub	local01, #6
	getbyte	result1, local07, #0
	cmp	result1, #229 wz
 if_ne	mov	local08, local07
 if_ne	getbyte	local08, local08, #0
 if_ne	cmp	local08, #46 wz
 if_e	jmp	#LR__1571
	mov	local10, #0
	getbyte	local08, local09, #0
	andn	local08, #32
	cmp	local08, #8 wz
 if_e	mov	local10, #1
	cmp	local10, local02 wz
 if_e	jmp	#LR__1572
LR__1571
	mov	local05, #255
	jmp	#LR__1579
LR__1572
	getbyte	local09, local09, #0
	cmp	local09, #15 wz
 if_ne	jmp	#LR__1576
	getbyte	local11, local07, #0
	test	local11, #64 wz
 if_e	jmp	#LR__1573
	add	local01, #28
	rdlong	local11, local01
	add	local11, #13
	rdbyte	local06, local11
	getbyte	local07, local07, #0
	and	local07, #191
	mov	local05, local07
	sub	local01, #12
	rdlong	local11, local01
	add	local01, #28
	wrlong	local11, local01
	sub	local01, #44
LR__1573
	getbyte	local08, local07, #0
	getbyte	local10, local05, #0
	cmp	local08, local10 wz
 if_ne	jmp	#LR__1574
	getbyte	local10, local06, #0
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	add	local09, #13
	rdbyte	local08, local09
	getbyte	local09, local08, #0
	cmp	local10, local09 wz
 if_ne	jmp	#LR__1574
	add	local04, #12
	rdlong	arg01, local04
	sub	local04, #12
	add	local01, #28
	rdlong	local12, local01
	sub	local01, #28
	mov	arg02, local12
	call	#_fatfs_cc_pick_lfn
	cmps	result1, #0 wz
 if_ne	mov	local12, local05
 if_ne	getbyte	local12, local12, #0
 if_ne	sub	local12, #1
 if_ne	mov	local11, local12
 if_ne	jmp	#LR__1575
LR__1574
	mov	local11, #255
LR__1575
	mov	local05, local11
	jmp	#LR__1578
LR__1576
	mov	local11, local05
	zerox	local11, #7 wz
 if_ne	jmp	#LR__1577
	getbyte	local06, local06, #0
	add	local01, #28
	rdlong	arg01, local01
	sub	local01, #28
	call	#_fatfs_cc_sum_sfn
	getbyte	result1, result1, #0
	cmp	local06, result1 wz
 if_e	jmp	#LR__1580
LR__1577
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
' 						dp->blk_ofs = 0xFFFFFFFF;
' 					}
' 					break;
	jmp	#LR__1580
LR__1578
LR__1579
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local03, result1 wz
 if_e	jmp	#LR__1570
LR__1580
	cmp	local03, #0 wz
 if_ne	add	local01, #24
 if_ne	wrlong	#0, local01
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_read_ret
	ret

_fatfs_cc_dir_find
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1602
	mov	local03, #255
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
' #line 2404 "ff.c"
' 	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;
' 
' 	do {
LR__1590
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local05, result1 wz
 if_ne	jmp	#LR__1601
	add	local01, #28
	rdlong	arg03, local01
	sub	local01, #28
	rdbyte	local06, arg03
	mov	arg03, local06
	zerox	arg03, #7 wz
 if_e	mov	local05, #4
 if_e	jmp	#LR__1601
	add	local01, #28
	rdlong	local07, local01
	mov	arg03, local07
	add	arg03, #11
	rdbyte	local08, arg03
	and	local08, #63
	sub	local01, #22
	wrbyte	local08, local01
	sub	local01, #6
	getbyte	arg03, local06, #0
	cmp	arg03, #229 wz
 if_e	jmp	#LR__1591
	getbyte	arg03, local08, #0
	test	arg03, #8 wz
 if_ne	mov	local07, local08
 if_ne	getbyte	local07, local07, #0
 if_ne	cmp	local07, #15 wz
 if_e	jmp	#LR__1592
LR__1591
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
	jmp	#LR__1600
LR__1592
	getbyte	local08, local08, #0
	cmp	local08, #15 wz
 if_ne	jmp	#LR__1596
	add	local01, #43
	rdbyte	local08, local01
	sub	local01, #43
	test	local08, #64 wz
 if_ne	jmp	#LR__1599
	getbyte	local09, local06, #0
	test	local09, #64 wz
 if_e	jmp	#LR__1593
	add	local01, #28
	rdlong	local09, local01
	add	local09, #13
	rdbyte	local03, local09
	getbyte	local06, local06, #0
	and	local06, #191
	mov	local04, local06
	sub	local01, #12
	rdlong	local09, local01
	add	local01, #28
	wrlong	local09, local01
	sub	local01, #44
LR__1593
	getbyte	local10, local06, #0
	getbyte	local07, local04, #0
	cmp	local10, local07 wz
 if_ne	jmp	#LR__1594
	getbyte	local08, local03, #0
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	add	local07, #13
	rdbyte	local06, local07
	getbyte	local07, local06, #0
	cmp	local08, local07 wz
 if_ne	jmp	#LR__1594
	add	local02, #12
	rdlong	arg01, local02
	sub	local02, #12
	add	local01, #28
	rdlong	local11, local01
	sub	local01, #28
	mov	arg02, local11
	call	#_fatfs_cc_cmp_lfn
	cmps	result1, #0 wz
 if_ne	mov	local11, local04
 if_ne	getbyte	local11, local11, #0
 if_ne	sub	local11, #1
 if_ne	mov	local09, local11
 if_ne	jmp	#LR__1595
LR__1594
	mov	local09, #255
LR__1595
	mov	local04, local09
	jmp	#LR__1599
LR__1596
	mov	local09, local04
	zerox	local09, #7 wz
 if_ne	jmp	#LR__1597
	getbyte	local10, local03, #0
	add	local01, #28
	rdlong	arg01, local01
	sub	local01, #28
	call	#_fatfs_cc_sum_sfn
	getbyte	result1, result1, #0
	cmp	local10, result1 wz
 if_e	jmp	#LR__1601
LR__1597
	add	local01, #43
	rdbyte	local09, local01
	sub	local01, #43
	test	local09, #1 wz
 if_ne	jmp	#LR__1598
	add	local01, #28
	rdlong	arg01, local01
	add	local01, #4
	mov	arg02, local01
	sub	local01, #32
	mov	arg03, #11
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1601
LR__1598
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
LR__1599
LR__1600
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local05, result1 wz
 if_e	jmp	#LR__1590
LR__1601
' 
' 	return res;
	mov	result1, local05
LR__1602
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_find_ret
	ret

_fatfs_cc_dir_register
	mov	COUNT_, #9
	call	#pushregs_
	add	ptra, #44
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #43
	rdbyte	local03, local01
	sub	local01, #43
	test	local03, #160 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__1621
' 	for (len = 0; fs->lfnbuf[len]; len++) ;
	mov	local04, #0
	add	local02, #12
	callpa	#(@LR__1611-@LR__1610)>>2,fcache_load_ptr_
LR__1610
	rdlong	local03, local02
	mov	arg04, local04
	shl	arg04, #1
	add	arg04, local03
	rdword	local03, arg04 wz
 if_ne	mov	local05, local04
 if_ne	add	local05, #1
 if_ne	mov	local04, local05
 if_ne	jmp	#LR__1610
LR__1611
	sub	local02, #12
	mov	arg01, fp
	add	arg01, #28
	mov	arg02, local01
	add	arg02, #32
	mov	arg03, #12
	call	#__system____builtin_memmove
	add	fp, #39
	rdbyte	local03, fp
	sub	fp, #39
	test	local03, #1 wz
 if_e	jmp	#LR__1614
	add	local01, #43
	wrbyte	#64, local01
	sub	local01, #43
' 		dp->fn[ 11 ] =  0x40 ;
' 		for (n = 1; n < 100; n++) {
	mov	local06, #1
LR__1612
	cmp	local06, #100 wc
 if_ae	jmp	#LR__1613
	mov	arg01, local01
	add	arg01, #32
	mov	arg02, fp
	add	arg02, #28
	add	local02, #12
	rdlong	arg03, local02
	sub	local02, #12
	mov	arg04, local06
	call	#_fatfs_cc_gen_numname
	mov	arg01, local01
	call	#_fatfs_cc_dir_find
	mov	local07, result1 wz
 if_e	add	local06, #1
 if_e	jmp	#LR__1612
LR__1613
	cmp	local06, #100 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__1621
	cmp	local07, #4 wz
 if_ne	mov	result1, local07
 if_ne	jmp	#LR__1621
	add	fp, #39
	rdbyte	local03, fp
	sub	fp, #39
	add	local01, #43
	wrbyte	local03, local01
	sub	local01, #43
LR__1614
	add	fp, #39
	rdbyte	local07, fp
	test	local07, #2 wz
 if_ne	add	local04, #12
 if_ne	qdiv	local04, #13
	sub	fp, #39
	mov	arg01, local01
 if_ne	getqx	local03
 if_ne	add	local03, #1
 if_e	mov	local03, #1
	mov	local08, local03
	mov	arg02, local08
	call	#_fatfs_cc_dir_alloc
	mov	local07, result1 wz
 if_ne	jmp	#LR__1618
	sub	local08, #1 wz
 if_e	jmp	#LR__1618
	mov	arg01, local01
	mov	local07, local08
	shl	local07, #5
	add	local01, #16
	rdlong	arg02, local01
	sub	local01, #16
	sub	arg02, local07
	call	#_fatfs_cc_dir_sdi
	mov	local07, result1 wz
 if_ne	jmp	#LR__1617
	mov	arg01, local01
	add	arg01, #32
	call	#_fatfs_cc_sum_sfn
	mov	local09, result1
' 			sum = sum_sfn(dp->fn);
' 			do {
LR__1615
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local07, result1 wz
 if_ne	jmp	#LR__1616
	add	local02, #12
	rdlong	arg01, local02
	add	local01, #28
	rdlong	arg02, local01
	sub	local01, #28
	mov	arg04, local09
	mov	arg03, local08
	call	#_fatfs_cc_put_lfn
	sub	local02, #9
	wrbyte	#1, local02
	sub	local02, #3
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local07, result1 wz
 if_e	djnz	local08, #LR__1615
LR__1616
LR__1617
LR__1618
	cmp	local07, #0 wz
 if_ne	jmp	#LR__1620
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local07, result1 wz
 if_ne	jmp	#LR__1619
	add	local01, #28
	rdlong	arg01, local01
	mov	arg02, #0
	mov	arg03, #32
	call	#\builtin_bytefill_
	rdlong	arg01, local01
	add	local01, #4
	mov	arg02, local01
	mov	arg03, #11
	call	#__system____builtin_memmove
	sub	local01, #4
	rdlong	local03, local01
	add	local01, #15
	rdbyte	local09, local01
	and	local09, #24
	add	local03, #12
	wrbyte	local09, local03
	add	local02, #3
	wrbyte	#1, local02
LR__1619
LR__1620
' 			__builtin_memset(dp->dir, 0, 32 ) ;
' 			__builtin_memcpy(dp->dir + 0 , dp->fn, 11) ;
' 
' 			dp->dir[ 12 ] = dp->fn[ 11 ] & ( 0x08  |  0x10 );
' 
' 			fs->wflag = 1;
' 		}
' 	}
' 
' 	return res;
	mov	result1, local07
LR__1621
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_register_ret
	ret

_fatfs_cc_dir_remove
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #16
	rdlong	local03, local01
	add	local01, #28
	rdlong	arg02, local01
	sub	local01, #44
	cmp	arg02, ##-1 wz
 if_e	mov	local04, #0
 if_e	jmp	#LR__1630
	mov	arg01, local01
	add	local01, #44
	rdlong	arg02, local01
	sub	local01, #44
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1
LR__1630
	mov	local05, local04 wz
 if_ne	jmp	#LR__1633
' 		do {
LR__1631
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local05, result1 wz
 if_ne	jmp	#LR__1632
	add	local01, #28
	rdlong	local04, local01
	wrbyte	#229, local04
	add	local02, #3
	wrbyte	#1, local02
	sub	local02, #3
	sub	local01, #12
	rdlong	local04, local01
	sub	local01, #16
	cmp	local04, local03 wc
 if_ae	jmp	#LR__1632
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local05, result1 wz
 if_e	jmp	#LR__1631
LR__1632
	cmp	local05, #4 wz
 if_e	mov	local05, #2
LR__1633
' 	}
' #line 2590 "ff.c"
' 	return res;
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_remove_ret
	ret

_fatfs_cc_get_fileinfo
	mov	COUNT_, #12
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local02, #28
	wrbyte	#0, local02
	sub	local02, #28
	add	local01, #24
	rdlong	local04, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__1654
	add	local01, #44
	rdlong	local04, local01
	sub	local01, #44
	cmp	local04, ##-1 wz
 if_e	jmp	#LR__1643
	mov	local05, #0
	mov	local06, #0
	mov	local07, #0
' 			si = di = 0;
' 			hs = 0;
' 			while (fs->lfnbuf[si] != 0) {
LR__1640
	add	local03, #12
	rdlong	local04, local03
	sub	local03, #12
	mov	local08, local06
	shl	local08, #1
	add	local08, local04
	rdword	local04, local08 wz
 if_e	jmp	#LR__1642
	add	local03, #12
	rdlong	local09, local03
	sub	local03, #12
	mov	local04, local06
	shl	local04, #1
	add	local04, local09
	rdword	local10, local04
	mov	local04, local07
	zerox	local04, #15 wz
	add	local06, #1
 if_ne	jmp	#LR__1641
	getword	local04, local10, #0
	cmp	local04, ##55296 wc
 if_b	jmp	#LR__1641
	getword	local11, local10, #0
	cmp	local11, ##57344 wc
 if_b	mov	local07, local10
' 					hs = wc; continue;
 if_b	jmp	#LR__1640
LR__1641
	getword	arg01, local07, #0
	shl	arg01, #16
	getword	local10, local10, #0
	or	arg01, local10
	mov	arg02, local05
	mov	local10, local02
	add	local10, #28
	add	arg02, local10
	mov	arg03, #255
	sub	arg03, local05
	call	#_fatfs_cc_put_utf
	mov	local10, result1 wz
 if_e	mov	local05, #0
 if_ne	add	local05, local10
 if_ne	mov	local07, #0
 if_ne	jmp	#LR__1640
LR__1642
	mov	local04, local07
	zerox	local04, #15 wz
 if_ne	mov	local05, #0
	mov	local10, local02
	add	local10, #28
	add	local05, local10
	wrbyte	#0, local05
LR__1643
	mov	local05, #0
	mov	local06, #0
' 			fno->fname[di] = 0;
' 		}
' 	}
' 
' 	si = di = 0;
' 	while (si < 11) {
LR__1644
	cmp	local06, #11 wc
 if_ae	jmp	#LR__1647
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	mov	local10, local06
	add	local10, local09
	rdbyte	local10, local10
	getword	local04, local10, #0
	cmp	local04, #32 wz
	add	local06, #1
 if_e	jmp	#LR__1644
	getword	local04, local10, #0
	cmp	local04, #5 wz
 if_e	mov	local10, #229
	cmp	local06, #9 wz
 if_ne	jmp	#LR__1645
	cmp	local05, #12 wc
 if_ae	jmp	#LR__1645
	mov	local11, local05
	mov	local08, local02
	add	local08, #12
	add	local11, local08
	wrbyte	#46, local11
	add	local05, #1
LR__1645
	getword	arg01, local10, #0
	zerox	arg01, #7 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_ne	cmp	local06, #8 wz
 if_ne	cmp	local06, #11 wz
 if_e	jmp	#LR__1646
	add	local01, #28
	rdlong	local11, local01
	sub	local01, #28
	mov	local08, local06
	add	local08, local11
	rdbyte	arg01, local08 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__1646
	getword	local10, local10, #0
	shl	local10, #8
	add	local01, #28
	rdlong	local11, local01
	sub	local01, #28
	mov	local09, local06
	add	local09, local11
	rdbyte	local11, local09
	or	local10, local11
	add	local06, #1
LR__1646
	mov	arg01, local10
	mov	arg02, ##850
	call	#_fatfs_cc_ff_oem2uni
	mov	local10, result1
	mov	local04, local10
	zerox	local04, #15 wz
 if_e	mov	local05, #0
 if_e	jmp	#LR__1647
	getword	arg01, local10, #0
	mov	arg02, local05
	mov	local11, local02
	add	local11, #12
	add	arg02, local11
	mov	arg03, #12
	sub	arg03, local05
	call	#_fatfs_cc_put_utf
	mov	local11, result1 wz
 if_e	mov	local05, #0
 if_ne	add	local05, local11
 if_ne	jmp	#LR__1644
LR__1647
	mov	local04, local05
	add	local02, #12
	add	local04, local02
	wrbyte	#0, local04
	add	local02, #16
	rdbyte	local04, local02 wz
	sub	local02, #28
 if_ne	jmp	#LR__1653
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1648
	mov	local11, local05
	mov	local10, local02
	add	local10, #28
	add	local11, local10
	wrbyte	#63, local11
	add	local05, #1
	jmp	#LR__1652
LR__1648
' 			for (si = di = 0, lcf =  0x08 ; fno->altname[si]; si++, di++) {
	mov	local05, #0
	mov	local06, #0
	mov	local12, #8
LR__1649
	mov	local04, local06
	mov	local11, local02
	add	local11, #12
	add	local04, local11
	rdbyte	local11, local04 wz
 if_e	jmp	#LR__1651
	mov	local08, local06
	mov	local11, local02
	add	local11, #12
	add	local08, local11
	rdbyte	local10, local08
	getword	local11, local10, #0
	cmp	local11, #46 wz
 if_e	mov	local12, #16
	getword	local11, local10, #0
	cmp	local11, #65 wc
 if_b	jmp	#LR__1650
	getword	local08, local10, #0
	cmp	local08, #91 wc
 if_ae	jmp	#LR__1650
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	add	local09, #12
	rdbyte	local09, local09
	getbyte	local11, local12, #0
	test	local09, local11 wz
 if_ne	getword	local10, local10, #0
 if_ne	add	local10, #32
LR__1650
	mov	local11, local05
	mov	local08, local02
	add	local08, #28
	add	local11, local08
	getword	local10, local10, #0
	wrbyte	local10, local11
	add	local06, #1
	add	local05, #1
	jmp	#LR__1649
LR__1651
LR__1652
	mov	local12, local02
	add	local12, #28
	add	local05, local12
	wrbyte	#0, local05
	add	local01, #28
	rdlong	local04, local01
	sub	local01, #28
	add	local04, #12
	rdbyte	local11, local04 wz
 if_e	add	local02, #12
 if_e	wrbyte	#0, local02
 if_e	sub	local02, #12
LR__1653
	add	local01, #28
	rdlong	local12, local01
	add	local12, #11
	rdbyte	local04, local12
	and	local04, #63
	add	local02, #8
	wrbyte	local04, local02
	sub	local02, #8
	rdlong	arg01, local01
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	wrlong	result1, local02
	rdlong	arg01, local01
	add	arg01, #22
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local02, #6
	wrword	result1, local02
	rdlong	arg01, local01
	add	arg01, #24
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local02, #2
	wrword	result1, local02
LR__1654
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fileinfo_ret
	ret

_fatfs_cc_create_name
	mov	COUNT_, #18
	call	#pushregs_
	add	ptra, #52
	mov	local01, arg01
	mov	local02, arg02
	rdlong	result1, local02
	add	fp, #48
	wrlong	result1, fp
	sub	fp, #48
	rdlong	local03, local01
	add	local03, #12
	rdlong	local04, local03
	mov	local05, #0
' 
' 
' 
' 	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
' 	for (;;) {
LR__1660
	mov	arg01, fp
	add	arg01, #48
	call	#_fatfs_cc_tchar2uni
	mov	local06, result1
	cmp	local06, ##-1 wz
 if_e	mov	result1, #6
 if_e	jmp	#LR__1694
	cmp	local06, ##65536 wc
 if_b	jmp	#LR__1661
	mov	local03, local05
	shl	local03, #1
	mov	local07, local04
	add	local03, local04
	mov	local08, local06
	shr	local08, #16
	wrword	local08, local03
	add	local05, #1
LR__1661
	mov	local09, local06
	getword	local03, local09, #0
	cmp	local03, #32 wc
 if_b	jmp	#LR__1663
	getword	local10, local09, #0
	cmp	local10, #47 wz
 if_ne	mov	local03, local09
 if_ne	getword	local03, local03, #0
 if_ne	cmp	local03, #92 wz
 if_e	jmp	#LR__1663
	getword	local03, local09, #0
	cmp	local03, #128 wc
 if_ae	jmp	#LR__1662
	mov	arg01, ##@LR__2168
	getword	arg02, local09, #0
	call	#_fatfs_cc_strchr
	mov	local10, result1 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__1694
LR__1662
	cmp	local05, #255 wc
 if_ae	mov	result1, #6
 if_ae	jmp	#LR__1694
	mov	local06, local05
	shl	local06, #1
	mov	local07, local04
	add	local06, local04
	wrword	local09, local06
	add	local05, #1
	jmp	#LR__1660
LR__1663
	getword	local03, local09, #0
	cmp	local03, #32 wc
 if_b	mov	local11, #4
 if_b	jmp	#LR__1668
	callpa	#(@LR__1666-@LR__1664)>>2,fcache_load_ptr_
' 		while ( ((*p) == '/' || (*p) == '\\') ) p++;
LR__1664
	add	fp, #48
	rdlong	local10, fp
	sub	fp, #48
	rdbyte	local03, local10
	cmp	local03, #47 wz
 if_e	jmp	#LR__1665
	add	fp, #48
	rdlong	local08, fp
	sub	fp, #48
	rdbyte	local11, local08
	cmp	local11, #92 wz
 if_ne	jmp	#LR__1667
LR__1665
	add	fp, #48
	rdlong	local11, fp
	add	local11, #1
	wrlong	local11, fp
	sub	fp, #48
	jmp	#LR__1664
LR__1666
LR__1667
	mov	local11, #0
	add	fp, #48
	rdlong	local10, fp
	sub	fp, #48
	rdbyte	local03, local10
	cmp	local03, #32 wc
 if_b	mov	local11, #4
LR__1668
	add	fp, #48
	rdlong	local03, fp
	sub	fp, #48
	wrlong	local03, local02
' 	}
' 	*path = p;
' #line 2862 "ff.c"
' 	while (di) {
	cmp	local05, #0 wz
 if_e	jmp	#LR__1671
	callpa	#(@LR__1670-@LR__1669)>>2,fcache_load_ptr_
LR__1669
	mov	local09, local05
	sub	local09, #1
	shl	local09, #1
	add	local09, local04
	rdword	local09, local09
	getword	local03, local09, #0
	cmp	local03, #32 wz
 if_ne	mov	local10, local09
 if_ne	getword	local10, local10, #0
 if_ne	cmp	local10, #46 wz
 if_e	djnz	local05, #LR__1669
LR__1670
LR__1671
	mov	local10, local05
	shl	local10, #1
	add	local10, local04
	wrword	#0, local10
	cmp	local05, #0 wz
 if_e	mov	result1, #6
 if_e	jmp	#LR__1694
' 
' 
' 	for (si = 0; lfn[si] == ' '; si++) ;
	mov	local12, #0
	callpa	#(@LR__1673-@LR__1672)>>2,fcache_load_ptr_
LR__1672
	mov	local09, local12
	shl	local09, #1
	add	local09, local04
	rdword	local03, local09
	cmp	local03, #32 wz
 if_e	mov	local08, local12
 if_e	add	local08, #1
 if_e	mov	local12, local08
 if_e	jmp	#LR__1672
LR__1673
	cmp	local12, #1 wc
 if_ae	jmp	#LR__1674
	mov	local09, local12
	shl	local09, #1
	add	local09, local04
	rdword	local03, local09
	cmp	local03, #46 wz
 if_ne	jmp	#LR__1675
LR__1674
	getbyte	local11, local11, #0
	or	local11, #3
LR__1675
	callpa	#(@LR__1677-@LR__1676)>>2,fcache_load_ptr_
' 	while (di > 0 && lfn[di - 1] != '.') di--;
LR__1676
	cmp	local05, #1 wc
 if_b	jmp	#LR__1678
	mov	local09, local05
	sub	local09, #1
	shl	local09, #1
	add	local09, local04
	rdword	local03, local09
	cmp	local03, #46 wz
 if_ne	sub	local05, #1
 if_ne	jmp	#LR__1676
LR__1677
LR__1678
	mov	arg01, local01
	add	arg01, #32
	mov	arg02, #32
	mov	arg03, #11
	mov	local13, arg01
	call	#\builtin_bytefill_
	mov	result1, local13
	mov	local14, #0
	mov	local15, #0
	mov	local16, #8
' 
' 	__builtin_memset(dp->fn, ' ', 11) ;
' 	i = b = 0; ni = 8;
' 	for (;;) {
LR__1679
	mov	local17, local12
	mov	local18, local17
	shl	local18, #1
	mov	local07, local04
	add	local18, local04
	rdword	local09, local18
	mov	local03, local09
	zerox	local03, #15 wz
	add	local12, #1
 if_e	jmp	#LR__1692
	getword	local03, local09, #0
	cmp	local03, #32 wz
 if_e	jmp	#LR__1680
	getword	local10, local09, #0
	cmp	local10, #46 wz
 if_ne	jmp	#LR__1681
	cmp	local12, local05 wz
 if_e	jmp	#LR__1681
LR__1680
	getbyte	local11, local11, #0
	or	local11, #3
' 			cf |=  0x01  |  0x02 ;
' 			continue;
	jmp	#LR__1679
LR__1681
	cmp	local15, local16 wc
 if_b	cmp	local12, local05 wz
 if_c_and_nz	jmp	#LR__1682
	cmp	local16, #11 wz
 if_e	getbyte	local11, local11, #0
 if_e	or	local11, #3
' 				cf |=  0x01  |  0x02 ;
' 				break;
 if_e	jmp	#LR__1692
	cmp	local12, local05 wz
 if_ne	getbyte	local11, local11, #0
 if_ne	or	local11, #3
	cmp	local12, local05 wcz
 if_a	jmp	#LR__1692
	mov	local12, local05
	mov	local15, #8
	mov	local16, #11
	getbyte	local14, local14, #0
	shl	local14, #2
' 			si = di; i = 8; ni = 11; b <<= 2;
' 			continue;
	jmp	#LR__1679
LR__1682
	getword	local03, local09, #0
	cmp	local03, #128 wc
 if_b	jmp	#LR__1684
	getbyte	local11, local11, #0
	or	local11, #2
	getword	arg01, local09, #0
	mov	local10, ##850
	mov	arg02, ##850
	call	#_fatfs_cc_ff_uni2oem
	mov	local09, result1
	getword	local03, local09, #0
	test	local03, #128 wz
 if_e	jmp	#LR__1683
	getword	local10, local09, #0
	and	local10, #127
	mov	local17, local10
	mov	local18, ptr__fatfs_cc_dat__
	add	local18, ##955
	add	local17, local18
	rdbyte	local09, local17
LR__1683
LR__1684
	getword	local03, local09, #0
	cmp	local03, #256 wc
 if_b	jmp	#LR__1685
	mov	local03, local16
	sub	local03, #1
	cmp	local15, local03 wc
 if_ae	getbyte	local11, local11, #0
 if_ae	or	local11, #3
 if_ae	mov	local15, local16
' 				cf |=  0x01  |  0x02 ;
' 				i = ni; continue;
 if_ae	jmp	#LR__1679
	mov	local17, local15
	mov	local18, local01
	add	local18, #32
	add	local17, local18
	getword	local07, local09, #0
	shr	local07, #8
	wrbyte	local07, local17
	add	local15, #1
	jmp	#LR__1691
LR__1685
	mov	local03, local09
	zerox	local03, #15 wz
 if_e	jmp	#LR__1686
	mov	arg01, ##@LR__2169
	getword	arg02, local09, #0
	call	#_fatfs_cc_strchr
	cmp	result1, #0 wz
 if_e	jmp	#LR__1687
LR__1686
	mov	local09, #95
	getbyte	local11, local11, #0
	or	local11, #3
	jmp	#LR__1690
LR__1687
	getword	local03, local09, #0
	cmp	local03, #65 wc
 if_b	jmp	#LR__1688
	getword	local10, local09, #0
	cmp	local10, #91 wc
 if_b	getbyte	local14, local14, #0
 if_b	or	local14, #2
LR__1688
	getword	local03, local09, #0
	cmp	local03, #97 wc
 if_b	jmp	#LR__1689
	getword	local10, local09, #0
	cmp	local10, #123 wc
 if_b	getbyte	local14, local14, #0
 if_b	or	local14, #1
 if_b	getword	local09, local09, #0
 if_b	sub	local09, #32
LR__1689
LR__1690
LR__1691
	mov	local17, local15
	mov	local18, local01
	add	local18, #32
	add	local17, local18
	getword	local09, local09, #0
	wrbyte	local09, local17
	add	local15, #1
	jmp	#LR__1679
LR__1692
	add	local01, #32
	rdbyte	local03, local01
	sub	local01, #32
	cmp	local03, #229 wz
 if_e	add	local01, #32
 if_e	wrbyte	#5, local01
 if_e	sub	local01, #32
	cmp	local16, #8 wz
 if_e	getbyte	local14, local14, #0
 if_e	shl	local14, #2
	getbyte	local03, local14, #0
	and	local03, #12
	cmp	local03, #12 wz
 if_ne	mov	local10, local14
 if_ne	getbyte	local10, local10, #0
 if_ne	and	local10, #3
 if_ne	cmp	local10, #3 wz
 if_e	getbyte	local11, local11, #0
 if_e	or	local11, #2
	getbyte	local03, local11, #0
	test	local03, #2 wz
 if_ne	jmp	#LR__1693
	getbyte	local03, local14, #0
	test	local03, #1 wz
 if_ne	getbyte	local11, local11, #0
 if_ne	or	local11, #16
	getbyte	local14, local14, #0
	test	local14, #4 wz
 if_ne	getbyte	local11, local11, #0
 if_ne	or	local11, #8
LR__1693
	add	local01, #43
	wrbyte	local11, local01
' 	}
' 
' 	dp->fn[ 11 ] = cf;
' 
' 	return FR_OK;
	mov	result1, #0
LR__1694
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_name_ret
	ret

_fatfs_cc_follow_path
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #24
	mov	local01, arg01
	add	fp, #8
	wrlong	arg02, fp
	sub	fp, #8
	rdlong	local02, local01
	callpa	#(@LR__1702-@LR__1700)>>2,fcache_load_ptr_
' )
' {
' 	FRESULT res;
' 	BYTE ns;
' 	FATFS *fs = dp->obj.fs;
' #line 3034 "ff.c"
' 	{
' 		while ( ((*path) == '/' || (*path) == '\\') ) path++;
LR__1700
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	rdbyte	result1, result1
	cmp	result1, #47 wz
 if_e	jmp	#LR__1701
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	rdbyte	result1, result1
	cmp	result1, #92 wz
 if_ne	jmp	#LR__1703
LR__1701
	add	fp, #8
	rdlong	result1, fp
	add	result1, #1
	wrlong	result1, fp
	sub	fp, #8
	jmp	#LR__1700
LR__1702
LR__1703
	add	local01, #8
	wrlong	#0, local01
	sub	local01, #8
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	rdbyte	arg02, arg02
	cmp	arg02, #32 wc
 if_ae	jmp	#LR__1704
	add	local01, #43
	wrbyte	#128, local01
	sub	local01, #43
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local03, result1
	jmp	#LR__1708
LR__1704
' 		for (;;) {
LR__1705
	mov	arg02, fp
	add	arg02, #8
	mov	arg01, local01
	call	#_fatfs_cc_create_name
	mov	local03, result1 wz
 if_ne	jmp	#LR__1707
	mov	arg01, local01
	call	#_fatfs_cc_dir_find
	mov	local03, result1 wz
	add	local01, #43
	rdbyte	local04, local01
	sub	local01, #43
 if_e	jmp	#LR__1706
	cmp	local03, #4 wz
 if_ne	jmp	#LR__1707
	getbyte	local04, local04, #0
	test	local04, #4 wz
 if_e	mov	local03, #5
' 					}
' 				}
' 				break;
	jmp	#LR__1707
LR__1706
	getbyte	local04, local04, #0
	test	local04, #4 wz
 if_ne	jmp	#LR__1707
	add	local01, #6
	rdbyte	local04, local01
	sub	local01, #6
	test	local04, #16 wz
 if_e	mov	local03, #5
' 				res = FR_NO_PATH; break;
 if_e	jmp	#LR__1707
	mov	arg01, local02
	mov	arg02, local02
	add	arg02, #52
	add	local01, #16
	rdlong	local04, local01
	and	local04, #511
	add	arg02, local04
	call	#_fatfs_cc_ld_clust
	sub	local01, #8
	wrlong	result1, local01
	sub	local01, #8
	jmp	#LR__1705
LR__1707
LR__1708
' 			}
' #line 3090 "ff.c"
' 			{
' 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr %  ((UINT) 512 ) );
' 			}
' 		}
' 	}
' 
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_follow_path_ret
	ret

_fatfs_cc_get_ldnumber
	neg	_var01, #1
	rdlong	_var02, arg01 wz
	mov	_var03, _var02
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_get_ldnumber_ret
	callpa	#(@LR__1711-@LR__1710)>>2,fcache_load_ptr_
' 	do tc = *tt++; while (! ((UINT)(tc) < ( 1 ? ' ' : '!'))  && tc != ':');
LR__1710
	rdbyte	_var04, _var03
	getbyte	result1, _var04, #0
	cmp	result1, #32 wc
	add	_var03, #1
 if_ae	mov	_var05, _var04
 if_ae	getbyte	_var05, _var05, #0
 if_ae	cmp	_var05, #58 wz
 if_a	jmp	#LR__1710
LR__1711
	getbyte	_var04, _var04, #0
	cmp	_var04, #58 wz
 if_ne	jmp	#LR__1713
	mov	_var06, #1
	rdbyte	_var05, _var02
	cmp	_var05, #48 wc
 if_b	jmp	#LR__1712
	rdbyte	_var05, _var02
	cmp	_var05, #58 wc
 if_b	mov	_var07, _var02
 if_b	add	_var07, #2
 if_b	cmp	_var07, _var03 wz
 if_c_and_z	mov	_var06, _var05
 if_c_and_z	sub	_var06, #48
LR__1712
	cmps	_var06, #1 wc
 if_b	mov	_var01, _var06
 if_b	wrlong	_var03, arg01
' 			vol = i;
' 			*path = tt;
' 		}
' 		return vol;
	mov	result1, _var01
	jmp	#_fatfs_cc_get_ldnumber_ret
LR__1713
' 	}
' #line 3170 "ff.c"
' 	vol = 0;
' 
' 	return vol;
	mov	result1, #0
_fatfs_cc_get_ldnumber_ret
	ret

_fatfs_cc_check_fs
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #45
	wrlong	##-1, local01
	sub	local01, #48
	mov	arg01, local01
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #4
 if_ne	jmp	#LR__1723
	add	local01, #52
	mov	arg01, local01
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	local02, arg01
	rdbyte	local03, local01
	sub	local01, #52
	getbyte	local04, local03, #0
	cmp	local04, #235 wz
 if_ne	mov	arg03, local03
 if_ne	getbyte	arg03, arg03, #0
 if_ne	cmp	arg03, #233 wz
 if_ne	getbyte	local03, local03, #0
 if_ne	cmp	local03, #232 wz
 if_ne	jmp	#LR__1722
	getword	local04, local02, #0
	cmp	local04, ##43605 wz
 if_ne	jmp	#LR__1720
	mov	arg01, local01
	add	arg01, #134
	mov	arg02, ##@LR__2170
	mov	arg03, #8
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
' 			return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__1723
LR__1720
	add	local01, #52
	mov	arg01, local01
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local01, #13
	rdbyte	local03, local01
	sub	local01, #65
	getword	local04, result1, #0
	getword	arg02, result1, #0
	sub	arg02, #1
	test	local04, arg02 wz
 if_ne	jmp	#LR__1721
	getword	arg02, result1, #0
	cmp	arg02, ##512 wc
 if_b	jmp	#LR__1721
	getword	arg02, result1, #0
	cmp	arg02, ##513 wc
 if_ae	jmp	#LR__1721
	mov	arg01, local03
	zerox	arg01, #7 wz
 if_e	jmp	#LR__1721
	getbyte	arg01, local03, #0
	getbyte	local03, local03, #0
	sub	local03, #1
	test	arg01, local03 wz
 if_ne	jmp	#LR__1721
	mov	arg01, local01
	add	arg01, #66
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__1721
	add	local01, #68
	rdbyte	arg01, local01
	sub	local01, #68
	sub	arg01, #1
	cmp	arg01, #2 wc
 if_ae	jmp	#LR__1721
	mov	arg01, local01
	add	arg01, #69
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__1721
	mov	arg01, local01
	add	arg01, #71
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local03, result1, #0
	cmp	local03, #128 wc
 if_b	mov	arg01, local01
 if_b	add	arg01, #84
' {
' 
' 	return *((DWORD*)ptr);
 if_b	rdlong	result1, arg01
 if_b	cmp	result1, ##65536 wc
 if_ae	add	local01, #74
' {
' 
' 	return *((WORD*)ptr);
 if_ae	rdword	result1, local01 wz
' 			&& b != 0 && (b & (b - 1)) == 0
' 			&& ld_word(fs->win +  14 ) != 0
' 			&& (UINT)fs->win[ 16 ] - 1 <= 1
' 			&& ld_word(fs->win +  17 ) != 0
' 			&& (ld_word(fs->win +  19 ) >= 128 || ld_dword(fs->win +  32 ) >= 0x10000)
' 			&& ld_word(fs->win +  22 ) != 0) {
' 				return 0;
 if_a	mov	result1, #0
 if_a	jmp	#LR__1723
LR__1721
LR__1722
' 		}
' 	}
' 	return sign == 0xAA55 ? 2 : 3;
	getword	local03, local02, #0
	cmp	local03, ##43605 wz
 if_e	mov	local04, #2
 if_ne	mov	local04, #3
	mov	result1, local04
LR__1723
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_check_fs_ret
	ret

_fatfs_cc_find_volume
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #36
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_check_fs
	cmp	result1, #2 wz
 if_e	jmp	#LR__1730
	cmp	result1, #3 wc
 if_b	cmp	local02, #0 wz
 if_nc_or_z	jmp	#LR__1738
LR__1730
' 	for (i = 0; i < 4; i++) {
	mov	local03, #0
	callpa	#(@LR__1732-@LR__1731)>>2,fcache_load_ptr_
LR__1731
	cmp	local03, #4 wc
 if_ae	jmp	#LR__1733
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	mov	arg01, local01
	add	arg01, #498
	mov	arg02, local03
	shl	arg02, #4
	add	arg01, arg02
	add	arg01, #8
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	wrlong	result1, local04
	add	local03, #1
	jmp	#LR__1731
LR__1732
LR__1733
	cmp	local02, #0 wz
 if_ne	mov	local04, local02
 if_ne	sub	local04, #1
 if_e	mov	local04, #0
	mov	local03, local04
' 		mbr_pt[i] = ld_dword(fs->win +  446  + i *  16  +  8 );
' 	}
' 	i = part ? part - 1 : 0;
' 	do {
LR__1734
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	rdlong	local04, local04 wz
 if_e	jmp	#LR__1735
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	rdlong	arg02, local04
	mov	arg01, local01
	call	#_fatfs_cc_check_fs
	mov	local04, result1
	jmp	#LR__1736
LR__1735
	mov	local04, #3
LR__1736
	mov	local05, local04
	cmp	local02, #0 wz
 if_e	cmp	local05, #2 wc
 if_c_and_z	jmp	#LR__1737
 if_e	add	local03, #1
 if_e	cmp	local03, #4 wc
 if_c_and_z	jmp	#LR__1734
LR__1737
' 	return fmt;
	mov	result1, local05
LR__1738
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_find_volume_ret
	ret

_fatfs_cc_mount_volume
	mov	COUNT_, #10
	call	#pushregs_
	mov	local01, arg03
	wrlong	#0, arg02
	call	#_fatfs_cc_get_ldnumber
	mov	local02, result1
	cmps	local02, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__1749
	mov	arg03, local02
	shl	arg03, #2
	add	arg03, objptr
	rdlong	local03, arg03 wz
 if_e	mov	result1, #12
 if_e	jmp	#LR__1749
	wrlong	local03, arg02
	getbyte	local01, local01, #0
	and	local01, #254
	rdbyte	arg03, local03 wz
 if_e	jmp	#LR__1741
	add	objptr, ##528
	rdlong	arg01, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
'     }
'     return RES_OK;
 if_ne	mov	result1, #0
	getbyte	arg03, result1, #0
	test	arg03, #1 wz
 if_ne	jmp	#LR__1740
	cmp	local01, #0 wz
 if_ne	getbyte	result1, result1, #0
 if_ne	test	result1, #4 wz
' 				return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__1749
' 			}
' 			return FR_OK;
	mov	result1, #0
	jmp	#LR__1749
LR__1740
LR__1741
	wrbyte	#0, local03
	add	local03, #1
	wrbyte	local02, local03
	sub	local03, #1
	add	objptr, ##528
	rdlong	local02, objptr wz
	sub	objptr, ##528
' 
'         return RES_NOTRDY;
 if_e	mov	result1, #3
'     }
'     return RES_OK;
 if_ne	mov	result1, #0
	mov	arg03, result1
	getbyte	local04, arg03, #0
	test	local04, #1 wz
' 		return FR_NOT_READY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__1749
	cmp	local01, #0 wz
 if_ne	mov	local04, arg03
 if_ne	getbyte	local04, local04, #0
 if_ne	test	local04, #4 wz
' 		return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__1749
	mov	arg01, local03
	mov	arg02, #0
	call	#_fatfs_cc_find_volume
	mov	arg01, result1
	cmp	arg01, #4 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__1749
	cmp	arg01, #2 wc
 if_ae	mov	result1, #13
 if_ae	jmp	#LR__1749
	add	local03, #48
	rdlong	local05, local03
	add	local03, #4
	mov	arg01, local03
	sub	local03, #52
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	cmp	result1, ##512 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__1749
	mov	arg01, local03
	add	arg01, #74
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local06, result1 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #88
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	mov	local06, result1
	add	local03, #28
	wrlong	local06, local03
	add	local03, #40
	rdbyte	local04, local03
	sub	local03, #66
	wrbyte	local04, local03
	getbyte	local04, local04, #0
	sub	local03, #2
	cmp	local04, #1 wz
 if_ne	add	local03, #2
 if_ne	rdbyte	local04, local03
 if_ne	sub	local03, #2
 if_ne	cmp	local04, #2 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__1749
	add	local03, #2
	rdbyte	local04, local03
	qmul	local06, local04
	add	local03, #63
	rdbyte	local04, local03
	sub	local03, #55
	wrword	local04, local03
	getword	local04, local04, #0
	sub	local03, #10
	zerox	local04, #15 wz
	getqx	local06
 if_e	jmp	#LR__1742
	add	local03, #10
	rdword	local04, local03
	getword	local02, local04, #0
	sub	local03, #10
	getword	local04, local04, #0
	sub	local04, #1
	test	local02, local04 wz
 if_e	jmp	#LR__1743
LR__1742
	mov	result1, #13
	jmp	#LR__1749
LR__1743
	add	local03, #52
	mov	arg01, local03
	add	arg01, #17
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local03, #44
	wrword	result1, local03
	getword	local04, result1, #0
	sub	local03, #8
	abs	arg01, local04 wc
	getnib	arg01, arg01, #0
	negc	arg01, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__1749
	mov	arg01, local03
	add	arg01, #71
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local07, result1 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #84
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	local07, arg01
	mov	arg01, local03
	add	arg01, #66
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	arg01, result1
	mov	local04, arg01
	zerox	local04, #15 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__1749
	getword	local08, arg01, #0
	add	local08, local06
	add	local03, #8
	rdword	local04, local03
	sub	local03, #8
	abs	local04, local04 wc
	shr	local04, #4
	sumc	local08, local04
	cmp	local07, local08 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__1749
	sub	local07, local08
	add	local03, #10
	rdword	local04, local03
	qdiv	local07, local04
	sub	local03, #10
	getqx	local04
	cmp	local04, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__1749
	mov	local09, #0
	cmp	local04, ##268435446 wc
 if_b	mov	local09, #3
	cmp	local04, ##65526 wc
 if_b	mov	local09, #2
	cmp	local04, ##4086 wc
 if_b	mov	local09, #1
	cmp	local09, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__1749
	add	local04, #2
	add	local03, #24
	wrlong	local04, local03
	add	local03, #8
	wrlong	local05, local03
	mov	local04, local05
	getword	arg01, arg01, #0
	add	local04, arg01
	add	local03, #4
	wrlong	local04, local03
	mov	local04, local05
	add	local04, local08
	add	local03, #8
	wrlong	local04, local03
	sub	local03, #44
	cmp	local09, #3 wz
 if_ne	jmp	#LR__1744
	mov	arg01, local03
	add	arg01, #94
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__1749
	add	local03, #8
	rdword	local04, local03 wz
	sub	local03, #8
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__1749
	add	local03, #52
	mov	arg01, local03
	add	arg01, #44
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local03, #12
	wrlong	result1, local03
	sub	local03, #16
	rdlong	local10, local03
	sub	local03, #24
	shl	local10, #2
	jmp	#LR__1746
LR__1744
	add	local03, #8
	rdword	local04, local03 wz
	sub	local03, #8
 if_e	mov	result1, #13
 if_e	jmp	#LR__1749
	add	local03, #36
	rdlong	local04, local03
	add	local04, local06
	add	local03, #4
	wrlong	local04, local03
	sub	local03, #40
	cmp	local09, #2 wz
 if_e	add	local03, #24
 if_e	rdlong	local04, local03
 if_e	sub	local03, #24
 if_e	shl	local04, #1
 if_e	jmp	#LR__1745
	add	local03, #24
	rdlong	local10, local03
	mov	local04, local10
	shl	local04, #1
	add	local04, local10
	shr	local04, #1
	sub	local03, #24
	and	local10, #1
	add	local04, local10
LR__1745
	mov	local10, local04
LR__1746
	add	local10, #511
	shr	local10, #9
	add	local03, #28
	rdlong	arg03, local03
	sub	local03, #28
	cmp	arg03, local10 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__1749
	add	local03, #20
	wrlong	##-1, local03
	sub	local03, #4
	wrlong	##-1, local03
	sub	local03, #12
	wrbyte	#128, local03
	sub	local03, #4
	cmp	local09, #3 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #100
' {
' 
' 	return *((WORD*)ptr);
 if_e	rdword	result1, arg01
 if_e	getword	local04, result1, #0
 if_e	cmp	local04, #1 wz
 if_ne	jmp	#LR__1748
	add	local05, #1
	mov	arg01, local03
	mov	arg02, local05
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1748
	add	local03, #4
	wrbyte	#0, local03
	add	local03, #48
	mov	arg01, local03
	sub	local03, #52
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local04, result1, #0
	cmp	local04, ##43605 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #52
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	cmp	result1, ##1096897106 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, ##536
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	cmp	result1, ##1631679090 wz
 if_ne	jmp	#LR__1747
	add	local03, #52
	mov	arg01, local03
	add	arg01, #488
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local03, #32
	wrlong	result1, local03
	add	local03, #32
	mov	arg01, local03
	add	arg01, #492
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local03, #36
	wrlong	result1, local03
	sub	local03, #16
LR__1747
LR__1748
	wrbyte	local09, local03
	add	objptr, #4
	rdword	local04, objptr
	add	local04, #1
	wrword	local04, objptr
	getword	local10, local04, #0
	add	local03, #6
	wrword	local10, local03
	add	objptr, #4
	add	local03, #6
	wrlong	objptr, local03
' 				&& ld_dword(fs->win +  0 ) == 0x41615252
' 				&& ld_dword(fs->win +  484 ) == 0x61417272)
' 			{
' 
' 				fs->free_clst = ld_dword(fs->win +  488 );
' 
' 
' 				fs->last_clst = ld_dword(fs->win +  492 );
' 
' 			}
' 		}
' 
' 
' 	}
' 
' 	fs->fs_type = (BYTE)fmt;
' 	fs->id = ++Fsid;
' 
' 	fs->lfnbuf = LfnBuf;
' #line 3567 "ff.c"
' 	return FR_OK;
	mov	result1, #0
	sub	objptr, #8
LR__1749
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mount_volume_ret
	ret

_fatfs_cc_validate
	mov	_var01, arg01 wz
	mov	_var02, #9
 if_ne	rdlong	_var03, _var01 wz
 if_ne	rdbyte	_var04, _var03 wz
 if_e	jmp	#LR__1750
	add	_var01, #4
	rdword	_var04, _var01
	sub	_var01, #4
	rdlong	arg01, _var01
	add	arg01, #6
	rdword	result1, arg01
	cmp	_var04, result1 wz
 if_ne	jmp	#LR__1750
	add	objptr, ##528
	rdlong	_var04, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
'     }
'     return RES_OK;
 if_ne	mov	result1, #0
	getbyte	_var03, result1, #0
	test	_var03, #1 wz
 if_e	mov	_var02, #0
LR__1750
	cmp	_var02, #0 wz
 if_e	rdlong	_var03, _var01
 if_ne	mov	_var03, #0
	wrlong	_var03, arg02
' 			res = FR_OK;
' 		}
' 
' 	}
' 	*rfs = (res == FR_OK) ? obj->fs : 0;
' 	return res;
	mov	result1, _var02
_fatfs_cc_validate_ret
	ret

_fatfs_cc_f_mount
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #32
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	local01, arg03
	add	fp, #20
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #28
	call	#_fatfs_cc_get_ldnumber
	mov	local02, result1
	cmps	local02, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__1761
	mov	arg03, local02
	shl	arg03, #2
	add	arg03, objptr
	rdlong	local03, arg03 wz
 if_e	jmp	#LR__1760
	add	local03, #1
	rdbyte	arg01, local03
	sub	local03, #1
	call	#_fatfs_cc_disk_deinitialize
	wrbyte	#0, local03
LR__1760
	add	fp, #4
	rdlong	local04, fp wz
	sub	fp, #4
 if_ne	add	fp, #4
 if_ne	rdlong	local04, fp
 if_ne	sub	fp, #4
 if_ne	wrbyte	#0, local04
	shl	local02, #2
	add	local02, objptr
	add	fp, #4
	rdlong	local04, fp
	sub	fp, #4
	wrlong	local04, local02
	zerox	local01, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__1761
	add	fp, #8
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, fp
	sub	fp, #4
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
' 
' 	res = mount_volume(&path, &fs, 0);
' 	return res ;
LR__1761
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mount_ret
	ret

_fatfs_cc_f_open
	mov	COUNT_, #8
	call	#pushregs_
	add	ptra, #96
	mov	local01, arg01 wz
	add	fp, #8
	wrlong	arg02, fp
	sub	fp, #8
	mov	local02, arg03
 if_e	mov	result1, #9
 if_e	jmp	#LR__1787
	getbyte	local02, local02, #0
	and	local02, #63
	add	fp, #8
	mov	arg01, fp
	add	fp, #60
	mov	arg02, fp
	sub	fp, #68
	mov	arg03, local02
	call	#_fatfs_cc_mount_volume
	mov	local03, result1 wz
 if_ne	jmp	#LR__1786
	add	fp, #68
	rdlong	local03, fp
	sub	fp, #48
	wrlong	local03, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	local04, fp
	sub	fp, #8
	mov	arg02, local04
	call	#_fatfs_cc_follow_path
	mov	local03, result1 wz
 if_ne	jmp	#LR__1770
	add	fp, #63
	rdbyte	local04, fp
	sub	fp, #63
	getbyte	arg04, local04, #0
	test	arg04, #128 wz
 if_ne	mov	local03, #6
LR__1770
	getbyte	arg04, local02, #0
	test	arg04, #28 wz
 if_e	jmp	#LR__1775
	cmp	local03, #0 wz
 if_e	jmp	#LR__1772
	cmp	local03, #4 wz
 if_ne	jmp	#LR__1771
	mov	arg01, fp
	add	arg01, #20
	call	#_fatfs_cc_dir_register
	mov	local03, result1
LR__1771
	getbyte	local02, local02, #0
	or	local02, #8
	jmp	#LR__1774
LR__1772
	add	fp, #26
	rdbyte	local04, fp
	sub	fp, #26
	test	local04, #17 wz
 if_ne	mov	local03, #7
 if_ne	jmp	#LR__1773
	getbyte	local04, local02, #0
	test	local04, #4 wz
 if_ne	mov	local03, #8
LR__1773
LR__1774
	cmp	local03, #0 wz
 if_ne	jmp	#LR__1778
	getbyte	local04, local02, #0
	test	local04, #8 wz
 if_e	jmp	#LR__1778
	call	#_fatfs_cc__get_fattime
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #14
	wrlong	result1, arg01
	rdlong	arg01, fp
	add	arg01, #22
	wrlong	result1, arg01
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	mov	local04, result1
	add	fp, #48
	rdlong	arg04, fp
	add	arg04, #11
	wrbyte	#32, arg04
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	mov	arg03, #0
	call	#_fatfs_cc_st_clust
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #28
	wrlong	#0, arg01
	add	fp, #20
	rdlong	arg04, fp
	sub	fp, #68
	add	arg04, #3
	wrbyte	#1, arg04
	cmp	local04, #0 wz
 if_e	jmp	#LR__1778
	add	fp, #68
	rdlong	local03, fp
	add	local03, #48
	rdlong	local05, local03
	sub	fp, #48
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, local04
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	mov	local03, result1 wz
 if_ne	jmp	#LR__1778
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #68
	mov	arg02, local05
	call	#_fatfs_cc_move_window
	mov	local03, result1
	add	fp, #68
	rdlong	local05, fp
	sub	fp, #68
	sub	local04, #1
	add	local05, #16
	wrlong	local04, local05
	jmp	#LR__1778
LR__1775
	cmp	local03, #0 wz
 if_ne	jmp	#LR__1777
	add	fp, #26
	rdbyte	local05, fp
	sub	fp, #26
	test	local05, #16 wz
 if_ne	mov	local03, #4
 if_ne	jmp	#LR__1776
	getbyte	local05, local02, #0
	test	local05, #2 wz
 if_ne	add	fp, #26
 if_ne	rdbyte	local04, fp
 if_ne	sub	fp, #26
 if_ne	test	local04, #1 wz
 if_ne	mov	local03, #7
LR__1776
LR__1777
LR__1778
	cmp	local03, #0 wz
 if_ne	jmp	#LR__1779
	getbyte	local05, local02, #0
	test	local05, #8 wz
 if_ne	getbyte	local02, local02, #0
 if_ne	or	local02, #64
	add	fp, #68
	rdlong	local05, fp
	add	local05, #48
	rdlong	local05, local05
	add	local01, #32
	wrlong	local05, local01
	sub	fp, #20
	rdlong	local05, fp
	sub	fp, #48
	add	local01, #4
	wrlong	local05, local01
	sub	local01, #36
LR__1779
	cmp	local03, #0 wz
 if_ne	jmp	#LR__1785
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	add	local01, #8
	wrlong	result1, local01
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	add	local01, #4
	wrlong	result1, local01
	sub	local01, #12
	add	fp, #20
	rdlong	local05, fp
	wrlong	local05, local01
	rdlong	local05, fp
	sub	fp, #68
	add	local05, #6
	rdword	local04, local05
	add	local01, #4
	wrword	local04, local01
	add	local01, #12
	wrbyte	local02, local01
	add	local01, #1
	wrbyte	#0, local01
	add	local01, #11
	wrlong	#0, local01
	sub	local01, #8
	wrlong	#0, local01
	add	local01, #20
	mov	arg01, local01
	sub	local01, #40
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	getbyte	local02, local02, #0
	test	local02, #32 wz
 if_e	jmp	#LR__1784
	add	local01, #12
	rdlong	local04, local01
	sub	local01, #12
	cmp	local04, #1 wc
 if_b	jmp	#LR__1784
	add	local01, #12
	rdlong	local04, local01
	add	local01, #8
	wrlong	local04, local01
	add	fp, #68
	rdlong	local04, fp
	sub	fp, #68
	add	local04, #10
	rdword	local06, local04
	shl	local06, #9
	sub	local01, #12
	rdlong	local07, local01
' 				fp->fptr = fp->obj.objsize;
' 				bcs = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 				clst = fp->obj.sclust;
' 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
	add	local01, #4
	rdlong	local08, local01
	sub	local01, #12
LR__1780
	cmp	local03, #0 wz
 if_ne	jmp	#LR__1781
	cmp	local08, local06 wcz
 if_be	jmp	#LR__1781
	mov	arg01, local01
	mov	arg02, local07
	call	#_fatfs_cc_get_fat
	mov	local07, result1
	cmp	local07, #2 wc
 if_b	mov	local03, #2
	cmp	local07, ##-1 wz
 if_e	mov	local03, #1
	sub	local08, local06
	jmp	#LR__1780
LR__1781
	add	local01, #24
	wrlong	local07, local01
	sub	local01, #24
	cmp	local03, #0 wz
 if_ne	jmp	#LR__1783
	test	local08, #511 wz
 if_e	jmp	#LR__1783
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #68
	mov	arg02, local07
	call	#_fatfs_cc_clst2sect
	mov	local05, result1 wz
 if_e	mov	local03, #2
 if_e	jmp	#LR__1782
	shr	local08, #9
	add	local05, local08
	add	local01, #28
	wrlong	local05, local01
	add	fp, #68
	rdlong	local04, fp
	sub	fp, #68
	add	local04, #1
	rdbyte	arg01, local04
	mov	arg02, local01
	add	arg02, #12
	mov	arg03, local05
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	mov	local03, #1
LR__1782
LR__1783
LR__1784
LR__1785
LR__1786
	cmp	local03, #0 wz
 if_ne	wrlong	#0, local01
' 
' 	return res ;
	mov	result1, local03
LR__1787
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_open_ret
	ret

_fatfs_cc_f_read
	mov	COUNT_, #14
	call	#pushregs_
	add	ptra, #56
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, local02
	wrlong	#0, local04
	mov	arg02, fp
	add	arg02, #24
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local06, result1 wz
 if_e	add	local01, #17
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #17
 if_e	cmps	local06, #0 wz
 if_ne	mov	result1, local06
 if_ne	jmp	#LR__1801
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__1801
	add	local01, #12
	rdlong	local08, local01
	add	local01, #8
	rdlong	local09, local01
	sub	local01, #20
	sub	local08, local09
	fle	local03, local08 wcz
' 
' 	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
LR__1790
	cmp	local03, #1 wc
 if_b	jmp	#LR__1800
	add	local01, #20
	rdlong	local07, local01
	sub	local01, #20
	test	local07, #511 wz
 if_ne	jmp	#LR__1798
	add	local01, #20
	rdlong	local10, local01
	sub	local01, #20
	shr	local10, #9
	add	fp, #24
	rdlong	local07, fp
	sub	fp, #24
	add	local07, #10
	rdword	local07, local07
	sub	local07, #1
	and	local10, local07 wz
 if_ne	jmp	#LR__1792
	add	local01, #20
	rdlong	local07, local01 wz
	sub	local01, #20
 if_e	add	local01, #8
 if_e	rdlong	local11, local01
 if_e	sub	local01, #8
 if_e	jmp	#LR__1791
	mov	arg01, local01
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	call	#_fatfs_cc_get_fat
	mov	local11, result1
LR__1791
	cmp	local11, #2 wc
 if_b	add	local01, #17
 if_b	wrbyte	#2, local01
 if_b	mov	result1, #2
 if_b	jmp	#LR__1801
	cmp	local11, ##-1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#1, local01
 if_e	mov	result1, #1
 if_e	jmp	#LR__1801
	add	local01, #24
	wrlong	local11, local01
	sub	local01, #24
LR__1792
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #24
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	call	#_fatfs_cc_clst2sect
	mov	local12, result1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__1801
	add	local12, local10
	mov	local13, local03
	shr	local13, #9
	cmp	local13, #1 wc
 if_b	jmp	#LR__1795
	mov	local07, local10
	add	local07, local13
	add	fp, #24
	rdlong	local09, fp
	sub	fp, #24
	add	local09, #10
	rdword	result1, local09
	cmp	local07, result1 wcz
 if_be	jmp	#LR__1793
	add	fp, #24
	rdlong	local13, fp
	sub	fp, #24
	add	local13, #10
	rdword	local13, local13
	sub	local13, local10
LR__1793
	add	fp, #24
	rdlong	local07, fp
	sub	fp, #24
	add	local07, #1
	rdbyte	arg01, local07
	mov	arg02, local05
	mov	arg04, local13
	mov	arg03, local12
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1801
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #128 wz
 if_e	jmp	#LR__1794
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	sub	local09, local12
	cmp	local09, local13 wc
 if_ae	jmp	#LR__1794
	mov	arg01, local05
	add	local01, #28
	rdlong	local10, local01
	sub	local10, local12
	shl	local10, #9
	add	arg01, local10
	add	local01, #12
	mov	arg02, local01
	sub	local01, #40
	decod	arg03, #9
	call	#__system____builtin_memmove
LR__1794
	shl	local13, #9
	mov	local14, local13
' 					__builtin_memcpy(rbuff + ((fp->sect - sect) * ((UINT) 512 ) ), fp->buf, ((UINT) 512 ) ) ;
' 				}
' 
' 
' 				rcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__1799
LR__1795
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	cmp	local07, local12 wz
 if_e	jmp	#LR__1797
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #128 wz
 if_e	jmp	#LR__1796
	add	fp, #24
	rdlong	local14, fp
	sub	fp, #24
	add	local14, #1
	rdbyte	arg01, local14
	add	local01, #40
	mov	arg02, local01
	sub	local01, #12
	rdlong	arg03, local01
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1801
	add	local01, #16
	rdbyte	local07, local01
	and	local07, #127
	wrbyte	local07, local01
	sub	local01, #16
LR__1796
	add	fp, #24
	rdlong	local14, fp
	sub	fp, #24
	add	local14, #1
	rdbyte	arg01, local14
	mov	arg02, local01
	add	arg02, #40
	mov	arg03, local12
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1801
LR__1797
	add	local01, #28
	wrlong	local12, local01
	sub	local01, #28
LR__1798
	add	local01, #20
	rdlong	local13, local01
	and	local13, #511
	decod	local14, #9
	sub	local14, local13
	fle	local14, local03 wcz
	mov	arg02, local01
	add	arg02, #20
	rdlong	local13, local01
	sub	local01, #20
	and	local13, #511
	add	arg02, local13
	mov	arg01, local05
	mov	arg03, local14
	call	#__system____builtin_memmove
LR__1799
	sub	local03, local14
	rdlong	local07, local04
	add	local07, local14
	wrlong	local07, local04
	add	local05, local14
	add	local01, #20
	rdlong	local07, local01
	add	local07, local14
	wrlong	local07, local01
	sub	local01, #20
	jmp	#LR__1790
LR__1800
' 
' 
' 
' 
' 		__builtin_memcpy(rbuff, fp->buf + fp->fptr % ((UINT) 512 ) , rcnt) ;
' 
' 	}
' 
' 	return FR_OK ;
	mov	result1, #0
LR__1801
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_read_ret
	ret

_fatfs_cc_f_write
	mov	COUNT_, #18
	call	#pushregs_
	add	ptra, #52
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, local02
	wrlong	#0, local04
	mov	arg02, fp
	add	arg02, #24
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local06, result1 wz
 if_e	add	local01, #17
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #17
 if_e	cmps	local06, #0 wz
 if_ne	mov	result1, local06
 if_ne	jmp	#LR__1822
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #2 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__1822
	add	local01, #20
	rdlong	local08, local01
	mov	local09, local08
	add	local09, local03
	sub	local01, #20
	cmp	local09, local08 wc
 if_b	neg	local03, #1
 if_b	add	local01, #20
 if_b	rdlong	local10, local01
 if_b	sub	local01, #20
 if_b	sub	local03, local10
' 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
' 	}
' 
' 	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
LR__1810
	cmp	local03, #1 wc
 if_b	jmp	#LR__1821
	add	local01, #20
	rdlong	local07, local01
	sub	local01, #20
	test	local07, #511 wz
 if_ne	jmp	#LR__1819
	add	local01, #20
	rdlong	local11, local01
	sub	local01, #20
	shr	local11, #9
	add	fp, #24
	rdlong	local08, fp
	sub	fp, #24
	mov	local12, local08
	add	local12, #10
	rdword	local13, local12
	sub	local12, #10
	getword	local09, local13, #0
	sub	local09, #1
	and	local11, local09 wz
 if_ne	jmp	#LR__1813
	add	local01, #20
	rdlong	local07, local01 wz
	sub	local01, #20
 if_ne	jmp	#LR__1811
	add	local01, #8
	rdlong	local14, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__1812
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	mov	local14, result1
	jmp	#LR__1812
LR__1811
	mov	arg01, local01
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	call	#_fatfs_cc_create_chain
	mov	local14, result1
LR__1812
	cmp	local14, #0 wz
 if_e	jmp	#LR__1821
	cmp	local14, #1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__1822
	cmp	local14, ##-1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#1, local01
 if_e	mov	result1, #1
 if_e	jmp	#LR__1822
	add	local01, #24
	wrlong	local14, local01
	sub	local01, #16
	rdlong	local07, local01 wz
	sub	local01, #8
 if_e	add	local01, #8
 if_e	wrlong	local14, local01
 if_e	sub	local01, #8
LR__1813
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #128 wz
 if_e	jmp	#LR__1814
	add	fp, #24
	rdlong	local10, fp
	sub	fp, #24
	add	local10, #1
	rdbyte	arg01, local10
	add	local01, #40
	mov	arg02, local01
	sub	local01, #12
	rdlong	arg03, local01
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1822
	add	local01, #16
	rdbyte	local07, local01
	and	local07, #127
	wrbyte	local07, local01
	sub	local01, #16
LR__1814
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #24
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	call	#_fatfs_cc_clst2sect
	mov	local15, result1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__1822
	add	local15, local11
	mov	local16, local03
	shr	local16, #9
	cmp	local16, #1 wc
 if_b	jmp	#LR__1817
	mov	local07, local11
	add	local07, local16
	add	fp, #24
	rdlong	local17, fp
	sub	fp, #24
	add	local17, #10
	rdword	local10, local17
	cmp	local07, local10 wcz
 if_be	jmp	#LR__1815
	add	fp, #24
	rdlong	local10, fp
	sub	fp, #24
	add	local10, #10
	rdword	local16, local10
	sub	local16, local11
LR__1815
	add	fp, #24
	rdlong	local10, fp
	sub	fp, #24
	add	local10, #1
	rdbyte	arg01, local10
	mov	arg02, local05
	mov	arg03, local15
	mov	arg04, local16
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1822
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	sub	local07, local15
	cmp	local07, local16 wc
 if_ae	jmp	#LR__1816
	add	local01, #40
	mov	arg01, local01
	mov	arg02, local05
	sub	local01, #12
	rdlong	local13, local01
	sub	local13, local15
	shl	local13, #9
	add	arg02, local13
	decod	arg03, #9
	call	#__system____builtin_memmove
	sub	local01, #12
	rdbyte	local07, local01
	and	local07, #127
	wrbyte	local07, local01
	sub	local01, #16
LR__1816
	mov	local18, local16
	shl	local18, #9
' 					__builtin_memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT) 512 ) ), ((UINT) 512 ) ) ;
' 					fp->flag &= (BYTE)~ 0x80 ;
' 				}
' 
' 
' 				wcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__1820
LR__1817
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	cmp	local07, local15 wz
 if_e	jmp	#LR__1818
	add	local01, #20
	rdlong	local17, local01
	sub	local01, #8
	rdlong	local12, local01
	sub	local01, #12
	cmp	local17, local12 wc
 if_ae	jmp	#LR__1818
	add	fp, #24
	rdlong	local18, fp
	sub	fp, #24
	add	local18, #1
	rdbyte	arg01, local18
	mov	arg02, local01
	add	arg02, #40
	mov	arg03, local15
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
' 				fp->fptr < fp->obj.objsize &&
' 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
' 					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR ; } ;
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1822
LR__1818
	add	local01, #28
	wrlong	local15, local01
	sub	local01, #28
LR__1819
	add	local01, #20
	rdlong	local10, local01
	and	local10, #511
	decod	local18, #9
	sub	local18, local10
	fle	local18, local03 wcz
	mov	arg01, local01
	add	arg01, #20
	rdlong	local13, local01
	and	local13, #511
	add	arg01, local13
	mov	arg02, local05
	mov	arg03, local18
	call	#__system____builtin_memmove
	sub	local01, #4
	rdbyte	local07, local01
	or	local07, #128
	wrbyte	local07, local01
	sub	local01, #16
LR__1820
	sub	local03, local18
	rdlong	local07, local04
	add	local07, local18
	wrlong	local07, local04
	add	local05, local18
	add	local01, #20
	rdlong	local10, local01
	add	local10, local18
	wrlong	local10, local01
	sub	local01, #8
	rdlong	local09, local01
	sub	local01, #12
	cmp	local10, local09 wcz
 if_a	add	local01, #20
 if_a	rdlong	local07, local01
 if_a	sub	local01, #20
 if_be	add	local01, #12
 if_be	rdlong	local07, local01
 if_be	sub	local01, #12
	add	local01, #12
	wrlong	local07, local01
	sub	local01, #12
	jmp	#LR__1810
LR__1821
	add	local01, #16
	rdbyte	local07, local01
	or	local07, #64
	wrbyte	local07, local01
' 
' 
' 
' 
' 
' 		__builtin_memcpy(fp->buf + fp->fptr % ((UINT) 512 ) , wbuff, wcnt) ;
' 		fp->flag |=  0x80 ;
' 
' 	}
' 
' 	fp->flag |=  0x40 ;
' 
' 	return FR_OK ;
	mov	result1, #0
LR__1822
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_write_ret
	ret

_fatfs_cc_f_sync
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	mov	local01, arg01
	mov	arg02, fp
	add	arg02, #12
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local02, result1 wz
 if_ne	jmp	#LR__1833
	add	local01, #16
	rdbyte	arg04, local01
	sub	local01, #16
	test	arg04, #64 wz
 if_e	jmp	#LR__1832
	add	local01, #16
	rdbyte	local02, local01
	sub	local01, #16
	test	local02, #128 wz
 if_e	jmp	#LR__1830
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local02, #1
	rdbyte	arg01, local02
	add	local01, #40
	mov	arg02, local01
	sub	local01, #12
	rdlong	arg03, local01
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1834
	add	local01, #16
	rdbyte	local02, local01
	and	local02, #127
	wrbyte	local02, local01
	sub	local01, #16
LR__1830
	call	#_fatfs_cc__get_fattime
	mov	local03, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	local01, #32
	rdlong	arg02, local01
	sub	local01, #32
	call	#_fatfs_cc_move_window
	mov	local02, result1 wz
 if_ne	jmp	#LR__1831
	add	local01, #36
	rdlong	local02, local01
	sub	local01, #36
	add	local02, #11
	rdbyte	arg04, local02
	or	arg04, #32
	wrbyte	arg04, local02
	sub	local02, #11
	rdlong	arg01, local01
	add	local01, #8
	rdlong	arg03, local01
	mov	arg02, local02
	call	#_fatfs_cc_st_clust
	mov	arg01, local02
	add	arg01, #28
	add	local01, #4
	rdlong	arg02, local01
	wrlong	arg02, arg01
	mov	arg01, local02
	add	arg01, #22
	wrlong	local03, arg01
	add	local02, #18
	wrword	#0, local02
	add	fp, #12
	rdlong	local03, fp
	add	local03, #3
	wrbyte	#1, local03
	rdlong	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_sync_fs
	mov	local02, result1
	add	local01, #4
	rdbyte	local03, local01
	and	local03, #191
	wrbyte	local03, local01
LR__1831
LR__1832
LR__1833
' 					dir = fp->dir_ptr;
' 					dir[ 11 ] |=  0x20 ;
' 					st_clust(fp->obj.fs, dir, fp->obj.sclust);
' 					st_dword(dir +  28 , (DWORD)fp->obj.objsize);
' 					st_dword(dir +  22 , tm);
' 					st_word(dir +  18 , 0);
' 					fs->wflag = 1;
' 					res = sync_fs(fs);
' 					fp->flag &= (BYTE)~ 0x40 ;
' 				}
' 			}
' 		}
' 	}
' 
' 	return res ;
	mov	result1, local02
LR__1834
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_sync_ret
	ret

_fatfs_cc_f_close
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #16
	mov	local01, arg01
	call	#_fatfs_cc_f_sync
	mov	local02, result1 wz
 if_ne	jmp	#LR__1840
	mov	arg02, fp
	add	arg02, #12
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local02, result1 wz
 if_e	wrlong	#0, local01
LR__1840
' 
' 
' 
' 
' 			fp->obj.fs = 0;
' #line 4192 "ff.c"
' 		}
' 	}
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_close_ret
	ret

_fatfs_cc_f_lseek
	mov	COUNT_, #13
	call	#pushregs_
	add	ptra, #36
	mov	local01, arg01
	mov	local02, arg02
	mov	arg02, fp
	add	arg02, #16
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local03, result1 wz
 if_e	add	local01, #17
 if_e	rdbyte	local03, local01
 if_e	sub	local01, #17
	cmp	local03, #0 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__1866
	add	local01, #12
	rdlong	local04, local01
	sub	local01, #12
	cmp	local02, local04 wcz
 if_be	jmp	#LR__1850
	add	local01, #16
	rdbyte	local05, local01
	sub	local01, #16
	getbyte	local06, local05, #0
	test	local06, #2 wz
 if_e	add	local01, #12
 if_e	rdlong	local02, local01
 if_e	sub	local01, #12
LR__1850
	add	local01, #20
	rdlong	local07, local01
	mov	local08, #0
	wrlong	#0, local01
	sub	local01, #20
	cmp	local02, #1 wc
 if_b	jmp	#LR__1862
	add	fp, #16
	rdlong	local09, fp
	sub	fp, #16
	add	local09, #10
	rdword	local05, local09
	getword	local10, local05, #0
	shl	local10, #9
	mov	local11, local10
	cmp	local07, #1 wc
 if_b	jmp	#LR__1851
	mov	local09, local02
	sub	local09, #1
	qdiv	local09, local11
	mov	local05, local07
	sub	local05, #1
	mov	local12, local11
	getqx	local09
	qdiv	local05, local12
	getqx	local10
	cmp	local09, local10 wc
 if_b	jmp	#LR__1851
	mov	local06, local07
	sub	local06, #1
	mov	local09, local11
	sub	local09, #1
	andn	local06, local09
	add	local01, #20
	wrlong	local06, local01
	sub	local02, local06
	add	local01, #4
	rdlong	local13, local01
	sub	local01, #24
	jmp	#LR__1853
LR__1851
	add	local01, #8
	rdlong	local13, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__1852
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	mov	local13, result1
	cmp	local13, #1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__1866
	cmp	local13, ##-1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#1, local01
 if_e	mov	result1, #1
 if_e	jmp	#LR__1866
	add	local01, #8
	wrlong	local13, local01
	sub	local01, #8
LR__1852
	add	local01, #24
	wrlong	local13, local01
	sub	local01, #24
LR__1853
	cmp	local13, #0 wz
 if_e	jmp	#LR__1861
' 				while (ofs > bcs) {
LR__1854
	cmp	local02, local11 wcz
 if_be	jmp	#LR__1859
	sub	local02, local11
	add	local01, #20
	rdlong	local04, local01
	add	local04, local11
	wrlong	local04, local01
	sub	local01, #4
	rdbyte	local04, local01
	sub	local01, #16
	test	local04, #2 wz
 if_e	jmp	#LR__1855
	mov	arg01, local01
	mov	arg02, local13
	call	#_fatfs_cc_create_chain
	mov	local13, result1 wz
 if_e	mov	local02, #0
' 							ofs = 0; break;
 if_e	jmp	#LR__1859
	jmp	#LR__1856
LR__1855
	mov	arg01, local01
	mov	arg02, local13
	call	#_fatfs_cc_get_fat
	mov	local13, result1
LR__1856
	cmp	local13, ##-1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#1, local01
 if_e	mov	result1, #1
 if_e	jmp	#LR__1866
	cmp	local13, #2 wc
 if_b	jmp	#LR__1857
	add	fp, #16
	rdlong	local04, fp
	sub	fp, #16
	add	local04, #24
	rdlong	local05, local04
	cmp	local13, local05 wc
 if_b	jmp	#LR__1858
LR__1857
	add	local01, #17
	wrbyte	#2, local01
	mov	result1, #2
	jmp	#LR__1866
LR__1858
	add	local01, #24
	wrlong	local13, local01
	sub	local01, #24
	jmp	#LR__1854
LR__1859
	add	local01, #20
	rdlong	local04, local01
	add	local04, local02
	wrlong	local04, local01
	sub	local01, #20
	test	local02, #511 wz
 if_e	jmp	#LR__1860
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	mov	arg02, local13
	call	#_fatfs_cc_clst2sect
	mov	local08, result1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__1866
	shr	local02, #9
	add	local08, local02
LR__1860
LR__1861
LR__1862
	add	local01, #20
	rdlong	local04, local01
	sub	local01, #8
	rdlong	local06, local01
	sub	local01, #12
	cmp	local04, local06 wcz
 if_be	jmp	#LR__1863
	add	local01, #20
	rdlong	local04, local01
	sub	local01, #8
	wrlong	local04, local01
	add	local01, #4
	rdbyte	local04, local01
	or	local04, #64
	wrbyte	local04, local01
	sub	local01, #16
LR__1863
	add	local01, #20
	rdlong	local04, local01
	sub	local01, #20
	test	local04, #511 wz
 if_ne	add	local01, #28
 if_ne	rdlong	local05, local01
 if_ne	sub	local01, #28
 if_ne	cmp	local08, local05 wz
 if_e	jmp	#LR__1865
	add	local01, #16
	rdbyte	local04, local01
	sub	local01, #16
	test	local04, #128 wz
 if_e	jmp	#LR__1864
	add	fp, #16
	rdlong	local09, fp
	sub	fp, #16
	add	local09, #1
	rdbyte	arg01, local09
	add	local01, #40
	mov	arg02, local01
	sub	local01, #12
	rdlong	arg03, local01
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1866
	add	local01, #16
	rdbyte	local04, local01
	and	local04, #127
	wrbyte	local04, local01
	sub	local01, #16
LR__1864
	add	fp, #16
	rdlong	local09, fp
	sub	fp, #16
	add	local09, #1
	rdbyte	arg01, local09
	mov	arg02, local01
	add	arg02, #40
	mov	arg03, local08
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__1866
	add	local01, #28
	wrlong	local08, local01
LR__1865
' 
' 			fp->sect = nsect;
' 		}
' 	}
' 
' 	return res ;
	mov	result1, local03
LR__1866
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_lseek_ret
	ret

_fatfs_cc_f_opendir
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
	mov	local01, arg01 wz
	add	fp, #8
	wrlong	arg02, fp
	sub	fp, #8
 if_e	mov	result1, #9
 if_e	jmp	#LR__1876
	add	fp, #8
	mov	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	mov	local02, result1 wz
 if_ne	jmp	#LR__1875
	add	fp, #16
	rdlong	local02, fp
	wrlong	local02, local01
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	mov	arg01, local01
	call	#_fatfs_cc_follow_path
	mov	local02, result1 wz
 if_ne	jmp	#LR__1874
	add	local01, #43
	rdbyte	arg03, local01
	sub	local01, #43
	test	arg03, #128 wz
 if_ne	jmp	#LR__1872
	add	local01, #6
	rdbyte	arg03, local01
	sub	local01, #6
	test	arg03, #16 wz
 if_e	jmp	#LR__1870
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	add	local01, #28
	rdlong	arg02, local01
	call	#_fatfs_cc_ld_clust
	sub	local01, #20
	wrlong	result1, local01
	sub	local01, #8
	jmp	#LR__1871
LR__1870
	mov	local02, #5
LR__1871
LR__1872
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1873
	add	fp, #16
	rdlong	local02, fp
	sub	fp, #16
	add	local02, #6
	rdword	local02, local02
	add	local01, #4
	wrword	local02, local01
	sub	local01, #4
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local02, result1
LR__1873
LR__1874
	cmp	local02, #4 wz
 if_e	mov	local02, #5
LR__1875
	cmp	local02, #0 wz
 if_ne	wrlong	#0, local01
' 
' 	return res ;
	mov	result1, local02
LR__1876
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_opendir_ret
	ret

_fatfs_cc_f_closedir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	mov	local01, arg01
	mov	arg02, fp
	add	arg02, #12
	mov	arg01, local01
	call	#_fatfs_cc_validate
	cmps	result1, #0 wz
 if_e	wrlong	#0, local01
' 
' 
' 
' 
' 		dp->obj.fs = 0;
' #line 4633 "ff.c"
' 	}
' 	return res;
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_closedir_ret
	ret

_fatfs_cc_f_readdir
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #20
	mov	local01, arg01
	mov	local02, arg02
	mov	arg02, fp
	add	arg02, #16
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local03, result1 wz
 if_ne	jmp	#LR__1883
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1880
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local03, result1
	jmp	#LR__1882
LR__1880
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	mov	local03, result1
	cmp	local03, #4 wz
 if_e	mov	local03, #0
	cmp	local03, #0 wz
 if_ne	jmp	#LR__1881
	mov	arg01, local01
	mov	arg02, local02
	call	#_fatfs_cc_get_fileinfo
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local03, result1
	cmp	local03, #4 wz
 if_e	mov	local03, #0
LR__1881
LR__1882
LR__1883
' 			}
' 			;
' 		}
' 	}
' 	return res ;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_readdir_ret
	ret

_fatfs_cc_f_stat
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #64
	add	fp, #4
	wrlong	arg01, fp
	mov	local01, arg02
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	mov	local02, result1 wz
 if_ne	jmp	#LR__1892
	add	fp, #16
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	mov	local02, result1 wz
 if_ne	jmp	#LR__1891
	add	fp, #59
	rdbyte	arg03, fp
	sub	fp, #59
	test	arg03, #128 wz
 if_ne	mov	local02, #6
 if_ne	jmp	#LR__1890
	cmp	local01, #0 wz
 if_ne	mov	arg01, fp
 if_ne	add	arg01, #16
 if_ne	mov	arg02, local01
 if_ne	call	#_fatfs_cc_get_fileinfo
LR__1890
LR__1891
LR__1892
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_stat_ret
	ret

_fatfs_cc_f_unlink
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #116
	add	fp, #4
	wrlong	arg01, fp
	mov	local01, #0
	mov	arg01, fp
	add	fp, #108
	mov	arg02, fp
	sub	fp, #112
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	mov	local02, result1 wz
 if_ne	jmp	#LR__1908
	add	fp, #112
	rdlong	local02, fp
	sub	fp, #100
	wrlong	local02, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	mov	local02, result1 wz
 if_ne	jmp	#LR__1907
	add	fp, #55
	rdbyte	result1, fp
	sub	fp, #55
	test	result1, #128 wz
 if_ne	mov	local02, #6
 if_ne	jmp	#LR__1900
	add	fp, #18
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #1 wz
 if_ne	mov	local02, #7
LR__1900
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1903
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #72
	rdlong	arg02, fp
	sub	fp, #40
	call	#_fatfs_cc_ld_clust
	mov	local01, result1
	add	fp, #18
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #16 wz
 if_e	jmp	#LR__1902
	add	fp, #112
	rdlong	local02, fp
	sub	fp, #52
	wrlong	local02, fp
	add	fp, #8
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local02, result1 wz
 if_ne	jmp	#LR__1901
	mov	arg01, fp
	add	arg01, #60
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	mov	local02, result1 wz
 if_e	mov	local02, #7
	cmp	local02, #4 wz
 if_e	mov	local02, #0
LR__1901
LR__1902
LR__1903
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1906
	mov	arg01, fp
	add	arg01, #12
	call	#_fatfs_cc_dir_remove
	mov	local02, result1 wz
 if_ne	jmp	#LR__1904
	cmp	local01, #0 wz
 if_e	jmp	#LR__1904
	mov	arg01, fp
	add	arg01, #12
	mov	arg02, local01
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	mov	local02, result1
LR__1904
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1905
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	call	#_fatfs_cc_sync_fs
	mov	local02, result1
LR__1905
LR__1906
LR__1907
LR__1908
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_unlink_ret
	ret

_fatfs_cc_f_mkdir
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #92
	add	fp, #4
	wrlong	arg01, fp
	mov	arg01, fp
	add	fp, #72
	mov	arg02, fp
	sub	fp, #76
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	mov	local01, result1 wz
 if_ne	jmp	#LR__1915
	add	fp, #76
	rdlong	local01, fp
	sub	fp, #64
	wrlong	local01, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	mov	local01, result1 wz
 if_e	mov	local01, #8
	cmp	local01, #4 wz
 if_ne	jmp	#LR__1914
	add	fp, #76
	rdlong	local01, fp
	sub	fp, #16
	wrlong	local01, fp
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	mov	local02, result1 wz
	mov	local01, #0
 if_e	mov	local01, #7
	cmp	local02, #1 wz
 if_e	mov	local01, #2
	cmp	local02, ##-1 wz
 if_e	mov	local01, #1
	call	#_fatfs_cc__get_fattime
	mov	local03, result1
	cmp	local01, #0 wz
 if_ne	jmp	#LR__1911
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	mov	arg02, local02
	call	#_fatfs_cc_dir_clear
	mov	local01, result1 wz
 if_ne	jmp	#LR__1910
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	add	arg01, #52
	mov	arg02, #32
	mov	arg03, #11
	call	#\builtin_bytefill_
	add	fp, #76
	rdlong	local01, fp
	add	local01, #52
	wrbyte	#46, local01
	rdlong	local01, fp
	add	local01, #63
	wrbyte	#16, local01
	rdlong	arg01, fp
	add	arg01, #74
	wrlong	local03, arg01
	rdlong	arg02, fp
	mov	arg01, arg02
	sub	fp, #76
	add	arg02, #52
	mov	arg03, local02
	call	#_fatfs_cc_st_clust
	add	fp, #76
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg01, #84
	sub	fp, #76
	add	arg02, #52
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #76
	rdlong	local01, fp
	add	local01, #85
	wrbyte	#46, local01
	sub	fp, #56
	rdlong	arg03, fp
	add	fp, #56
	rdlong	arg02, fp
	mov	arg01, arg02
	sub	fp, #76
	add	arg02, #84
	call	#_fatfs_cc_st_clust
	add	fp, #76
	rdlong	local01, fp
	sub	fp, #76
	add	local01, #3
	wrbyte	#1, local01
	mov	arg01, fp
	add	arg01, #12
	call	#_fatfs_cc_dir_register
	mov	local01, result1
LR__1910
LR__1911
	cmp	local01, #0 wz
 if_ne	jmp	#LR__1912
	add	fp, #40
	rdlong	arg01, fp
	add	arg01, #22
	wrlong	local03, arg01
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	rdlong	arg02, fp
	sub	fp, #40
	mov	arg03, local02
	call	#_fatfs_cc_st_clust
	add	fp, #40
	rdlong	local03, fp
	add	local03, #11
	wrbyte	#16, local03
	add	fp, #36
	rdlong	local03, fp
	sub	fp, #76
	add	local03, #3
	wrbyte	#1, local03
	cmp	local01, #0 wz
 if_ne	jmp	#LR__1913
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	call	#_fatfs_cc_sync_fs
	mov	local01, result1
	jmp	#LR__1913
LR__1912
	mov	arg01, fp
	add	arg01, #60
	mov	arg02, local02
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
LR__1913
LR__1914
LR__1915
' 				remove_chain(&sobj, dcl, 0);
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mkdir_ret
	ret

_fatfs_cc_f_rename
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #156
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #8
	call	#_fatfs_cc_get_ldnumber
	add	fp, #4
	mov	arg01, fp
	add	fp, #108
	mov	arg02, fp
	sub	fp, #112
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	mov	local01, result1 wz
 if_ne	jmp	#LR__1932
	add	fp, #112
	rdlong	local02, fp
	sub	fp, #96
	wrlong	local02, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	mov	local01, result1 wz
 if_ne	jmp	#LR__1920
	add	fp, #59
	rdbyte	local02, fp
	sub	fp, #59
	test	local02, #160 wz
 if_ne	mov	local01, #6
LR__1920
	cmp	local01, #0 wz
 if_ne	jmp	#LR__1931
	add	fp, #116
	mov	arg01, fp
	sub	fp, #72
	rdlong	arg02, fp
	sub	fp, #44
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #64
	mov	arg01, fp
	sub	fp, #48
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #48
	call	#__system____builtin_memmove
	add	fp, #64
	mov	arg01, fp
	sub	fp, #56
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_follow_path
	mov	local01, result1 wz
 if_ne	jmp	#LR__1923
	add	fp, #72
	rdlong	local01, fp
	sub	fp, #48
	rdlong	result1, fp
	sub	fp, #24
	cmp	local01, result1 wz
 if_ne	jmp	#LR__1921
	add	fp, #80
	rdlong	local01, fp
	sub	fp, #48
	rdlong	result1, fp
	sub	fp, #32
	cmp	local01, result1 wz
 if_e	mov	local02, #4
 if_e	jmp	#LR__1922
LR__1921
	mov	local02, #8
LR__1922
	mov	local01, local02
LR__1923
	cmp	local01, #4 wz
 if_ne	jmp	#LR__1928
	mov	arg01, fp
	add	arg01, #64
	call	#_fatfs_cc_dir_register
	mov	local01, result1 wz
 if_ne	jmp	#LR__1927
	add	fp, #92
	rdlong	local03, fp
	mov	arg01, local03
	add	arg01, #13
	add	fp, #24
	mov	arg02, fp
	sub	fp, #116
	add	arg02, #13
	mov	arg03, #19
	call	#__system____builtin_memmove
	add	fp, #127
	rdbyte	local02, fp
	add	local03, #11
	wrbyte	local02, local03
	getbyte	local02, local02, #0
	sub	local03, #11
	test	local02, #16 wz
 if_e	add	local03, #11
 if_e	rdbyte	local02, local03
 if_e	or	local02, #32
 if_e	wrbyte	local02, local03
 if_e	sub	local03, #11
	sub	fp, #15
	rdlong	local02, fp
	sub	fp, #112
	add	local02, #3
	wrbyte	#1, local02
	add	local03, #11
	rdbyte	local02, local03
	sub	local03, #11
	test	local02, #16 wz
 if_e	jmp	#LR__1926
	add	fp, #24
	rdlong	local02, fp
	add	fp, #48
	rdlong	arg03, fp
	sub	fp, #72
	cmp	local02, arg03 wz
 if_e	jmp	#LR__1926
	add	fp, #112
	rdlong	arg01, fp
	mov	local02, arg01
	sub	fp, #112
	mov	arg02, local03
	call	#_fatfs_cc_ld_clust
	mov	arg02, result1
	mov	arg01, local02
	call	#_fatfs_cc_clst2sect
	mov	local03, result1 wz
 if_e	mov	local01, #2
 if_e	jmp	#LR__1925
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	mov	arg02, local03
	call	#_fatfs_cc_move_window
	mov	local01, result1 wz
	add	fp, #112
	rdlong	local03, fp
	sub	fp, #112
	add	local03, #84
 if_e	add	local03, #1
 if_e	rdbyte	local02, local03
 if_e	sub	local03, #1
 if_e	cmp	local02, #46 wz
 if_ne	jmp	#LR__1924
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #40
	rdlong	arg03, fp
	sub	fp, #72
	mov	arg02, local03
	call	#_fatfs_cc_st_clust
	add	fp, #112
	rdlong	local02, fp
	sub	fp, #112
	add	local02, #3
	wrbyte	#1, local02
LR__1924
LR__1925
LR__1926
LR__1927
LR__1928
	cmp	local01, #0 wz
 if_ne	jmp	#LR__1930
	mov	arg01, fp
	add	arg01, #16
	call	#_fatfs_cc_dir_remove
	mov	local01, result1 wz
 if_ne	jmp	#LR__1929
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	call	#_fatfs_cc_sync_fs
	mov	local01, result1
LR__1929
LR__1930
LR__1931
LR__1932
' 					res = sync_fs(fs);
' 				}
' 			}
' 
' 		}
' 		;
' 	}
' 
' 	return res ;
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_rename_ret
	ret

_fatfs_cc___default_flush
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #8 wz
 if_e	jmp	#LR__1942
	cmps	local03, #1 wc
 if_b	jmp	#LR__1944
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #128 wz
 if_e	jmp	#LR__1941
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #256 wz
 if_e	jmp	#LR__1940
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #256
	wrlong	local06, local01
	sub	local01, #8
LR__1940
LR__1941
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #12
	rdlong	arg02, local02
	sub	local02, #12
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__1944
LR__1942
	add	local01, #8
	rdlong	local06, local01
	sub	local01, #8
	test	local06, #4 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__1943
	neg	arg02, local03
	mov	arg03, arg02
	sar	arg03, #31
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg04, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__1943
LR__1944
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local01, #8
	rdlong	local07, local01
	andn	local07, #12
	wrlong	local07, local01
'     }
'     b->cnt = 0;
'     b->ptr = 0;
'     f->state &= ~( (0x08) | (0x04) );
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_fatfs_cc___default_flush_ret
	ret

_fatfs_cc_getenv
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__1951-@LR__1950)>>2,fcache_load_ptr_
LR__1950
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__1950
LR__1951
	sub	local02, arg01
	mov	result1, local02
	add	ptr__fatfs_cc_dat__, ##1276
	rdlong	arg03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1276
'             return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__1954
' 
' 	for (var = _environ_ptr; (name = *var) != 0; var++) {
	add	ptr__fatfs_cc_dat__, ##1276
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1276
LR__1952
	rdlong	local04, local03 wz
 if_e	jmp	#LR__1953
	mov	arg01, local04
	mov	arg02, local01
	mov	arg03, local02
	call	#_fatfs_cc_strncmp
	cmp	result1, #0 wz
 if_e	mov	local05, local02
 if_e	add	local05, local04
 if_e	rdbyte	local06, local05
 if_e	cmp	local06, #61 wz
' 			return name+len+1;
 if_e	add	local04, local02
 if_e	add	local04, #1
 if_e	mov	result1, local04
 if_e	jmp	#LR__1954
	add	local03, #4
	jmp	#LR__1952
LR__1953
' 	}
' 	return 0;
	mov	result1, #0
LR__1954
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_getenv_ret
	ret

_fatfs_cc__get_fattime
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #52
	mov	arg01, #0
	call	#_fatfs_cc_time
	add	fp, #4
	wrlong	result1, fp
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc__gmtime_r
	add	fp, #36
	rdlong	result1, fp
	sub	result1, #80
	shl	result1, #9
	sub	fp, #4
	rdlong	arg02, fp
	add	arg02, #1
	shl	arg02, #5
	or	result1, arg02
	sub	fp, #4
	rdlong	arg02, fp
	or	result1, arg02
	sub	fp, #4
	rdlong	arg02, fp
	shl	arg02, #11
	sub	fp, #4
	rdlong	arg01, fp
	shl	arg01, #5
	or	arg02, arg01
	sub	fp, #4
	rdlong	arg01, fp
	sub	fp, #16
	or	arg02, arg01
' 
'     now = time(0);
'     _gmtime_r (&now, &date);
'     ffdate = ((date.tm_year - 80) << 9) | ((date.tm_mon + 1) << 5) | ((date.tm_mday));
'     fftime = (date.tm_hour << 11) | (date.tm_min << 5) | (date.tm_sec);
'     return (ffdate << 16) | fftime;
	shl	result1, #16
	or	result1, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__get_fattime_ret
	ret

_fatfs_cc_unixtime_0593
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #52
	mov	local01, arg01
	shr	local01, #9
	and	local01, #127
	mov	local02, #80
	add	local02, local01
	add	fp, #36
	wrlong	local02, fp
	mov	local02, arg01
	shr	local02, #5
	getnib	local02, local02, #0
	sub	local02, #1
	sub	fp, #4
	wrlong	local02, fp
	and	arg01, #31
	sub	fp, #4
	wrlong	arg01, fp
	mov	local02, arg02
	shr	local02, #11
	and	local02, #31
	sub	fp, #4
	wrlong	local02, fp
	mov	local02, arg02
	shr	local02, #5
	and	local02, #63
	sub	fp, #4
	wrlong	local02, fp
	and	arg02, #31
	shl	arg02, #1
	sub	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #16
	call	#_fatfs_cc_mktime
' 
'     date.tm_year = 80 + ((dosdate >> 9) & 0x7f);
'     date.tm_mon = ((dosdate >> 5) & 0xf) - 1;
'     date.tm_mday = (dosdate & 0x1f);
'     date.tm_hour = (dostime >> 11) & 0x1f;
'     date.tm_min = (dostime >> 5) & 0x3f;
'     date.tm_sec = (dostime & 0x1f) << 1;
' 
'     t = mktime(&date);
' #line 66 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return t;
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_unixtime_0593_ret
	ret

_fatfs_cc__set_dos_error_0595
	mov	_var01, arg01
' #line 82 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     switch (derr) {
	fle	_var01, #20
	jmprel	_var01
LR__1960
	jmp	#LR__1961
	jmp	#LR__1975
	jmp	#LR__1976
	jmp	#LR__1977
	jmp	#LR__1962
	jmp	#LR__1963
	jmp	#LR__1964
	jmp	#LR__1965
	jmp	#LR__1967
	jmp	#LR__1970
	jmp	#LR__1966
	jmp	#LR__1971
	jmp	#LR__1972
	jmp	#LR__1973
	jmp	#LR__1978
	jmp	#LR__1978
	jmp	#LR__1978
	jmp	#LR__1968
	jmp	#LR__1974
	jmp	#LR__1969
	jmp	#LR__1978
LR__1961
	mov	_var02, #0
'         r = 0;
'         break;
	jmp	#LR__1979
LR__1962
LR__1963
LR__1964
	mov	_var02, #4
'         r =  4 ;
'         break;
	jmp	#LR__1979
LR__1965
LR__1966
	mov	_var02, #6
'         r =  6 ;
'         break;
	jmp	#LR__1979
LR__1967
	mov	_var02, #9
'         r =  9 ;
'         break;
	jmp	#LR__1979
LR__1968
	mov	_var02, #7
'         r =  7 ;
'         break;
	jmp	#LR__1979
LR__1969
LR__1970
LR__1971
LR__1972
LR__1973
	mov	_var02, #10
'         r =  10 ;
'         break;
	jmp	#LR__1979
LR__1974
	mov	_var02, #11
'         r =  11 ;
'         break;
	jmp	#LR__1979
LR__1975
LR__1976
LR__1977
LR__1978
	mov	_var02, #12
'         r =  12 ;
'         break;
LR__1979
'     }
'     return _seterror(r);
	cmps	_var02, #0 wz
	add	ptr___system__dat__, #32
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
_fatfs_cc__set_dos_error_0595_ret
	ret

_fatfs_cc_v_creat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, ##1592
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__1981
	mov	arg01, local03
	mov	arg02, #0
	mov	arg03, ##1592
	call	#\builtin_bytefill_
	mov	arg01, local03
	add	arg01, ##1040
	mov	arg02, local02
	mov	arg03, #7
	call	#_fatfs_cc_f_open
	mov	local04, result1 wz
 if_e	jmp	#LR__1980
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0595
	jmp	#LR__1981
LR__1980
	wrlong	local03, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__1981
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_creat_ret
	ret

_fatfs_cc_v_close
	mov	COUNT_, #2
	call	#pushregs_
	rdlong	local01, arg01
	mov	arg01, local01
	add	arg01, ##1040
	call	#_fatfs_cc_f_close
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
'     FAT_FIL *f = fil->vfsdata;
'     r=f_close(&f->fil);
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local02
	call	#_fatfs_cc__set_dos_error_0595
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_close_ret
	ret

_fatfs_cc_v_opendir
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, #48
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
' #line 166 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__1991
	mov	arg02, local02
	mov	arg01, local03
	call	#_fatfs_cc_f_opendir
	mov	local04, result1 wz
 if_e	jmp	#LR__1990
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'         free(f);
'         return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0595
	jmp	#LR__1991
LR__1990
	add	local01, #4
	wrlong	local03, local01
'     }
'     dir->vfsdata = f;
'     return 0;
	mov	result1, #0
LR__1991
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_opendir_ret
	ret

_fatfs_cc_v_closedir
	mov	COUNT_, #2
	call	#pushregs_
	add	arg01, #4
	rdlong	local01, arg01
	mov	arg01, local01
	call	#_fatfs_cc_f_closedir
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
	cmp	local02, #0 wz
 if_ne	mov	arg01, local02
 if_ne	call	#_fatfs_cc__set_dos_error_0595
'     return r;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_closedir_ret
	ret

_fatfs_cc_v_readdir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #300
	mov	local01, arg02
	add	arg01, #4
	rdlong	arg01, arg01
	mov	arg02, fp
	add	arg02, #12
	call	#_fatfs_cc_f_readdir
	mov	arg03, result1 wz
 if_e	jmp	#LR__2000
'         return _set_dos_error(r);
	mov	arg01, arg03
	call	#_fatfs_cc__set_dos_error_0595
	jmp	#LR__2001
LR__2000
	add	fp, #40
	rdbyte	arg03, fp wz
	sub	fp, #40
'         return -1;
 if_e	neg	result1, #1
 if_e	jmp	#LR__2001
	mov	arg02, fp
	add	arg02, #40
	mov	arg01, local01
	mov	arg03, #63
	call	#_fatfs_cc_strncpy
	add	local01, #63
	wrbyte	#0, local01
	sub	local01, #63
	add	fp, #20
	rdbyte	arg03, fp
	test	arg03, #16 wz
 if_ne	add	local01, #80
 if_ne	wrbyte	#1, local01
	sumnz	local01, #80
 if_e	wrbyte	#0, local01
 if_e	sub	local01, #80
	sub	fp, #8
	rdlong	arg03, fp
	add	local01, #72
	wrlong	arg03, local01
	add	fp, #4
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #18
	call	#_fatfs_cc_unixtime_0593
	add	local01, #4
	wrlong	result1, local01
'         ent->d_type =  (0) ;
'     }
'     ent->d_size = finfo.fsize;
'     ent->d_mtime = unixtime(finfo.fdate, finfo.ftime);
'     return 0;
	mov	result1, #0
LR__2001
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_readdir_ret
	ret

_fatfs_cc_v_stat
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #304
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local02
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	rdbyte	result2, local01 wz
 if_e	jmp	#LR__2010
	rdbyte	result2, local01
	cmp	result2, #46 wz
 if_e	add	local01, #1
 if_e	rdbyte	local03, local01
 if_e	sub	local01, #1
 if_e	cmps	local03, #0 wz
 if_ne	jmp	#LR__2011
LR__2010
	add	fp, #24
	wrbyte	#16, fp
	sub	fp, #24
	mov	local04, #0
	jmp	#LR__2012
LR__2011
	mov	arg02, fp
	add	arg02, #16
	mov	arg01, local01
	call	#_fatfs_cc_f_stat
	mov	local04, result1
LR__2012
	cmp	local04, #0 wz
 if_e	jmp	#LR__2013
'         return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0595
	jmp	#LR__2014
LR__2013
	mov	local05, #292
	add	fp, #24
	rdbyte	local03, fp
	test	local03, #1 wz
 if_e	mov	local05, #438
	test	local03, #16 wz
 if_ne	or	local05, ##4169
	add	local02, #8
	wrlong	local05, local02
	add	local02, #4
	wrlong	#1, local02
	sub	fp, #8
	rdlong	result1, fp
	add	local02, #12
	wrlong	result1, local02
	add	local02, #4
	wrlong	#0, local02
	add	local02, #4
	wrlong	##512, local02
	rdlong	local03, fp
	add	local03, #511
	shr	local03, #9
	add	local02, #4
	wrlong	local03, local02
	add	fp, #4
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #22
	call	#_fatfs_cc_unixtime_0593
	add	local02, #12
	wrlong	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	result1, local02
'         mode |=  0010000  |  0100  |  0010  |  0001 ;
'     }
'     buf->st_mode = mode;
'     buf->st_nlink = 1;
'     buf->st_size = finfo.fsize;
'     buf->st_blksize = 512;
'     buf->st_blocks = (finfo.fsize + 511) / 512;
'     buf->st_atime = buf->st_mtime = buf->st_ctime = unixtime(finfo.fdate, finfo.ftime);
' #line 257 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return r;
	mov	result1, local04
LR__2014
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_stat_ret
	ret

_fatfs_cc_v_read
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #28
	mov	local01, arg01
	rdlong	arg01, local01 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2021
	add	arg01, ##1040
	mov	arg04, fp
	add	arg04, #24
	call	#_fatfs_cc_f_read
	mov	arg04, result1 wz
 if_e	jmp	#LR__2020
	add	local01, #8
	rdlong	arg01, local01
	or	arg01, #32
	wrlong	arg01, local01
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	mov	arg01, arg04
	call	#_fatfs_cc__set_dos_error_0595
	jmp	#LR__2021
LR__2020
	add	fp, #24
	rdlong	local02, fp wz
 if_e	add	local01, #8
 if_e	rdlong	local02, local01
 if_e	or	local02, #16
 if_e	wrlong	local02, local01
'         fil->state |=  (0x10) ;
'     }
'     return x;
	rdlong	result1, fp
	sub	fp, #24
LR__2021
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_read_ret
	ret

_fatfs_cc_v_write
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #28
	mov	local01, arg01
	rdlong	arg01, local01 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2031
	add	arg01, ##1040
	mov	arg04, fp
	add	arg04, #24
	call	#_fatfs_cc_f_write
	mov	arg04, result1 wz
 if_e	jmp	#LR__2030
	add	local01, #8
	rdlong	arg01, local01
	or	arg01, #32
	wrlong	arg01, local01
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	mov	arg01, arg04
	call	#_fatfs_cc__set_dos_error_0595
	jmp	#LR__2031
LR__2030
'     }
'     return x;
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #24
LR__2031
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_write_ret
	ret

_fatfs_cc_v_lseek
	mov	COUNT_, #6
	call	#pushregs_
	mov	local03, arg02
	mov	local04, arg04
	rdlong	local05, arg01
	add	local05, ##1040 wz
 if_ne	jmp	#LR__2040
'         return _seterror( 5 );
	add	ptr___system__dat__, #32
	wrlong	#5, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result2, #1
	neg	result1, #1
	jmp	#LR__2043
LR__2040
	cmp	local04, #0 wz
 if_e	jmp	#LR__2041
	cmp	local04, #1 wz
 if_e	add	local05, #20
 if_e	rdlong	local06, local05
 if_e	sub	local05, #20
 if_e	add	local03, local06
 if_ne	add	local05, #12
 if_ne	rdlong	local06, local05
 if_ne	sub	local05, #12
 if_ne	add	local03, local06
LR__2041
	mov	arg01, local05
	mov	arg02, local03
	call	#_fatfs_cc_f_lseek
	mov	arg01, result1 wz
 if_e	jmp	#LR__2042
'         return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_0595
	mov	result2, result1
	sar	result2, #31
	jmp	#LR__2043
LR__2042
'     }
'     return (off_t)offset;
	mov	result1, local03
	mov	result2, local02
LR__2043
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_lseek_ret
	ret

_fatfs_cc_v_ioctl
' {
'     return _seterror( 10 );
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
_fatfs_cc_v_ioctl_ret
	ret

_fatfs_cc_v_mkdir
	call	#_fatfs_cc_f_mkdir
	mov	arg01, result1
' 
'     r = f_mkdir(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0595
_fatfs_cc_v_mkdir_ret
	ret

_fatfs_cc_v_remove
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0595
_fatfs_cc_v_remove_ret
	ret

_fatfs_cc_v_rmdir
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0595
_fatfs_cc_v_rmdir_ret
	ret

_fatfs_cc_v_rename
	call	#_fatfs_cc_f_rename
	mov	arg01, result1
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0595
_fatfs_cc_v_rename_ret
	ret

_fatfs_cc_v_open
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, ##1592
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local04, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2056
	mov	arg01, local04
	mov	arg02, #0
	mov	arg03, ##1592
	call	#\builtin_bytefill_
'   switch (flags & 3) {
	mov	local05, local03
	and	local05, #3 wz
 if_e	jmp	#LR__2050
	cmp	local05, #1 wz
 if_e	jmp	#LR__2051
	jmp	#LR__2052
LR__2050
	mov	local06, #1
'       fs_flags =  0x01 ;
'       break;
	jmp	#LR__2053
LR__2051
	mov	local06, #2
'       fs_flags =  0x02 ;
'       break;
	jmp	#LR__2053
LR__2052
	mov	local06, #3
'       fs_flags =  0x01  |  0x02 ;
'       break;
LR__2053
	test	local03, #8 wz
 if_ne	or	local06, #24
 if_ne	jmp	#LR__2054
	test	local03, #32 wz
 if_ne	or	local06, #48
LR__2054
	mov	arg01, local04
	add	arg01, ##1040
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_f_open
	mov	local07, result1 wz
 if_e	jmp	#LR__2055
	mov	arg01, local04
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
' #line 426 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(r);
	mov	arg01, local07
	call	#_fatfs_cc__set_dos_error_0595
	jmp	#LR__2056
LR__2055
	wrlong	local04, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__2056
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_open_ret
	ret

_fatfs_cc_v_flush
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	call	#_fatfs_cc___default_flush
	rdlong	local01, local01
	add	local01, ##1040 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2060
	mov	arg01, local01
	call	#_fatfs_cc_f_sync
	mov	arg01, result1
'     }
' #line 449 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     result = f_sync(f);
' #line 453 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_0595
LR__2060
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_flush_ret
	ret

_fatfs_cc_v_init
' {
'     return 0;
	mov	result1, #0
_fatfs_cc_v_init_ret
	ret

_fatfs_cc_v_deinit
	mov	arg02, ##@LR__2171
	mov	arg01, #0
	mov	arg03, #0
	call	#_fatfs_cc_f_mount
	add	objptr, ##520
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##524
	call	#__system___freepins
' #line 474 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     _freepins(f_pinmask);
'     return 0;
	mov	result1, #0
_fatfs_cc_v_deinit_ret
	ret

_fatfs_cc_get_vfs
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #88
	call	#__system___gc_alloc_managed
	mov	arg01, result1
	mov	result1, objptr
	bith	result1, #116
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #24
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##17825792
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##18874368
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##19922944
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##20971520
	add	arg01, #4
	wrlong	result1, arg01
	add	arg01, #4
	wrlong	local01, arg01
	add	arg01, #4
	wrlong	#0, arg01
	mov	result1, objptr
	or	result1, ##22020096
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##23068672
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##24117248
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #55
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##26214400
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##27262976
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##28311552
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #86
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##30408704
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #117
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #148
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #25
	add	arg01, #4
	wrlong	result1, arg01
	add	arg01, #4
	wrlong	#0, arg01
	add	arg01, #4
	wrlong	#0, arg01
	sub	arg01, #84
' 
'     v->close = &v_close;
'     v->read = &v_read;
'     v->write = &v_write;
'     v->lseek = &v_lseek;
'     v->ioctl = &v_ioctl;
'     v->flush = &v_flush;
'     v->vfs_data = ptr;
'     v->reserved = 0;
' 
'     v->open = &v_open;
'     v->creat = &v_creat;
'     v->opendir = &v_opendir;
'     v->closedir = &v_closedir;
'     v->readdir = &v_readdir;
'     v->stat = &v_stat;
' 
'     v->mkdir = &v_mkdir;
'     v->rmdir = &v_rmdir;
' 
'     v->remove = &v_remove;
'     v->rename = &v_rename;
' 
'     v->init = &v_init;
'     v->deinit = &v_deinit;
' 
' 
'     v->getcf = 0;
'     v->putcf = 0;
' #line 532 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return v;
	mov	result1, arg01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_vfs_ret
	ret

_fatfs_cc_gettimeofday
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	call	#__system___getus
	mov	arg01, result1
	add	ptr__fatfs_cc_dat__, ##1288
	rdlong	local02, ptr__fatfs_cc_dat__
	mov	result1, arg01
	sub	result1, local02
	qdiv	result1, ##1000000
	sub	ptr__fatfs_cc_dat__, ##1288
	getqx	local02
	qdiv	result1, ##1000000
	cmp	local02, #0 wz
	getqy	local03
 if_e	jmp	#LR__2070
	add	ptr__fatfs_cc_dat__, ##1284
	rdlong	local04, ptr__fatfs_cc_dat__
	add	local04, local02
	wrlong	local04, ptr__fatfs_cc_dat__
	sub	arg01, local03
	add	ptr__fatfs_cc_dat__, #4
	wrlong	arg01, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1288
LR__2070
	add	ptr__fatfs_cc_dat__, ##1284
	rdlong	local04, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1284
	wrlong	local04, local01
	add	local01, #4
	wrlong	local03, local01
'         lastsec += secs;
'         lastus = now - leftover;
'     }
'     tv->tv_sec = lastsec;
'     tv->tv_usec = leftover;
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gettimeofday_ret
	ret

_fatfs_cc__is_leap_year
	abs	result1, arg01 wc
	and	result1, #3
	negc	result1, result1 wz
 if_ne	jmp	#LR__2081
	abs	result1, arg01 wc
	qdiv	result1, #100
	getqy	result1
	negc	result1, result1 wz
 if_ne	jmp	#LR__2080
	abs	result1, arg01 wc
	qdiv	result1, #400
'       return (0 == y % 400);
	mov	result1, #0
	getqy	_var01
	negc	_var01, _var01 wz
 if_e	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__2080
'     return 1;
	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__2081
'   }
'   return 0;
	mov	result1, #0
_fatfs_cc__is_leap_year_ret
	ret

_fatfs_cc___tzoffset
	mov	_var01, arg01 wz
	wrlong	##-1, arg02
	mov	_var02, #1
 if_ne	rdbyte	_var03, _var01 wz
'                 return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__2107
	wrlong	#0, arg02
	mov	_var04, ptr__fatfs_cc_dat__
	add	_var04, ##1244
	callpa	#(@LR__2091-@LR__2090)>>2,fcache_load_ptr_
' 
'        *hasdst = 0;
' 
' 	n = stdname;
'         while (*s && isalpha(*s)) {
LR__2090
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__2092
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__2092
	mov	_var05, _var01
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var05
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__2090
LR__2091
LR__2092
	wrbyte	#0, _var04
	mov	_var08, #0
	rdbyte	_var03, _var01
	cmp	_var03, #45 wz
 if_e	neg	_var02, #1
 if_e	add	_var01, #1
	callpa	#(@LR__2094-@LR__2093)>>2,fcache_load_ptr_
'                 sgn = -1;
'                 s++;
'         }
'         while (isdigit(*s)) {
LR__2093
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #2 wz
 if_e	jmp	#LR__2095
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__2093
LR__2094
LR__2095
	qmul	_var08, ##3600
	rdbyte	_var03, _var01
	cmp	_var03, #58 wz
	getqx	_var09
 if_ne	jmp	#LR__2099
	mov	_var08, #0
	add	_var01, #1
	callpa	#(@LR__2097-@LR__2096)>>2,fcache_load_ptr_
'                 x = 0;
'                 s++;
'                 while (isdigit(*s)) {
LR__2096
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #2 wz
 if_e	jmp	#LR__2098
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__2096
LR__2097
LR__2098
	mov	_var07, _var08
	shl	_var07, #4
	sub	_var07, _var08
	shl	_var07, #2
	add	_var09, _var07
LR__2099
	mov	_var04, ptr__fatfs_cc_dat__
	add	_var04, ##1253
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__2102
	wrlong	#1, arg02
'                 *hasdst = 1;
' 		while (*s && isalpha(*s)) *n++ = *s++;
LR__2100
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__2101
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__2101
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var01
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__2100
LR__2101
LR__2102
	wrbyte	#0, _var04
	add	ptr__fatfs_cc_dat__, ##1244
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1244
 if_e	jmp	#LR__2103
	add	ptr__fatfs_cc_dat__, ##1244
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #8
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1236
	jmp	#LR__2104
LR__2103
	add	ptr__fatfs_cc_dat__, ##1262
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #26
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1236
LR__2104
	add	ptr__fatfs_cc_dat__, ##1253
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1253
 if_e	jmp	#LR__2105
	add	ptr__fatfs_cc_dat__, ##1253
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #13
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1240
	jmp	#LR__2106
LR__2105
	add	ptr__fatfs_cc_dat__, ##1244
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #4
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1240
LR__2106
	qmul	_var02, _var09
' 		_tzname[1] = stdname;
' 
'         return sgn * off;
	getqx	result1
LR__2107
_fatfs_cc___tzoffset_ret
	ret

_fatfs_cc___indst
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #2 wz
 if_ne	jmp	#LR__2110
	mov	_var01, #7
	add	arg01, #24
	rdlong	_var02, arg01
	add	_var01, _var02
	sub	arg01, #12
	rdlong	_var03, arg01
	sub	_var01, _var03
	cmps	_var01, #0 wc
'                         return 1;
 if_b	mov	result1, #1
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 0;
	mov	result1, #0
	jmp	#_fatfs_cc___indst_ret
LR__2110
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #10 wz
 if_ne	jmp	#LR__2111
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #12
	rdlong	_var04, arg01
	sub	_var01, _var04
	cmps	_var01, #0 wc
'                         return 0;
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 1;
	mov	result1, #1
	jmp	#_fatfs_cc___indst_ret
LR__2111
'         }
' 
'         return (t->tm_mon > 2 && t->tm_mon < 10);
	mov	_var01, #0
	add	arg01, #16
	rdlong	_var02, arg01
	sub	arg01, #16
	cmps	_var02, #3 wc
 if_b	jmp	#LR__2112
	add	arg01, #16
	rdlong	_var03, arg01
	cmps	_var03, #10 wc
 if_b	mov	_var01, #1
LR__2112
	mov	result1, _var01
_fatfs_cc___indst_ret
	ret

_fatfs_cc_disk_deinitialize
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, ##528
	rdlong	arg01, objptr wz
	sub	objptr, ##528
' 
'         return RES_NOTRDY;
 if_e	mov	result1, #3
 if_e	jmp	#LR__2120
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	local01, arg01
	add	local01, #36
	rdlong	local01, local01
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	sub	objptr, ##528
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
'     }
'     fh->close(fh);
'     return RES_OK;
	mov	result1, #0
LR__2120
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_deinitialize_ret
	ret

' 	
' 	FUNCTION pfunc(c as integer) as integer
__system____strs_cl_pfunc_
' 		if (i < 16) then
	add	objptr, #4
	rdlong	result1, objptr
	sub	objptr, #4
	cmps	result1, #16 wc
 if_ae	jmp	#LR__2130
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	_var01, objptr
	add	_var01, result1
	wrbyte	arg01, _var01
	rdlong	result1, objptr
	add	result1, #1
	wrlong	result1, objptr
	sub	objptr, #4
' 			p(i) = c
' 			i = i+1
' 			return 1
	mov	result1, #1
	jmp	#__system____strs_cl_pfunc__ret
LR__2130
' 			return -1
	neg	result1, #1
__system____strs_cl_pfunc__ret
	ret

__system___struct__s_vfs_file_t_putchar_
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, #28
	rdlong	local01, objptr wz
	sub	objptr, #28
 if_e	mov	result1, #0
 if_e	jmp	#LR__2140
	add	objptr, #28
	rdlong	local02, objptr
	mov	local03, local02
	sub	objptr, #28
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, objptr
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
'     return (i < 0) ? 0 : 1;
	cmps	result1, #0 wc
 if_b	mov	local01, #0
 if_ae	mov	local01, #1
	mov	result1, local01
LR__2140
	mov	ptra, fp
	call	#popregs_
__system___struct__s_vfs_file_t_putchar__ret
	ret

__system___struct__s_vfs_file_t_getchar_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #32
	rdlong	arg01, objptr wz
	sub	objptr, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2150
'     return getcf(__this);
	add	objptr, #32
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #32
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	arg01, objptr
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
LR__2150
	mov	ptra, fp
	call	#popregs_
__system___struct__s_vfs_file_t_getchar__ret
	ret

__system___struct___bas_wrap_sender_tx_
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, objptr
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_tx__ret
	ret

__system___struct___bas_wrap_sender_rx_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #4
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #4
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_rx__ret
	ret

__system___struct___bas_wrap_sender_close_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #8
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #8
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_close__ret
	ret

LR__2160
	byte	"/"
	byte	0
LR__2161
	byte	"inf"
	byte	0
LR__2162
	byte	"nan"
	byte	0
LR__2163
	byte	" !!! corrupted heap??? !!! "
	byte	0
LR__2164
	byte	" !!! out of heap memory !!! "
	byte	0
LR__2165
	byte	" !!! corrupted heap !!! "
	byte	0
LR__2166
	byte	0
	byte	0
LR__2167
	byte	"TZ"
	byte	0
LR__2168
	byte	"*:<>|",34,"?",127
	byte	0
LR__2169
	byte	"+,;=[]"
	byte	0
LR__2170
	byte	"FAT32   "
	byte	0
LR__2171
	byte	0
	byte	0
LR__2172
	byte	"/sd"
	byte	0
LR__2173
	byte	"/sd/bas"
	byte	0
LR__2174
	byte	"/sd/bas"
	byte	0
LR__2175
	byte	"kwas"
	byte	0
LR__2176
	byte	
	byte	0
LR__2177
	byte	"Window test 1234567890"
	byte	0
	alignl
_dat_
	byte	$00[16]
	byte	$61, $41, $17, $0e, $62, $42, $00, $00, $63, $43, $19, $10, $64, $44, $00, $00
	byte	$65, $45, $18, $0f, $66, $46, $00, $00, $67, $47, $00, $00, $68, $48, $00, $00
	byte	$69, $49, $00, $00, $6a, $4a, $00, $00, $6b, $4b, $00, $00, $6c, $4c, $1f, $16
	byte	$6d, $4d, $00, $00, $6e, $4e, $1a, $11, $6f, $4f, $1e, $15, $70, $50, $00, $00
	byte	$71, $51, $00, $00, $72, $52, $00, $00, $73, $53, $1b, $12, $74, $54, $00, $00
	byte	$75, $55, $00, $00, $76, $56, $00, $00, $77, $57, $00, $00, $78, $58, $1c, $13
	byte	$79, $59, $00, $00, $7a, $5a, $1d, $14, $31, $21, $04, $00, $32, $40, $05, $00
	byte	$33, $23, $06, $00, $34, $24, $07, $00, $35, $25, $08, $00, $36, $5e, $09, $00
	byte	$37, $26, $0a, $00, $38, $2a, $0b, $00, $39, $28, $0c, $00, $30, $29, $0d, $00
	byte	$8d, $8d, $00, $00, $9b, $9b, $00, $00, $88, $88, $00, $00, $89, $89, $00, $00
	byte	$20, $20, $00, $00, $2d, $5f, $00, $00, $3d, $2b, $00, $00, $5b, $7b, $00, $00
	byte	$5d, $7d, $00, $00, $5c, $7c, $00, $00, $23, $7e, $00, $00, $3b, $3a, $00, $00
	byte	$27, $22, $00, $00, $60, $7e, $03, $00, $2c, $3c, $00, $00, $2e, $3e, $00, $00
	byte	$2f, $3f, $00, $00, $b9, $b9, $00, $00, $ba, $00, $00, $00, $bb, $00, $00, $00
	byte	$bc, $00, $00, $00, $bd, $00, $00, $00, $be, $00, $00, $00, $bf, $00, $00, $00
	byte	$c0, $00, $00, $00, $c1, $00, $00, $00, $c2, $00, $00, $00, $c3, $00, $00, $00
	byte	$c4, $00, $00, $00, $c5, $00, $00, $00, $c6, $00, $00, $00, $c7, $00, $00, $00
	byte	$c8, $00, $00, $00, $c9, $00, $00, $00, $ca, $00, $00, $00, $cb, $00, $00, $00
	byte	$7f, $7f, $00, $00, $cc, $00, $00, $00, $cd, $00, $00, $00, $ce, $00, $00, $00
	byte	$cf, $00, $00, $00, $d0, $00, $00, $00, $d1, $00, $00, $00, $d2, $00, $00, $00
	byte	$2f, $2f, $00, $00, $2a, $2a, $00, $00, $2d, $2d, $00, $00, $2b, $2b, $00, $00
	byte	$8d, $8d, $00, $00, $31, $31, $00, $00, $32, $32, $00, $00, $33, $33, $00, $00
	byte	$34, $34, $00, $00, $35, $35, $00, $00, $36, $36, $00, $00, $37, $37, $00, $00
	byte	$38, $38, $00, $00, $39, $39, $00, $00, $30, $30, $00, $00, $2e, $7f, $00, $00
	byte	$5c, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3d, $3d, $00, $00
	byte	$00[96]
'-' mouse  file "mouse2.def"
	byte	$01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0b, $01, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0c, $0d, $0d, $03, $01, $01, $01, $01, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0c, $01, $09, $0d, $03, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0c, $01, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0c, $01, $00, $00, $01, $0a, $0d, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $01, $00, $00, $00, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00
	byte	$00[22]
	byte	$01, $0b, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[425]
	alignl
_hg010b_spin2_dat_
'-' 
'-' vga_font       file "vgafont.def"
	byte	$00[19]
	byte	$7e, $81, $a5, $81, $81, $bd, $99, $81, $81, $7e, $00, $00, $00, $00, $00, $00
	byte	$7e, $ff, $db, $ff, $ff, $c3, $e7, $ff, $ff, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $7f, $7f, $7f, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $3e, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $3c, $e7, $e7, $e7, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $ff, $ff, $7e, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $3c, $3c, $18, $00, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $ff, $e7, $c3, $c3, $e7, $ff, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$00, $00, $3c, $66, $42, $42, $66, $3c, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $c3, $99, $bd, $bd, $99, $c3, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$78, $70, $58, $4c, $1e, $33, $33, $33, $33, $1e, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$fc, $cc, $fc, $0c, $0c, $0c, $0c, $0e, $0f, $07, $00, $00, $00, $00, $00, $00
	byte	$fe, $c6, $fe, $c6, $c6, $c6, $c6, $e6, $e7, $67, $03, $00, $00, $00, $00, $00
	byte	$18, $18, $db, $3c, $e7, $3c, $db, $18, $18, $00, $00, $00, $00, $00, $00, $01
	byte	$03, $07, $0f, $1f, $7f, $1f, $0f, $07, $03, $01, $00, $00, $00, $00, $00, $40
	byte	$60, $70, $78, $7c, $7f, $7c, $78, $70, $60, $40, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $18, $18, $18, $7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$00, $66, $66, $00, $00, $00, $00, $00, $00, $fe, $db, $db, $db, $de, $d8, $d8
	byte	$d8, $d8, $d8, $00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c
	byte	$30, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $7f, $7f, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $7e
	byte	$3c, $18, $7e, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $18
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $18, $30, $7f, $30, $18
	byte	$00[11]
	byte	$0c, $06, $7f, $06, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $03, $03, $03, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$14, $36, $7f, $36, $14, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $1c, $3e, $3e, $7f, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $3e, $3e, $1c, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[14]
	byte	$18, $3c, $3c, $3c, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $66, $66
	byte	$66, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $18, $18
	byte	$3e, $63, $43, $03, $3e, $60, $60, $61, $63, $3e, $18, $18, $00, $00, $00, $00
	byte	$00, $00, $43, $63, $30, $18, $0c, $06, $63, $61, $00, $00, $00, $00, $00, $00
	byte	$1c, $36, $36, $1c, $6e, $3b, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00
	byte	$0c, $0c, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $30, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f, $00, $00
	byte	$00[16]
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $40, $60, $30, $18, $0c, $06
	byte	$03, $01, $00, $00, $00, $00, $00, $00, $1c, $36, $63, $63, $6b, $6b, $63, $63
	byte	$36, $1c, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18, $18
	byte	$18, $7e, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $30, $18, $0c, $06, $03
	byte	$63, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $60, $3c, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30, $30
	byte	$30, $78, $00, $00, $00, $00, $00, $00, $7f, $03, $03, $03, $3f, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $1c, $06, $03, $03, $3f, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $7f, $63, $60, $60, $30, $18, $0c, $0c
	byte	$0c, $0c, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $3e, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $7e, $60, $60, $60
	byte	$30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $60, $30, $18, $0c, $06, $0c, $18
	byte	$30, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00, $7e, $00
	byte	$00[9]
	byte	$06, $0c, $18, $30, $60, $30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $3e
	byte	$63, $63, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $63, $7b, $7b, $7b, $3b, $03, $3e, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3f
	byte	$66, $66, $66, $3e, $66, $66, $66, $66, $3f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00, $00, $1f
	byte	$36, $66, $66, $66, $66, $66, $66, $36, $1f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $7b, $63, $63, $66, $5c, $00, $00, $00, $00, $00, $00, $63
	byte	$63, $63, $63, $7f, $63, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3c
	byte	$18[8]
	byte	$3c, $00, $00, $00, $00, $00, $00, $78, $30, $30, $30, $30, $30, $33, $33, $33
	byte	$1e, $00, $00, $00, $00, $00, $00, $67, $66, $66, $36, $1e, $1e, $36, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $7f, $6b, $63, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $06, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $6b, $7b
	byte	$3e, $30, $70, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $36, $1c
	byte	$08, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $6b, $6b, $6b, $7f, $77
	byte	$36, $00, $00, $00, $00, $00, $00, $63, $63, $36, $3e, $1c, $1c, $3e, $36, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $01, $03, $07, $0e, $1c, $38, $70, $60
	byte	$40, $00, $00, $00, $00, $00, $00, $3c, $30, $30, $30, $30, $30, $30, $30, $30
	byte	$3c, $00, $00, $00, $1c, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$ff, $00, $00, $0c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $07, $06, $06
	byte	$1e, $36, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $30, $30
	byte	$3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $7f, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $6c, $4c
	byte	$0c, $1e, $0c, $0c, $0c, $0c, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$6e, $33, $33, $33, $33, $33, $3e, $30, $33, $1e, $00, $00, $00, $07, $06, $06
	byte	$36, $6e, $66, $66, $66, $66, $67, $00, $00, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $60, $60, $00
	byte	$70, $60, $60, $60, $60, $60, $60, $66, $66, $3c, $00, $00, $00, $07, $06, $06
	byte	$66, $36, $1e, $1e, $36, $66, $67, $00, $00, $00, $00, $00, $00, $1c, $18, $18
	byte	$18[6]
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $6b, $6b, $6b
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$3e, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $6e, $33, $33, $33, $33, $33
	byte	$3e, $30, $30, $78, $00, $00, $00, $00, $00, $00, $3b, $6e, $66, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36
	byte	$1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $6b, $6b, $6b, $7f
	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $1c, $36
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63
	byte	$7e, $60, $30, $1f, $00, $00, $00, $00, $00, $00, $7f, $33, $18, $0c, $06, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18, $18
	byte	$70, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18, $18
	byte	$0e, $00, $00, $00, $6e, $3b, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[10]
	byte	$08, $1c, $36, $63, $63, $63, $7f, $00, $00, $00, $00, $00, $00, $3c, $66, $43
	byte	$03, $03, $03, $03, $43, $66, $3c, $18, $30, $1e, $00, $00, $00, $00, $33, $00
	byte	$33[6]
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $33, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $1c, $36, $1c, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $18, $30, $1e, $00, $00, $00, $1c, $58, $78, $38, $18, $1c, $1e, $1a, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $66, $33, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $cc, $66, $33, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $18, $3c, $66, $00, $1c, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $63, $00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63
	byte	$63, $00, $00, $00, $30, $18, $00, $3c, $66, $43, $03, $03, $03, $03, $43, $66
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66
	byte	$7f, $00, $00, $00, $0c, $06, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $6f, $46, $26, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $6e, $4c, $2c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$1e, $00, $00, $00, $30, $18, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $6c, $38, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $60, $48, $2c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $0f, $26, $36, $1e, $0e, $07, $07, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36, $63, $00
	byte	$00[6]
	byte	$36, $1c, $08, $00, $3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63, $63, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $1e, $30, $3e, $33, $33, $33, $6e, $18, $0c, $78, $36, $1c
	byte	$00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00
	byte	$00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66, $7f, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $7f, $03, $03, $63, $3e, $18, $0c, $78, $00, $00
	byte	$00, $3c, $66, $03, $1f, $03, $0f, $03, $03, $66, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $6c, $38
	byte	$00, $3c, $66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63, $3e, $18, $30, $1e, $00, $00
	byte	$00[6]
	byte	$6c, $36, $1b, $36, $6c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$1b, $36, $6c, $36, $1b, $00, $00, $00, $88, $22, $88, $22, $88, $22, $88, $22
	byte	$88, $22, $88, $22, $88, $22, $88, $22, $aa, $55, $aa, $55, $aa, $55, $aa, $55
	byte	$aa, $55, $aa, $55, $aa, $55, $aa, $55, $bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee
	byte	$bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18[15]
	byte	$1f, $18, $18, $18, $18, $18, $18, $18, $18, $30, $18, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $1c, $36, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $36, $1c, $00, $7f, $66, $46, $16
	byte	$1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06
	byte	$1c, $30, $60, $63, $63, $3e, $18, $30, $1e, $6c, $6c, $6c, $6c, $6c, $6f, $60
	byte	$6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6c[9]
	byte	$00[5]
	byte	$7f, $60, $6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6f, $60, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $7f, $63
	byte	$61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00, $00, $18, $18
	byte	$00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $63, $3e, $00, $08, $1c
	byte	$36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $63, $3e
	byte	$00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $fc, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$fc, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$63, $3e, $63, $63, $63, $63, $3e, $63, $00, $00, $00, $00, $00, $00, $30, $7e
	byte	$30, $3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $1f, $36
	byte	$66, $66, $6f, $66, $66, $66, $36, $1f, $00, $00, $00, $36, $1c, $00, $1f, $36
	byte	$66[6]
	byte	$36, $1f, $00, $00, $00, $00, $63, $00, $7f, $66, $46, $16, $1e, $16, $06, $46
	byte	$66, $7f, $00, $00, $00, $6c, $38, $00, $38, $30, $30, $3c, $36, $33, $33, $33
	byte	$33, $6e, $00, $00, $00, $36, $1c, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63
	byte	$63, $63, $00, $00, $00, $30, $18, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $3c, $66, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $00, $00, $36, $1c, $08, $00, $3e, $63, $7f, $03, $03
	byte	$63, $3e, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $1f, $00, $00, $00
	byte	$00[12]
	byte	$f8, $18, $18, $18, $18, $18, $18, $18, $18, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	byte	$ff[9]
	byte	$00[7]
	byte	$ff[9]
	byte	$00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18, $3c, $18, $30, $1e
	byte	$1c, $36, $1c, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$ff[7]
	byte	$00[9]
	byte	$30, $18, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $00, $1e, $33, $33, $33, $1b, $33, $63, $63, $63, $33, $00, $00, $00
	byte	$1c, $36, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63, $63, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$36, $1c, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3e, $63, $06, $1c, $30, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00
	byte	$30, $18, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00
	byte	$66, $33, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $63, $63, $63, $63, $63, $63, $7e, $60, $30, $1f
	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18, $3c, $00, $00, $00
	byte	$00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c, $38, $18, $30, $1e
	byte	$30, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $66, $33, $00, $00, $00, $00, $00, $00
	byte	$00[21]
	byte	$0c, $06, $3c, $36, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c, $30, $63, $3e
	byte	$00[8]
	byte	$18, $00, $7e, $00, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $30, $1e, $00, $00, $00, $1c, $36, $36, $1c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[5]
	byte	$cc, $66, $33, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $36, $1c
	byte	$00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $7e, $7e, $7e, $7e, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' st_font        file "st4font.def"
	byte	$00[55]
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$18[9]
	byte	$00[7]
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $00, $00, $18, $3c, $7e, $66, $66
	byte	$66, $7e, $7e, $66, $66, $66, $66, $30, $18, $00, $00, $7e, $7e, $06, $06, $3e
	byte	$3e, $06, $06, $06, $06, $7e, $7e, $18, $0c, $30, $18, $3c, $7e, $66, $66, $06
	byte	$06, $06, $06, $66, $66, $7e, $3c, $00, $00, $30, $18, $66, $66, $66, $6e, $6e
	byte	$7e, $7e, $76, $76, $66, $66, $66, $00, $00, $30, $18, $7c, $7e, $06, $06, $0e
	byte	$1c, $38, $70, $60, $60, $7e, $3e, $00, $00, $30, $18, $7e, $7e, $30, $30, $18
	byte	$18, $0c, $0c, $06, $06, $7e, $7e, $00, $00, $18, $18, $00, $7e, $7e, $30, $30
	byte	$18, $18, $0c, $0c, $06, $7e, $7e, $00, $00, $30, $18, $3c, $7e, $66, $66, $66
	byte	$66[5]
	byte	$7e, $3c, $00, $00, $00, $00, $06, $06, $06, $06, $16, $1e, $0e, $06, $06, $06
	byte	$7e, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $7c, $60, $7c, $7e, $66, $66
	byte	$7e, $7c, $30, $18, $00, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $06, $06
	byte	$7e, $7c, $18, $0c, $00, $00, $30, $18, $00, $3c, $3e, $06, $06, $06, $06, $06
	byte	$7e, $7c, $00, $00, $00, $00, $30, $18, $00, $3e, $7e, $66, $66, $66, $66, $66
	byte	$66, $66, $00, $00, $00, $00, $30, $18, $00, $7c, $7e, $06, $0e, $3c, $70, $60
	byte	$7e, $3e, $00, $00, $00, $00, $30, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $18, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $00, $3c, $7e, $66, $66, $66, $66, $66
	byte	$7e, $3c, $00, $00, $00, $00, $1c, $1c, $18, $18, $38, $3c, $1c, $18, $18, $18
	byte	$3c, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[8]
	byte	$00, $00, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $00, $00, $00, $00
	byte	$00[9]
	byte	$66, $66, $ff, $ff, $66, $66, $ff, $ff, $66, $66, $00, $00, $00, $00, $18, $18
	byte	$7c, $7e, $06, $06, $3e, $7c, $60, $60, $7e, $3e, $18, $18, $00, $00, $00, $66
	byte	$66, $30, $30, $18, $18, $0c, $0c, $66, $66, $00, $00, $00, $00, $00, $3c, $7e
	byte	$66, $66, $3c, $1c, $1c, $fc, $fe, $66, $66, $fe, $fc, $00, $00, $00, $00, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $30
	byte	$18, $1c, $0c, $0c, $0c, $0c, $0c, $0c, $1c, $18, $30, $00, $00, $00, $00, $0c
	byte	$18, $38, $30, $30, $30, $30, $30, $30, $38, $18, $0c, $00, $00, $00, $00, $00
	byte	$66, $66, $3c, $3c, $ff, $ff, $3c, $3c, $66, $66, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $18, $7e, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[5]
	byte	$0c, $04, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00[13]
	byte	$18, $18, $18, $00, $00, $00, $00, $60, $60, $60, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $76, $6e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $18, $18, $1c, $1c, $18, $18, $18, $18, $18
	byte	$18, $7e, $7e, $00, $00, $00, $00, $3c, $7e, $66, $66, $30, $30, $18, $18, $0c
	byte	$0c, $7e, $7e, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $30, $30, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $30, $30, $38, $38, $3c, $3c, $36, $36, $7e
	byte	$7e, $30, $30, $00, $00, $00, $00, $7e, $7e, $06, $06, $3e, $7e, $60, $60, $60
	byte	$66, $7e, $3c, $00, $00, $00, $00, $38, $3c, $0e, $06, $06, $3e, $7e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $7e, $7e, $60, $60, $30, $30, $18, $18, $0c
	byte	$0c, $0c, $0c, $00, $00, $00, $00, $3c, $7e, $66, $66, $3c, $3c, $66, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $7c, $60, $60, $60
	byte	$70, $3c, $1c, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $18
	byte	$18, $18, $18, $0c, $04, $00, $00, $00, $70, $38, $1c, $0e, $07, $0e, $1c, $38
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $7e, $7e
	byte	$00[8]
	byte	$0e, $1c, $38, $70, $e0, $70, $38, $1c, $0e, $00, $00, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $30, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $66, $66, $36, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $18
	byte	$3c, $7e, $66, $66, $66, $7e, $7e, $66, $66, $66, $66, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $7e, $3e, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $06, $06, $06, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $66, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $7e, $7e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $7c
	byte	$7e, $06, $06, $76, $76, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $66
	byte	$66, $66, $66, $7e, $7e, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $7e
	byte	$7e, $18, $18, $18, $18, $18, $18, $18, $18, $7e, $7e, $00, $00, $00, $00, $60
	byte	$60[7]
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $36, $36, $1e, $1e, $36, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $06, $06, $06, $06, $06, $06, $06, $06
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $c6, $c6, $ee, $ee, $fe, $d6, $d6, $c6
	byte	$c6, $c6, $c6, $c6, $00, $00, $00, $00, $66, $66, $66, $6e, $6e, $7e, $7e, $76
	byte	$76, $66, $66, $66, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $66, $7e, $3e
	byte	$06, $06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $56, $3e, $6c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $7e, $3e, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $7c, $7e, $06, $06, $0e, $1c, $38, $70
	byte	$60, $60, $7e, $3e, $00, $00, $00, $00, $7e, $7e, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$3c, $3c, $18, $18, $00, $00, $00, $00, $c6, $c6, $c6, $c6, $c6, $d6, $d6, $fe
	byte	$fe, $ee, $c6, $82, $00, $00, $00, $00, $66, $66, $66, $3c, $3c, $18, $18, $3c
	byte	$3c, $66, $66, $66, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $3c, $3c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$0c, $0c, $3c, $3c, $00, $00, $00, $00, $06, $06, $0c, $0c, $18, $18, $30, $30
	byte	$60, $60, $c0, $c0, $00, $00, $00, $00, $3c, $3c, $30, $30, $30, $30, $30, $30
	byte	$30, $30, $3c, $3c, $00, $00, $00, $00, $18, $18, $3c, $3c, $66, $66, $00, $00
	byte	$00[18]
	byte	$fe, $fe, $00, $00, $00, $00, $0c, $0c, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$3c, $7c, $60, $7c, $7e, $66, $66, $7e, $7c, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $3e, $06, $06, $06, $06, $06, $7e, $7c, $00, $00, $00, $00, $60, $60, $60
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $7e, $06, $06, $7e, $7c, $00, $00, $00, $00, $70, $78, $18
	byte	$18, $7e, $7e, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $7e, $7c, $60, $7e, $3e, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $1c, $18, $18, $18, $18, $18, $3c, $3c, $00, $00, $00, $00, $30, $30, $00
	byte	$30[9]
	byte	$3e, $1e, $00, $00, $06, $06, $06, $36, $36, $1e, $1e, $1e, $36, $36, $66, $66
	byte	$00, $00, $00, $00, $1c, $1c, $18, $18, $18, $18, $18, $18, $18, $18, $3c, $3c
	byte	$00[7]
	byte	$6c, $fe, $fe, $d6, $d6, $c6, $c6, $c6, $c6, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $06, $06, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $60, $60, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $06, $0e, $3c, $70, $60, $7e, $3e, $00, $00, $00, $00, $00, $18, $18
	byte	$7e, $7e, $18, $18, $18, $18, $18, $78, $70, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$7e, $7c, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $c6, $c6, $d6, $d6, $fe, $fe, $ee
	byte	$c6, $82, $00, $00, $00, $00, $00, $00, $00, $66, $66, $3c, $3c, $18, $3c, $3c
	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $7e
	byte	$7c, $60, $7e, $3e, $00, $00, $00, $00, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $18, $18, $18, $0c, $0c, $18, $18, $18
	byte	$18, $30, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $0c, $18, $18, $18, $18, $30, $30, $18, $18, $18
	byte	$18, $0c, $00, $00, $00, $00, $6c, $7e, $36, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
'-' a8_font        file "atari8.fnt"
	byte	$00, $6c, $fe, $fe, $7c, $38, $10, $00, $18, $18, $18, $f8, $f8, $18, $18, $18
	byte	$c0[8]
	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
	byte	$0f[8]
	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
	byte	$66[5]
	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
	byte	$08, $00
'-' a8_font2       file "atari8.fnt"
	byte	$00, $6c, $fe, $fe, $7c, $38, $10, $00, $18, $18, $18, $f8, $f8, $18, $18, $18
	byte	$c0[8]
	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
	byte	$0f[8]
	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
	byte	$66[5]
	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
	byte	$08, $00
'-' amiga_font     file "amigafont.def"
	byte	$00[530]
	byte	$18[6]
	byte	$00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $00, $00, $00
	byte	$00[10]
	byte	$36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $7c, $06, $06, $3c, $60, $60, $3e, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $c6, $69, $36, $18, $6c, $96, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$1c, $36, $36, $1e, $6e, $3b, $33, $73, $de, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $66, $3c, $ff, $3c, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[7]
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00
	byte	$00[16]
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $c0, $60, $30, $18, $0c, $06
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $76, $7e, $6e, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $30, $18, $0c
	byte	$06, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $38, $60, $60
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30
	byte	$30, $30, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06, $3e, $60, $60, $60
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $06, $06, $3e, $66, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $7e, $60, $60, $60, $30, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $3c, $66, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $7c, $60, $60
	byte	$30, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $60, $18, $06, $18, $60
	byte	$00[12]
	byte	$7e, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06
	byte	$18, $60, $18, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60
	byte	$60, $30, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
	byte	$7b, $6b, $7b, $03, $03, $1e, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66
	byte	$66, $3e, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $78, $0c, $06
	byte	$06, $06, $06, $06, $0c, $78, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $63
	byte	$63, $63, $63, $63, $33, $1f, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
	byte	$06, $1e, $06, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
	byte	$06, $1e, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06
	byte	$06, $76, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3c, $18, $18
	byte	$18[5]
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60, $60, $60, $60, $60, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $c3, $63, $33, $1b, $0f, $1b, $33, $63
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $6b, $63, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7b, $73, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e, $06, $06, $06
	byte	$06, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $7b
	byte	$fe, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $33, $33, $1f, $1b, $33, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06, $0c, $18, $30, $60, $66
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $7e, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36, $36, $1c
	byte	$08, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $c3, $c3, $c3, $db, $ff, $e7
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $3c, $66, $c3
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $7f, $60, $60, $30, $18, $0c, $06, $03
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $03, $06, $0c, $18, $30, $60, $c0
	byte	$00[8]
	byte	$3c, $30, $30, $30, $30, $30, $30, $30, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$08, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$7f, $00, $00, $00, $00, $00, $00, $18, $18, $30, $00, $00, $00, $00, $00, $00
	byte	$00[10]
	byte	$3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $06, $06, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60
	byte	$7c, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $0c
	byte	$3e, $0c, $0c, $0c, $0c, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $66, $66, $66, $7c, $60, $60, $3c, $00, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $18, $00
	byte	$18[5]
	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $30, $00, $30, $30, $30, $30, $30
	byte	$30, $30, $1e, $00, $00, $00, $00, $00, $03, $03, $03, $33, $1b, $0f, $1b, $33
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $66
	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $66
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e
	byte	$06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7c, $66, $66, $66, $7c
	byte	$60, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $06, $06, $06
	byte	$06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $06, $0c, $30, $60
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $0c, $0c, $3e, $0c, $0c, $0c, $0c
	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $6b, $3e
	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
	byte	$18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $30, $18, $0c, $06
	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18
	byte	$0e, $00, $00, $00, $00, $00, $00, $00, $46, $5d, $31, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$c0, $f0, $3c, $0f, $c3, $f0, $3c, $0f, $03, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $00, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $7e, $1b, $1b, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$78, $cc, $0c, $0c, $1e, $0c, $0c, $06, $7f, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $3c, $66, $66, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$c3, $c3, $66, $3c, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $18, $18, $00, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $06, $06, $3c, $66, $66, $66, $3c, $60, $60, $3c, $00, $00, $00, $00, $00
	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $81, $b9, $85, $85, $b9, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $33, $33, $7e, $00, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $cc, $66, $33, $66, $cc, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $81, $9d, $a5, $9d, $a5, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $18, $7e, $18, $18, $18, $00, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $30, $30, $18, $0c, $06, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $30, $30, $1c, $30, $30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $66, $66, $66, $66, $66, $fe, $06, $06, $00, $00, $00, $00, $00
	byte	$7c, $5e, $5e, $5e, $5c, $50, $50, $50, $50, $50, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$30, $18, $00, $00, $00, $00, $00, $18, $1c, $18, $18, $18, $18, $18, $00, $00
	byte	$00[7]
	byte	$3c, $66, $66, $3c, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $33, $66, $cc, $66, $33, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$02, $63, $32, $1a, $4e, $66, $f3, $40, $40, $00, $00, $00, $00, $00, $00, $00
	byte	$04, $c6, $64, $34, $7c, $8c, $46, $23, $f0, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $c4, $66, $34, $5b, $6c, $f6, $43, $40, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $00, $18, $0c, $06, $06, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $33, $3e, $63, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$4e, $39, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$1c, $22, $1c, $36, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$f8, $3c, $3c, $36, $f6, $3f, $33, $33, $f3, $00, $00, $00, $00, $00, $00, $00
	byte	$78, $0c, $06, $06, $06, $06, $06, $0c, $78, $30, $18, $00, $00, $00, $00, $00
	byte	$0c, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $00, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $00, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $36, $66, $66, $6f, $66, $66, $36, $1e, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $73, $67, $6f, $7b, $73, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $33, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $63, $36, $1c, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$be, $63, $73, $7b, $6b, $6f, $67, $63, $3f, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $0c, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$08, $36, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $c3, $66, $3c, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $03, $3f, $63, $63, $3f, $03, $03, $03, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $66, $36, $66, $66, $66, $36, $06, $06, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $24, $18, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $d8, $fe, $1b, $1b, $ee, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $3c, $06, $06, $06, $06, $3c, $18, $0c, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $0c, $00, $0c, $0c, $0c, $0c, $0c, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $06, $3f, $18, $3c, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $00, $7e, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $73, $7b, $6f, $67, $3f, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
	byte	$06, $06, $06, $3e, $66, $66, $66, $3e, $06, $06, $06, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
	byte	$00, $7e, $66, $66, $66, $66, $66, $66, $66, $7e, $00, $00, $00, $00, $00, $00
	byte	$00[526]
'-' vga16          long  $00000000,$00008000,$00800000,$00808000,$80000000,$80008000,$80400000,$AAAAAA00,$55555500,$0000FF00,$00FF0000,$00FFFF00,$FF000000,$FF00FF00,$FFFF0000,$FFFFFF00
	byte	$00[5]
	byte	$80, $00, $00, $00, $00, $80, $00, $00, $80, $80, $00, $00, $00, $00, $80, $00
	byte	$80, $00, $80, $00, $00, $40, $80, $00, $aa, $aa, $aa, $00, $55, $55, $55, $00
	byte	$ff, $00, $00, $00, $00, $ff, $00, $00, $ff, $ff, $00, $00, $00, $00, $ff, $00
	byte	$ff, $00, $ff, $00, $00, $ff, $ff, $00, $ff, $ff, $ff
'-' ataripalette   file "ataripalettep2.def"
	byte	$00[5]
	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
'-' ataripalette2  file "ataripalettep2.def"
	byte	$00[5]
	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
'-' 
'-' '**********************************************************************************
'-' '
'-' '        Timings and colors definitions
'-' '
'-' '**********************************************************************************
'-' 
'-' '                      bf.hs, hs,  bf.vis  visible, up p., vsync, down p.,  cpl, total lines, clock,       hubset                                scanlines  ud bord mode reserved
'-' timings         long   8,     60,  8,       1024,   7,     4,     1,        128, 600,         340500000,   %1_100111__10_1010_1000__1111_1011,   600,        0,     192, 0, 0
	byte	$08, $00, $00, $00, $3c, $00, $00, $00, $08, $00, $00, $00, $00, $04, $00, $00
	byte	$07, $00, $00, $00, $04, $00, $00, $00, $01, $00, $00, $00, $80, $00, $00, $00
	byte	$58, $02, $00, $00, $20, $9e, $4b, $14, $fb, $a8, $9e, $01, $58, $02, $00, $00
	byte	$00, $00, $00, $00, $c0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' 'timings        long   16,    80,  12,      1024,   8,     4,     8,        128, 576,         336956522,   %1_101101__11_0000_0110__1111_1011,   576,        0,     192, 0, 0
'-' vgacolors       byte   0, 117, 199, 151, 39, 71, 246, 10, 5, 121, 203, 155, 43, 75, 234, 15
	byte	$00, $75, $c7, $97, $27, $47, $f6, $0a, $05, $79, $cb, $9b, $2b, $4b, $ea, $0f
'-' 
'-' ''--------  Initialization  ----------------------------------------------------------------
'-' 
'-' hdmi            setq    #6
	byte	$28, $0c, $64, $fd
'-'                 rdlong  vblankptr,  ptra                   ' read pointers
	byte	$00, $a5, $05, $fb
'-'                 setq    #8
	byte	$28, $10, $64, $fd
'-'                 rdlong  m_bs,modeptr                       ' read timings
	byte	$d3, $8a, $01, $fb
'-' 
'-'                 bitl    hbase, #31 wcz                     ' if pin 31 is set, use full strength for Adafruit Pico HDMI board
	byte	$1f, $ac, $1d, $f4
'-'                 setcmod #$100                              ' enable HDMI mode
	byte	$3c, $00, $66, $fd
'-'                 mov     t1,#448                            ' 7 << 6          
	byte	$c0, $c7, $05, $f6
'-'                 add     t1,hbase
	byte	$d6, $c6, $01, $f1
'-'                 drvl    t1                                 ' #7<<6 + hdmi_base      ' enable HDMI pins
	byte	$58, $c6, $61, $fd
'-'         if_z    wrpin   #0, t1  '#7<<6 + hdmi_base         ' for Adafruit breakout board - full logic as in Pico, the board has 220 Ohm resistors on it
	byte	$e3, $00, $08, $ac
'-' 	if_nz   wrpin   ##%10110_1111_0111_10_00000_0, t1  ' #7<<6 + hdmi_base      ' a '123 ohm BITDAC for Parallax breakout board
	byte	$7b, $0b, $80, $5f, $e3, $00, $0b, $5c
'-'                 setxfrq ##$0CCCCCCC+1                      ' set streamer freq to 1/10th clk
	byte	$66, $66, $86, $ff, $1d, $9a, $65, $fd
'-' '
'-'                 mov 	t1,hbase			   '
	byte	$d6, $c6, $01, $f6
'-'                 shl 	t1,#17                             '
	byte	$11, $c6, $65, $f0
'-'                 add 	lutg8,t1                           ' add the pin base to he streamer constant
	byte	$e3, $a2, $01, $f1
'-'                 sub 	i_upporch,#2			   ' the driver will call 2 blank lines itself to preload the buffer, so sub #2 from up porch time
	byte	$02, $92, $85, $f1
'-' 
'-'                 cogid   t1              		   ' get a cogid
	byte	$01, $c6, $61, $fd
'-'                 mul     t1, #12                            ' compute the offset to PSRAM mailbox 
	byte	$0c, $c6, $05, $fa
'-'                 add     mailbox, t1                        ' add offset to find this COG's mailbox
	byte	$e3, $ae, $01, $f1
'-' 
'-' ''--------  frame rendering main loop  ---------------------------------------------------
'-' 
'-' p101            setq 	#3
	byte	$28, $06, $64, $fd
'-' 		rdlong  vblankptr,ptra
	byte	$00, $a5, $05, $fb
'-'                 setq    #47+6				   ' read sprite data
	byte	$28, $6a, $64, $fd
'-' 	 	rdlong  sprite1pointer,spriteptr
	byte	$d8, $dc, $01, $fb
'-' 		mov     spriteline,#0                      ' init the sprite line variable
	byte	$00, $4a, $06, $f6
'-'                 mov     dlinum, #0
	byte	$00, $a0, $05, $f6
'-'                 add     frames,#1			   ' increment the frame counter
	byte	$01, $9e, $05, $f1
'-'                 mov     dlptr2,dlptr			   ' init the temporary DL pointer
	byte	$d5, $b8, $01, $f6
'-' 
'-' 
'-'                 mov     linenum,#0			   ' init the current line #
	byte	$00, $9c, $05, $f6
'-'                 mov     rcnt,#0			   	   ' init the DL repeat counter
	byte	$00, $ce, $05, $f6
'-'                 mov     rcnt2a,affffffff 		   ' why?!                
	byte	$ed, $d2, $01, $f6
'-'                 
'-' 
'-' 
'-' '' ------- reload the palette. If bit31 set, don't reload, to prevent blinking while modifying the palette
'-'   
'-'                 testb   paletteptr,#31 wc
	byte	$1f, $a8, $15, $f4
'-'          if_nc  setq2   #255
	byte	$29, $fe, $65, $3d
'-'          if_nc  rdlong  $000, paletteptr                   'read palette
	byte	$d4, $00, $00, $3b
'-' 
'-' '' -----   up porch (before the picture)
'-' 
'-'                 mov     hsync0,sync_000      	           ' init constants for sync
	byte	$c0, $c2, $01, $f6
'-'                 mov     hsync1,sync_001	
	byte	$c1, $c4, $01, $f6
'-'                 callpa  i_upporch ,#blank                  ' call the porch line i_upporch (-2) times
	byte	$40, $92, $45, $fb
'-'                 wrlong  #0,vblankptr                       ' the vblank time ends here
	byte	$d2, $00, $68, $fc
'-'  
'-'    
'-'  
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'          	     call    #dli	                  ' call DL interpreter for line #0 at line #(-2) - 2 lines earlier, so it can start preloading data from PSRAM
	byte	$60, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                          rdfast  #64,buf1d                          ' prepare the HUB buffer for 4 scanlines
	byte	$df, $80, $78, $fc
'-' 
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-' 		call    #dli
	byte	$48, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                  call    #sprite				   ' sprites for line #0
	byte	$20, $01, $b0, $fd
'-'                 	
'-'                 
'-' 
'-'  
'-' '' ------- the main screen drawing starts here
'-' 
'-' p301            xcont   m_bs,hsync0   			  ' make a right porch
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1                       ' make hsync
	byte	$e2, $8c, $b1, $fc
'-'                 call    #dli                              ' process the DL for line+2                
	byte	$30, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   lutg8,#0			  ' display the line 
	byte	$00, $a2, $c5, $fc
'-'                  add     linenum,#1                        ' increment the current line number 
	byte	$01, $9c, $05, $f1
'-'                  call    #sprite                           ' process sprites for line+1             
	byte	$04, $01, $b0, $fd
'-'               
'-' 
'-'                 cmp     linenum,i_totalvis  wz            ' check if all lines displayed
	byte	$cd, $9c, $09, $f2
'-'     if_nz       jmp     #p301                             ' if not, display the next line
	byte	$dc, $ff, $9f, $5d
'-' 
'-' ' ---------------- All visible lines displayed now, start vblank  
'-' 
'-' p112            wrlong  #1,vblankptr                       ' tell the system that the vblank started
	byte	$d2, $02, $68, $fc
'-'                 callpa  i_downporch ,#blank                ' bottom blanks
	byte	$28, $96, $45, $fb
'-'                 mov     hsync0,sync_222                    ' vsync on
	byte	$c2, $c2, $01, $f6
'-'                 mov     hsync1,sync_223
	byte	$c3, $c4, $01, $f6
'-'                 callpa  i_vsync,#blank                     ' vertical sync blanks
	byte	$25, $94, $45, $fb
'-'                 jmp     #p101                              ' return to the main loop
	byte	$4c, $ff, $9f, $fd
'-' 
'-' '' --------------- END of frame rendering loop ---------------------------------------------------------------------------
'-' 
'-' '' --------------- Display list interpreter ---------------------------------------------------------------------------
'-' 
'-' dli             cmp     rcnt,#0 wz			   ' check the DL repeat counter 
	byte	$00, $ce, $0d, $f2
'-' 
'-'     if_z        rdlong  dl,dlptr2				
	byte	$dc, $ba, $01, $ab
'-'     if_z        add     dlptr2,#4
	byte	$04, $b8, $05, $a1
'-'     if_z        jmp     #p307                              ' no repeat, goto read and interpret the next DL entry
	byte	$14, $00, $90, $ad
'-' 
'-'                 sub     rcnt,#1 wz                         ' decrement the repeat counter
	byte	$01, $ce, $8d, $f1
'-'     if_nz       mov     dl,rdl                             ' restore repeating DL entry from temporary buffer
	byte	$eb, $ba, $01, $56
'-'                 incmod  rcnt2a,rcnt2 wcz                   ' address update counter
	byte	$e8, $d2, $19, $f7
'-'     if_c        add     dl,roffset                         ' if it rollovers, add the offset to the data address
	byte	$ea, $ba, $01, $c1
'-'                 mov     rdl,dl                             ' save the result
	byte	$dd, $d6, $01, $f6
'-' 
'-' p307	        mov     framebuf2,dl wcz                   ' move this to framebuf2. If normal DL entry, the frame buffer start will be extracted from this
	byte	$dd, $c0, $19, $f6
'-'                 getnib  t1,dl,#0
	byte	$dd, $c6, $41, $f8
'-'                 cmp     t1,#%0010 wz			   ' 0010 - display a normal graphics line, preload it from the PSRAM
	byte	$02, $c6, $0d, $f2
'-'     if_z        jmp     #preload
	byte	$70, $00, $90, $ad
'-'     		cmp     t1,#%0000 wz			   ' 0000 - display a line from a PSRAM list
	byte	$00, $c6, $0d, $f2
'-'     if_z        jmp     #preload2
	byte	$94, $00, $90, $ad
'-'                 cmp     t1,#%0001 wz			   ' 0001 - repeat
	byte	$01, $c6, $0d, $f2
'-'     if_z        jmp     #p390
	byte	$0c, $00, $90, $ad
'-'                 cmp     t1,#%0011 wz			   ' 0011 - palette reload
	byte	$03, $c6, $0d, $f2
'-'     if_z        jmp     #p391  
	byte	$28, $00, $90, $ad
'-' 
'-' p308            ret
	byte	$2d, $00, $64, $fd
'-'    
'-' p390            rdlong  rdl,dlptr2                         ' read the next DL entry to repeat
	byte	$dc, $d6, $01, $fb
'-'                 getword rcnt,framebuf2,#1                  ' read the repeat count
	byte	$e0, $ce, $39, $f9
'-'                 shr     rcnt,#4                            ' from 12 upper bits
	byte	$04, $ce, $45, $f0
'-'                 mov     rcnt2a,affffffff                   ' I still don't know why?
	byte	$ed, $d2, $01, $f6
'-'                 getnib  rcnt2,framebuf2,#4                 ' read the pointer update counter
	byte	$e0, $d0, $61, $f8
'-'                 getword roffset,framebuf2,#0               ' read the offset to add
	byte	$e0, $d4, $31, $f9
'-'                 shr     roffset,#4                         ' clean the command field from offset
	byte	$04, $d4, $45, $f0
'-'                 shl     roffset,#4                         ' and make it ready to add to the DL entry (address=20 upper bits)
	byte	$04, $d4, $65, $f0
'-'                 jmp     #dli                               ' now start repeating 
	byte	$8c, $ff, $9f, $fd
'-'  
'-' '' --------  Reload palette. To do 
'-' 
'-' p391           	getnib  t1,framebuf2,#2			   ' get a bank (0..15) of 16 colors
	byte	$e0, $c6, $51, $f8
'-'          	shl     t1,#4				   ' compute the LUT address
	byte	$04, $c6, $65, $f0
'-'         	shr     framebuf2,#12			   ' compute the HUB address of 16 new colors
	byte	$0c, $c0, $45, $f0
'-'          	setq2   #15				   ' load 16 entries
	byte	$29, $1e, $64, $fd
'-'          	altd    t1                                 ' from t1 LUT address
	byte	$00, $c6, $8d, $f9
'-'         	rdlong  $000, framebuf2         	
	byte	$e0, $00, $00, $fb
'-'         	jmp     #dli                
	byte	$70, $ff, $9f, $fd
'-'       
'-' '' --------------- A display list interpreter end ------------------------------------------------------------------------    
'-' 
'-' 
'-' '' --------------- Blank and vsync procedures called via callpa have to be in the middle of the code ---------------------
'-' 
'-' blank           xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'         _ret_   djnz    pa,#blank
	byte	$fb, $ed, $6f, $0b
'-'         
'-' '' -------------- Preload a line from PSRAM        
'-'         
'-' preload         mov     buf1c,dlinum			   ' preload a line buffer #dlinum (0..3)
	byte	$d0, $bc, $01, $f6
'-'                 shl     buf1c,#10		           ' 1024 bytes per line
	byte	$0a, $bc, $65, $f0
'-'                 add     buf1c,buf1d			   ' add the start address (himem-debug-4096) : Todo: debug variable!
	byte	$df, $bc, $01, $f1
'-'                 mov     buf1,buf1c
	byte	$de, $b4, $01, $f6
'-'                 incmod  dlinum,#3
	byte	$03, $a0, $05, $f7
'-' 
'-'                 shr     framebuf2,#4                      ' get the PSRAM start address from DL - Todo: use new DL format
	byte	$04, $c0, $45, $f0
'-'                 mov     buf2,a1024
	byte	$32, $b7, $01, $f6
'-'                 mov     cmd,framebuf2                      ' set the address
	byte	$e0, $b2, $01, $f6
'-'                 setnib  cmd, #%1011, #7                    ' attach the command - read burst from the external memory
	byte	$0b, $b2, $3d, $f8
'-'                 setq    #2				   ' write 3 longs to the mailbox
	byte	$28, $04, $64, $fd
'-'     _ret_       wrlong  cmd,mailbox			   ' read the PSRAM
	byte	$d7, $b2, $61, $0c
'-'  
'-'  
'-' preload2      '  incmod  dlinum,#3
'-'                 shr 	framebuf2,#4
	byte	$04, $c0, $45, $f0
'-'                 mov 	cmd,affffffff
	byte	$ed, $b2, $01, $f6
'-'                 mov 	buf1,framebuf2
	byte	$e0, $b4, $01, $f6
'-'                 setq	#1
	byte	$28, $02, $64, $fd
'-'     _ret_	wrlong  cmd,mailbox
	byte	$d7, $b2, $61, $0c
'-'                 
'-' 
'-' '' -------------- Draw sprites
'-' 
'-' sprite          mov t8,frames
	byte	$cf, $5c, $02, $f6
'-' 		and t8,#16 wz
	byte	$10, $5c, $0e, $f5
'-'                 mov spritenum, #17			' 16 +2 sprites. Todo: this should be a parameter
	byte	$11, $48, $06, $f6
'-' 	if_z    mov spritenum, #16	
	byte	$10, $48, $06, $a6
'-' 		
'-' 
'-' p802            mov     t5,spritenum		   	' prepare a pointer to load sprite data
	byte	$24, $57, $02, $f6
'-'                 mul     t5,#3          			' one sprite data set needs 3 longs
	byte	$03, $56, $06, $fa
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_y,0-0,#1		        ' get a sprite y
	byte	$00, $4e, $3a, $f9
'-'                 signx	sprite_y,#15			' they can be negative
	byte	$0f, $4e, $66, $f7
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_x,0-0,#0                 ' and x
	byte	$00, $4c, $32, $f9
'-'                 signx	sprite_x,#15
	byte	$0f, $4c, $66, $f7
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_h,0-0,#1		       	' get a sprite height
	byte	$00, $52, $3a, $f9
'-'                 sub     sprite_h,#1
	byte	$01, $52, $86, $f1
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_w,0-0,#0                 ' and width
	byte	$00, $50, $32, $f9
'-' 
'-' 
'-'                	cmps	sprite_x,a1024 wcz	         
	byte	$32, $4d, $5a, $f2
'-'      if_ge	jmp 	#p801                           ' go out if >1023
	byte	$bc, $00, $90, $3d
'-'               	cmps	sprite_w,#0 wcz	         
	byte	$00, $50, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if w=0
	byte	$b4, $00, $90, $ad
'-'               	cmps	sprite_h,#0 wcz	         
	byte	$00, $52, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if h=0
	byte	$ac, $00, $90, $ad
'-'                 mov 	t9,#0
	byte	$00, $5e, $06, $f6
'-'                 sub 	t9,sprite_w                      	
	byte	$28, $5f, $82, $f1
'-'      		cmps  	sprite_x,t9 wcz   		'
	byte	$2f, $4d, $5a, $f2
'-'      if_le	jmp 	#p801	                        ' go out if sprite out of screen at right
	byte	$9c, $00, $90, $ed
'-'      
'-'   		mov     t2,linenum			' display line # to check if sprite has to be displayed
	byte	$ce, $c8, $01, $f6
'-'   		subs    t2,sprite_y wcz                 ' check if the sprite has to be displayed
	byte	$27, $c9, $d9, $f1
'-'      if_c       jmp     #p801				' if not, go out
	byte	$90, $00, $90, $cd
'-'                 cmp     t2,sprite_h wcz		    	' we have now the sprite line #, check, if it is not >= sprite height
	byte	$29, $c9, $19, $f2
'-'      if_gt      jmp     #p801				' if yes, go out
	byte	$88, $00, $90, $1d
'-'                 
'-'                 mov     t3,spriteline			' compute the line buffer addres where to put the sprite line
	byte	$25, $cb, $01, $f6
'-'                 shl     t3,#10			       	' =1024*spriteline where spriteline=0..3		' 
	byte	$0a, $ca, $65, $f0
'-'                 add     t3,buf1d			' line buffer addr
	byte	$df, $ca, $01, $f1
'-'   		
'-'   		testb	sprite_x,#31 wc 		' check if sprite pos <0
	byte	$1f, $4c, $16, $f4
'-'      if_nc      add     t3,sprite_x   			' if >=0 add xpos. If <0, the address is the start of the line  - now we have the address to where wmlong the sprite
	byte	$26, $cb, $01, $31
'-' 
'-'                 mul 	t2,sprite_w			' compute the offset to the sprite line data
	byte	$28, $c9, $01, $fa
'-'      if_c	add     sprite_w,sprite_x		' if sprite_x negative, shorten the width
	byte	$26, $51, $02, $c1
'-'      if_c	sub 	t2,sprite_x			' and add the offset (sub negative) to the sprite data offset
	byte	$26, $c9, $81, $c1
'-'  
'-'                 alts    t5,#sprite1pointer		' get the pointer to the sprite (3 longs per sprite data)
	byte	$ee, $56, $96, $f9
'-'                 add     t2,0-0				' then add the offset
	byte	$00, $c8, $01, $f1
'-'      if_c 	jmp     #p899		
	byte	$10, $00, $90, $cd
'-' 	
'-' 	
'-' 		mov 	t4,sprite_x	'
	byte	$26, $cd, $01, $f6
'-' 		add	t4,sprite_w
	byte	$28, $cd, $01, $f1
'-' 		sub     t4,a1024 wcz			' check if the sprite goes right off the screen
	byte	$32, $cd, $99, $f1
'-' 
'-' 	if_nc	sub	sprite_w,t4			' if yes, make it narrower
	byte	$e6, $50, $82, $31
'-' 
'-' p899		mov 	t6,sprite_w
	byte	$28, $59, $02, $f6
'-' 	 	sub     t6,#1
	byte	$01, $58, $86, $f1
'-' 	 	shr	t6,#2				' bytes to longs
	byte	$02, $58, $46, $f0
'-' 
'-'                 setq   	t6
	byte	$28, $58, $62, $fd
'-'                 rdlong 368,t2				' read sprite data to the cog
	byte	$e4, $e0, $02, $fb
'-'                 mov t8,sprite_w
	byte	$28, $5d, $02, $f6
'-'                 and t8,#3 wz				' if width mod 4=0 we have full longs, nothing to do
	byte	$03, $5c, $0e, $f5
'-'         if_z    jmp #p898
	byte	$24, $00, $90, $ad
'-'          
'-'         
'-'                 mov  t9,#368
	byte	$70, $5f, $06, $f6
'-'                 add t9,t6				' find the last long of the sprite
	byte	$2c, $5f, $02, $f1
'-' 
'-'                 subr t8,#4				' if modulo4=1, mask 3 bytes, if 2, mask 2, if 1, mask 3
	byte	$04, $5c, $c6, $f2
'-'                 mul t8,#8				' bits to shr
	byte	$08, $5c, $06, $fa
'-'                 mov t7,##-1				' full of 1s
	byte	$ff, $ff, $7f, $ff, $ff, $5b, $06, $f6
'-'                 shr t7,t8				' SHR to make 0s for masking
	byte	$2e, $5b, $42, $f0
'-'                 altd t9,#0				' and mask 
	byte	$00, $5e, $8e, $f9
'-'                 and 0-0, t7
	byte	$2d, $01, $00, $f5
'-'                
'-' 
'-' p898            setq   t6				' write the sprite data to the line buffer
	byte	$28, $58, $62, $fd
'-'                 wmlong 368,t3				
	byte	$e5, $e0, $7a, $fa
'-'                 
'-' p801            djnf spritenum,#p802			' get the next sprite
	byte	$c1, $49, $7e, $fb
'-'                 incmod spriteline,#3			' prepare to fill the next line
	byte	$03, $4a, $06, $f7
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 	
'-' 	
'-'                
'-'  
'-' '' -------------- Graphics line ------------------------------------------------------------
'-'  
'-' 
'-' '' consts and vars
'-' 
'-' sync_000        long    %1101010100_1101010100_1101010100_10    '
	byte	$52, $4d, $35, $d5
'-' sync_001        long    %1101010100_1101010100_0010101011_10    '        hsync
	byte	$ae, $42, $35, $d5
'-' sync_222        long    %0101010100_0101010100_0101010100_10    'vsync
	byte	$52, $45, $15, $55
'-' sync_223        long    %0101010100_0101010100_1010101011_10    'vsync + hsync
	byte	$ae, $4a, $15, $55
'-' 
'-' border          long    %00000000_00011010_00101100_00000000
	byte	$00, $2c, $1a, $00
'-' 
'-' '------ these longs will be set by setmode function
'-' 
'-' m_bs            long    0        'blanks before sync
	byte	$00, $00, $00, $00
'-' m_sn            long    0        'sync
	byte	$00, $00, $00, $00
'-' m_bv            long    0        'blanks before visible
	byte	$00, $00, $00, $00
'-' m_vi            long    0        'visible pixels #
	byte	$00, $00, $00, $00
'-' 'm_border        long    0        'left/right borders
'-' i_upporch       long    0        'up porch lines
	byte	$00, $00, $00, $00
'-' i_vsync         long    0        'vsync lines
	byte	$00, $00, $00, $00
'-' i_downporch     long    0        'down porch lines
	byte	$00, $00, $00, $00
'-' i_cpl           long    0        'chars/longs per line
	byte	$00, $00, $00, $00
'-' i_totalvis      long    0
	byte	$00, $00, $00, $00
'-' 
'-' '-------------------------------------
'-'  
'-' linenum         long    0
	byte	$00, $00, $00, $00
'-' frames          long    0
	byte	$00, $00, $00, $00
'-' dlinum long 0
	byte	$00, $00, $00, $00
'-' lutg8           long    $70880400 ' 0111_0000_1000_1000
	byte	$00, $04, $88, $70
'-' 
'-' vblankptr       long    0
	byte	$00, $00, $00, $00
'-' modeptr         long    0
	byte	$00, $00, $00, $00
'-' paletteptr      long    0
	byte	$00, $00, $00, $00
'-' dlptr           long    0
	byte	$00, $00, $00, $00
'-' hbase           long    1
	byte	$01, $00, $00, $00
'-' mailbox         long    0
	byte	$00, $00, $00, $00
'-' spriteptr          long 0
	byte	$00, $00, $00, $00
'-' 
'-' cmd             long    0
	byte	$00, $00, $00, $00
'-' buf1            long    $80000-1024-4096
	byte	$00, $ec, $07, $00
'-' buf2            long    1024
	byte	$00, $04, $00, $00
'-' dlptr2          long    1
	byte	$01, $00, $00, $00
'-' dl              long    1
	byte	$01, $00, $00, $00
'-' 
'-' buf1c long 0
	byte	$00, $00, $00, $00
'-' buf1d            long    $80000-1024-4096
	byte	$00, $ec, $07, $00
'-' framebuf2       long    1
	byte	$01, $00, $00, $00
'-' hsync0          long    1
	byte	$01, $00, $00, $00
'-' hsync1          long    1
	byte	$01, $00, $00, $00
'-' 
'-' t1              long    1
	byte	$01, $00, $00, $00
'-' t2 long 0
	byte	$00, $00, $00, $00
'-' t3 long 0
	byte	$00, $00, $00, $00
'-' t4 long 0
	byte	$00, $00, $00, $00
'-' 
'-' rcnt            long    0  'dl repeat count
	byte	$00, $00, $00, $00
'-' rcnt2           long    0
	byte	$00, $00, $00, $00
'-' rcnt2a          long    0
	byte	$00, $00, $00, $00
'-' roffset         long    0
	byte	$00, $00, $00, $00
'-' rdl             long    0  'dl repeat line
	byte	$00, $00, $00, $00
'-' dlc             long    0  'dl command
	byte	$00, $00, $00, $00
'-' 
'-' affffffff       long    $ffffffff
	byte	$ff, $ff, $ff, $ff
'-' sprite1pointer long 0
	byte	$00, $00, $00, $00
'-' sprite1xy      long 0
	byte	$00, $00, $00, $00
'-' sprite1wh      long 0
	byte	$00, $00, $00, $00
'-' sprite2pointer long 0
	byte	$00, $00, $00, $00
'-' sprite2xy      long 0
	byte	$00, $00, $00, $00
'-' sprite2wh      long 0
	byte	$00, $00, $00, $00
'-' sprite3pointer long 0
	byte	$00, $00, $00, $00
'-' sprite3xy      long 0
	byte	$00, $00, $00, $00
'-' sprite3wh      long 0
	byte	$00, $00, $00, $00
'-' sprite4pointer long 0
	byte	$00, $00, $00, $00
'-' sprite4xy      long 0
	byte	$00, $00, $00, $00
'-' sprite4wh      long 0
	byte	$00, $00, $00, $00
'-' sprite5pointer long 0
	byte	$00, $00, $00, $00
'-' sprite5xy      long 0
	byte	$00, $00, $00, $00
'-' sprite5wh      long 0
	byte	$00, $00, $00, $00
'-' sprite6pointer long 0
	byte	$00, $00, $00, $00
'-' sprite6xy      long 0
	byte	$00, $00, $00, $00
'-' sprite6wh      long 0
	byte	$00, $00, $00, $00
'-' sprite7pointer long 0
	byte	$00, $00, $00, $00
'-' sprite7xy      long 0
	byte	$00, $00, $00, $00
'-' sprite7wh      long 0
	byte	$00, $00, $00, $00
'-' sprite8pointer long 0
	byte	$00, $00, $00, $00
'-' sprite8xy      long 0
	byte	$00, $00, $00, $00
'-' sprite8wh      long 0
	byte	$00, $00, $00, $00
'-' sprite9pointer long 0
	byte	$00, $00, $00, $00
'-' sprite9xy      long 0
	byte	$00, $00, $00, $00
'-' sprite9wh      long 0
	byte	$00, $00, $00, $00
'-' sprite10pointer long 0
	byte	$00, $00, $00, $00
'-' sprite10xy      long 0
	byte	$00, $00, $00, $00
'-' sprite10wh      long 0
	byte	$00, $00, $00, $00
'-' sprite11pointer long 0
	byte	$00, $00, $00, $00
'-' sprite11xy      long 0
	byte	$00, $00, $00, $00
'-' sprite11wh      long 0
	byte	$00, $00, $00, $00
'-' sprite12pointer long 0
	byte	$00, $00, $00, $00
'-' sprite12xy      long 0
	byte	$00, $00, $00, $00
'-' sprite12wh      long 0
	byte	$00, $00, $00, $00
'-' sprite13pointer long 0
	byte	$00, $00, $00, $00
'-' sprite13xy      long 0
	byte	$00, $00, $00, $00
'-' sprite13wh      long 0
	byte	$00, $00, $00, $00
'-' sprite14pointer long 0
	byte	$00, $00, $00, $00
'-' sprite14xy      long 0
	byte	$00, $00, $00, $00
'-' sprite14wh      long 0
	byte	$00, $00, $00, $00
'-' sprite15pointer long 0
	byte	$00, $00, $00, $00
'-' sprite15xy      long 0
	byte	$00, $00, $00, $00
'-' sprite15wh      long 0
	byte	$00, $00, $00, $00
'-' sprite16pointer long 0
	byte	$00, $00, $00, $00
'-' sprite16xy      long 0
	byte	$00, $00, $00, $00
'-' sprite16wh      long 0
	byte	$00, $00, $00, $00
'-' sprite17pointer long 0
	byte	$00, $00, $00, $00
'-' sprite17xy      long 0
	byte	$00, $00, $00, $00
'-' sprite17wh      long 0
	byte	$00, $00, $00, $00
'-' sprite18pointer long 0
	byte	$00, $00, $00, $00
'-' sprite18xy      long 0
	byte	$00, $00, $00, $00
'-' sprite18wh      long 0
	byte	$00, $00, $00, $00
'-' spritenum long 0
	byte	$00, $00, $00, $00
'-' 
'-' spriteline long 0
	byte	$00, $00, $00, $00
'-' sprite_x long 900
	byte	$84, $03, $00, $00
'-' sprite_y long 0
	byte	$00, $00, $00, $00
'-' sprite_w long 16
	byte	$10, $00, $00, $00
'-' sprite_h long 64
	byte	$40, $00, $00, $00
'-' l2 long 0
	byte	$00, $00, $00, $00
'-' t5 long 0
	byte	$00, $00, $00, $00
'-' t6 long 0
	byte	$00, $00, $00, $00
'-' t7 long 0
	byte	$00, $00, $00, $00
'-' t8 long 0
	byte	$00, $00, $00, $00
'-' t9 long 0
	byte	$00, $00, $00, $00
'-' preloadaddr long 0
	byte	$00, $00, $00, $00
'-' preloadlineaddr long 0
	byte	$00, $00, $00, $00
'-' a1024 long 1024
	byte	$00, $04, $00, $00
'-' 
'-' aa long 992
	byte	$e0, $03, $00, $00
'-' a1023 long 1023
	byte	$ff, $03, $00, $00
'-' a4096 long 4096
	byte	$00, $10, $00, $00
'-'  fit 368
'-'  fit 368
	alignl
_psram_spin2_dat_
'-'     listdata long 0[8*8]
	byte	$00[256]
'-'             orgh
'-' 
'-' ' driver state
'-' drivercog   long    -1  ' COG id of driver
	byte	$ff, $ff, $ff, $ff
'-' driverlock  long    -1  ' LOCK id of driver
	byte	$ff, $ff, $ff, $ff
'-' 
'-' ' delay profile
'-' delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
	byte	$07, $00, $00, $00, $00, $cf, $7b, $05, $80, $d1, $f0, $08, $80, $4f, $47, $0c
	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
'-' 
'-' ' data to be passed to driver when starting it
'-' startupData
'-'     long    0           ' current frequency
	byte	$00, $00, $00, $00
'-'     long    FLAGS       ' optional flags for driver
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port A for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port B for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    DATABUS     ' PSRAM data bus start pin
	byte	$28, $00, $00, $00
'-'     long    deviceData  ' address of devices data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 328
'-'     long    qosData     ' address of QoS data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 456
'-'     long    mailboxes   ' address of mailbox structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 488
'-' 
'-' ' data for memory
'-' deviceData
'-'     ' 16 bank parameters follow (16MB per bank)
'-'     long    0[16]                               ' banks 0-15
	byte	$00[64]
'-'     ' 16 banks of pin parameters follow
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
	byte	$39, $38, $00, $00
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
	byte	$39, $38, $00, $00
'-'     long    -1[14]                              ' banks 2-15
	byte	$ff[56]
'-' 
'-' ' data for COG polling
'-' qosData 
'-'     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
'-'     
'-' ' mailbox storage
'-' 
'-' mailboxes
'-'     long    0[8*3]          ' 3 longs per mailbox per COG
	byte	$00[96]
	alignl
_psram16drv_spin2_dat_
'-'                             orgh
'-' scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
	byte	$00[32]
'-' 
'-' driver_start
'-'                             org
'-' '..................................................................................................
'-' ' Memory layout for COG RAM once operational:
'-' '
'-' '  COG RAM address      Usage
'-' '  ---------------      ----
'-' '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
'-' '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
'-' '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
'-' '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
'-' '   $100-$197           Mailbox poller, error handlers, and all driver management code
'-' '  ~$198-$1F3           State and register variables
'-' '
'-' ' Also during driver COG startup:
'-' '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
'-' ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
'-' '..................................................................................................
'-'                             
'-' ' Mailbox storage after vector initialization
'-' 
'-' req0                        call    #init                   'do HW setup/initialization
	byte	$fc, $01, $b0, $fd
'-' data0                       rdlut   c, b wz                 'read bank info          
	byte	$f0, $e3, $ab, $fa
'-' count0                      mov     a, b                    'set COGRAM address low nibble
	byte	$f0, $df, $03, $f6
'-' req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
	byte	$68, $f0, $07, $a6
'-' data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
	byte	$0a, $e2, $17, $f4
'-' count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
	byte	$50, $f0, $07, $16
'-' req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
	byte	$58, $f0, $07, $46
'-' data2                       mov     c, #$8                  'setup vector base to $80
	byte	$08, $e2, $07, $f6
'-' count2                      setnib  a, c, #1                'prepare vector base address for bank
	byte	$f1, $df, $0b, $f8
'-' req3                        altd    a, #0                   'prepare COG destination read address
	byte	$00, $de, $8f, $f9
'-' data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
	byte	$61, $01, $a4, $fa
'-' count3                      incmod  c, #15 wz               'next vector
	byte	$0f, $e2, $0f, $f7
'-' req4        if_nz           jmp     #count2                 'repeat
	byte	$ec, $ff, $9f, $5d
'-' data4                       incmod  b, #15 wz               'next bank
	byte	$0f, $e0, $0f, $f7
'-' count4      if_nz           jmp     #data0                  'repeat
	byte	$c8, $ff, $9f, $5d
'-' req5                        mov     ptra, #$20              'setup base LUT address to clear
	byte	$20, $f0, $07, $f6
'-' data5                       rep     #5, #80                 'update next 80 longs      
	byte	$50, $0a, $dc, $fc
'-' count5                      cmp     ptra, header wc         'check if LUT address range 
	byte	$e2, $f1, $13, $f2
'-' req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
	byte	$e3, $f1, $93, $32
'-' data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
	byte	$61, $01, $3c, $cc
'-' count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
	byte	$61, $b1, $37, $3c
'-' req7        if_nc           add     $-1, const512           'increment source of LUT write data
	byte	$a5, $29, $00, $31
'-' data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
	byte	$ff, $c0, $03, $f6
'-' count7      _ret_           mov     255, #dolist            'setup list address, return to notify
	byte	$26, $ff, $05, $06
'-' 
'-' ' Mailbox parameter addresses per COG once patched
'-'                             
'-' cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
	byte	$04, $00, $00, $00
'-' cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
	byte	$10, $00, $00, $00
'-' cog2mboxdata                long    2*12+4                  '...
	byte	$1c, $00, $00, $00
'-' cog3mboxdata                long    3*12+4
	byte	$28, $00, $00, $00
'-' cog4mboxdata                long    4*12+4
	byte	$34, $00, $00, $00
'-' cog5mboxdata                long    5*12+4
	byte	$40, $00, $00, $00
'-' cog6mboxdata                long    6*12+4
	byte	$4c, $00, $00, $00
'-' cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
	byte	$58, $00, $00, $00
'-' 
'-' '..................................................................................................
'-' ' Per COG request and state setup and service branching
'-'         
'-' cog0                 
'-'                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
	byte	$20, $f0, $07, $f6
'-'                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
	byte	$18, $f2, $03, $f6
'-'                             mov     id, id0                 'get COG0 state
	byte	$d0, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG0 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$30, $04, $90, $5d
'-'                             mov     addr1, req0             'get mailbox request parameter for COG0
	byte	$00, $b0, $03, $f6
'-'                             mov     hubdata, data0          'get COG0 mailbox data parameter
	byte	$01, $b2, $03, $f6
'-'                             mov     count, count0           'get COG0 mailbox count parameter
	byte	$02, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog1                        
'-'                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
	byte	$2a, $f0, $07, $f6
'-'                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
	byte	$19, $f2, $03, $f6
'-'                             mov     id, id1                 'get COG1 state
	byte	$d1, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG1 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$00, $04, $90, $5d
'-'                             mov     addr1, req1             'get mailbox request parameter for COG1
	byte	$03, $b0, $03, $f6
'-'                             mov     hubdata, data1          'get COG1 mailbox data parameter
	byte	$04, $b2, $03, $f6
'-'                             mov     count, count1           'get COG1 mailbox count parameter
	byte	$05, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog2                         
'-'                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
	byte	$34, $f0, $07, $f6
'-'                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
	byte	$1a, $f2, $03, $f6
'-'                             mov     id, id2                 'get COG2 state
	byte	$d2, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG2 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$d0, $03, $90, $5d
'-'                             mov     addr1, req2             'get mailbox request parameter for COG2
	byte	$06, $b0, $03, $f6
'-'                             mov     hubdata, data2          'get COG2 mailbox data parameter
	byte	$07, $b2, $03, $f6
'-'                             mov     count, count2           'get COG2 mailbox count parameter
	byte	$08, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog3                        
'-'                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
	byte	$3e, $f0, $07, $f6
'-'                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
	byte	$1b, $f2, $03, $f6
'-'                             mov     id, id3                 'get COG3 state
	byte	$d3, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG3 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$a0, $03, $90, $5d
'-'                             mov     addr1, req3             'get mailbox request parameter for COG3
	byte	$09, $b0, $03, $f6
'-'                             mov     hubdata, data3          'get COG3 mailbox data parameter
	byte	$0a, $b2, $03, $f6
'-'                             mov     count, count3           'get COG3 mailbox count parameter
	byte	$0b, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog4                        
'-'                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
	byte	$48, $f0, $07, $f6
'-'                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
	byte	$1c, $f2, $03, $f6
'-'                             mov     id, id4                 'get COG4 state
	byte	$d4, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG4 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$70, $03, $90, $5d
'-'                             mov     addr1, req4             'get mailbox request parameter for COG4
	byte	$0c, $b0, $03, $f6
'-'                             mov     hubdata, data4          'get COG4 mailbox data parameter
	byte	$0d, $b2, $03, $f6
'-'                             mov     count, count4           'get COG4 mailbox count parameter
	byte	$0e, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog5                        
'-'                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
	byte	$52, $f0, $07, $f6
'-'                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
	byte	$1d, $f2, $03, $f6
'-'                             mov     id, id5                 'get COG5 state
	byte	$d5, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG5 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$40, $03, $90, $5d
'-'                             mov     addr1, req5             'get mailbox request parameter for COG5
	byte	$0f, $b0, $03, $f6
'-'                             mov     hubdata, data5          'get COG5 mailbox data parameter
	byte	$10, $b2, $03, $f6
'-'                             mov     count, count5           'get COG5 mailbox count parameter
	byte	$11, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog6                        
'-'                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
	byte	$5c, $f0, $07, $f6
'-'                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
	byte	$1e, $f2, $03, $f6
'-'                             mov     id, id6                 'get COG6 state
	byte	$d6, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG6 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$10, $03, $90, $5d
'-'                             mov     addr1, req6             'get mailbox request parameter for COG6
	byte	$12, $b0, $03, $f6
'-'                             mov     hubdata, data6          'get COG6 mailbox data parameter
	byte	$13, $b2, $03, $f6
'-'                             mov     count, count6           'get COG6 mailbox count parameter
	byte	$14, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog7                        
'-'                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
	byte	$66, $f0, $07, $f6
'-'                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
	byte	$1f, $f2, $03, $f6
'-'                             mov     id, id7                 'get COG7 state
	byte	$d7, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG7 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$e0, $02, $90, $5d
'-'                             mov     addr1, req7             'get mailbox request parameter for COG7
	byte	$15, $b0, $03, $f6
'-'                             mov     hubdata, data7          'get COG7 mailbox data parameter
	byte	$16, $b2, $03, $f6
'-'                             mov     count, count7           'get COG7 mailbox count parameter
	byte	$17, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' 
'-'                             fit     128
'-'                             fit     128
'-' pad                         long    0[128-$]                'align init code to $80
'-' 
'-' '..................................................................................................
'-' 
'-' ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
'-' 
'-' init                        
'-'                             ' get driver scratch long address in hub
'-'                             cogid   hubscratch              'get cogid
	byte	$01, $da, $63, $fd
'-'                             add     hubscratch, #1          'increase by 1 from 1-8
	byte	$01, $da, $07, $f1
'-'                             mul     hubscratch, #4          'multiply by 4 to get 4-32
	byte	$04, $da, $07, $fa
'-'                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
	byte	$f9, $db, $c3, $f2
'-'                     
'-'                             ' read in the additional LUT RAM code
'-'                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
	byte	$f9, $41, $03, $f1
'-'                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
	byte	$29, $9e, $67, $fd
'-'                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
	byte	$a0, $61, $00, $fb
'-' 
'-'                             ' read the startup parameters
'-'                             setq    #8-1                    'read 8 longs from hub
	byte	$28, $0e, $64, $fd
'-'                             rdlong  startupparams, ptra     '.. as the startup parameters 
	byte	$00, $41, $07, $fb
'-' 
'-'                             ' setup some of the config flag dependent state and patch LUTRAM
'-'                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
	byte	$1c, $42, $0f, $f4
'-' 
'-'             if_z            add     expansion, ptrb         'compensate for HUB address
	byte	$f9, $71, $03, $a1
'-'             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
	byte	$01, $00, $00, $5f, $fb, $70, $07, $56
'-'                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
	byte	$1d, $42, $17, $f4
'-'             if_nc           or      clkconfig, registered   'enable this if so
	byte	$aa, $57, $43, $35
'-'             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
	byte	$00, $58, $07, $36
'-' 
'-'                             ' setup data pin modes and data bus pin group in streamer commands
'-'                             and     datapins, #%111000      'compute base pin
	byte	$38, $48, $07, $f5
'-'                             or      datapins, ##(15<<6)     'configure 16 pins total
	byte	$01, $00, $00, $ff, $c0, $49, $47, $f5
'-'                             mov     a, datapins             'get data pin base
	byte	$a4, $df, $03, $f6
'-'                             wrpin   registered, datapins    'prepare data pins for address phase transfer
	byte	$a4, $55, $03, $fc
'-'                             shr     a, #3                   'determine data pin group
	byte	$03, $de, $47, $f0
'-'                             and     a, #7                   'ignore the unwanted bits
	byte	$07, $de, $07, $f5
'-'                             or      a, #8
	byte	$08, $de, $47, $f5
'-'                             setnib  ximm8lut, a, #5         'setup bus group in streamer
	byte	$ef, $2f, $2b, $f8
'-'                             setnib  xrecvlo8, a, #5
	byte	$ef, $31, $2b, $f8
'-'                             setnib  xrecvdata, a, #5
	byte	$ef, $35, $2b, $f8
'-'                             setnib  xsenddata, a, #5
	byte	$ef, $37, $2b, $f8
'-'                             setnib  xsendimm, a, #5
	byte	$ef, $39, $2b, $f8
'-'                             add     a, #1
	byte	$01, $de, $07, $f1
'-'                             setnib  xrecvhi8, a, #5         ' increase port by one
	byte	$ef, $33, $2b, $f8
'-'  
'-'                             ' setup device control pin states
'-'                             setq2   #32-1                   'read 32 longs to LUTRAM
	byte	$29, $3e, $64, $fd
'-'                             rdlong  $000, devicelist        'read bank/pin data for all banks    
	byte	$a5, $01, $00, $fb
'-'                             mov     const512, ##512         'prepare constant
	byte	$01, $00, $00, $ff, $00, $4a, $07, $f6
'-' 
'-'                             mov     ptrb, #16               'point to bank pin config data
	byte	$10, $f2, $07, $f6
'-'                             rep     @pinloop, #16           'iterate through 16 banks
	byte	$10, $14, $dc, $fc
'-'                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
	byte	$e1, $cf, $b7, $fa
'-'                             and     pinconfig, pinmask      'save us from invalid bits in args
	byte	$af, $cf, $03, $f5
'-'             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
	byte	$e7, $53, $e3, $38
'-'             if_nc           wrpin   #0, cspin               'clear smart pin mode
	byte	$a9, $01, $08, $3c
'-'             if_nc           drvh    cspin                   'setup pins for all banks
	byte	$59, $52, $63, $3d
'-'             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
	byte	$e7, $51, $eb, $38
'-'             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
	byte	$50, $50, $63, $3d
'-'             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
	byte	$a8, $57, $03, $3c
'-'             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
	byte	$a8, $03, $18, $3c
'-'             if_nc           drvl    clkpin                  'set clk state low
	byte	$58, $50, $63, $3d
'-' pinloop
'-'                             ' generate minimum CE high time before access
'-'                             qdiv    frequency, ##1000000    'convert from Hz to MHz
	byte	$a1, $07, $00, $ff, $40, $40, $17, $fd
'-'                             getqx   c                       'get P2 clocks per microsecond
	byte	$18, $e2, $63, $fd
'-'                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
	byte	$96, $de, $07, $f6
'-'                             mul     a, c                    'convert microseconds to clocks
	byte	$f1, $df, $03, $fa
'-'                             waitx   a                       'delay
	byte	$1f, $de, $63, $fd
'-'                             call    #hwinit                 'setup HW into QSPI mode
	byte	$e8, $05, $b0, $fd
'-' 
'-'                             ' setup the COG mailboxes and addresses 
'-'                             rep     #2, #8                  'setup loop to patch mailbox addresses
	byte	$08, $04, $dc, $fc
'-'                             alti    $+1, #%111_000          'increase D field
	byte	$38, $70, $a5, $f9
'-'                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
	byte	$a7, $31, $00, $f1
'-' 
'-'                             setq    #24-1
	byte	$28, $2e, $64, $fd
'-'                             wrlong  #0, mbox                'clear out mailboxes ????
	byte	$a7, $01, $68, $fc
'-' 
'-'                             ' setup the polling loop for active COGs 
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             alts    id, #id0                'determine id register of control COG
	byte	$d0, $c3, $97, $f9
'-'                             setd    patchid, #0             'patch into destination address
	byte	$00, $90, $b6, $f9
'-'                             push    ptra                    'save ptra before we lose it
	byte	$2a, $f0, $63, $fd
'-'                             mov     ptra, #10
	byte	$0a, $f0, $07, $f6
'-'                             mul     ptra, id
	byte	$e1, $f1, $03, $fa
'-'                             add     ptra, #$20              'prep ptra for reloadcogs
	byte	$20, $f0, $07, $f1
'-'                             alts    id, #cog0_handler       'add to handler base
	byte	$b0, $c3, $97, $f9
'-'                             sets    ctrlpollinst, #0-0      'patch into jump instruction
	byte	$00, $48, $be, $f9
'-'                             mul     id, #3
	byte	$03, $c2, $07, $fa
'-'                             setd    ctrlpollinst, id
	byte	$e1, $49, $b2, $f9
'-'                             rdlut   id, ptra[9]             'save original value
	byte	$09, $c3, $a7, $fa
'-'                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
	byte	$09, $c1, $37, $fc
'-'                             call    #reloadcogs
	byte	$d8, $01, $b0, $fd
'-'                             wrlut   id, ptra[9]             'restore original value
	byte	$09, $c3, $37, $fc
'-'                             pop     ptra                    'restore original ptra
	byte	$2b, $f0, $63, $fd
'-'                             ' move LUT control vectors into temporary location to avoid clobbering them later
'-'                             setd    d, #addr1
	byte	$d8, $e5, $b7, $f9
'-'                             sets    d, #(ctrl_vect & $1ff)
	byte	$60, $e4, $bf, $f9
'-'                             rep     #2, #8
	byte	$08, $04, $dc, $fc
'-'                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
	byte	$3f, $e4, $a7, $f9
'-'                             rdlut   addr1-0, #$60-0
	byte	$60, $b0, $a7, $fa
'-' 
'-'                             'setup control COG service handling, we need to patch 5 instructions
'-'                             'one existing instruction is moved earlier and four instructions get replaced
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             mov     a, #(cog1-cog0)         'get code separation of handlers
	byte	$0c, $de, $07, $f6
'-'                             mul     a, id                   'scale ID by separation
	byte	$e1, $df, $03, $fa
'-'                             add     a, #cog0+4              'add to base for COG0 and offset
	byte	$24, $de, $07, $f1
'-'                             setd    d, a                    'set this as the destination
	byte	$ef, $e5, $b3, $f9
'-'                             add     a, #2                   'increment COG address
	byte	$02, $de, $07, $f1
'-'                             sets    d, a                    'set this as the source
	byte	$ef, $e5, $bb, $f9
'-'                             alti    d, #%111_100             
	byte	$3c, $e4, $a7, $f9
'-'                             mov     0-0, 0-0                'move instruction
	byte	$00, $00, $00, $f6
'-'                             sets    d, #controlpatch        'set source of patched instructions
	byte	$ee, $e4, $bf, $f9
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             add     d, const512             'skip two instructions
	byte	$a5, $e5, $03, $f1
'-'                             add     d, const512
	byte	$a5, $e5, $03, $f1
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             
'-'                             ' setup register values for control vector loop setup after we return
'-'                             mov     header, id              'get cog ID
	byte	$e1, $c5, $03, $f6
'-'                             mul     header, #10             'multiply by size of state memory per COG
	byte	$0a, $c4, $07, $fa
'-'                             add     header, #$20            'add to COG state base address in LUT
	byte	$20, $c4, $07, $f1
'-'                             mov     trailer, header         'determine start/end LUT address
	byte	$e2, $c7, $03, $f6
'-'                             add     trailer, #9             '...for control region
	byte	$09, $c6, $07, $f1
'-'                             or      id, initctrl            'set id field for control COG
	byte	$e0, $c3, $43, $f5
'-'                             altd    id, #id0
	byte	$d0, $c3, $8f, $f9
'-'                             mov     0-0, id                 'setup id field for notification
	byte	$e1, $01, $00, $f6
'-'                             mov     ptrb, ptra              'get startup parameter address
	byte	$f8, $f3, $03, $f6
'-'                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
	byte	$04, $f2, $07, $f1
'-'                             mov     b, #0                   'prepare b for upcoming loop
	byte	$00, $e0, $07, $f6
'-'                 _ret_       push    #notify                 'continue init in mailbox area
	byte	$2a, $14, $66, $0d
'-'  
'-' controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
	byte	$d8, $cb, $7b, $f8
'-'                             and     request, #7
	byte	$07, $ca, $07, $f5
'-'                             add     request, ptra           'add request vector offset
	byte	$f8, $cb, $03, $f1
'-'                             rdlut   request, request        'lookup jump vector service table 
	byte	$e5, $cb, $a3, $fa
'-' 
'-'                             fit     $100                    'ensure all init code fits this space
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             long    0[$100-$]               'pad more if required until table ends
	byte	$00[56]
'-' 
'-' '..................................................................................................
'-' ' Error result handling and COG notification of request completion
'-' 
'-' unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
	byte	$04, $04, $4c, $fb
'-' invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
	byte	$03, $02, $4c, $fb
'-' invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
	byte	$02, $06, $4c, $fb
'-' alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
	byte	$01, $08, $4c, $fb
'-' busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
	byte	$05, $ec, $07, $f6
'-' err                         altd    id, #id0                'adjust for the running COG
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
	byte	$09, $00, $04, $f4
'-'                             wrlut   #0, ptra[8]             'cancel any resume state
	byte	$08, $01, $3c, $fc
'-'                             skipf   #%10                    'dont notify with success code 0 below
	byte	$32, $04, $64, $fd
'-'                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
	byte	$bf, $ed, $67, $fc
'-' notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
	byte	$bf, $01, $6c, $fc
'-'                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
	byte	$0b, $c2, $0f, $f4
'-'                             decod   a, id                   'convert COG ID to bitmask
	byte	$e1, $df, $c3, $f9
'-'             if_z            cogatn  a                       'notify COG via ATN
	byte	$3f, $de, $63, $ad
'-' ' Poller re-starts here after a COG is serviced
'-' poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
	byte	$0f, $c2, $0f, $f4
'-'             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
	byte	$e6, $5f, $03, $57
'-'                             bmask   mask, rrcounter         'generate a RR skip mask from the count
	byte	$af, $45, $cb, $f9
'-' ' Main dynamic polling loop repeats until a request arrives
'-' polling_loop                rep     #0-0, #0                'repeat until we get a request for something
	byte	$00, $00, $dc, $fc
'-'                             setq    #24-1                   'read 24 longs
	byte	$28, $2e, $64, $fd
'-'                             rdlong  req0, mbox              'get all mailbox requests and data longs
	byte	$a7, $01, $00, $fb
'-' 
'-' polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
	byte	$b0, $01, $b0, $fb
'-'                             skipf   mask                    ']after all priority COG handlers if present
	byte	$32, $44, $63, $fd
'-'                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']based on the active COGs being polled
	byte	$b6, $25, $b0, $fb
'-'                             tjs     req7, cog7_handler      ']and whether priority or round robin.
	byte	$b7, $2b, $b0, $fb
'-'                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']have changed.
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
	byte	$b6, $25, $b0, $fb
'-' pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
	byte	$b7, $2b, $b0, $fb
'-' 
'-' ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
	byte	$b0, $01, $b0, $fb
'-' skipfinst                   skipf   mask                    'instruction template for skipf
	byte	$32, $44, $63, $fd
'-'  
'-' '..................................................................................................
'-' ' List handler                               
'-' 
'-' dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
	byte	$01, $b0, $a7, $fb
'-'                             execf   burstwrite              'otherwise do a burst write to this bank
	byte	$33, $c0, $63, $fd
'-' real_list                   setq    #8-1                    'read 8 longs (largest request size)
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, hubdata          '..to update the request state
	byte	$d9, $b1, $03, $fb
'-'                             tjns    addr1, #invalidlist     'error if request list item not valid
	byte	$d7, $b1, $bf, $fb
'-'                             altd    id, #id0                'get COG state
	byte	$d0, $c3, $8f, $f9
'-'                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
	byte	$09, $00, $3c, $f4
'-'                             bith    id, #LIST_BIT           'retain fact that we are in a list
	byte	$09, $c2, $27, $f4
'-'             if_z            jmp     #unsupported            'no list recursion is allowed!
	byte	$44, $ff, $9f, $ad
'-'                             getbyte request, addr1, #3      'get upper byte of this request
	byte	$d8, $cb, $fb, $f8
'-' service_request             altd    request, #0             'get request address in COG RAM
	byte	$00, $ca, $8f, $f9
'-'                             execf   0-0                     'process the request 
	byte	$33, $00, $60, $fd
'-' 
'-' '..................................................................................................
'-' ' Restoring per COG state and resuming where we left off
'-' 
'-' restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
	byte	$00, $b1, $a7, $fa
'-'                             rdlut   hubdata, ptra[1]
	byte	$01, $b3, $a7, $fa
'-'                             rdlut   count, ptra[2]
	byte	$02, $b5, $a7, $fa
'-'                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
	byte	$03, $b7, $b7, $fa
'-'                             getbyte request, addr1, #3
	byte	$d8, $cb, $fb, $f8
'-'             if_nc           execf   resume                  'if not extended then resume immediately
	byte	$33, $d2, $63, $3d
'-'                             rdlut   total, ptra[4]          'we need to read the extended parameters
	byte	$04, $b9, $a7, $fa
'-'                             rdlut   offset1, ptra[5]
	byte	$05, $bb, $a7, $fa
'-'                             rdlut   offset2, ptra[6]
	byte	$06, $bd, $a7, $fa
'-'                             rdlut   link, ptra[7]
	byte	$07, $bf, $a7, $fa
'-'                             rdlut   orighubsize, ptra[9]
	byte	$09, $d5, $a7, $fa
'-'                             execf   resume                  'then resume what we were doing last time
	byte	$33, $d2, $63, $fd
'-'                    
'-' '..................................................................................................
'-' ' Re-configuration of QoS settings and custom polling loop sequence generator
'-' 
'-' reconfig                    push    #notify                 'setup return addr, then reload 
	byte	$2a, $14, $66, $fd
'-' reloadcogs                  setq    #8-1                    'reload all per COG QoS params
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
	byte	$a6, $b1, $03, $fb
'-'                             setd    a, #id0
	byte	$d0, $df, $b7, $f9
'-'                             sets    a, #addr1
	byte	$d8, $df, $bf, $f9
'-'                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
	byte	$fe, $ff, $ff, $ff, $28, $00, $66, $fd
'-'                             rep     #2, #8                  'repeat for 8 COGs
	byte	$08, $04, $dc, $fc
'-'                             alti    a, #%111_111 
	byte	$3f, $de, $a7, $f9
'-'                             muxq    0-0, 0-0
	byte	$00, $00, $f0, $f9
'-' patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
	byte	$09, $01, $a4, $fa
'-'                             cogid   c
	byte	$01, $e2, $63, $fd
'-'                             decod   excludedcogs, c         'exclude driver cog initially
	byte	$f1, $41, $c3, $f9
'-'                             mov     a, #$8                  'a iterates through prio levels 8=lowest
	byte	$08, $de, $07, $f6
'-'                             neg     pa, #1                  'start with all ones
	byte	$01, $ec, $67, $f6
'-' fillprio                    mov     c, #7                   'c iterates through cogs
	byte	$07, $e2, $07, $f6
'-' prioloop                    alts    c, #id0
	byte	$d0, $e3, $97, $f9
'-'                             mov     b, 0-0
	byte	$00, $e0, $03, $f6
'-'                             getword d, b, #1                'get burst field
	byte	$f0, $e5, $3b, $f9
'-'                             test    d wz                    'if burst=0 
	byte	$f2, $e5, $cb, $f7
'-'             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
	byte	$f1, $41, $23, $a4
'-'             if_z            jmp     #excluded               
	byte	$0c, $00, $90, $ad
'-'                             getnib  d, b, #3                'get RR/PRI flag & priority
	byte	$f0, $e5, $5b, $f8
'-'                             cmp     d, a wz                 'compare against current priority level
	byte	$ef, $e5, $0b, $f2
'-'             if_z            rolnib  pa, c, #0               'if matches include COG at this level
	byte	$f1, $ed, $83, $a8
'-' excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
	byte	$f6, $e3, $7f, $fb
'-'                             incmod  a, #15 wz               'next level
	byte	$0f, $de, $0f, $f7
'-'             if_nz           jmp     #fillprio 
	byte	$cc, $ff, $9f, $5d
'-' 
'-' 'determine priority cogs and build instructions for the polling sequence
'-'                             mov     pb, #0                  'clear out set of priority COGs
	byte	$00, $ee, $07, $f6
'-'                             mov     a, #3                   'start with no COGs being polled + 3 instructions
	byte	$03, $de, $07, $f6
'-'                             setd    d, #polling_code        'initialize COGRAM write position
	byte	$14, $e5, $b7, $f9
'-' 
'-'                             rep     @endprioloop, #8        'test all 8 priority slots
	byte	$08, $18, $dc, $fc
'-'                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
	byte	$03, $ec, $17, $f4
'-'                             getnib  c, pa, #0               'get cogid ID at this priority level
	byte	$f6, $e3, $43, $f8
'-'             if_nc           testb   pb, c wz                'check if already exists as priority COG
	byte	$f1, $ef, $0b, $34
'-'             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
	byte	$f1, $ef, $23, $14
'-'             if_nc_and_nz    add     a, #1                   'add another COG to poll 
	byte	$01, $de, $07, $11
'-'             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
	byte	$b0, $e3, $97, $19
'-'             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $19
'-'             if_nc_and_nz    mul     c, #3
	byte	$03, $e2, $07, $1a
'-'             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
	byte	$f1, $47, $b2, $19
'-'             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $19
'-'             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $16
'-'                             ror     pa, #4                  'advance to next priority
	byte	$04, $ec, $07, $f0
'-' endprioloop
'-'                             xor     pb, #$ff                'invert to find all the non-priority COGs
	byte	$ff, $ee, $67, $f5
'-'                             andn    pb, excludedcogs        'and remove any other excluded COGs
	byte	$a0, $ef, $23, $f5
'-'                             ones    rrlimit, pb wz          'count the number of RR COGs
	byte	$f7, $cd, $ab, $f7
'-'                             add     a, rrlimit              'account for this number of RR COGs to poll
	byte	$e6, $df, $03, $f1
'-'                             sub     rrlimit, #1             'setup last RR count value for incmod
	byte	$01, $cc, $87, $f1
'-'                             alti    d, #%111_000            'generate the control polling instruction
	byte	$38, $e4, $a7, $f9
'-'                             mov     0-0, ctrlpollinst       'write the instruction
	byte	$24, $01, $00, $f6
'-'             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
	byte	$38, $e4, $a7, $59
'-'             if_nz           mov     0-0, skipfinst          'add the skipf instruction
	byte	$25, $01, $00, $56
'-'             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
	byte	$02, $de, $07, $51
'-'                             setd    polling_loop, a         'save it as the repeat count
	byte	$ef, $23, $b2, $f9
'-'             if_z            ret                             'we are done now, if no round robin COGs
	byte	$2d, $00, $64, $ad
'-' 
'-' ' populate the round robin COG polling instructions
'-'                             mov     rrcounter, #2           'fill the RR poll instruction list twice
	byte	$02, $5e, $07, $f6
'-' rrloop                      mov     b, pb                   'get the set of RR COGs
	byte	$f7, $e1, $03, $f6
'-'                             mov     c, #0                   'start at COG ID = 0
	byte	$00, $e2, $07, $f6
'-'                             mov     a, #0                   'req mailbox COGRAM address for COG 0
	byte	$00, $de, $07, $f6
'-' nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
	byte	$01, $e0, $5f, $f0
'-'             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
	byte	$ef, $47, $b2, $c9
'-'             if_c            alts    c, #cog0_handler        'determine jump address
	byte	$b0, $e3, $97, $c9
'-'             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $c9
'-'             if_c            alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $c9
'-'             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $c6
'-'                             add     c, #1                   'increment the COG ID
	byte	$01, $e2, $07, $f1
'-'                             add     a, #3                   'increase the request address
	byte	$03, $de, $07, $f1
'-'             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
	byte	$dc, $ff, $9f, $5d
'-'             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
	byte	$f3, $5f, $6f, $0b
'-' '..................................................................................................
'-' ' Code to get/set driver settings per bank or to dump COG/LUT state
'-' 
'-' set_latency                                                 '            (a) set latency
'-' get_latency                                                 '            (b) get latency
'-' set_burst                                                   '            (c) set burst size of bank
'-' get_burst                                                   '            (d) get burst size of bank
'-'                                                             '            (e) dump state
'-'                             getnib  b, addr1, #6            ' a b c d    get bank address
	byte	$d8, $e1, $73, $f8
'-' dump_state                  setq    #511                    ' | | | | e  prepare burst write
	byte	$28, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                                                             ' | | | | e  account for following AUGS
'-'                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
	byte	$04, $00, $00, $ff, $00, $b2, $07, $f1
'-'                             setq2   #511                    ' | | | | e  prepare burst write
	byte	$29, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                             add     b, #16                  ' a b | | |  point to latency params
	byte	$10, $e0, $07, $f1
'-'                             rdlut   a, b                    ' a b c d |  read data for bank
	byte	$f0, $df, $a3, $fa
'-'                             setbyte a, hubdata, #3          ' a | | | |  patch latency
	byte	$d9, $df, $db, $f8
'-'                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
	byte	$d9, $df, $03, $f6
'-'                             wrlut   a, b                    ' a | c | |  if setting, save bank data
	byte	$f0, $df, $33, $fc
'-'                             getbyte a, a, #3                ' | b | | |  extract latency field only
	byte	$ef, $df, $fb, $f8
'-'                             wrlong  a, ptrb                 ' | b | d |  write result          
	byte	$80, $df, $67, $fc
'-'                             jmp     #notify                 ' a b c d e  return success
	byte	$dc, $fd, $9f, $fd
'-' 
'-' '..................................................................................................
'-' ' Misc EXECF code
'-' 
'-' start_read_exec             execf   newburstr
	byte	$33, $72, $63, $fd
'-' start_write_exec            execf   resumewrites
	byte	$33, $7c, $63, $fd
'-' continue_read_exec          execf   lockedreads
	byte	$33, $78, $63, $fd
'-' continue_write_exec         execf   lockedwrites
	byte	$33, $7a, $63, $fd
'-' 
'-' '..................................................................................................
'-' ' Variables
'-' 
'-' ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
	byte	$08, $00, $cf, $20
'-' xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
	byte	$00, $00, $c0, $f0
'-' xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
	byte	$00, $00, $c0, $b0
'-' xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
	byte	$02, $00, $c0, $70
'-' 
'-' xfreq1          long    $80000000
	byte	$00, $00, $00, $80
'-' xfreq2          long    $40000000
	byte	$00, $00, $00, $40
'-' delay           long    3
	byte	$03, $00, $00, $00
'-' 
'-' lutcodeaddr                 
'-' startupparams
'-' excludedcogs                                    'careful: shared register use!
'-' frequency       long    lut_code - driver_start 'determine offset of LUT code from base
	byte	$cc, $07, $00, $00
'-' flags           long    0
	byte	$00, $00, $00, $00
'-' mask                                            'careful: shared register use!
'-' resetmaskA      long    0
	byte	$00, $00, $00, $00
'-' limit                                           'careful: shared register use!
'-' resetmaskB      long    0
	byte	$00, $00, $00, $00
'-' datapins        long    0
	byte	$00, $00, $00, $00
'-' const512                                        'careful: shared register use!
'-' devicelist      long    0
	byte	$00, $00, $00, $00
'-' coglist         long    0
	byte	$00, $00, $00, $00
'-' mbox            long    0 
	byte	$00, $00, $00, $00
'-' 
'-' clkpin                                          'shared with code patched during init
'-' clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
	byte	$a8, $03, $18, $fc
'-' cspin                                           'shared with code patched during init
'-' speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
	byte	$1d, $3a, $63, $fd
'-' registered      long    %100_000_000_00_00000_0 'config pin for clocked input
	byte	$00, $00, $01, $00
'-' clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
	byte	$4a, $00, $00, $00
'-' clkdelay        long    1
	byte	$01, $00, $00, $00
'-' regdatabus      long    0
	byte	$00, $00, $00, $00
'-' 
'-' deviceaddr      long    $10
	byte	$10, $00, $00, $00
'-' rrcounter
'-' pinmask         long    $ff3f7f7f
	byte	$7f, $7f, $3f, $ff
'-' 
'-' ' jump addresses for the per COG handlers
'-' cog0_handler    long    cog0
	byte	$20, $00, $00, $00
'-' cog1_handler    long    cog1
	byte	$2c, $00, $00, $00
'-' cog2_handler    long    cog2
	byte	$38, $00, $00, $00
'-' cog3_handler    long    cog3
	byte	$44, $00, $00, $00
'-' cog4_handler    long    cog4
	byte	$50, $00, $00, $00
'-' cog5_handler    long    cog5
	byte	$5c, $00, $00, $00
'-' cog6_handler    long    cog6
	byte	$68, $00, $00, $00
'-' cog7_handler    long    cog7
	byte	$74, $00, $00, $00
'-' expansion       long    gfxexpansion - driver_start
	byte	$0c, $0f, $00, $00
'-' 
'-' ' EXECF sequences
'-' newburstr       long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-' lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
	byte	$48, $9b, $ef, $00
'-' restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
	byte	$41, $f3, $05, $74
'-' lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
	byte	$80, $22, $3f, $00
'-' lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
	byte	$4b, $f3, $e0, $0f
'-' resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
	byte	$4b, $03, $e0, $0f
'-' resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
	byte	$76, $02, $8a, $84
'-' 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
'-' 
'-' 
'-' ' SKIPF sequences
'-' skiptable
'-'                 long    %11000011000001111110  ' read modify write byte
	byte	$7e, $30, $0c, $00
'-'                 long    %110011011100001110    ' read modify write word
	byte	$0e, $37, $03, $00
'-'                 long    0                      ' read modify write long
	byte	$00, $00, $00, $00
'-'                 long    %1111110               ' single byte read
	byte	$7e, $00, $00, $00
'-'                 long    %11110001110           ' single word read
	byte	$8e, $07, $00, $00
'-' pattern2        long    0
	byte	$00, $00, $00, $00
'-' pattern3        long    0
	byte	$00, $00, $00, $00
'-' singlelong      long    %1001110111  
	byte	$77, $02, $00, $00
'-' skipcase_a      long    %01101111100000000001000011111101
	byte	$fd, $10, $80, $6f
'-' skipcase_b      long    %00000000010100000001100000010000
	byte	$10, $18, $50, $00
'-' skipcase_c      long    %00000000011000000011111000010001
	byte	$11, $3e, $60, $00
'-' skipseq_write   long    %00000000000000000000111100000010
	byte	$02, $0f, $00, $00
'-' 
'-' ' LUT RAM address values
'-' complete_rw     long    complete_rw_lut
	byte	$ff, $02, $00, $00
'-' continue_read   long    continue_read_lut
	byte	$dd, $02, $00, $00
'-' continue_write  long    continue_write_lut
	byte	$db, $02, $00, $00
'-' noread          long    noread_lut
	byte	$f6, $02, $00, $00
'-' 
'-' id0             long    0
	byte	$00, $00, $00, $00
'-' id1             long    1
	byte	$01, $00, $00, $00
'-' id2             long    2
	byte	$02, $00, $00, $00
'-' id3             long    3
	byte	$03, $00, $00, $00
'-' id4             long    4
	byte	$04, $00, $00, $00
'-' id5             long    5
	byte	$05, $00, $00, $00
'-' id6             long    6
	byte	$06, $00, $00, $00
'-' id7             long    7
	byte	$07, $00, $00, $00
'-' 
'-' 'These next 10 request registers below are also temporarily reused during init 
'-' 'and COG updates and need to follow immediately after id0-id7
'-' addr1           long    0
	byte	$00, $00, $00, $00
'-' hubdata         long    0
	byte	$00, $00, $00, $00
'-' count           long    0
	byte	$00, $00, $00, $00
'-' addr2           long    0
	byte	$00, $00, $00, $00
'-' total           long    0
	byte	$00, $00, $00, $00
'-' offset1         long    0
	byte	$00, $00, $00, $00
'-' offset2         long    0
	byte	$00, $00, $00, $00
'-' link            long    0
	byte	$00, $00, $00, $00
'-' 
'-' burstwrite                                      'note shared register use during init
'-' initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
	byte	$00, $10, $f0, $fe
'-' id              long    0
	byte	$00, $00, $00, $00
'-' 
'-' header          long    0
	byte	$00, $00, $00, $00
'-' trailer         long    0
	byte	$00, $00, $00, $00
'-' cmdaddr         long    0
	byte	$00, $00, $00, $00
'-' request         long    0
	byte	$00, $00, $00, $00
'-' rrlimit         long    0
	byte	$00, $00, $00, $00
'-' pinconfig       long    0
	byte	$00, $00, $00, $00
'-' clks            long    0
	byte	$00, $00, $00, $00
'-' resume          long    0
	byte	$00, $00, $00, $00
'-' orighubsize     long    0
	byte	$00, $00, $00, $00
'-' wrclks          long    0
	byte	$00, $00, $00, $00
'-' 
'-' pattern         long    0
	byte	$00, $00, $00, $00
'-' hubscratch      long    0
	byte	$00, $00, $00, $00
'-' val4k           long    4096
	byte	$00, $10, $00, $00
'-' 
'-' ' temporary general purpose regs
'-' a               long    0
	byte	$00, $00, $00, $00
'-' b               long    0
	byte	$00, $00, $00, $00
'-' c               long    0
	byte	$00, $00, $00, $00
'-' d               long    0
	byte	$00, $00, $00, $00
'-' 
'-'                 fit     502
'-'                 fit     502
'-' 
'-' '..................................................................................................
'-' 
'-'             orgh
'-' 
'-' lut_code
'-' 'HW init code up to 80 longs
'-' 
'-' '..................................................................................................
'-' ' Memory layout for LUT RAM once operational:
'-' '
'-' '  LUT RAM address      Usage
'-' '  ---------------      ----
'-' '    $200-$20F          Bank parameters: burst + type + size per bank (16)
'-' '    $210-$21F          Pin parameters : latency + control pins per bank (16)
'-' '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
'-' '    $270-$3FF          Main PSRAM access code in LUTRAM 
'-' '
'-' ' Also during driver COG startup:
'-' ' $230-$24F is used for HW init setup
'-' ' $250-$26F is used as temporary vector storage 
'-' '..................................................................................................
'-' 
'-'                 org $230    
'-' 
'-' ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
'-' hwinit                      setxfrq xfreq2
	byte	$1d, $3c, $63, $fd
'-'                             pollxfi
	byte	$24, $16, $60, $fd
'-'                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
	byte	$ff, $aa, $2a, $ff, $ff, $ed, $07, $f6
'-'                             call    #sendqspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$0FF00FF0         '$66 - reset enable
	byte	$07, $f8, $07, $ff, $f0, $ed, $07, $f6
'-'                             call    #sendspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$F00FF00F         '$99 - reset
	byte	$f8, $07, $78, $ff, $0f, $ec, $07, $f6
'-'                             call    #sendspi
	byte	$1c, $00, $b0, $fd
'-'                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
	byte	$7f, $78, $78, $ff, $00, $ed, $07, $f6
'-'                             call    #sendspi 
	byte	$10, $00, $b0, $fd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' sendqspi                    mov     clks,#4
	byte	$04, $d0, $07, $f6
'-'                             skipf   #%110
	byte	$32, $0c, $64, $fd
'-'                             mov     pb, xsendimm
	byte	$9c, $ef, $03, $f6
'-' 
'-' sendspi                     mov     clks, #16
	byte	$10, $d0, $07, $f6
'-'                             mov     pb, ximm8lut
	byte	$97, $ef, $03, $f6
'-'                             drvl    cspin                   'active low chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   pb, pa                  'send 32 bit immediate data
	byte	$f6, $ef, $a3, $fc
'-'                             wypin   clks, clkpin            'start memory clock output 
	byte	$a8, $d1, $23, $fc
'-'                             waitxfi                         'wait for the completion
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                'float data bus
	byte	$50, $48, $63, $fd
'-'                             drvh    cspin                   'raise chip select
	byte	$59, $52, $63, $fd
'-'             _ret_           waitx   #200                    'delay before return to ensure CS delay
	byte	$1f, $90, $65, $0d
'-' 
'-'                 long    0[$270-32-$]
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'     
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-' ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
'-' rw_vect ' PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    (%0111010000000000111000 << 10) + w_single
	byte	$41, $e3, $00, $74
'-'                 long    (%0111010000000000100100 << 10) + w_single
	byte	$41, $93, $00, $74
'-'                 long    (%0111010000000000011100 << 10) + w_single
	byte	$41, $73, $00, $74
'-'                 long    (%1111111000000000000110 << 10) + w_burst
	byte	$47, $1b, $00, $fe
'-' ro_vect ' R/O PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-' ctrl_vect ' Control jump vectors
'-'                 long    (%0000000000111001111110 << 10) + get_latency
	byte	$84, $f9, $39, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000001111011111110 << 10) + get_burst
	byte	$84, $f9, $7b, $00
'-'                 long    (%0000000001111111000000 << 10) + dump_state
	byte	$85, $01, $7f, $00
'-'                 long    (%0000000011010001111110 << 10) + set_latency
	byte	$84, $f9, $d1, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000011001011111110 << 10) + set_burst
	byte	$84, $f9, $cb, $00
'-'                 long    reconfig 
	byte	$3e, $01, $00, $00
'-' no_vect ' Invalid bank jump vectors
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-' 
'-'                 fit     $270
'-'                 fit     $270
'-' '..................................................................................................
'-' ' PSRAM READS
'-'                                                             ' a b c d e f
'-'                                                             ' B W L B R L  (a) byte read
'-'                                                             ' Y O O U E O  (b) word read
'-'                                                             ' T R N R S C  (c) long read
'-'                                                             ' E D G S U K  (d) new burst read
'-'                                                             '       T M E  (e) resumed sub-burst
'-'                                                             '         E D  (f) locked sub-burst
'-' 
'-' 
'-' r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
	byte	$da, $d5, $03, $f6
'-' r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
	byte	$da, $b5, $cb, $f7
'-'                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
	byte	$36, $d9, $07, $f6
'-'             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
	byte	$20, $d9, $27, $a5
'-'                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
	byte	$02, $34, $27, $f9
'-'                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
	byte	$80, $b4, $97, $fb
'-' r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    ' a b c d e    get bank limit/mask
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 ' | | | d e    build mask for addr
	byte	$f0, $45, $cb, $f9
'-'                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
	byte	$f0, $3f, $eb, $f8
'-' p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
	byte	$11, $e0, $47, $f0
'-'                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
	byte	$f0, $47, $23, $f3
'-'                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
	byte	$05, $3e, $57, $f0
'-'             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
	byte	$10, $5a, $67, $04
'-'                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
	byte	$10, $5a, $67, $f4
'-'                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
	byte	$f9, $3b, $83, $fc
'-' r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
	byte	$d9, $3b, $83, $fc
'-'                             mov     c, count                ' | | | d e f  get count of bytes left to read
	byte	$da, $e3, $03, $f6
'-'                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
	byte	$20, $d0, $17, $f6
'-'             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
	byte	$cd, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
	byte	$cc, $d3, $03, $36
'-'                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
	byte	$32, $20, $64, $fd
'-'                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
	byte	$54, $00, $90, $fd
'-' 
'-'                             ' fall through to read bursts
'-'                         
'-' burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
	byte	$cd, $d3, $03, $c6
'-'                             mov     pattern, #0             'enable all by default
	byte	$00, $d8, $07, $f6
'-'                             testb   addr1, #1 wc            'test if start addr starts in second word
	byte	$01, $b0, $17, $f4
'-'                             bitnc   pattern, #1             'enable delay cycle if so
	byte	$01, $d8, $67, $f4
'-'                             wrc     clks                    'and account for its clock cycle
	byte	$6c, $d0, $63, $fd
'-'                             testb   addr1, #0 wc            'test if start addr starts on odd byte
	byte	$00, $b0, $17, $f4
'-'                             bitnc   pattern, #2             'add hi 8 transfer initially
	byte	$02, $d8, $67, $f4
'-'                             mov     d, c                    'get count of bytes to be read into HUB
	byte	$f1, $e5, $03, $f6
'-'             if_c            sub     d, #1                   'minus 1 if start addr was odd
	byte	$01, $e4, $87, $c1
'-'                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
	byte	$01, $e4, $4f, $f0
'-'                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
	byte	$f2, $d1, $23, $f1
'-'                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
	byte	$f2, $35, $23, $f9
'-'                             bitz    pattern, #3             'adjust the pattern to include this
	byte	$03, $d8, $87, $f4
'-'                             testb   c, #0 xorc              'test for end address
	byte	$00, $e2, $d7, $f4
'-'                             bitnc   pattern, #4             'include low 8 bit transfer if required
	byte	$04, $d8, $67, $f4
'-'                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
	byte	$0e, $d0, $27, $f1
'-'                             add     clks, clks
	byte	$e8, $d1, $03, $f1
'-' readcommon
'-'                             mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$EB, #3       'add quad read command
	byte	$eb, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-' 
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable data bus
	byte	$58, $48, $63, $fd
'-'             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
'-'                             xinit   ximm8lut, cmdaddr       'stream out command+address
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   clks, clkpin            'start clock output
	byte	$a8, $d1, $23, $fc
'-'                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
	byte	$00, $00, $cc, $fc
'-'                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
	byte	$00, $0c, $cc, $fc
'-'                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
'-'                             fltl    datapins                'safe to float the data bus, address has been sent by now
	byte	$50, $48, $63, $fd
'-'                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
	byte	$a4, $5b, $03, $fc
'-'                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
	byte	$28, $3a, $63, $fd
'-'                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
	byte	$00, $3e, $c7, $fc
'-'                             xcont   #6, #0                  'fixed delay offset to expand delay range
	byte	$00, $0c, $cc, $fc
'-'                             skipf   pattern                 'choose path below
	byte	$32, $d8, $63, $fd
'-'                                                             'Bursts Bytes Words Longs  RMW FromWrites
'-'                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
	byte	$28, $3c, $63, $fd
'-'                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
	byte	$00, $02, $cc, $fc
'-'                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
	byte	$00, $32, $c7, $fc
'-'                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
	byte	$00, $34, $c7, $fc
'-'                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
	byte	$00, $30, $c7, $fc
'-'                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
	byte	$24, $36, $60, $fd
'-'                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
	byte	$a4, $55, $03, $fc
'-'             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
	byte	$59, $52, $63, $0d
'-'                             drvh    cspin                   '         b     c           e       deassert chip select and continue
	byte	$59, $52, $63, $fd
'-'                             getnib  d, request, #1          'get request code value
	byte	$e5, $e5, $4b, $f8
'-'             if_nz           sub     d, #3                   'offset for table if RMW
	byte	$03, $e4, $87, $51
'-'                             altd    d, #skiptable-5         'patch next instruction
	byte	$bb, $e5, $8f, $f9
'-'                             skipf   0-0                     'generate skip sequence
	byte	$32, $00, $60, $fd
'-'                                                             ' B   W  RMWB RMWW RMLL 
'-'                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
	byte	$80, $df, $07, $fb
'-'                             setq    count                   ' |   |   |    |    e   setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
	byte	$d9, $df, $f3, $f9
'-'                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
	byte	$40, $00, $90, $fd
'-'                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
	byte	$01, $b0, $17, $f4
'-'             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
	byte	$ef, $ef, $3b, $c9
'-'             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
	byte	$ef, $ef, $33, $39
'-'                             mov     d, addr1                ' a   |   c    d
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3                   ' a   |   c    |        get LSBs of address
	byte	$03, $e4, $07, $f5
'-'                             altgb   d, #a                   ' a   |   c    |        index into long
	byte	$ef, $e5, $6f, $f9
'-'                             getbyte pb                      ' a   |   c    |        and extract the byte
	byte	$00, $ee, $e3, $f8
'-'                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
	byte	$80, $ef, $67, $fc
'-'                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
	byte	$c0, $00, $b0, $fd
'-'                             ret                             ' a   b   |    |        then return
	byte	$2d, $00, $64, $fd
'-'                             setq    count                   '         c    d        setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    pb, hubdata             '         c    d        apply bit mux
	byte	$d9, $ef, $f3, $f9
'-'                             altsb   d, #a                   '         c    |
	byte	$ef, $e5, $67, $f9
'-'                             setbyte 0-0, pb, #0             '         c    |
	byte	$f7, $01, $c0, $f8
'-'             if_c            setword a, pb, #1               '         |    d
	byte	$f7, $df, $2b, $c9
'-'             if_nc           setword a, pb, #0               '         |    d
	byte	$f7, $df, $23, $39
'-' writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
	byte	$37, $8a, $07, $f6
'-'                             mov     hubdata, a              'write a to PSRAM
	byte	$ef, $b3, $03, $f6
'-'                             mov     wrclks, #20             '20 clocks to write a long
	byte	$14, $d6, $07, $f6
'-'                             mov     resume, complete_rw     'we'll complete the operation after this
	byte	$cc, $d3, $03, $f6
'-'                             jmp     #writecommon
	byte	$10, $03, $90, $fd
'-' 
'-' '..................................................................................................
'-' ' Burst continuation testing
'-' 
'-' continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
	byte	$32, $96, $63, $fd
'-'                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
	byte	$be, $d3, $03, $f6
'-' continue_read_lut          
'-'                             mov     resume, resumereads     ' | setup resume address to execf
	byte	$bf, $d3, $03, $f6
'-'                             add     hubdata, c              ' a compute the next hub addr to use
	byte	$f1, $b3, $03, $f1
'-'                             sub     count, c                ' a account for the bytes already sent
	byte	$f1, $b5, $83, $f1
'-'                             add     c, addr1                ' a compute next external mem address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    ' a configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
	byte	$14, $00, $90, $5d
'-'                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
	byte	$e1, $47, $3b, $f9
'-'                             fle     limit, b                ' | also re-apply per bank limit
	byte	$f0, $47, $23, $f3
'-'             _ret_           push    #continue_read_exec     ' | 
	byte	$2a, $2a, $67, $0d
'-'             if_nz           jmp     #yield                  ' a
	byte	$04, $00, $90, $5d
'-'             _ret_           push    #continue_write_exec    ' a
	byte	$2a, $2c, $67, $0d
'-' 
'-' yield                       wrlut   total, ptra[4]          'save context for next time
	byte	$04, $b9, $37, $fc
'-'                             wrlut   offset1, ptra[5]        'save context for next time
	byte	$05, $bb, $37, $fc
'-'                             wrlut   offset2, ptra[6]        'save context for next time
	byte	$06, $bd, $37, $fc
'-'                             wrlut   link, ptra[7]           'save context for next time
	byte	$07, $bf, $37, $fc
'-' yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
	byte	$00, $b1, $37, $fc
'-'                             wrlut   hubdata, ptra[1]        'save context for next time
	byte	$01, $b3, $37, $fc
'-'                             wrlut   count, ptra[2]          'save context for next time
	byte	$02, $b5, $37, $fc
'-'                             wrlut   addr2, ptra[3]          'save context for next time
	byte	$03, $b7, $37, $fc
'-'                             wrlut   resume, ptra[8]         'save next resume address
	byte	$08, $d3, $37, $fc
'-'                             wrlut   orighubsize, ptra[9]    'save original hub size
	byte	$09, $d5, $37, $fc
'-'             _ret_           push    #poller
	byte	$2a, $1c, $66, $0d
'-' 
'-' 
'-' notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
	byte	$32, $be, $65, $fd
'-' nowrite_lut                                                 '  (a) new skip sequence 
'-' noread_lut                  skipf   #0                      ' | cancel skipping
	byte	$32, $00, $64, $fd
'-'                             wrlut   #0, ptra[8]             ' | clear resume
	byte	$08, $01, $3c, $fc
'-'                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_nz           jmp     #notify                 ' | if not a request list then we are done
	byte	$40, $f8, $9f, $5d
'-'                             testb   addr2, #31 wz           ' | check if extended list item
	byte	$1f, $b6, $0f, $f4
'-' donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
	byte	$df, $b7, $03, $a6
'-' checklist                   call    #checknext              ' | handle running from list
	byte	$1c, $00, $b0, $fd
'-'                             ret                             ' | continue processing
	byte	$2d, $00, $64, $fd
'-'             _ret_           push    noread                  'continue end of transfer
	byte	$2a, $9e, $63, $0d
'-' '..................................................................................................
'-' ' Completion of requests
'-' 
'-' complete_rw_lut             
'-'                             testb   id, #LIST_BIT wz        'test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_z            skipf   #%10                    'if a request list then skip notification
	byte	$32, $04, $64, $ad
'-'                             wrlut   #0, ptra[8]             ' a   default is not to resume
	byte	$08, $01, $3c, $fc
'-'             _ret_           push    #notify                 ' |   if not a request list then we are done
	byte	$2a, $14, $66, $0d
'-'                             tjs     addr2, #extendedreq     '     test for special extended request  
	byte	$0d, $b6, $b7, $fb
'-' checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
	byte	$07, $b6, $97, $fb
'-'                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
	byte	$bf, $ed, $07, $fb
'-'                             tjns    pa, #listcomplete       'exit if it has
	byte	$05, $ec, $bf, $fb
'-'                             testb   id, #LOCKED_BIT wz
	byte	$0a, $c2, $0f, $f4
'-'             if_z            mov     hubdata, addr2
	byte	$db, $b3, $03, $a6
'-'             if_z            skipf   #%110001
	byte	$32, $62, $64, $ad
'-'             if_nz           skipf   #%1000                  'do not notify if list is continuing
	byte	$32, $10, $64, $5d
'-'                             wrlong  addr2, ptrb             ' a  write back next list address
	byte	$80, $b7, $67, $fc
'-' listcomplete                altd    id, #id0                ' a  compute COG's state address
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
	byte	$09, $00, $04, $f4
'-'             _ret_           push    #notify                 ' |  we are done with the list
	byte	$2a, $14, $66, $0d
'-'             _ret_           push    #poller                 ' a  we are still continuing the list
	byte	$2a, $1c, $66, $0d
'-'             _ret_           push    #real_list              ' a  we are still continuing the list
	byte	$2a, $50, $66, $0d
'-' extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
	byte	$e3, $b5, $97, $fb
'-'                             getnib  a, addr2, #7            'check the request type
	byte	$db, $df, $7b, $f8
'-'                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
	byte	$0f, $de, $0f, $f2
'-'                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
	byte	$d8, $df, $73, $f8
'-'             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
	byte	$32, $90, $63, $5d
'-'                                                             ' skipcase (a) gfx copy to/from hub
'-'                                                             ' skipcase (b) gfx copy extmem bank to bank
'-'                                                             ' skipcase (c) linear copy extmem bank to bank
'-'                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
	byte	$db, $df, $73, $f8
'-'                             rdlut   d, a wz                 ' a      load bank information and check if valid
	byte	$ef, $e5, $ab, $fa
'-'             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
	byte	$31, $02, $64, $5d
'-'             _ret_           push    #invalidbank            ' |      otherwise bail out after this
	byte	$2a, $02, $66, $0d
'-'                             test    offset1 wz              ' |      check for first offset being zero
	byte	$dd, $bb, $cb, $f7
'-'             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
	byte	$de, $bd, $cb, $a7
'-'             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
	byte	$32, $94, $63, $ad
'-'                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
	byte	$32, $92, $63, $fd
'-'                             add     hubdata, c              ' a b c  add bytes just sent to hub address
	byte	$f1, $b3, $03, $f1
'-'                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
	byte	$ea, $b3, $83, $f1
'-'                             add     c, addr1                ' a b c  compute next address to use
	byte	$d8, $e3, $03, $f1
'-'                             test    total wz                ' a b |  check for zero tranfers
	byte	$dc, $b9, $cb, $f7
'-'                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
	byte	$dc, $d5, $2b, $f3
'-'             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
	byte	$44, $ff, $9f, $ad
'-'                             testb   addr1, #30 wz           ' a b c  check if reading/writing
	byte	$1e, $b0, $0f, $f4
'-'                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
	byte	$ea, $b5, $03, $f6
'-'                             sub     c, orighubsize          ' a b |  rewind to original position
	byte	$ea, $e3, $83, $f1
'-'             if_z            add     c, offset1              ' a b |  add any dst scanline offset
	byte	$dd, $e3, $03, $a1
'-'             if_nz           add     c, offset2              ' a b |  add any src scanline offset
	byte	$de, $e3, $03, $51
'-'             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
	byte	$de, $b3, $03, $a1
'-'             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
	byte	$dd, $b3, $03, $51
'-'                             setq    mask                    ' a b c  configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a b c  perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             mov     a, addr1                ' | b c  ]
	byte	$d8, $df, $03, $f6
'-'                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
	byte	$db, $b1, $03, $f6
'-'                             mov     addr2, a                ' | b c  ]
	byte	$ef, $b7, $03, $f6
'-'                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
	byte	$1e, $b0, $a7, $f4
'-'                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
	byte	$0f, $b6, $3f, $f8
'-'                             sub     total, #1 wz            ' a | |  decrement scanline count
	byte	$01, $b8, $8f, $f1
'-'             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
	byte	$01, $b8, $8f, $a1
'-'             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
	byte	$ea, $b9, $8b, $a1
'-'             if_z            mov     addr2, link
	byte	$df, $b7, $03, $a6
'-'             if_z            jmp     #checknext
	byte	$34, $ff, $9f, $ad
'-' moretransfers               getbyte request, addr1, #3      'prepare next request
	byte	$d8, $cb, $fb, $f8
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            skipf   #%1110                  '     skip some code if we are locked
	byte	$32, $1c, $64, $ad
'-'                             testb   addr1, #30 wz           ' a   test if will be reading or writing
	byte	$1e, $b0, $0f, $f4
'-'             if_z            mov     resume, resumewrites    ' |   resume burst writing
	byte	$be, $d3, $03, $a6
'-'             if_nz           mov     resume, newburstr       ' |   resume burst reading
	byte	$b9, $d3, $03, $56
'-'                             jmp     #yield                  ' |   yield to poller
	byte	$b0, $fe, $9f, $fd
'-'             if_z            skip    #%1                     '     skip next instruction for writing case
	byte	$31, $02, $64, $ad
'-'             _ret_           push    #start_read_exec        '(|)  do new read burst next 
	byte	$2a, $26, $67, $0d
'-'             _ret_           push    #start_write_exec       'do new write burst next
	byte	$2a, $28, $67, $0d
'-' 
'-' '..................................................................................................
'-' ' PSRAM WRITES
'-'                                                             '  a b c d e f g h
'-' 
'-'                                                             '  B W L F B R L L (a) byte write(s)
'-'                                                             '  Y O O I U E O O (b) word write(s)
'-'                                                             '  T R N L R S C C (c) long write(s)
'-'                                                             '  E D G L S U K K (d) resumed fill
'-'                                                             '          T M E E (e) new burst write
'-'                                                             '            E D D (f) resumed burst
'-'                                                             '              F B (g) locked fill
'-'                                                             '              I U (h) locked burst write
'-'                                                             '              L R 
'-'                                                             '              L S 
'-'                                                             '                T 
'-' 
'-' w_single                   
'-' w_fill_cont           
'-'                             getnib  a, addr1, #7            '  a b c d          obtain request
	byte	$d8, $df, $7b, $f8
'-'                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
	byte	$03, $de, $07, $f5
'-'                             movbyts hubdata, #0             '  a | | |          replicate byte across long
	byte	$00, $b2, $ff, $f9
'-'                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
	byte	$44, $b2, $ff, $f9
'-'                             andn    addr1, #1               '  | b | |          align word addresses
	byte	$01, $b0, $27, $f5
'-'                             andn    addr1, #3               '  | | c |          align long addresses
	byte	$03, $b0, $27, $f5
'-' w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
	byte	$da, $d5, $03, $f6
'-' w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
	byte	$01, $b4, $0f, $f2
'-'                             shl     count, a                '  a b c | |   |    scale into bytes
	byte	$ef, $b5, $63, $f0
'-'                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
	byte	$ab, $b5, $97, $fb
'-' w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
	byte	$da, $e3, $03, $f6
'-'                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
	byte	$76, $02, $a0, $fd
'-'                ' disable call to r_resume_burst for single longs when z=0
'-'                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
	byte	$3f, $8a, $0f, $f6
'-'                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
	byte	$ce, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
	byte	$cc, $d3, $03, $36
'-'                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
	byte	$d9, $df, $03, $f6
'-'                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
	byte	$14, $d6, $07, $f6
'-'                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
	byte	$01, $de, $17, $f4
'-'                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
	byte	$c7, $8b, $03, $f6
'-'             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
	byte	$14, $01, $90, $8d
'-'             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
	byte	$09, $8a, $67, $25
'-'             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
	byte	$5c, $00, $90, $2d
'-'                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
	byte	$0f, $8a, $07, $f6
'-'         
'-'             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
'-'             '
'-'             '  At least one of these 3 optional components will be sent
'-'             '     header - first partial long of data, gets aligned to PSRAM long boundary
'-'             '     body - N x full longs of data
'-'             '     trailer - last partial long of data
'-'             '
'-'             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
'-'             '
'-'             'Case    Type                           Sends
'-'             ' 1)     Single byte/word write         header only (takes its own optimized path)
'-'             ' 2)     Single long write              body only (takes its own optimized path)
'-'             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
'-'             ' 4)     Multiple long fill             body only
'-'             ' 5)     Burst write                    optional header, optional body, optional trailer
'-' 
'-'                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
	byte	$ce, $d3, $03, $c6
'-'                             mov     pattern3, #%10011
	byte	$13, $8c, $07, $f6
'-'                             mov     d, addr1                'get start address position 
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3 wz                'get alignment
	byte	$03, $e4, $0f, $f5
'-'                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
	byte	$04, $e2, $17, $f2
'-'                             mov     wrclks, #16             'clocks needed for address phase
	byte	$10, $d6, $07, $f6
'-'                             mov     pb, c                   'get number of bytes to send
	byte	$f1, $ef, $03, $f6
'-'                             add     pb, d                   'and increase total to send, including initial re-alignment
	byte	$f2, $ef, $03, $f1
'-'             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
	byte	$40, $00, $90, $2d
'-'                             
'-'                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'             if_c            skipf   #%11110                 'if fill skip burst write stuff
	byte	$32, $3c, $64, $cd
'-'                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
	byte	$04, $d6, $07, $f1
'-'                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
	byte	$f2, $df, $83, $f1
'-'                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
	byte	$ef, $e5, $03, $fb
'-'                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
	byte	$04, $de, $07, $f1
'-'                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
	byte	$32, $08, $64, $fd
'-'                             sub     pb, #4 wcz              ' subtract a long from the total
	byte	$04, $ee, $9f, $f1
'-'                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
	byte	$00, $8a, $07, $f4
'-' single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
	byte	$d9, $e5, $03, $f6
'-'                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
	byte	$88, $01, $b0, $fd
'-'                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
	byte	$5a, $b0, $47, $fb
'-'                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
	byte	$ed, $c5, $03, $fb
'-'                             setq    pa                      ' setup byte mux mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    header, d               ' copy bytes into long
	byte	$f2, $c5, $f3, $f9
'-'             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
	byte	$94, $00, $90, $ed
'-' 
'-' header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'                             mov     d, pb                   'preserve the count
	byte	$f7, $e5, $03, $f6
'-'                             andn    pb, #3 wz               'determine the number of full long bytes left to send
	byte	$03, $ee, $2f, $f5
'-'                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
	byte	$07, $ee, $97, $fb
'-'                  
'-'                             add     wrclks, pb              'include this number of bytes as more clock transitions
	byte	$f7, $d7, $03, $f1
'-'             if_c            skipf   #%1010                 'for fills we can skip burst stuff
	byte	$32, $14, $64, $cd
'-'             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
	byte	$0c, $8a, $27, $c5
'-'                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
	byte	$01, $8a, $07, $f4
'-'                             shr     pb, #1                  ' |  b  compute word count for bursts
	byte	$01, $ee, $47, $f0
'-'                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
	byte	$f7, $37, $23, $f9
'-'                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
	byte	$01, $ee, $47, $f0
'-' 
'-' body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
	byte	$03, $e4, $07, $f5
'-'                             tjz     d, #trailer_done        'no trailer to send, we exit now
	byte	$17, $e4, $97, $fb
'-'             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
	byte	$da, $e3, $0b, $c2
'-'             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
	byte	$cc, $d3, $0b, $32
'-'             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
	byte	$f2, $e3, $83, $51
'-'             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
	byte	$4c, $00, $90, $5d
'-' 
'-'                             'we have 1-3 more aligned residual bytes left to send as the trailer
'-'                             or      d, #$1f0                'setup mux mask address
	byte	$f0, $e5, $47, $f5
'-'                             rdlut   pa, d                   'read mux mask for this length at offset 0
	byte	$f2, $ed, $a3, $fa
'-'                             push    addr1                   'save address
	byte	$2a, $b0, $63, $fd
'-' 
'-' ' use this code (note: foldover can occur here in PSRAM bank)
'-'                             add     addr1, c                'find last long address in PSRAM
	byte	$f1, $b1, $03, $f1
'-'                             sub     addr1, #1               '..to be rewritten
	byte	$01, $b0, $87, $f1
'-'                             call    #readlong               'read data from this external address
	byte	$18, $01, $b0, $fd
'-'             
'-'             if_c            mov     d, hubdata              'get data to be sent for fills
	byte	$d9, $e5, $03, $c6
'-'             if_c            skipf   #%11110                 'skip burst code for fills
	byte	$32, $3c, $64, $cd
'-'                             pop     addr1                   'restore address
	byte	$2b, $b0, $63, $fd
'-'                             mov     d, pb                   ' | get number of full longs that were sent
	byte	$f7, $e5, $03, $f6
'-'                             shl     d, #2                   ' | convert to bytes
	byte	$02, $e4, $67, $f0
'-'                             add     d, a                    ' | add to start adress of longs to stream
	byte	$ef, $e5, $03, $f1
'-'                             rdlong  d, d                    ' | read this last long from HUB RAM
	byte	$f2, $e5, $03, $fb
'-' 
'-'                             rdlong  trailer, hubscratch     'read external RAM data value
	byte	$ed, $c7, $03, $fb
'-'                             setq    pa                      'setup byte mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    trailer, d              'apply byte mask to data via muxq
	byte	$f2, $c7, $f3, $f9
'-'                             add     wrclks, #4              'increase by 4 more clocks
	byte	$04, $d6, $07, $f1
'-'                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
	byte	$05, $8a, $07, $f4
'-'                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
	byte	$00, $8c, $07, $f4
'-' 
'-'                             'trailer is done
'-' trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
	byte	$ef, $3b, $73, $fc
'-' 
'-' writecommon                 mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$02, #3       'add quad write command
	byte	$02, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr                 
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-'                             
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   wrclks, clkpin          'start memory clock output 
	byte	$a8, $d7, $23, $fc
'-'                                                          
'-'                             skipf   pattern2                '   B W L Burst FB FW FL RMW
	byte	$32, $8a, $63, $fd
'-'                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
	byte	$e2, $39, $c3, $fc
'-'                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
	byte	$00, $36, $c7, $fc
'-'                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
	byte	$f7, $03, $d8, $fc
'-'                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
	byte	$d9, $39, $c3, $fc
'-'                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
	byte	$32, $8c, $63, $fd
'-'                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
	byte	$e3, $39, $c3, $fc
'-'                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
	byte	$50, $48, $63, $fd
'-'             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
	byte	$59, $52, $63, $0d
'-'  
'-'                             drvh    cspin
	byte	$59, $52, $63, $fd
'-' check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
	byte	$09, $c2, $17, $f4
'-'                             sub     count, c wz             'account for bytes written
	byte	$f1, $b5, $8b, $f1
'-'             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
	byte	$34, $00, $90, $5d
'-'                             wrlut   #0, ptra[8]             'default is not to resume
	byte	$08, $01, $3c, $fc
'-'             if_nc           jmp     #notify                 'if not a request list then we are done
	byte	$3c, $f5, $9f, $3d
'-'                             tjns    addr2, #checklist       'if not extended, check next list entry
	byte	$40, $b7, $bf, $fb
'-'                             djz     total, #donerepeats     'check for repeats remaining
	byte	$3e, $b9, $67, $fb
'-'                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
	byte	$b8, $b9, $b3, $fb
'-'                             mov     d, orighubsize
	byte	$ea, $e5, $03, $f6
'-'                             shl     d, a
	byte	$ef, $e5, $63, $f0
'-'                             sub     c, d
	byte	$f2, $e3, $83, $f1
'-'                             add     c, offset1
	byte	$dd, $e3, $03, $f1
'-'                             mov     count, d                'restore original count
	byte	$f2, $b5, $03, $f6
'-' readmask                    getnib  b, request, #0          'get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 'build mask for addr (in case count=1)
	byte	$f0, $45, $cb, $f9
'-' continue_fill               add     c, addr1                'add bytes to destination address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    'setup bit mask
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                'setup new external memory address
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            execf   lockedfill              'continue next fill operation
	byte	$33, $74, $63, $ad
'-'                             mov     resume, restorefill
	byte	$bb, $d3, $03, $f6
'-'             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
	byte	$00, $b6, $07, $36
'-'             if_nc           call    #yieldfill              'we have to yield now to other COGs
	byte	$80, $fc, $bf, $3d
'-'             if_c            call    #yield
	byte	$6c, $fc, $bf, $cd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-'                            
'-' getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
'-'                       '     rczl    pa                      'rotate left into address offset
'-'                       '     rczl    c wcz                   'restore count and flags
'-'                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
	byte	$03, $e2, $ef, $f7
'-'                             shl     pa, #2
	byte	$02, $ec, $67, $f0
'-'             if_z            setq    #3
	byte	$28, $06, $64, $ad
'-'             if_z            muxq    pa, c
	byte	$f1, $ed, $f3, $a9
'-'                             or      pa, #$1f0               'setup LUT address offset
	byte	$f0, $ed, $47, $f5
'-'            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
	byte	$f6, $ed, $a3, $fa
'-'                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
	byte	$2d, $00, $7c, $fd
'-' 
'-' readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
	byte	$ed, $3b, $83, $fc
'-'                             setword xrecvdata, #2, #0       'read 2x16 words
	byte	$02, $34, $27, $f9
'-'                             mov     clks, #32               '32 read clock transitions
	byte	$20, $d0, $07, $f6
'-'                             mov     pattern, #%110110       'setup read skip pattern
	byte	$36, $d8, $07, $f6
'-'                             jmp     #readcommon             'read then return directly to caller
	byte	$14, $fb, $9f, $fd
'-'         
'-' 
'-' '..................................................................................................
'-' 
'-'                 fit 1024-32
'-'                 fit 1024-32
'-'                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'                 org 1024-32
'-' 
'-' ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
'-'                 long $0000
	byte	$00, $00, $00, $00
'-'                 long $1111
	byte	$11, $11, $00, $00
'-'                 long $2222
	byte	$22, $22, $00, $00
'-'                 long $3333
	byte	$33, $33, $00, $00
'-'                 long $4444
	byte	$44, $44, $00, $00
'-'                 long $5555
	byte	$55, $55, $00, $00
'-'                 long $6666
	byte	$66, $66, $00, $00
'-'                 long $7777
	byte	$77, $77, $00, $00
'-'                 long $8888
	byte	$88, $88, $00, $00
'-'                 long $9999
	byte	$99, $99, $00, $00
'-'                 long $aaaa
	byte	$aa, $aa, $00, $00
'-'                 long $bbbb
	byte	$bb, $bb, $00, $00
'-'                 long $cccc
	byte	$cc, $cc, $00, $00
'-'                 long $dddd
	byte	$dd, $dd, $00, $00
'-'                 long $eeee
	byte	$ee, $ee, $00, $00
'-'                 long $ffff
	byte	$ff, $ff, $00, $00
'-' 
'-' 'masks
'-'                 long $ffffffff ' 00 aligned 0/4 length
	byte	$ff, $ff, $ff, $ff
'-'                 long $000000ff ' 00 aligned 1 length
	byte	$ff, $00, $00, $00
'-'                 long $0000ffff ' 00 aligned 2 length
	byte	$ff, $ff, $00, $00
'-'                 long $00ffffff ' 00 aligned 3 length
	byte	$ff, $ff, $ff, $00
'-' 
'-'                 long $ffffff00 ' 01 aligned 0/4 length
	byte	$00, $ff, $ff, $ff
'-'                 long $0000ff00 ' 01 aligned 1 length
	byte	$00, $ff, $00, $00
'-'                 long $00ffff00 ' 01 aligned 2 length
	byte	$00, $ff, $ff, $00
'-'                 long $ffffff00 ' 01 aligned 3 length
	byte	$00, $ff, $ff, $ff
'-' 
'-'                 long $ffff0000 ' 10 aligned 0/4 length
	byte	$00, $00, $ff, $ff
'-'                 long $00ff0000 ' 10 aligned 1 length
	byte	$00, $00, $ff, $00
'-'                 long $ffff0000 ' 10 aligned 2 length
	byte	$00, $00, $ff, $ff
'-'                 long $ffff0000 ' 10 aligned 3 length
	byte	$00, $00, $ff, $ff
'-' 
'-'                 long $ff000000 ' 11 aligned 0/4 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 1 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 2 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 3 length
	byte	$00, $00, $00, $ff
'-' 
'-'         fit 1024
'-'         fit 1024
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-'         orgh
'-' 
'-' gfxexpansion
'-'                             'simple line drawing graphics expansion of memory driver
'-'                             'jmp     #donerepeats                'just return for now
'-' 
'-'                             cmp     addr1, addr2 wz         'see if we've reached the end
	byte	$db, $b1, $0b, $f2
'-'             if_z            jmp     #donerepeats            'nothing more to draw
	byte	$fb, $02, $80, $ad
'-'                             add     total, #1               'restore total after decrement
	byte	$01, $b8, $07, $f1
'-'                             mov     b, offset1              'get error term
	byte	$dd, $e1, $03, $f6
'-'                             shl     b, #1                   'compute e2 = 2 x error
	byte	$01, $e0, $67, $f0
'-'                             getword d, offset2, #0          'get dx = abs(x0-x1)
	byte	$de, $e5, $33, $f9
'-'                             sar     offset2, #16            'get dy = -abs(y0-y1)
	byte	$10, $bc, $c7, $f0
'-'                             cmps    b, offset2 wc           'compare if e2 >= dy
	byte	$de, $e1, $53, $f2
'-'                             mov     c, #0                   'clear accumulator reg
	byte	$00, $e2, $07, $f6
'-'             if_c            skip    #%1110                  'if not, skip
	byte	$31, $1c, $64, $cd
'-'                             decod   a                       'decode as 1,2,or 4 byte size
	byte	$ef, $df, $c3, $f9
'-'                             add     offset1, offset2        'err+=dy 
	byte	$de, $bb, $03, $f1
'-'                             testb   total, #16 wz           'check sign sx   
	byte	$10, $b8, $0f, $f4
'-'                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
	byte	$ef, $e3, $c3, $f3
'-'                             cmps    d, b wc                 'compare if e2 <= dx
	byte	$f0, $e5, $53, $f2
'-'             if_c            skip    #%11110                 'if not, skip
	byte	$31, $3c, $64, $cd
'-'                             rolword offset2, d, #0          'restore offset
	byte	$f2, $bd, $43, $f9
'-'                             add     offset1, d              'err+=dx
	byte	$f2, $bb, $03, $f1
'-'                             testb   total, #17 wz           'check sign sy
	byte	$11, $b8, $0f, $f4
'-'                             getword d, total, #0            'get line width
	byte	$dc, $e5, $33, $f9
'-'                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
	byte	$f2, $e3, $c3, $f3
'-'                             encod   a wc                    'restore size and set carry
	byte	$ef, $df, $93, $f7
'-'                             mov     count, orighubsize      'reset the fill width
	byte	$ea, $b5, $03, $f6
'-'                             shl     count, a                '..for the type of transfer
	byte	$ef, $b5, $63, $f0
'-'                             jmp     #readmask               'continue filling
	byte	$c3, $03, $80, $fd
	alignl
_usbnew_spin2_dat_
'-'                 org     $000
'-' 
'-' usb_host_start
'-'                 mov     hcog_base_addr, ptrb
	byte	$f9, $8f, $02, $f6
'-' 
'-'                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
	byte	$03, $00, $00, $ff, $d0, $72, $07, $f6
'-'                 shr     htmp, #2                        ' so byte->long for the lut cell count
	byte	$02, $72, $47, $f0
'-'                 loc     pb, #@hlut_start - @usb_host_start
	byte	$b4, $04, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq2   htmp
	byte	$29, $72, $63, $fd
'-'                 rdlong  0, pb                           ' Do the hub->lut copy
	byte	$f7, $01, $00, $fb
'-' 
'-'                 loc     pb, #@usb_host_init - @usb_host_start
	byte	$88, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 jmp     pb                              ' Initialize host and enter main processing loop
	byte	$2c, $ee, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
'-' ' special because the receiving function must not respond with either STALL or
'-' ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
'-' ' non-control endpoint receives a SETUP token, or the function receives a
'-' ' corrupt packet, it must ignore the transaction
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data struct.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error code.
'-' '------------------------------------------------------------------------------
'-' txn_setup
'-'                 setbyte ep_addr_pid, #PID_SETUP, #0
	byte	$2d, $bc, $c6, $f8
'-'                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
	byte	$08, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
	byte	$03, $96, $06, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
	byte	$0c, $a2, $06, $f6
'-'                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
	byte	$f8, $ed, $03, $f6
'-' .setup
'-'                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
	byte	$24, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait
	byte	$7c, $0b, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
	byte	$f6, $f1, $03, $f6
'-'                 jmp     #.setup
	byte	$e0, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' IN/INTERRUPT transaction.
'-' ' Possible function response: STALL or NAK handshake, or DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_in
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$90, $03, $b0, $fd
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #utx_token                      ' Put IN request on the bus
	byte	$bc, $00, $b0, $fd
'-' 
'-'                 ' Fall through to urx_packet
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a packet from a device/function. As host, the only two packet types
'-' ' received are handshakes and IN DATAx.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'-' '     returned.
'-' '------------------------------------------------------------------------------
'-' urx_packet
'-'                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #urx_packet
	byte	$f4, $ff, $9f, $cd
'-'                 getct   hct2
	byte	$1a, $94, $63, $fd
'-'                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
	byte	$4e, $95, $6b, $fa
'-'                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
	byte	$05, $96, $06, $f4
'-'                 mov     newb_flg, #0                    ' Initialize for multi-byte read
	byte	$00, $a8, $06, $f6
'-' .wait_sop
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #.get_pid
	byte	$08, $00, $90, $cd
'-'                 jnct2   #.wait_sop
	byte	$fc, $25, $cc, $fb
'-'         _ret_   mov     retval, #ERR_TAT
	byte	$05, $be, $06, $06
'-' .get_pid
'-'                 call    #urx_next
	byte	$28, $02, $b0, $fd
'-'                 testb   urx, #BUS_ERRB          wc
	byte	$06, $a6, $16, $f4
'-'         if_nc   jmp     #.chk_pid
	byte	$04, $00, $90, $3d
'-'         _ret_   mov     retval, #ERR_URX
	byte	$02, $be, $06, $06
'-' .chk_pid
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $52
'-'         if_nz   cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
	byte	$38, $00, $90, $ad
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
	byte	$03, $96, $16, $f4
'-'                 cmp     retval, #PID_DATA0      wz
	byte	$c3, $be, $0e, $f2
'-'    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
	byte	$28, $01, $90, $2d
'-'    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
	byte	$10, $00, $90, $8d
'-'                 cmp     retval, #PID_DATA1      wz
	byte	$4b, $be, $0e, $f2
'-'    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
	byte	$1c, $01, $90, $8d
'-'    if_z_and_nc  jmp     #.ack_resend
	byte	$04, $00, $90, $2d
'-'         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
	byte	$04, $be, $06, $06
'-' .ack_resend
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.ack_resend
	byte	$f4, $ff, $9f, $3d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 call    #utx_handshake                  ' Send handshake PID and return to caller
	byte	$98, $01, $b0, $fd
'-'         _ret_   mov     retval, #ERR_DATAX_SYNC
	byte	$09, $be, $06, $06
'-' .chk_eop
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
	byte	$1c, $00, $90, $3d
'-'                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
	byte	$c8, $01, $b0, $fd
'-'                 testb   hstatus, #EOPB          wc
	byte	$05, $96, $16, $f4
'-'         if_c    jmp     #.idle                          ' Low-speed EOP seen
	byte	$10, $00, $90, $cd
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
	byte	$04, $be, $06, $36
'-'         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
	byte	$02, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
	byte	$f4, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send a token packet with CRC5 checksum of address and endpoint. It is the
'-' ' responsibility of the caller to append the appropriate inter-packet delay,
'-' ' if one is required.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - packed with the PID, address and endpoint.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_token
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #utx_token
	byte	$f4, $ff, $9f, $3d
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$34, $0d, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync byte
	byte	$70, $01, $b0, $fd
'-'                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
	byte	$5e, $73, $03, $f6
'-'                 mov     pkt_cnt, #3
	byte	$03, $b8, $06, $f6
'-' .next_byte
'-'                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
	byte	$b9, $a5, $e2, $f8
'-'                 shr     htmp, #8                        ' Shift to next byte to send
	byte	$08, $72, $47, $f0
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   utx, dm
	byte	$22, $a5, $22, $fc
'-'         _ret_   djnz    pkt_cnt, #.next_byte
	byte	$f9, $b9, $6e, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP/OUT/INTERRUPT transaction.
'-' ' Possible function response in order of precedence: STALL, ACK, NAK.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' '   PTRA - start address of the data buff/struct that has the bytes to send.
'-' '   pkt_data - count of DATAx payload bytes to send.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_out
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$88, $02, $b0, $fd
'-'                 call    #utx_token                      ' Put SETUP/OUT token on the bus
	byte	$b8, $ff, $bf, $fd
'-'                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
	byte	$00, $00, $c0, $ff, $f8, $01, $78, $fc
'-'                 mov     pkt_cnt, pkt_data
	byte	$58, $b9, $02, $f6
'-' 
'-'                 ' Fall through to utx_data
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
'-' ' calculated while the data byte is being shifted out. Since data stage
'-' ' success/fail is not determined until the status stage of the transaction,
'-' ' this routine is only concerned about the current DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - hub start address of the data to read.
'-' '   pkt_cnt - data payload size.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_data
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #utx_data
	byte	$f4, $ff, $9f, $cd
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
	byte	$2c, $0a, $b0, $fd
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$d8, $0c, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$14, $01, $b0, $fd
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
	byte	$03, $96, $16, $f4
'-'         if_nc   mov     utx, #PID_DATA0
	byte	$c3, $a4, $06, $36
'-'         if_c    mov     utx, #PID_DATA1
	byte	$4b, $a4, $06, $c6
'-'                 call    #utx_byte                       ' No CRC calc done on PID
	byte	$00, $01, $b0, $fd
'-'                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
	byte	$1c, $00, $90, $ad
'-' .read_byte
'-'                 rfbyte  utx                             ' Fetch data byte
	byte	$10, $a4, $62, $fd
'-'                 call    #utx_byte
	byte	$f0, $00, $b0, $fd
'-'                 rev     utx                             ' Calculate CRC while the data is shifting out
	byte	$69, $a4, $62, $fd
'-'                 setq    utx                             ' SETQ left-justifies the reflected data byte
	byte	$28, $a4, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-'                 djnz    pkt_cnt, #.read_byte
	byte	$f9, $b9, $6e, $fb
'-' .send_crc
'-'                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
	byte	$e0, $bb, $e6, $f4
'-'                 getbyte utx, crc, #0
	byte	$5d, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$d0, $00, $b0, $fd
'-'                 getbyte utx, crc, #1
	byte	$5d, $a5, $ea, $f8
'-'                 call    #utx_byte                       ' Last CRC byte out
	byte	$c8, $00, $b0, $fd
'-'                 jmp     #urx_packet                     ' Handle function response/error and back to caller
	byte	$7c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
'-' ' payload bytes are received. The routine reads bytes until EOP is detected and
'-' ' expects that the packet includes at least the CRC word.
'-' '
'-' ' In control transfers, it's possible to recieve fewer data bytes than what
'-' ' was requested, which makes it difficult to determine where the data stops
'-' ' and the CRC word begins. So the CRC calculation is done on every byte of the
'-' ' packet, including the CRC word. The CRC value should then be equal to the
'-' ' USB-16 expected residual value of 0xB001.
'-' '
'-' ' The routine writes the IN packet data to a static max_packet_size buffer
'-' ' so the caller can verify IN success before writing the data to its final
'-' ' destination.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   pkt_data - max byte count expected to be in the packet.
'-' '   newb_flg - signals new byte ready when toggled.
'-' ' On exit:
'-' '   pkt_cnt - actual number of bytes read.
'-' '------------------------------------------------------------------------------
'-' urx_data
'-'                 mov     htmp2, pb
	byte	$f7, $77, $03, $f6
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
	byte	$00, $00, $c0, $ff, $f7, $01, $88, $fc
'-'                 mov     pb, htmp2
	byte	$bb, $ef, $03, $f6
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
	byte	$00, $b8, $06, $f6
'-'                 mov     pkt_tmp, pkt_data
	byte	$58, $85, $03, $f6
'-'                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
	byte	$02, $84, $07, $f1
'-' .wait_byte
'-' ' In-line rx for max speed
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   jmp     #.get_byte                      ' New byte!
	byte	$0c, $00, $90, $5d
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_c    jmp     #.chk_crc                       ' At end-of-packet
	byte	$38, $00, $90, $cd
'-'                 jmp     #.wait_byte
	byte	$dc, $ff, $9f, $fd
'-' .get_byte
'-'                 getbyte retval, urx, #1                 ' New byte from smart pins
	byte	$53, $bf, $ea, $f8
'-'                 wfbyte  retval                          ' Add it to the data buffer
	byte	$15, $be, $62, $fd
'-'                 rev     retval                          ' Calculate CRC while next byte is shifting in
	byte	$69, $be, $62, $fd
'-'                 setq    retval                          ' SETQ left-justifies the reflected data byte
	byte	$28, $be, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-' .end_crc
'-'                 add     pkt_cnt, #1
	byte	$01, $b8, $06, $f1
'-'                 cmp     pkt_cnt, pkt_tmp        wcz
	byte	$c2, $b9, $1a, $f2
'-'         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
	byte	$04, $be, $06, $16
'-'         if_a    ret
	byte	$2d, $00, $64, $1d
'-' ' For full-speed at 80MHz, the time it takes to do the final byte write and
'-' ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
'-' ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
'-' ' to miss it, so cheat a bit and look for SOP clear here.
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
	byte	$a8, $ff, $9f, $3d
'-' ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
'-' .chk_crc
'-'                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
	byte	$02, $b8, $86, $f1
'-'                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
	byte	$58, $00, $00, $ff, $01, $ba, $6e, $f5
'-'         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
	byte	$f0, $fd, $9f, $5d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$34, $09, $b0, $fd
'-' 
'-'                 ' Fall through to utx_handshake
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
'-' ' the appropriate IP delay has been inserted.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - handshake PID to send.
'-' ' On exit:
'-' '   retval unchanged.
'-' '------------------------------------------------------------------------------
'-' utx_handshake
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$e0, $0b, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$1c, $00, $b0, $fd
'-'                 mov     utx, retval
	byte	$5f, $a5, $02, $f6
'-'                 call    #utx_byte                       ' Send handshake PID
	byte	$14, $00, $b0, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
	byte	$f4, $ff, $9f, $3d
'-'                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
	byte	$4e, $99, $02, $f6
'-'                 jmp     #poll_waitx
	byte	$08, $09, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for the USB tx buffer to empty and feed it a new byte.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   utx - byte to transmit.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_byte
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #utx_byte
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
	byte	$1f, $94, $62, $fd
'-'         _ret_   wypin   utx, dm
	byte	$22, $a5, $22, $0c
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Fetch the next data byte of a packet. Always check receiver status for EOP.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the byte read.
'-' '   urx - the receiver status. The caller must check the hstatus reg EOP flag
'-' '     on return. If EOP is set, the byte in reg retval remains as the last byte
'-' '     received.
'-' '------------------------------------------------------------------------------
'-' urx_next
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
	byte	$53, $bf, $ea, $58
'-'         if_nz   ret                                     ' New byte is priority, so return now
	byte	$2d, $00, $64, $5d
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
	byte	$d8, $ff, $9f, $4d
'-'         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
	byte	$05, $96, $26, $34
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
'-' ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
'-' ' length, and the PID is not included in the CRC calculation:
'-' '  CRC5  FRAME_NUMBER SOF (full-speed)
'-' '  CRC5  ENDP ADDRESS PID
'-' ' %00000_1111_1111111_xxxxxxxx
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - stuffed with the function endpoint, address and
'-' '     SETUP/IN/OUT/SOF PID according to the USB standard.
'-' ' On exit:
'-' '   ep_addr_pid - CRC value appended to the packet.
'-' '------------------------------------------------------------------------------
'-' calc_crc5
'-'                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
	byte	$ff, $03, $00, $ff, $ff, $bd, $06, $f5
'-'                 mov     htmp, ep_addr_pid
	byte	$5e, $73, $03, $f6
'-'                 shr     htmp, #8                        ' PID not included in CRC calc
	byte	$08, $72, $47, $f0
'-'                 mov     crc, #$1f                       ' Initial CRC5 value
	byte	$1f, $ba, $06, $f6
'-'                 rev     htmp                            ' Input data reflected
	byte	$69, $72, $63, $fd
'-'                 setq    htmp                            ' CRCNIB setup for data bits 0..7
	byte	$28, $72, $63, $fd
'-'                 crcnib  crc, #USB5_POLY
	byte	$14, $ba, $de, $f9
'-'                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
	byte	$14, $ba, $de, $f9
'-'                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
	byte	$09, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 xor     crc, #$1f                       ' Final XOR value
	byte	$1f, $ba, $66, $f5
'-'                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
	byte	$13, $ba, $66, $f0
'-'         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
	byte	$5d, $bd, $42, $05
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed/low-speed frame timing interrupt service routine.
'-' '------------------------------------------------------------------------------
'-' isr1_fsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $fc
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 mov     utx, #PID_SOF
	byte	$a5, $a4, $06, $f6
'-'                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
	byte	$22, $01, $29, $fc
'-'                 call    #utx_byte                       ' Send token PID byte
	byte	$4c, $ff, $bf, $fd
'-'                 mov     icrc, #$1f                      ' Prime the CRC5 pump
	byte	$1f, $b6, $06, $f6
'-'                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
	byte	$59, $b5, $02, $f6
'-'                 rev     sof_pkt                         ' Input data reflected
	byte	$69, $b4, $62, $fd
'-'                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
	byte	$28, $b4, $62, $fd
'-'                 crcnib  icrc, #USB5_POLY
	byte	$14, $b6, $de, $f9
'-'                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
	byte	$14, $b6, $de, $f9
'-'                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
	byte	$59, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$2c, $ff, $bf, $fd
'-'                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
	byte	$08, $b4, $66, $f0
'-'                 rep     #2, #3                          ' Three data bits left to process
	byte	$03, $04, $dc, $fc
'-'                 shl     sof_pkt, #1             wc
	byte	$01, $b4, $76, $f0
'-'                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
	byte	$14, $b6, $d6, $f9
'-'                 xor     icrc, #$1f                      ' Final XOR value
	byte	$1f, $b6, $66, $f5
'-'                 getbyte utx, frame, #1                  ' Send remaining frame number bits
	byte	$59, $a5, $ea, $f8
'-'                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
	byte	$03, $b6, $66, $f0
'-'                 or      utx, icrc
	byte	$5b, $a5, $42, $f5
'-'                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
	byte	$08, $ff, $bf, $fd
'-'                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
	byte	$a4, $83, $03, $f6
'-'                 jmp     #isr1_wait
	byte	$20, $00, $90, $fd
'-' isr1_lsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
	byte	$22, $09, $28, $fc
'-'                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
	byte	$a3, $83, $03, $f6
'-' isr1_wait
'-'                 rqpin   utx, dm
	byte	$22, $a5, $82, $fa
'-'                 testb   utx, #SOPB                 wc
	byte	$04, $a4, $16, $f4
'-'         if_c    jmp     #isr1_wait
	byte	$f4, $ff, $9f, $cd
'-'                 add     frame, #1                       ' Next frame# and check for wrap around
	byte	$01, $b2, $06, $f1
'-'                 and     frame, ##$7ff
	byte	$03, $00, $00, $ff, $ff, $b3, $06, $f5
'-'                 waitx   isrtmp1                         ' Make sure bus is idle
	byte	$1f, $82, $63, $fd
'-'                 reti1
	byte	$f5, $ff, $3b, $fb
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a window within the 1ms frame boundary that will ensure that a
'-' ' transaction will complete before the next frame is triggered.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' wait_txn_ok
'-'                 getct   htmp2
	byte	$1a, $76, $63, $fd
'-'                 sub     htmp2, iframe_ct_base
	byte	$49, $77, $83, $f1
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    cmp     htmp2, _txn_ok_ls_      wcz
	byte	$a1, $77, $1b, $c2
'-'         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
	byte	$a2, $77, $1b, $32
'-'         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
	byte	$e8, $ff, $9f, $1d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A device connection was detected, or a bus reset was requested by the USB
'-' ' client. Set the appropriate smart pin FS/LS speed mode to match the device
'-' ' and perform a reset sequence prior to device enumeration.
'-' '------------------------------------------------------------------------------
'-' dev_reset
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
	byte	$01, $a6, $16, $f4
'-'         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
	byte	$f4, $03, $b0, $cd
'-'         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
	byte	$e0, $03, $b0, $3d
'-' reset
'-'                 setint1 #0                              ' Don't want frame interrupt while in reset
	byte	$25, $00, $64, $fd
'-'                 wypin   #OUT_SE0, dm                    ' Assert bus reset
	byte	$22, $03, $28, $fc
'-'                 waitx   _reset_hold_                    ' Spec is >= 10ms
	byte	$1f, $5c, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 mov     frame, #0                       ' Reset the frame timespan count
	byte	$00, $b2, $06, $f6
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
	byte	$59, $73, $03, $f6
'-'                 add     htmp, #36
	byte	$24, $72, $07, $f1
'-'                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
	byte	$25, $02, $64, $fd
'-' .framewait
'-'                 cmp     frame, htmp             wcz
	byte	$b9, $b3, $1a, $f2
'-'         if_b    jmp     #.framewait
	byte	$f8, $ff, $9f, $cd
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - source address.
'-' '   PB - destination address.
'-' '   hr0 - length of copy, in bytes.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hmemcpy
'-'                 rdbyte  htmp, ptra++
	byte	$61, $73, $c7, $fa
'-'                 wrbyte  htmp, pb
	byte	$f7, $73, $43, $fc
'-'                 add     pb, #1
	byte	$01, $ee, $07, $f1
'-'         _ret_   djnz    hr0, #hmemcpy
	byte	$fc, $87, $6f, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
'-' ' loop until the errant device is disconnected.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' host_error
'-'           if ERROR_LED >= 0
'-'           end
'-'                 jmp     #host_reset                     ' See if it works...
	byte	$a0, $07, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get HID descriptor buffer for current port
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   PB - HID descriptor buffer pointer
'-' '------------------------------------------------------------------------------
'-' get_hid_descr_buffer
'-'                 mov     pb, hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb, #1
	byte	$01, $ee, $e7, $f2
'-'                 mul     pb, #HID_DESCR_LEN
	byte	$00, $ef, $07, $fa
'-'         _ret_   add     pb, hid_descr_p
	byte	$25, $ef, $03, $01
'-' 
'-' 
'-' usb16_poly_r    long    USB16_POLY
	byte	$01, $a0, $00, $00
'-' 
'-' ' USB commands and error codes
'-' cmd_data        long    0
	byte	$00, $00, $00, $00
'-' usb_err_code    long    ERR_NONE
	byte	$00, $00, $00, $00
'-' 
'-' ' Parameters block assigned at cog startup
'-' dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
	byte	$12, $00, $00, $00
'-' dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
	byte	$13, $00, $00, $00
'-' usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
	byte	$11, $00, $00, $00
'-' if ACTIVITY_LED >= 0
'-' host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
'-' end
'-' if ERROR_LED >= 0
'-' host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
'-' end
'-' hid_descr_p     long    0
	byte	$00, $00, $00, $00
'-' 'hid_report_p    long    0, 0[MAX_DEVICES]
'-' 'hkbd_report_p   long    0
'-' hub_descr_p     long    0
	byte	$00, $00, $00, $00
'-' urx_buff_p      long    0
	byte	$00, $00, $00, $00
'-' dev_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' con_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' cache_start_p   long    0
	byte	$00, $00, $00, $00
'-' cache_end_p     long    0
	byte	$00, $00, $00, $00
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_out_ptr  long    0
'-' end
'-' save_sysclk     long    0         ' Save the current sysclock as the client may change it
	byte	$00, $00, $00, $00
'-' 
'-' hdev_init_start
'-' hdev_port       res     1
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' kbm_next_datax  res     1
'-' hub_intf_num    res     1
'-' hub_next_datax  res     1
'-' hub_status_chg  res     1
'-' hub_port_status res     1
'-' if HAVE_MOUSE
'-' ms_intf_num     res     1
'-' ms_in_max_pkt   res     1
'-' end
'-' kb_intf_num     res     1
'-' kb_interval     res     1
'-' kb_in_max_pkt   res     1
'-' kb_max_index    res     1
'-' kb_led_states   res     1
'-' gp_intf_num     res     1
'-' gp_interval     res     1
'-' gp_max_index    res     1
'-' gp_descr_len    res     1+MAX_DEVICES
'-' hdev_init_end
'-' 
'-' ' Initialized at cog startup:
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' iframe_ct_new   res     1
'-' iframe_ct_base  res     1
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' 
'-' ' This register block is reset to zero when a USB device connects
'-' hreg_init_start
'-' hstatus         res     1         ' Host status flags
'-' hctwait         res     1         ' Poll-based wait clocks
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' xfer_retry      res     1         ' Control transfer retry count
'-' retry           res     1         ' Transaction retry count
'-' utx             res     1         ' Byte to transmit on USB
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' frame           res     1         ' USB 1ms frame counter value
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' crc             res     1         ' Used for CRC16 calculation
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' retval          res     1         ' Global success/fail return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' ' Device stuff
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_bcd        res     1
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' ' Keyboard/mouse stuff
'-' hctrl_ep_addr   res     1
'-' hctrl_max_pkt   res     1
'-' hconfig_base    res     1
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_class      res     1
'-' hdev_subclass   res     1
'-' hdev_protocol   res     1
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' if HAVE_MOUSE
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' end
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_out_addr   res     1
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
'-' end
'-' 
'-' hreg_init_end
'-' 
'-' hidr_start
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_flags      res     1
'-' hidr_axis       res     4
'-' hidr_buttons    res     1
'-' hidr_hats       res     1
'-' '' Above are actually useful values, 6 longs
'-' hidr_type       res     1
'-' hidr_id         res     1
'-' hidr_offset     res     1
'-' hidr_usage_idx  res     1
'-' ' below need to be push/pop'd
'-' hidr_state      res     1
'-' hidr_size       res     1
'-' hidr_count      res     1
'-' hidr_lminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_end
'-' 
'-' ' Variables dependent on the system freqency
'-' _var_64_lower_  res     1
'-' _var_64_upper_  res     1
'-' _12Mbps_        res     1
'-' _1_5Mbps_       res     1
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1us_           res     1         ' 1us
'-' _10us_          res     1         ' 10us
'-' _33us_          res     1         ' 33us
'-' _txn_err_       res     1         ' 250us
'-' _500us_         res     1         ' 500us
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _preamble_wait_ res     1
'-' _1ms_           res     1         ' 1ms
'-' _2ms_           res     1         ' 2ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _4ms_           res     1         ' 4ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _reset_hold_    res     1         ' 15ms
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _21ms_          res     1         ' 21ms
'-' _100ms_         res     1         ' 100ms
'-' _500ms_         res     1         ' 500ms
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' '------------------------------------------------------------------------------
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_d_ls_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' '------------------------------------------------------------------------------
'-' ' Scratch registers
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp1           res     1
'-' htmp2           res     1
'-' htmp3           res     1
'-' hrep            res     1         ' Repeat count
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave1          res     1
'-' hsave2          res     1
'-' isrtmp1         res     1
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' hr0             res     1         ' Multi-purpose registers
'-' hr1             res     1
'-' hr2             res     1
'-' hr3             res     1
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar2           res     1
'-' hpar3           res     1
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' mod_cnt         res     1         ' Used in idle loops
'-' 
'-'                 fit     $1F0
'-'                 fit     $1F0
'-'                 org     $200
'-' hlut_start
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed is the host's native speed, so all that is needed is to set the FS
'-' ' settings to startup defaults.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: Save/restore caller C flag state if C is changed in this routine!
'-' '------------------------------------------------------------------------------
'-' set_speed_full
'-'                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$d0, $e8, $07, $f6
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
	byte	$a4, $9b, $02, $06
'-' '                ret                             wcz     ' Restore caller flags on exit
'-' 
'-' '------------------------------------------------------------------------------
'-' ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
'-' ' is a downstream hub connected (not yet implemented), the baud generator
'-' ' remains set at the full-speed rate, but signaling is switched to low-speed,
'-' ' which reverses the D-/D+ polarity. The polarity can be changed without
'-' ' putting the smart pins into reset.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: CZ flags restored to caller states
'-' '------------------------------------------------------------------------------
'-' set_speed_low
'-'                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
	byte	$80, $96, $ce, $f7
'-'         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$ed, $e8, $07, $a6
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
	byte	$22, $6b, $13, $fc
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $f6
'-'                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
	byte	$02, $96, $26, $f4
'-'                 ret                             wcz     ' Restore caller flags on exit
	byte	$2d, $00, $7c, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform configuration stuff required when a device intitially connects.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' on_connect
'-'                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$02, $86, $07, $f6
'-'                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
	byte	$d8, $fb, $bf, $fd
'-' .retry
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
	byte	$01, $8e, $07, $c6
'-'         if_nc   mov     hpar1, #USB_SPEED_FULL
	byte	$02, $8e, $07, $36
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$20, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$f4, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.get_dev_desc
	byte	$18, $00, $90, $ad
'-'                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
	byte	$b2, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$4c, $03, $b0, $fd
'-'                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$01, $86, $8f, $f1
'-'         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
	byte	$f0, $fb, $9f, $ad
'-'                 call    #reset                          ' Try another reset to see if the device responds
	byte	$a4, $fb, $bf, $fd
'-'                 jmp     #.retry
	byte	$b8, $ff, $9f, $fd
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
	byte	$28, $03, $b0, $fd
'-'                 call    #reset
	byte	$88, $fb, $bf, $fd
'-'                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
	byte	$38, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
	byte	$01, $11, $5c, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$d8, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$04, $03, $b0, $fd
'-'                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
	byte	$04, $00, $00, $ff, $00, $bc, $06, $f6
'-'                 call    #calc_crc5
	byte	$34, $fa, $bf, $fd
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
	byte	$20, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$78, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
	byte	$07, $db, $c6, $fa
'-'                 mov     hctwait, _500us_
	byte	$a0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $02, $b0, $fd
'-'                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$28, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$48, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $87, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $89, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $73, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $86, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $88, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $73, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #host_error
	byte	$2c, $fb, $9f, $cd
'-'                 loc     pa, #@init_kbdm_data - @usb_host_start
	byte	$24, $13, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-'                 loc     pa, #@hparse_con_desc - @usb_host_start
	byte	$b8, $0d, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 jmp     pa
	byte	$2c, $ec, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
'-' ' Status reporting is always in the function-to-host direction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data in hub.
'-' '   PB - start address of the buffer/struct to be written to during the IN data
'-' '     stage.
'-' '   ep_addr_pid - device address, endpoint and CRC5.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'-' '     contains the count of data stage bytes actually received, which must
'-' '     always be <= the count requested.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_read
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8f, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $91, $03, $f6
'-'                 mov     hpar3, pb                       ' Save dest buffer pointer
	byte	$f7, $93, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$c0, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to caller to handle error
	byte	$2d, $00, $64, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$90, $01, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 mov     nak_retry, ##IN_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
	byte	$55, $b1, $02, $16
'-' .nak_retry
'-'                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
	byte	$0c, $a2, $06, $f6
'-' .in_retry
'-'                 call    #txn_in
	byte	$bc, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$28, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$a8, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$14, $02, $b0, $fd
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak_retry                     ' Function not ready to send data
	byte	$dc, $ff, $9f, $ad
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$94, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.in_retry                      ' Bus error retry
	byte	$d0, $ff, $9f, $5d
'-'                 ret                                     ' The transfer has failed
	byte	$2d, $00, $64, $fd
'-' .commit
'-'                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.pre_status                    ' and also end-of-data
	byte	$38, $00, $90, $ad
'-'                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
	byte	$27, $f1, $03, $f6
'-'                 mov     hr0, pkt_cnt
	byte	$5c, $87, $03, $f6
'-'                 cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $f2
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$6c, $fa, $bf, $5d
'-'                 add     stage_data, pkt_cnt             ' Update bytes received on commit
	byte	$5c, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
	byte	$56, $af, $0a, $f2
'-'         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
	byte	$1c, $00, $90, $ad
'-'                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
	byte	$58, $b9, $1a, $f2
'-'         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
	byte	$14, $00, $90, $cd
'-'         if_a    mov     retval, #ERR_PACKET
	byte	$04, $be, $06, $16
'-'         if_a    mov     context_retval, retval          ' In this case overall and context are the same
	byte	$5f, $c1, $02, $16
'-'         if_a    ret                                     ' Caller must handle ERR_PACKET
	byte	$2d, $00, $64, $1d
'-'                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $f4
'-'                 jmp     #.data                          ' Start next IN transaction
	byte	$78, $ff, $9f, $fd
'-' .pre_status
'-'                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
	byte	$57, $ad, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $f8
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-'                 mov     nak_retry, ##OUT_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-' .out_retry
'-'                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
	byte	$34, $f7, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret                                     ' All is good when ACK
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$18, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$84, $01, $b0, $fd
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
	byte	$d8, $ff, $9f, $5d
'-'                 ret                                     ' Caller must handle transfer retirement
	byte	$2d, $00, $64, $fd
'-' ' I've encountered transfer STALL, even though the data looks correct, and
'-' ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
'-' ' ControlRead() transfer gets things unstuck most of the time...
'-' .xfer_retry
'-'                 mov     hctwait, _xfer_wait_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$58, $01, $b0, $fd
'-'                 call    #wait_txn_ok
	byte	$8c, $f9, $bf, $fd
'-'                 mov     ep_addr_pid, hpar1
	byte	$c7, $bd, $02, $f6
'-'                 mov     ptra, hpar2
	byte	$c8, $f1, $03, $f6
'-'                 mov     pb, hpar3
	byte	$c9, $ef, $03, $f6
'-'                 djnz    xfer_retry, #.xfer_start
	byte	$bb, $a1, $6e, $fb
'-'                 mov     context_retval, retval          ' Preserve the USB error code
	byte	$5f, $c1, $02, $f6
'-'         _ret_   mov     retval, #ERR_XFER_RETRY
	byte	$07, $be, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
'-' ' reporting is always in the function-to-host direction. It is assumed that
'-' ' the SETUP data struct is filled with the required values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - points to the start of the struct for the SETUP data.
'-' '   PB - the start address of the struct/buffer to be read for the OUT data
'-' '     stage.
'-' '   ep_addr_pid - the proper CRC'd address and endpoint to use.
'-' ' On exit:
'-' '   retval - used to convey the success/failure of each stage.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_write
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8f, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $91, $03, $f6
'-'                 mov     hpar3, pb
	byte	$f7, $93, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
	byte	$00, $9e, $06, $f6
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$84, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
	byte	$ec, $00, $90, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$54, $00, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
	byte	$e1, $bc, $c6, $f8
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
	byte	$55, $b1, $02, $16
'-' .out_retry
'-'                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
	byte	$f7, $f1, $03, $f6
'-'                 call    #txn_out
	byte	$88, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit                        ' Function got the data
	byte	$10, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$e0, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry
	byte	$e4, $ff, $9f, $5d
'-'                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
	byte	$a4, $00, $90, $fd
'-' .commit
'-'                 mov     pb, ptra                        ' Save the current buffer/struct location
	byte	$f8, $ef, $03, $f6
'-'                 add     stage_data, pkt_data
	byte	$58, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz
	byte	$56, $af, $0a, $f2
'-'         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $54
'-'         if_nz   jmp     #.data                          ' More data to send
	byte	$bc, $ff, $9f, $5d
'-' pre_status_in
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .status_retry
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 call    #txn_in
	byte	$44, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
	byte	$d2, $be, $0e, $f2
'-'         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
	byte	$00, $b0, $0e, $a2
'-'         if_z    jmp     #dwnstream_reset                ' Control Write finished
	byte	$74, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait                     ' NAK or bus error, so delay a bit
	byte	$98, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.status_retry
	byte	$d8, $ff, $9f, $5d
'-' '               ret                                     ' Caller must handle transfer retirement
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - The function address and endpoint for the IN request.
'-' '   hpar2 - Address of the IN data buffer
'-' '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
'-' ' On exit:
'-' '   retval - the result of the operation.
'-' '   hpar3 - the count of IN data bytes actually received.
'-' '------------------------------------------------------------------------------
'-' do_int_in
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 getword htmp, hpar3, #0
	byte	$c9, $73, $33, $f9
'-'                 cmp     htmp, #PID_DATA0        wz
	byte	$c3, $72, $0f, $f2
'-'                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
	byte	$03, $96, $a6, $f4
'-'                 mov     retry, #TXN_RETRIES
	byte	$0c, $a2, $06, $f6
'-' .retry
'-'                 getword pkt_data, hpar3, #1             ' IN max packet length
	byte	$c9, $b1, $3a, $f9
'-'                 call    #txn_in
	byte	$00, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK if data received
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$1c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
	byte	$5a, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.post_ret                      ' The caller must handle either
	byte	$24, $00, $90, $ad
'-'                 call    #retry_wait
	byte	$54, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    jmp     #.post_ret
	byte	$18, $00, $90, $ad
'-'                 jmp     #.retry
	byte	$d4, $ff, $9f, $fd
'-' .commit
'-'                 mov     ptra, urx_buff_p                ' Copy the rx buffer
	byte	$27, $f1, $03, $f6
'-'                 mov     pb, hpar2                       ' to the destination buffer
	byte	$c8, $ef, $03, $f6
'-'                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
	byte	$5c, $87, $0b, $f6
'-'         if_nz   cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $52
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$c0, $f8, $bf, $5d
'-' .post_ret
'-'                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
	byte	$5c, $93, $03, $f6
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Resets the downstream hub port to FS
'-' '------------------------------------------------------------------------------
'-' dwnstream_reset
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_nc   ret                                     ' No LS device, reset not needed
	byte	$2d, $00, $64, $3d
'-' 
'-'                 bitl    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $07, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $fc
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a4, $9b, $02, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The one millisecond frame timer is implemented as an interrupt service
'-' ' routine. Since this timing is critical, care must be taken to avoid any
'-' ' instructions that can delay the interrupt branch, which will likely upset
'-' ' the timer. WAITX is among those instructions, so any time you're inside
'-' ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hctwait - wait interval in sysclocks.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' poll_waitx
'-'                 getct   hct2
	byte	$1a, $94, $63, $fd
'-'                 addct2  hct2, hctwait
	byte	$4c, $95, $6b, $fa
'-' .wait
'-'                 jnct2   #.wait
	byte	$ff, $25, $cc, $fb
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transaction retry handling for NAK/STALL or bus error.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - transaction response PID or error code.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' retry_wait
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret                                     ' STALL is special case
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak
	byte	$14, $00, $90, $ad
'-'                 mov     hctwait, _txn_err_              ' Transaction error wait...
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$d8, $ff, $bf, $fd
'-' .dec
'-'                 sub     retry, #1               wz
	byte	$01, $a2, $8e, $f1
'-'         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
	byte	$06, $be, $06, $a6
'-'                 ret                                     ' Retry result to caller
	byte	$2d, $00, $64, $fd
'-' .nak
'-'                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
	byte	$9e, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $ff, $bf, $fd
'-'                 cmp     nak_retry, #NAK_NOLIMIT wz
	byte	$00, $9e, $0e, $f2
'-'         if_z    ret                                     ' Indefinite NAK retries
	byte	$2d, $00, $64, $ad
'-'                 sub     nak_retry, #1           wz
	byte	$01, $9e, $8e, $f1
'-'         if_z    mov     retval, #ERR_NAK
	byte	$08, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' host_reset
'-'                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
	byte	$25, $00, $64, $fd
'-'                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
	byte	$14, $72, $07, $fb
'-' ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
'-'                 cmp     htmp, ##168_000_000     wcz
	byte	$bd, $01, $05, $ff, $00, $72, $1f, $f2
'-'         if_be   mov     utx_tweak, #0
	byte	$00, $94, $06, $e6
'-'         if_a    mov     utx_tweak, #3   '#20
	byte	$03, $94, $06, $16
'-' ' Check to see if the system clock has been changed.
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $73, $0b, $f2
'-'         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $5e
'-'         if_nz   add     pb, hcog_base_addr
	byte	$47, $ef, $03, $51
'-'         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $5d
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-' 
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
	byte	$22, $6f, $13, $fc
'-' .enable
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 waitx   _1us_
	byte	$1f, $38, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 ' Handle Port protection enable and startup delay
'-'                 cmps    usb_enable_pin, #0      wc
	byte	$00, $48, $56, $f2
'-'         if_ae   drvl    usb_enable_pin                 ' disable port
	byte	$58, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Wait a while for everything to turn off
	byte	$1f, $60, $63, $fd
'-'         if_ae   drvh    usb_enable_pin                  ' Enable the port
	byte	$59, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Hold to let the idle state get settled
	byte	$1f, $60, $63, $fd
'-' 
'-'                 'call #dev_reset ' TODO THINK ABOUT THIS
'-' 
'-' discon_entry
'-'                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
	byte	$03, $98, $07, $f6
'-' 
'-'                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
	byte	$4b, $ed, $b7, $f9
'-'                 rep     @.regloop,#hreg_init_end - hreg_init_start
	byte	$3b, $04, $dc, $fc
'-'                 alti    pa, #%000_111_000
	byte	$38, $ec, $a7, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' .regloop
'-'               
'-'         if HAVE_HIDPAD
'-'                 loc     pb, #@hidpad_report - @usb_host_start
	byte	$f8, $27, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
	byte	$28, $6e, $64, $fd
'-'                 wrlong  #0,pb
	byte	$f7, $01, $68, $fc
'-'         end
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-'                 ' Fall through to disconnected loop
'-' 
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' Device connect handling (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
'-' ' device to connect (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' disconnected
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
	byte	$14, $88, $07, $fb
'-'                 cmp     hr1, save_sysclk        wz
	byte	$2c, $89, $0b, $f2
'-'         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
	byte	$6c, $ff, $9f, $5d
'-'                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
	byte	$03, $88, $47, $f0
'-'                 waitx   hr1                             ' it down to smaller wait chunks
	byte	$1f, $88, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
	byte	$e0, $ff, $9f, $ad
'-'         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
	byte	$28, $00, $90, $5d
'-' .se1_test
'-'                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$fc, $fe, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
	byte	$00, $be, $06, $56
'-'         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
	byte	$a0, $ff, $9f, $5d
'-' .se1            'SE1 is a fatal error condition
'-'                 mov     hctwait, _100ms_
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$e4, $fe, $bf, $fd
'-'                 mov     retval, #ERR_SE1
	byte	$03, $be, $06, $f6
'-'                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
	byte	$88, $f7, $bf, $fd
'-' .connect_test                                           ' Test lines until stable J/K state seen
'-'                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
	byte	$1f, $62, $63, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #discon_entry                   ' D+ and D- low
	byte	$80, $ff, $9f, $ad
'-'         if_e    jmp     #.se1_test                      ' D+ and D- high
	byte	$c4, $ff, $9f, $ad
'-' connected
'-'                 bith    hstatus, #CONNECTEDB            ' Device plugged in
	byte	$01, $96, $26, $f4
'-'                 call    #on_connect                     ' Initial device configuration
	byte	$34, $fb, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #discon_entry
	byte	$6c, $ff, $9f, $5d
'-' .set_pulse
'-'                 getct   _pulse_time_
	byte	$1a, $66, $63, $fd
'-'                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
	byte	$b2, $67, $03, $f1
'-' ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
'-' ' of 1ms and make a correction, if necessary.
'-' '                mov     htmp, _1ms_
'-' '                subs    htmp, iframe_delta
'-' '                adds    _frame1ms_clks_, htmp
'-' '                debug(udec(_frame1ms_clks_))
'-' 
'-'                 ' Fall through to idle/processing loop
'-'                 cmp     hdev_port, #MAX_DEVICES wcz
	byte	$07, $5a, $1e, $f2
'-'         if_a    mov     hdev_port, #0 
	byte	$00, $5a, $06, $16
'-' 
'-' hidle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_c    jmp     #.se0_test
	byte	$98, $00, $90, $cd
'-'                 pollct3                         wc
	byte	$24, $06, $70, $fd
'-'         if_nc   jmp     #.nopoll
	byte	$68, $00, $90, $3d
'-'                 getct   hct3
	byte	$1a, $96, $63, $fd
'-'                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
	byte	$a8, $97, $73, $fa
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $72, $e3, $f8
'-' 
'-'                 cmp     htmp, #HUB_READY        wz
	byte	$09, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_hub_status - @usb_host_start
	byte	$8c, $1b, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$40, $00, $90, $ad
'-' 
'-'         if _HAVE_GAMEPAD
'-'                 cmp     htmp, #HID_READY        wz
	byte	$06, $72, $0f, $f2
'-'         if_nz   cmp     htmp, #PS3_READY        wz
	byte	$08, $72, $0f, $52
'-'         if_nz   cmp     htmp, #XINPUT_READY     wz
	byte	$07, $72, $0f, $52
'-'         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
	byte	$f4, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$2c, $00, $90, $ad
'-'         end
'-' 
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$44, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$20, $00, $90, $ad
'-'         end
'-' 
'-'                 cmp     htmp, #KB_READY         wz
	byte	$03, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$ac, $13, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$14, $00, $90, $ad
'-' 
'-'                 cmp     htmp, #KBM_READY        wz
	byte	$05, $72, $0f, $f2
'-'         if_nz   jmp     #.skip_poll
	byte	$14, $00, $90, $5d
'-'                 bitnot  hstatus, #KBM_TOGGLEB   wcz
	byte	$09, $96, $fe, $f4
'-'         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$ac, $13, $80, $3e
'-'         if HAVE_MOUSE
'-'         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$44, $15, $80, $ce
'-'         else
'-'         end
'-' 
'-' .poll
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-' .skip_poll
'-' 
'-'                 incmod  hdev_port, #MAX_DEVICES
	byte	$07, $5a, $06, $f7
'-' 
'-' .nopoll
'-'                 cmp     cmd_data, #CMD_SUSPEND  wz
	byte	$0e, $40, $0e, $f2
'-'         if_z    jmp     #hsuspend
	byte	$44, $00, $90, $ad
'-'                 cmp     cmd_data, #CMD_RESET    wz
	byte	$10, $40, $0e, $f2
'-'         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
	byte	$00, $40, $06, $a6
'-'         if_z    jmp     #host_reset                     ' See if it works...
	byte	$68, $fe, $9f, $ad
'-'                 getct   hr0
	byte	$1a, $86, $63, $fd
'-'                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
	byte	$b3, $87, $1b, $f2
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'         if_ae   getct   _pulse_time_
	byte	$1a, $66, $63, $3d
'-'         if_ae   add     _pulse_time_, _500ms_
	byte	$b2, $67, $03, $31
'-'                 jmp     #hidle
	byte	$5c, $ff, $9f, $fd
'-' ' Check for extended SE0 state on the bus
'-' .se0_test
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
	byte	$fc, $fd, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_nc   jmp     #hidle                          ' Bus still IDLE
	byte	$48, $ff, $9f, $3d
'-'                 call    #wait_txn_ok
	byte	$24, $f6, $bf, $fd
'-'                 wypin   ##OUT_IDLE, dm                  ' Float USB
	byte	$00, $00, $80, $ff, $22, $01, $28, $fc
'-'                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
'-'                 jmp     #discon_entry                   ' Device disconnected
	byte	$94, $fe, $9f, $fd
'-' 
'-' hsuspend
'-'                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
	byte	$14, $f6, $bf, $fd
'-'                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
	byte	$25, $00, $64, $fd
'-'                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
	byte	$1f, $54, $63, $fd
'-'                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
	byte	$22, $01, $28, $fc
'-'                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
	byte	$00, $40, $06, $f6
'-'                 mov     mod_cnt, #0
	byte	$00, $98, $07, $f6
'-' 
'-'                 ' Fall through to resume wait loop
'-' 
'-' hwait_resume
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
	byte	$14, $88, $07, $fb
'-'                 shr     hr1, #2
	byte	$02, $88, $47, $f0
'-'                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
	byte	$1f, $88, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 cmp     cmd_data, #CMD_RESUME   wz
	byte	$0f, $40, $0e, $f2
'-'         if_nz   jmp     #hwait_resume
	byte	$ec, $ff, $9f, $5d
'-'                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
	byte	$14, $72, $07, $fb
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $73, $0b, $f2
'-'         if_z    jmp     #.resume
	byte	$18, $00, $90, $ad
'-'                 loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $fd
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
	byte	$22, $6f, $13, $3c
'-'         if_c    wxpin   _usb_h_ls_nco_, dm
	byte	$22, $6b, $13, $cc
'-' .resume
'-'                 wypin   #OUT_K, dm
	byte	$22, $05, $28, $fc
'-'                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
	byte	$1f, $5e, $63, $fd
'-'                 wypin   #OUT_SE0, dm
	byte	$22, $03, $28, $fc
'-'                 mov     htmp, _ip_delay_ls_
	byte	$a3, $73, $03, $f6
'-'                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
	byte	$01, $72, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $72, $63, $fd
'-'                 wypin   #OUT_J, dm
	byte	$22, $07, $28, $fc
'-'                 shr     htmp, #1
	byte	$01, $72, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $72, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 setint1 #1                              ' Enable the 1ms frame ISR
	byte	$25, $02, $64, $fd
'-'                 mov     hctwait, _4ms_
	byte	$ab, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
	byte	$50, $fd, $bf, $fd
'-'         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
	byte	$00, $40, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send preamble to enable low-speed HUB ports
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   USB baud rate set to low-speed
'-' '------------------------------------------------------------------------------
'-' utx_pre
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   #0, dm                          ' Disable smartpin mode
	byte	$22, $01, $08, $fc
'-'                 drvl    dm
	byte	$58, $44, $62, $fd
'-'                 drvh    dp
	byte	$59, $46, $62, $fd
'-' 
'-'                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
	byte	$1e, $00, $00, $ff, $80, $72, $07, $f6
'-' 
'-'                 rep     @.l1, #16 + 1
	byte	$11, $08, $dc, $fc
'-'                 shr     htmp, #1        wc
	byte	$01, $72, $57, $f0
'-'         if_nc   setq    #1
	byte	$28, $02, $64, $3d
'-'         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
	byte	$4f, $44, $62, $3d
'-'                 waitx   _preamble_wait_
	byte	$1f, $4e, $63, $fd
'-' .l1
'-' 
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
	byte	$22, $6b, $13, $fc
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $06
'-' 
'-' hlut_end
'-'                 fit     $400
'-'                 fit     $400
'-'                 orgh
'-' if OVERLAP_MEMORY
'-'                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
'-' end
'-' '------------------------------------------------------------------------------
'-' ' Routines called from cog space.
'-' '------------------------------------------------------------------------------
'-' ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'-' '------------------------------------------------------------------------------
'-' 
'-' '------------------------------------------------------------------------------
'-' ' USB host cog initialization.
'-' '------------------------------------------------------------------------------
'-' usb_host_init
'-'                 ' Initialize buffer pointers
'-'         if OVERLAP_MEMORY
'-'         else
'-'                 loc     pb, #hid_descr
	byte	$4c, $15, $b0, $fe
'-'         end
'-'                 mov     hid_descr_p, pb
	byte	$f7, $4b, $02, $f6
'-'                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
'-'                 {
'-'                 }
'-'         
'-'                 {
'-'                 }
'-'                 'loc     pb,#hkbd_report
'-'                 'mov     hkbd_report_p,pb
'-' 
'-'                 loc     pb, #hub_descr
	byte	$44, $1d, $b0, $fe
'-'                 mov     hub_descr_p, pb
	byte	$f7, $4d, $02, $f6
'-'                 loc     pb, #urx_buff
	byte	$59, $1d, $b0, $fe
'-'                 mov     urx_buff_p, pb
	byte	$f7, $4f, $02, $f6
'-'                 loc     pb, #dev_desc_buff
	byte	$d1, $1d, $b0, $fe
'-'                 mov     dev_desc_buff_p, pb
	byte	$f7, $51, $02, $f6
'-'                 loc     pb, #con_desc_buff
	byte	$db, $1d, $b0, $fe
'-'                 mov     con_desc_buff_p, pb
	byte	$f7, $53, $02, $f6
'-'                 loc     pb, #usb_cache_start
	byte	$24, $15, $b0, $fe
'-'                 mov     cache_start_p, pb
	byte	$f7, $55, $02, $f6
'-'                 loc     pb, #usb_cache_end
	byte	$25, $1d, $b0, $fe
'-'                 mov     cache_end_p, pb
	byte	$f7, $57, $02, $f6
'-' 
'-'         if ERROR_LED >= 0
'-'         end
'-' 
'-'                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
'-'                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
'-'                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
'-' ' Configure and enable the Serial Host USB port.
'-'                 jmp     #host_reset                     ' Initialize host and enter main processing loop
	byte	$03, $03, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Timing calculations happen before any interrupt(s) are enabled.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   htmp - current CLKFREQ value.
'-' '------------------------------------------------------------------------------
'-' hinit_usb_timings
'-' '                getct   htmp2
'-'                 mov     save_sysclk, htmp
	byte	$b9, $59, $02, $f6
'-'                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
	byte	$8d, $5b, $80, $ff, $2c, $01, $2a, $fd
'-'                 getqx   _12Mbps_
	byte	$18, $32, $63, $fd
'-'                 shr     _12Mbps_, #16           wc
	byte	$10, $32, $57, $f0
'-'                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
	byte	$00, $32, $27, $f1
'-'                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
	byte	$03, $6e, $07, $f6
'-'                 shl     _usb_h_fs_nco_, #14
	byte	$0e, $6e, $67, $f0
'-'                 add     _usb_h_fs_nco_, _12Mbps_
	byte	$99, $6f, $03, $f1
'-'                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
	byte	$01, $70, $07, $f6
'-'                 shl     _usb_d_fs_nco_, #14
	byte	$0e, $70, $67, $f0
'-'                 add     _usb_d_fs_nco_, _12Mbps_
	byte	$99, $71, $03, $f1
'-'                 mov     _1_5Mbps_, _12Mbps_
	byte	$99, $35, $03, $f6
'-'                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
	byte	$03, $34, $47, $f0
'-'                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
	byte	$02, $6a, $07, $f6
'-'                 shl     _usb_h_ls_nco_, #14
	byte	$0e, $6a, $67, $f0
'-'                 add     _usb_h_ls_nco_, _1_5Mbps_
	byte	$9a, $6b, $03, $f1
'-'                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
	byte	$9a, $6d, $03, $f6
'-'                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
	byte	$80, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1b
	byte	$65, $cd, $1d, $ff, $00, $30, $27, $fd
'-'                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
	byte	$18, $36, $63, $fd
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1m
	byte	$a1, $07, $00, $ff, $40, $30, $27, $fd
'-'                 getqx   _1us_                           ' 1us as 32,9 fixed point
	byte	$18, $38, $63, $fd
'-'                 mov     hsave0, _1us_                   ' Save it to compute other us values
	byte	$9c, $7d, $03, $f6
'-'                 shr     _1us_, #9               wc
	byte	$09, $38, $57, $f0
'-'                 addx    _1us_, #0                       ' Round to final value
	byte	$00, $38, $27, $f1
'-'                 qmul    hsave0, #10                     ' Calc 10us
	byte	$0a, $7c, $07, $fd
'-'                 getqx   _10us_
	byte	$18, $3a, $63, $fd
'-'                 shr     _10us_, #9              wc
	byte	$09, $3a, $57, $f0
'-'                 addx    _10us_, #0                      ' 10us
	byte	$00, $3a, $27, $f1
'-'                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
	byte	$21, $7c, $07, $fd
'-'                 getqx   _33us_
	byte	$18, $3c, $63, $fd
'-'                 shr     _33us_, #9              wc
	byte	$09, $3c, $57, $f0
'-'                 addx    _33us_, #0                      ' 33us
	byte	$00, $3c, $27, $f1
'-'                 qmul    hsave0, #250                    ' Calc 250us
	byte	$fa, $7c, $07, $fd
'-'                 getqx   _txn_err_
	byte	$18, $3e, $63, $fd
'-'                 shr     _txn_err_, #9           wc
	byte	$09, $3e, $57, $f0
'-'                 addx    _txn_err_, #0                   ' 250us
	byte	$00, $3e, $27, $f1
'-'                 qmul    hsave0, #500                    ' Calc 500us
	byte	$f4, $7d, $07, $fd
'-'                 getqx   _500us_
	byte	$18, $40, $63, $fd
'-'                 shr     _500us_, #9             wc
	byte	$09, $40, $57, $f0
'-'                 addx    _500us_, #0                     ' 500us
	byte	$00, $40, $27, $f1
'-'                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
	byte	$01, $00, $00, $ff, $9a, $7c, $07, $fd
'-'                 getqx   _txn_ok_ls_
	byte	$18, $42, $63, $fd
'-'                 shr     _txn_ok_ls_, #9         wc
	byte	$09, $42, $57, $f0
'-'                 addx    _txn_ok_ls_, #0                 ' 666us
	byte	$00, $42, $27, $f1
'-'                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
	byte	$01, $00, $00, $ff, $52, $7d, $07, $fd
'-'                 getqx   _txn_ok_fs_
	byte	$18, $44, $63, $fd
'-'                 shr     _txn_ok_fs_, #9         wc
	byte	$09, $44, $57, $f0
'-'                 addx    _txn_ok_fs_, #0                 ' 850us
	byte	$00, $44, $27, $f1
'-'                 mov     _ip_delay_ls_, _1ns16fp_
	byte	$9b, $47, $03, $f6
'-'                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
	byte	$05, $00, $00, $ff, $80, $46, $07, $fa
'-'                 shr     _ip_delay_ls_, #16      wc
	byte	$10, $46, $57, $f0
'-'                 addx    _ip_delay_ls_, #0
	byte	$00, $46, $27, $f1
'-'                 mov     _tat_wait_ls_, _1ns16fp_
	byte	$9b, $4b, $03, $f6
'-'                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
	byte	$1c, $00, $00, $ff, $c0, $4b, $07, $fa
'-'                 shr     _tat_wait_ls_, #16      wc
	byte	$10, $4a, $57, $f0
'-'                 addx    _tat_wait_ls_, #0
	byte	$00, $4a, $27, $f1
'-'                 mov     _ip_delay_fs_, _1ns16fp_
	byte	$9b, $49, $03, $f6
'-'                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
	byte	$00, $00, $00, $ff, $4e, $49, $07, $fa
'-'                 shr     _ip_delay_fs_, #16      wc
	byte	$10, $48, $57, $f0
'-'                 addx    _ip_delay_fs_, #0
	byte	$00, $48, $27, $f1
'-'                 mov     _tat_wait_fs_, _1ns16fp_
	byte	$9b, $4d, $03, $f6
'-'                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
	byte	$04, $00, $00, $ff, $23, $4d, $07, $fa
'-'                 shr     _tat_wait_fs_, #16      wc
	byte	$10, $4c, $57, $f0
'-'                 addx    _tat_wait_fs_, #0
	byte	$00, $4c, $27, $f1
'-'                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
	byte	$8d, $5b, $00, $ff, $00, $59, $16, $fd
'-'                 getqx   _preamble_wait_
	byte	$18, $4e, $63, $fd
'-'                 sub     _preamble_wait_,# 9 - 1
	byte	$08, $4e, $87, $f1
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1thou
	byte	$01, $00, $00, $ff, $e8, $31, $27, $fd
'-'                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
	byte	$18, $50, $63, $fd
'-'                 shr     _1ms_, #9               wc
	byte	$09, $50, $57, $f0
'-'                 addx    _1ms_, #0                       ' 1ms
	byte	$00, $50, $27, $f1
'-'                 mov     _frame1ms_clks_, ##-14
	byte	$ff, $ff, $7f, $ff, $f2, $69, $07, $f6
'-'                 adds    _frame1ms_clks_, _1ms_
	byte	$a8, $69, $43, $f1
'-'                 mov     _2ms_, _1ms_
	byte	$a8, $53, $03, $f6
'-'                 shl     _2ms_, #1                       ' 2ms
	byte	$01, $52, $67, $f0
'-'                 mov     _suspend_wait_, _1ms_
	byte	$a8, $55, $03, $f6
'-'                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
	byte	$a8, $55, $03, $f1
'-'                 mov     _4ms_, _1ms_
	byte	$a8, $57, $03, $f6
'-'                 shl     _4ms_, #2                       ' 4ms
	byte	$02, $56, $67, $f0
'-'                 mov     _xfer_wait_, _4ms_
	byte	$ab, $59, $03, $f6
'-'                 add     _xfer_wait_, _1ms_              ' 5ms
	byte	$a8, $59, $03, $f1
'-'                 mov     _reset_hold_, _xfer_wait_       ' 5ms
	byte	$ac, $5d, $03, $f6
'-'                 mov     _resume_hold_, _reset_hold_
	byte	$ae, $5f, $03, $f6
'-'                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
	byte	$02, $5e, $67, $f0
'-'                 mov     _100ms_, _resume_hold_          ' 20ms
	byte	$af, $63, $03, $f6
'-'                 shl     _100ms_, #1                     ' 40ms
	byte	$01, $62, $67, $f0
'-'                 mov     _8ms_, _1ms_
	byte	$a8, $5b, $03, $f6
'-'                 shl     _8ms_, #3                       ' 8ms
	byte	$03, $5a, $67, $f0
'-'                 shl     _reset_hold_, #1                ' 10ms
	byte	$01, $5c, $67, $f0
'-'                 add     _100ms_, _reset_hold_           ' 50ms
	byte	$ae, $63, $03, $f1
'-'                 add     _reset_hold_, _xfer_wait_       ' 15ms
	byte	$ac, $5d, $03, $f1
'-'                 mov     _21ms_, _xfer_wait_             ' 5ms
	byte	$ac, $61, $03, $f6
'-'                 shl     _21ms_, #2                      ' 20ms
	byte	$02, $60, $67, $f0
'-'                 add     _21ms_, _1ms_                   ' 21ms
	byte	$a8, $61, $03, $f1
'-'                 mov     _500ms_, _100ms_                ' 50ms
	byte	$b1, $65, $03, $f6
'-'                 shl     _100ms_, #1                     ' 100ms
	byte	$01, $62, $67, $f0
'-'                 shl     _500ms_, #3                     ' 400ms
	byte	$03, $64, $67, $f0
'-'         _ret_   add     _500ms_, _100ms_                ' 500ms
	byte	$b1, $65, $03, $01
'-' '        _ret_   mov     _1sec_, save_sysclk
'-' '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'-' '                ret
'-' {
'-' }
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Parse a configuration descriptor chain to see if the device is a recognized
'-' ' one. If it is, start the task progression that will configure the device for
'-' ' use.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hconfig_base - start address of the cached config descriptor chain.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hparse_con_desc
'-'                 mov     ptrb, dev_desc_buff_p
	byte	$28, $f3, $03, $f6
'-'                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
	byte	$82, $73, $07, $fb
'-'                 altr    hdev_port,#hdev_id
	byte	$61, $5b, $86, $f9
'-'                 movbyts htmp,#%%1032
	byte	$4e, $72, $ff, $f9
'-'                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
	byte	$86, $d3, $e6, $fa
'-'                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
'-' 
'-'                 mov     pa, #CON_wTotalLen
	byte	$02, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
	byte	$f6, $df, $e2, $fa
'-'                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
'-' ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
'-' ' that defines a keyboard and/or mouse.
'-'                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
	byte	$6e, $eb, $c2, $fa
'-' .next_intf
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #hset_config
	byte	$b8, $01, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $72, $0f, $f2
'-'         if_z    jmp     #.intf
	byte	$0c, $00, $90, $ad
'-'                 rdbyte  htmp, ptrb
	byte	$80, $73, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b9, $eb, $02, $f1
'-'                 jmp     #.next_intf
	byte	$d8, $ff, $9f, $fd
'-' .intf
'-'                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
	byte	$00, $90, $07, $f6
'-'                 mov     hpar3, #0
	byte	$00, $92, $07, $f6
'-'                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
	byte	$82, $e1, $c6, $fa
'-'                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
	byte	$85, $e3, $c6, $fa
'-'                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
	byte	$86, $e5, $c6, $fa
'-'                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
	byte	$87, $e7, $c6, $fa
'-'                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
'-' 
'-' .endp
'-'                 rdbyte  htmp, ptrb
	byte	$80, $73, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b9, $eb, $02, $f1
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #.get_device
	byte	$78, $00, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $72, $0f, $f2
'-'         if_z    jmp     #.get_device
	byte	$64, $00, $90, $ad
'-'                 cmp     htmp, #TYPE_ENDPOINT    wz
	byte	$05, $72, $0f, $f2
'-'         if_z    jmp     #.get_ep
	byte	$04, $00, $90, $ad
'-'                 jmp     #.endp
	byte	$d0, $ff, $9f, $fd
'-' .get_ep
'-'                 rdbyte  hr1, ptrb[ENDP_bAddress]
	byte	$82, $89, $c7, $fa
'-'                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
	byte	$07, $88, $17, $f4
'-'                 shl     hr1, #8 + 7
	byte	$0f, $88, $67, $f0
'-'                 mov     htmp, hctrl_ep_addr
	byte	$6c, $73, $03, $f6
'-'                 and     htmp, ##ADDR_MASK
	byte	$3f, $00, $00, $ff, $00, $73, $07, $f5
'-'                 or      htmp, hr1                       ' endpoint address
	byte	$c4, $73, $43, $f5
'-'                 cmp     hpar2, #0               wz
	byte	$00, $90, $0f, $f2
'-'  if_z_and_c     jmp     #.in_ep
	byte	$0c, $00, $90, $8d
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'  if_z_and_nc    jmp     #.out_ep
	byte	$18, $00, $90, $2d
'-'                 jmp     #.endp
	byte	$a0, $ff, $9f, $fd
'-' .in_ep
'-'                 mov     hpar2, htmp                     ' IN endpoint
	byte	$b9, $91, $03, $f6
'-'                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8b, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $87, $c7, $fa
'-'                 setbyte hr2, hr0, #3
	byte	$c3, $8b, $db, $f8
'-'                 jmp     #.endp
	byte	$8c, $ff, $9f, $fd
'-' .out_ep
'-'                 mov     hpar3, htmp                     ' OUT endpoint
	byte	$b9, $93, $03, $f6
'-'                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8d, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $87, $c7, $fa
'-'                 setbyte hr3, hr0, #3
	byte	$c3, $8d, $db, $f8
'-'                 jmp     #.endp
	byte	$78, $ff, $9f, $fd
'-' 
'-' .get_device
'-'                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
	byte	$ff, $e2, $0e, $f2
'-'         if_z    cmp     hdev_subclass, #$5D     wz
	byte	$5d, $e4, $0e, $a2
'-'         if_z    cmp     hdev_protocol, #$01     wz
	byte	$01, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$64, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HUB  wz
	byte	$09, $e2, $0e, $f2
'-'         if_z    jmp     #.hub
	byte	$a8, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HID              wz
	byte	$03, $e2, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No HID class, ignore
	byte	$18, $ff, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_z    jmp     #.gamepad
	byte	$4c, $00, $90, $ad
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
	byte	$01, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
	byte	$08, $ff, $9f, $5d
'-' .keyboard
'-'                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
	byte	$01, $e6, $0e, $f2
'-'         if HAVE_MOUSE
'-'         if_nz  jmp      #.mouse                         ' No Keyboard
	byte	$1c, $00, $90, $5d
'-'         else
'-'         end
'-'                 cmp     hkbd_ep_addr, #0    wz
	byte	$00, $f2, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$f8, $fe, $9f, $5d
'-'                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6f, $e2, $f8
'-'                 getbyte kb_interval, hr2, #3
	byte	$c5, $71, $fa, $f8
'-'                 getbyte kb_in_max_pkt, hr2, #0
	byte	$c5, $73, $e2, $f8
'-'                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
	byte	$c8, $f3, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$e4, $fe, $9f, $fd
'-' if HAVE_MOUSE
'-' .mouse
'-'                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
	byte	$02, $e6, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No Mouse
	byte	$dc, $fe, $9f, $5d
'-'                 cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$d4, $fe, $9f, $5d
'-'                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6b, $e2, $f8
'-'                 'getbyte ms_interval, hr2, #3
'-'                 getbyte ms_in_max_pkt, hr2, #0
	byte	$c5, $6d, $e2, $f8
'-'                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
	byte	$c8, $f5, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$c4, $fe, $9f, $fd
'-' end
'-' .gamepad
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $73, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c8, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$b0, $fe, $9f, $ad
'-'         if HAVE_MOUSE
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $73, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c8, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$9c, $fe, $9f, $ad
'-'         end
'-'                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz      ' |
	byte	$00, $00, $0c, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$90, $fe, $9f, $5d
'-' 
'-'                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $79, $e2, $f8
'-'                 getbyte gp_interval, hr2, #3
	byte	$c5, $7b, $fa, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, hpar2                      ' IN endpoint address
	byte	$c8, $01, $00, $f6
'-'                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
	byte	$c9, $0b, $03, $f6
'-'                 'debug(udec(gp_intf_num))
'-'                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
'-'                 jmp     #.next_intf
	byte	$78, $fe, $9f, $fd
'-' .hub
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$70, $fe, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_nz   cmp     hdev_protocol, #2                   wz
	byte	$02, $e6, $0e, $52
'-'         if_nz   jmp     #.next_intf
	byte	$64, $fe, $9f, $5d
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$5c, $fe, $9f, $5d
'-'                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
	byte	$70, $63, $e2, $f8
'-'                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $ed, $02, $f6
'-'                 mov     ep_addr_pid, hpar2              ' IN endpoint address
	byte	$c8, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 mov     hhub_ep_addr, ep_addr_pid
	byte	$5e, $ef, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
	byte	$6c, $bd, $02, $f6
'-'                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
'-'                 jmp     #.next_intf
	byte	$40, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' If a newly-connected device is recognized, do whatever is needed to configure
'-' ' it according to its function, or functions. In the case of this boot protocol
'-' ' keyboard/mouse class driver:
'-' ' - SetConfiguration(config_num)
'-' ' - SetProtocol(boot)
'-' ' - SetIdle(indefinite)
'-' ' - Enter the device interrupt IN polling task stage.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_config
'-' '                mov     hkbd_ep_addr, #0                ' DEBUG
'-' '                mov     hmouse_ep_addr, #0              ' DEBUG
'-'                 mov     htmp2, #DEV_UNKNOWN
	byte	$02, $76, $07, $f6
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $a2
'-'         if HAVE_MOUSE
'-'         if_z    cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $a2
'-'         end
'-'         if_z    cmp     hhub_ep_addr, #0        wz
	byte	$00, $ee, $0e, $a2
'-'         if_z    jmp     #.notify_client                 ' No known device
	byte	$60, $03, $90, $ad
'-' .set_config
'-'                 loc     ptra, #set_config
	byte	$74, $0e, $d0, $fe
'-'                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
	byte	$05, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdbyte  hpar1, pa
	byte	$f6, $8f, $c3, $fa
'-'                 debug("SetConfiguration: ",udec_(hpar1))
'-'                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
	byte	$01, $8f, $57, $fc
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
	byte	$6c, $bd, $02, $f6
'-'                 mov     pb, #0                          ' SetConfiguration() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-' .kbd_config
'-'                 cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $f2
'-'         if_z    jmp     #.mouse_config                  ' No keyboard
	byte	$98, $00, $90, $ad
'-' 
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.mouse_config                  ' No keyboard
	byte	$84, $00, $90, $5d
'-' 
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $73, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$3c, $0e, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$f8, $02, $90, $5d
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8e, $07, $f6
'-'                 getbyte hpar2, kb_intf_num, #0
	byte	$37, $91, $e3, $f8
'-'                 call    #hset_idle
	byte	$44, $03, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hkbd_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 mov     hctwait, _2ms_
	byte	$a9, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
	byte	$00, $76, $06, $f6
'-'         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
'-'         end
'-'                 mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $f6
'-'                 loc     pa, #hkbd_led_rep
	byte	$a0, $17, $90, $fe
'-'                 wrbyte  hkbd_ledstates,pa
	byte	$f6, $f9, $42, $fc
'-'                 call    #hset_kbdled_report
	byte	$40, $03, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$c4, $02, $90, $5d
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hkbd_ep_addr, ep_addr_pid
	byte	$5e, $f3, $02, $f6
'-'                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $f1, $02, $f6
'-'                 bitc    hkbd_ctrl_ep, #31
	byte	$1f, $f0, $46, $f4
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
	byte	$00, $f6, $06, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $c6, $f8
'-'                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
	byte	$03, $76, $07, $f6
'-'         if !!HAVE_MOUSE
'-'         end
'-' 
'-' .mouse_config
'-' if HAVE_MOUSE
'-'                 cmp     hmouse_ep_addr, #0        wz
	byte	$00, $f4, $0e, $f2
'-'         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$ac, $00, $90, $ad
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$98, $00, $90, $5d
'-' 
'-'                 debug("mouse passed addr check")
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$b8, $0d, $d0, $fe
'-'                 wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $ff, $03, $01, $5e, $fc
'-'                 wrword  ms_intf_num,ptra[wIndex]
	byte	$02, $6b, $56, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$58, $02, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 getbyte htmp, ms_intf_num, #0
	byte	$35, $73, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$6c, $0d, $d0, $fe
'-'                 wrword  #MOUSE_FULL_PROTOCOL ? REPORT_PROTOCOL : BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$28, $02, $90, $5d
'-'                 debug("mouse passed SetProtocol")
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8e, $07, $f6
'-'                 getbyte hpar2, ms_intf_num, #0
	byte	$35, $91, $e3, $f8
'-'                 call    #hset_idle
	byte	$74, $02, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hmouse_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 debug("mouse passed SetIdle")
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hmouse_ep_addr, ep_addr_pid
	byte	$5e, $f5, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $ce, $f8
'-'                 mov     htmp2, hkbd_ep_addr
	byte	$79, $77, $03, $f6
'-'                 xor     htmp2, hmouse_ep_addr
	byte	$7a, $77, $63, $f5
'-'                 and     htmp2, ##ADDR_MASK              wz
	byte	$3f, $00, $00, $ff, $00, $77, $0f, $f5
'-'         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
	byte	$05, $76, $07, $a6
'-'         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
	byte	$04, $76, $07, $56
'-'                 jmp     #.notify_client
	byte	$e4, $01, $90, $fd
'-' end
'-' .gamepad_config
'-' if _HAVE_GAMEPAD
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    jmp     #.hub_config                    ' No gamepad
	byte	$6c, $01, $90, $ad
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     htmp, 0-0
	byte	$00, $72, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.hub_config                    ' No gamepad
	byte	$54, $01, $90, $5d
'-' 
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, ep_addr_pid
	byte	$5e, $01, $00, $f6
'-'                 mov     ep_addr_pid, hdev_out_addr  wz
	byte	$85, $bd, $0a, $f6
'-'         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $58
'-'         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $5d
'-'         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $54
'-'         if_nz   bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $54
'-'         if_nz   mov     hdev_out_addr, ep_addr_pid
	byte	$5e, $0b, $03, $56
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 if EMUPAD_MAX_PLAYER > 0
'-'                 
'-' .rule_loop           
'-'                 end
'-' 
'-'                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
	byte	$ff, $e2, $0e, $f2
'-'         if_e    jmp     #.xinput
	byte	$5c, $00, $90, $ad
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     htmp,0-0
	byte	$00, $72, $03, $f6
'-'                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
	byte	$01, $a6, $02, $ff, $68, $72, $0f, $f2
'-'         if_e    jmp     #.ps3
	byte	$8c, $00, $90, $ad
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$a4, $0c, $d0, $fe
'-'                 cmp     hdev_port,#0            wz
	byte	$00, $5a, $0e, $f2
'-'         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $5f, $03, $01, $5e, $5c
'-'         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
	byte	$03, $00, $80, $af, $03, $01, $5e, $ac
'-'                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
	byte	$02, $01, $5c, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $01, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),udec(total_data),uhex_byte_array(pb,total_data))
'-' 
'-'                 mov     htmp2, #HID_READY               ' Standard gamepad
	byte	$06, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$20, $01, $90, $fd
'-' .xinput
'-'                 loc     ptra, #xinp_led_cmd             ' Turn on LED
	byte	$b8, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb,#1 ' root device is also player 1
	byte	$01, $ee, $e7, $f2
'-'                 fle     pb,#3
	byte	$03, $ee, $27, $f3
'-'                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
	byte	$06, $ee, $07, $f1
'-'                 wrbyte  pb, ptra[2]
	byte	$02, $ef, $47, $fc
'-' 
'-'                 mov     pkt_data, #3
	byte	$03, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB
	byte	$03, $96, $06, $f4
'-'                 mov     ep_addr_pid, hdev_out_addr
	byte	$85, $bd, $02, $f6
'-'                 debug("XInput LED set ",uhex_long(ep_addr_pid),uhex_byte(pb))
'-'                 call    #txn_out
	byte	$5a, $00, $a0, $fd
'-'                 mov     ep_addr_pid, hctrl_ep_addr
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 loc     ptra, #xinp_fix_8bitdo
	byte	$97, $0c, $d0, $fe
'-'                 mov     pb, urx_buff_p          ' We don't actually care where it goes
	byte	$27, $ef, $03, $f6
'-'                 call    #control_read           ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 debug("8bitdo weird fix... ",uhex(retval))
'-'                 mov retval,#PID_ACK             ' If we don't do this something else becomes sad (TODO fix?)
	byte	$d2, $be, $06, $f6
'-' 
'-' 
'-'                 mov     htmp2, #XINPUT_READY
	byte	$07, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$dc, $00, $90, $fd
'-' .ps3
'-'                 loc     ptra, #ps3_command_buff         ' Turn on LED
	byte	$44, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 fge     pb,#1 ' root device is also player 1
	byte	$01, $ee, $07, $f3
'-'                 fle     pb,#4
	byte	$04, $ee, $27, $f3
'-'                 decod   pb
	byte	$f7, $ef, $c3, $f9
'-'                 wrbyte  pb, ptra[9]
	byte	$09, $ef, $47, $fc
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$f4, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #48, ptra[wLength]
	byte	$03, $61, $5c, $fc
'-'                 loc     pb, #ps3_command_buff
	byte	$14, $0c, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$d4, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $e9, $5f, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #4, ptra[wLength]
	byte	$03, $09, $5c, $fc
'-'                 loc     pb, #ps3_enable_cmd             ' Enable PS3
	byte	$f0, $0b, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK    wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$74, $00, $90, $5d
'-' 
'-'                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
	byte	$08, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$6c, $00, $90, $fd
'-' end
'-' 
'-' .hub_config
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_z    jmp     #.notify_client                 ' No HUB
	byte	$64, $00, $90, $ad
'-'                 mov     htmp, hhub_ep_addr
	byte	$77, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.notify_client                 ' No HUB
	byte	$50, $00, $90, $5d
'-' 
'-'                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
	byte	$94, $0b, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, hub_descr_p
	byte	$26, $ef, $03, $f6
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hhub_ep_addr, #0
	byte	$00, $ee, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $00, $90, $5d
'-'                 debug(uhex_byte_array(hub_descr_p,total_data))
'-' 
'-'                 mov     ptra, hub_descr_p
	byte	$26, $f1, $03, $f6
'-'                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
	byte	$02, $79, $c7, $fa
'-'                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
	byte	$07, $78, $27, $f3
'-'                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
'-' .pwr_loop
'-'                 loc     ptra, #set_port_feat            ' Power on ports
	byte	$74, $0b, $d0, $fe
'-'                 wrword  #HUB_PORT_POWER, ptra[wValue]
	byte	$01, $11, $5c, $fc
'-'                 wrword  htmp3, ptra[wIndex]
	byte	$02, $79, $57, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 djnz    htmp3, #.pwr_loop
	byte	$fb, $79, $6f, $fb
'-' 
'-'                 mov     hctwait, _500ms_
	byte	$b2, $99, $02, $f6
'-'                 add     hctwait, _100ms_
	byte	$b1, $99, $02, $f1
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 mov     htmp2, #HUB_READY               ' Hub ready
	byte	$09, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$00, $00, $90, $fd
'-' 
'-' .notify_client
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte htmp2                           ' Save device ready
	byte	$bb, $01, $c0, $f8
'-'                 debug(uhex_long(hdev_type,hdev_type+1))
'-'         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Initialize the keyboard/mouse data area to start-up values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' init_kbdm_data
'-'                 mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $f6
'-'                 mov     hdev_ep_addr, #0
	byte	$00, $fa, $06, $f6
'-' 
'-'                 mov     ptra, cache_start_p         ' Clear cached data buffers
	byte	$2a, $f1, $03, $f6
'-'                 mov     pa, cache_end_p
	byte	$2b, $ed, $03, $f6
'-' .loop
'-'                 wrbyte  #0, ptra++
	byte	$61, $01, $4c, $fc
'-'                 cmp     ptra, pa                wcz
	byte	$f6, $f1, $1b, $f2
'-'         if_b    jmp     #.loop
	byte	$f4, $ff, $9f, $cd
'-'         
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' 
'-'                 mov     pa, #hdev_init_start        ' Clear device data registers
	byte	$2d, $ed, $07, $f6
'-' .regloop
'-'                 altd    pa
	byte	$00, $ec, $8f, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-'                 add     pa, #1
	byte	$01, $ec, $07, $f1
'-'                 cmp     pa, #hdev_init_end      wz
	byte	$47, $ed, $0f, $f2
'-'         if_nz   jmp     #.regloop
	byte	$ec, $ff, $9f, $5d
'-' 
'-'                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
	byte	$e1, $e1, $61, $ff, $c3, $5d, $06, $f6
'-'                 mov     hdev_next_datax + 1,hdev_next_datax
	byte	$2e, $5f, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0
	byte	$c3, $60, $c6, $f8
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1
	byte	$c3, $60, $ce, $f8
'-' 
'-'         _ret_   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
'-' ' function.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'-' '   hpar2 - index number of the target interface.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_idle
'-'                 mov     hctwait, _2ms_
	byte	$a9, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #set_idle
	byte	$cc, $0a, $d0, $fe
'-'                 wrword  hpar1, ptra[wValue]
	byte	$01, $8f, $57, $fc
'-'                 wrword  hpar2, ptra[wIndex]
	byte	$02, $91, $57, $fc
'-'                 jmp     #control_write
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
'-' ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - device address and enpoint for the request.
'-' ' On exit:
'-' '   retval - transaction result.
'-' '------------------------------------------------------------------------------
'-' hset_kbdled_report
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$c0, $0a, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
	byte	$01, $00, $80, $ff, $01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
	byte	$03, $03, $5c, $fc
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrbyte  kb_led_states, pb
	byte	$f7, $77, $42, $fc
'-'                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for keyboard activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_kbd_in_report
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #0
	byte	$30, $93, $e3, $f8
'-'                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
	byte	$39, $93, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
	byte	$30, $73, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
	byte	$4b, $60, $c6, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
	byte	$c3, $60, $c6, $58
'-' 
'-'                 mov     kb_max_index, hpar3             ' Save actual bytes read
	byte	$c9, $75, $02, $f6
'-'                 call    #hkbd_compare
	byte	$18, $00, $b0, $fd
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' .led_check
'-'                 mov     htmp, kb_led_states
	byte	$3b, $73, $03, $f6
'-'                 cmp     hkbd_ledstates, htmp    wz
	byte	$b9, $f9, $0a, $f2
'-'         if_z    ret                                     ' No toggle key indicator changes, so we're done
	byte	$2d, $00, $64, $ad
'-'                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
	byte	$7c, $77, $02, $f6
'-'                 mov     ep_addr_pid, hkbd_ctrl_ep
	byte	$78, $bd, $02, $f6
'-'                 jmp     #hset_kbdled_report             ' Set report and ignore errors
	byte	$88, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Compare current and previous keyboard data buffers for keypress changes.
'-' '------------------------------------------------------------------------------
'-' hkbd_compare
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$d0, $13, $f0, $fe
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $77, $07, $fb
'-'                 cmp     htmp1, htmp2    wz
	byte	$bb, $75, $0b, $f2
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $77, $07, $fb
'-'         if_z    cmp     htmp1, htmp2    wz
	byte	$bb, $75, $0b, $a2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-' 
'-'                 loc     ptra, #hkbd_report
	byte	$b0, $13, $d0, $fe
'-' 
'-'                 ' Handle modifiers
'-'                 rdbyte  hpar2, urx_buff_p
	byte	$27, $91, $c3, $fa
'-'                 rdbyte  hr1, ptra
	byte	$00, $89, $c7, $fa
'-'                 rolword hr1,hpar2,#0
	byte	$c8, $89, $43, $f9
'-'                 mergew  hr1
	byte	$63, $88, $63, $fd
'-'                 mov     pa,#8
	byte	$08, $ec, $07, $f6
'-' .modloop
'-'                 rczr    hr1     wcz ' New value in C, old value in Z
	byte	$6a, $88, $7b, $fd
'-'                 mov     hpar1,#$E8
	byte	$e8, $8e, $07, $f6
'-'                 sub     hpar1,pa
	byte	$f6, $8f, $83, $f1
'-'       if_c_ne_z call    #hkbd_translate
	byte	$a0, $00, $b0, $6d
'-'                 djnz    pa,#.modloop
	byte	$fb, $ed, $6f, $fb
'-' 
'-' .release        modc    _set    wc
	byte	$6f, $e0, $75, $fd
'-'                 'alts    hdev_port, #hid_report_p
'-'                 'mov     ptra, hid_report_p
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .rl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8f, $cf, $fa
'-'         if_z    jmp     #.rl3
	byte	$20, $00, $90, $ad
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .rl2            rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b9, $8f, $0b, $f2
'-'         if_z    jmp     #.rl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.rl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$68, $00, $b0, $fd
'-' .rl3            djnz    pa, #.rl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-'                 mov     hpar3, #0
	byte	$00, $92, $07, $f6
'-'                 bith    hpar3, #31
	byte	$1f, $92, $27, $f4
'-' 
'-' .press          modc    _clr    wc
	byte	$6f, $00, $74, $fd
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .pl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8f, $cf, $fa
'-'         if_z    jmp     #.pl3
	byte	$20, $00, $90, $ad
'-'                 loc     ptrb, #hkbd_report
	byte	$2c, $13, $f0, $fe
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .pl2            rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b9, $8f, $0b, $f2
'-'         if_z    jmp     #.pl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.pl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$24, $00, $b0, $fd
'-' .pl3            djnz    pa, #.pl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-' .copy           mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$04, $13, $f0, $fe
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 wrlong  htmp1, ptrb++
	byte	$e1, $75, $67, $fc
'-'                 wrbyte  hkbd_ledstates,ptrb++
	byte	$e1, $f9, $46, $fc
'-' 
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Translate keyboard scancode to ASCII
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - scancode
'-' '   hpar2 - key modifiers state
'-' '       c - pressed (0) or released (1) flag
'-' ' On exit:
'-' '   hpar1 - bit     31 = 0 pressed, 1 released
'-' '               30..17 = unused
'-' '                   18 = scroll-lock state 
'-' '                   17 = caps-lock state
'-' '                   16 = num-lock state 
'-' '                15..8 = key modifiers state
'-' '                 7..0 = scancode
'-' '------------------------------------------------------------------------------
'-' hkbd_translate
'-'                 cmp     hpar1, #KEY_CAPSLOCK    wz
	byte	$39, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
	byte	$01, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_NUMLOCK     wz
	byte	$53, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
	byte	$00, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_SCROLLLOCK  wz
	byte	$47, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
	byte	$02, $f8, $e6, $24
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' 
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' 
'-'         end
'-'                 setbyte hpar1, hpar2, #1
	byte	$c8, $8f, $cb, $f8
'-'                 setbyte hpar1, hkbd_ledstates,#2
	byte	$7c, $8f, $d3, $f8
'-'                 bitc    hpar1, #31
	byte	$1f, $8e, $47, $f4
'-'         if KEYQUEUE_SIZE > 0
'-'                 loc pb,#keyq_head
	byte	$c0, $09, $b0, $fe
'-'                 rdword htmp,pb
	byte	$f7, $73, $e3, $fa
'-'                 getbyte htmp1,htmp,#1 ' tail
	byte	$b9, $75, $eb, $f8
'-'                 getbyte htmp,htmp,#0 ' head
	byte	$b9, $73, $e3, $f8
'-'                 mov htmp2,htmp
	byte	$b9, $77, $03, $f6
'-'                 mul htmp2,#4
	byte	$04, $76, $07, $fa
'-'                 add htmp2,pb
	byte	$f7, $77, $03, $f1
'-'                 add htmp2,#2
	byte	$02, $76, $07, $f1
'-'                 incmod htmp,#KEYQUEUE_SIZE - 1
	byte	$7f, $72, $07, $f7
'-'                 cmp htmp1,htmp wz ' check buffer overflow
	byte	$b9, $75, $0b, $f2
'-'         if_nz   wrlong hpar1,htmp2
	byte	$bb, $8f, $63, $5c
'-'         if_nz   wrbyte htmp,pb
	byte	$f7, $73, $43, $5c
'-'         end
'-'                 ret wcz
	byte	$2d, $00, $7c, $fd
'-' 
'-' if HAVE_MOUSE
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for mouse activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_mouse_in_report
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #1
	byte	$30, $93, $eb, $f8
'-'                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
	byte	$36, $93, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
	byte	$30, $73, $eb, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
	byte	$4b, $60, $ce, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
	byte	$c3, $60, $ce, $58
'-' 
'-'         'debug(uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 call #hid_decode
	byte	$c8, $00, $b0, $fd
'-'         else
'-'         end
'-' 
'-'                 loc     pa, #mouse_limits
	byte	$48, $09, $90, $fe
'-'                 loc     ptrb, #mouse_xacc
	byte	$5d, $13, $f0, $fe
'-' 
'-'                 ' load xacc,yacc,zacc
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  hr1,ptrb
	byte	$80, $89, $07, $fb
'-'                 ' load limits and outptr
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  htmp1,pa
	byte	$f6, $75, $03, $fb
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 wrbyte  hidr_buttons, ptrb[12]
	byte	$8c, $19, $47, $fc
'-'         else
'-'                 { ' Currently not used
'-'                 '}
'-'         end
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+0, #0
	byte	$88, $73, $33, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'         else
'-'         end
'-'                 add     hr1,htmp
	byte	$b9, $89, $03, $f1
'-'                 cmp     htmp1,#0 wz
	byte	$00, $74, $0f, $f2
'-'         if_ne   fles    hr1,htmp1
	byte	$ba, $89, $63, $53
'-'         if_ne   fges    hr1,#0
	byte	$00, $88, $47, $53
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+0, #1
	byte	$88, $73, $3b, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'         else
'-'         end
'-'                 add     hr2,htmp
	byte	$b9, $8b, $03, $f1
'-'                 cmp     htmp2,#0 wz
	byte	$00, $76, $0f, $f2
'-'         if_ne   fles    hr2,htmp2
	byte	$bb, $8b, $63, $53
'-'         if_ne   fges    hr2,#0
	byte	$00, $8a, $47, $53
'-'                 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+3, #1           ' Mouse wheel is actually on the "wheel axis"
	byte	$8b, $73, $3b, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'                 add     hr3, htmp
	byte	$b9, $8d, $03, $f1
'-'         else    
'-'         end
'-' 
'-'                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
	byte	$90, $73, $cf, $fa
'-'         if_nz   ret                                     ' If so, don't write results
	byte	$2d, $00, $64, $5d
'-' 
'-'                 ' write back accumulators
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 wrlong  hr1,ptrb
	byte	$80, $89, $67, $fc
'-'                 ' if outptr set, write X/Y words
'-'                 cmp htmp3,#0                    wz
	byte	$00, $78, $0f, $f2
'-'         if_nz   setword hr1,hr2,#1
	byte	$c5, $89, $2b, $59
'-'         if_nz   wrlong hr1,htmp3
	byte	$bc, $89, $63, $5c
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' hget_gp_in_report
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-' 
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 altgb   hdev_port, #hdev_next_datax
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte hpar3
	byte	$00, $92, $e3, $f8
'-'                 setword hpar3, #255, #1                 ' Always ask for max report size
	byte	$ff, $92, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-'                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte htmp                            ' |
	byte	$00, $72, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    mov     htmp, #PID_DATA1                ' |
	byte	$4b, $72, $07, $a6
'-'         if_nz   mov     htmp, #PID_DATA0                ' |
	byte	$c3, $72, $07, $56
'-'                 altsb   hdev_port, #hdev_next_datax     ' |
	byte	$2e, $5b, $66, $f9
'-'                 setbyte htmp                            ' |
	byte	$b9, $01, $c0, $f8
'-' 
'-' ' Note: the following code compares the current and previous reports
'-' ' and process the data if there are changes to ease the debug output.
'-' ' Actual implementations should remove this block, along with hid_pre_rpt_p and
'-' ' gpPreReport buffer.
'-' 
'-'                 ' ----- start of block to remove
'-'                 {
'-'                 }
'-'                 ' ----- end of block to remove
'-'                 loc pa,#hpad_translate
	byte	$14, $05, $90, $fe
'-'                 push pa
	byte	$2a, $ec, $63, $fd
'-' 
'-'                 ' FALL THROUGH !!!!
'-' end
'-' if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
'-' '------------------------------------------------------------------------------
'-' ' Decode controller report
'-' '------------------------------------------------------------------------------
'-' hid_decode
'-'                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
'-'                 setq #(hidr_end-hidr_start)-1
	byte	$28, $20, $64, $fd
'-'                 rdlong  hidr_start,##$8_0000
	byte	$00, $04, $00, $ff, $00, $0c, $07, $fb
'-' 
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte hidr_type
	byte	$00, $1c, $e3, $f8
'-'         if _HAVE_GAMEPAD
'-'                 cmp     hidr_type, #XINPUT_READY        wz
	byte	$07, $1c, $0f, $f2
'-'         if_z    jmp     #hpad_xinput
	byte	$08, $03, $90, $ad
'-'                 cmp     hidr_type, #PS3_READY           wz
	byte	$08, $1c, $0f, $f2
'-'         if_z    jmp     #hpad_ps3
	byte	$ec, $03, $90, $ad
'-'         end
'-'                 cmp     hidr_type, #KBM_READY           wz
	byte	$05, $1c, $0f, $f2
'-'         if_z    mov     hidr_type,#M_READY
	byte	$04, $1c, $07, $a6
'-'                 cmp     hidr_type, #M_READY             wz
	byte	$04, $1c, $0f, $f2
'-'                 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle HID controller (or mouse now
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' hpad_hid
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 mov     ptra, pb
	byte	$f7, $f1, $03, $f6
'-'                 alts    hdev_port, #gp_descr_len
	byte	$3f, $5b, $96, $f9
'-'                 mov     pa, 0-0
	byte	$00, $ec, $03, $f6
'-'                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
'-'                 mov     hidr_usage, ##$76543210
	byte	$19, $2a, $3b, $ff, $10, $0c, $07, $f6
'-' 
'-' .next
'-'                 cmps    pa, #0      wcz
	byte	$00, $ec, $5f, $f2
'-'         if_be   ret     wcz
	byte	$2d, $00, $7c, $ed
'-' 
'-'                 rdbyte  hpar1, ptra++
	byte	$61, $8f, $c7, $fa
'-'                 sub     pa, #1
	byte	$01, $ec, $87, $f1
'-'                 mov     hpar2, #0
	byte	$00, $90, $07, $f6
'-' 
'-'                 mov     htmp, hpar1
	byte	$c7, $73, $03, $f6
'-'                 and     htmp, #$03
	byte	$03, $72, $07, $f5
'-'                 cmp     htmp, #1    wz
	byte	$01, $72, $0f, $f2
'-'         if_z    rdbyte  hpar2, ptra++
	byte	$61, $91, $c7, $aa
'-'         if_z    signx   hpar2,#7
	byte	$07, $90, $67, $a7
'-'         if_z    sub     pa, #1
	byte	$01, $ec, $87, $a1
'-'                 cmp     htmp, #2    wz
	byte	$02, $72, $0f, $f2
'-'         if_z    rdword  hpar2, ptra++
	byte	$61, $91, $e7, $aa
'-'         if_z    signx   hpar2,#15
	byte	$0f, $90, $67, $a7
'-'         if_z    sub     pa, #2
	byte	$02, $ec, $87, $a1
'-'                 cmp     htmp, #3    wz
	byte	$03, $72, $0f, $f2
'-'         if_z    rdlong  hpar2, ptra++
	byte	$61, $91, $07, $ab
'-'         if_z    sub     pa, #4
	byte	$04, $ec, $87, $a1
'-' 
'-'                 and     hpar1, #$FC
	byte	$fc, $8e, $07, $f5
'-'                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
'-' 
'-'                 cmp     hpar1, #HID_REPORT_ID   wz
	byte	$84, $8e, $0f, $f2
'-'         if_z    jmp     #.report_id
	byte	$18, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE_PAGE  wz
	byte	$04, $8e, $0f, $f2
'-'         if_z    jmp     #.usage_page
	byte	$30, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE       wz
	byte	$08, $8e, $0f, $f2
'-'         if_z    jmp     #.usage
	byte	$38, $01, $90, $ad
'-'                 cmp     hpar1, #HID_LOGICAL_MIN wz
	byte	$14, $8e, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #1
	byte	$c8, $2b, $2b, $a9
'-'                 cmp     hpar1, #HID_LOGICAL_MAX wz
	byte	$24, $8e, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #0
	byte	$c8, $2b, $23, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MIN wz
	byte	$34, $8e, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #1
	byte	$c8, $2d, $2b, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MAX wz
	byte	$44, $8e, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #0
	byte	$c8, $2d, $23, $a9
'-'                 cmp     hpar1, #HID_REPORT_SIZE wz
	byte	$74, $8e, $0f, $f2
'-'         if_z    mov     hidr_size, hpar2
	byte	$c8, $27, $03, $a6
'-'                 cmp     hpar1, #HID_REPORT_COUNT wz
	byte	$94, $8e, $0f, $f2
'-'         if_z    mov     hidr_count, hpar2
	byte	$c8, $29, $03, $a6
'-'                 cmp     hpar1, #HID_POP wcz
	byte	$b4, $8e, $1f, $f2
'-'         if_nz   cmp     hpar1, #HID_PUSH wz
	byte	$a4, $8e, $0f, $52
'-'         if_z    jmp     #.pushpop ' Entering with C set if PUSH  
	byte	$64, $01, $90, $ad
'-'                 cmp     hpar1, #HID_INPUT       wz
	byte	$80, $8e, $0f, $f2
'-'         if_nz   jmp     #.next
	byte	$58, $ff, $9f, $5d
'-' 
'-'                 tjf     hidr_state,#.next
	byte	$d5, $25, $a7, $fb
'-' 
'-'                 and     hpar2, #$03
	byte	$03, $90, $07, $f5
'-'                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
	byte	$02, $90, $0f, $f2
'-'         if_nz   jmp     #.skip
	byte	$18, $00, $90, $5d
'-' 
'-'                 cmp     hidr_state, #2  wz
	byte	$02, $24, $0f, $f2
'-'         if_z    jmp     #.axes
	byte	$20, $00, $90, $ad
'-'                 cmp     hidr_state, #3  wz
	byte	$03, $24, $0f, $f2
'-'         if_z    jmp     #.hats
	byte	$5c, $00, $90, $ad
'-'                 cmp     hidr_state, #4  wz
	byte	$04, $24, $0f, $f2
'-'         if_z    jmp     #.buttons
	byte	$70, $00, $90, $ad
'-' .skip
'-'                 mov     htmp, hidr_size
	byte	$93, $73, $03, $f6
'-'                 mul     htmp, hidr_count
	byte	$94, $73, $03, $fa
'-'                 add     hidr_offset, htmp
	byte	$b9, $21, $03, $f1
'-'                 jmp     #.next
	byte	$20, $ff, $9f, $fd
'-' .axes
'-'                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count),uhex_long(hidr_flags))
'-'                 getnib  hr0, hidr_flags, #2
	byte	$87, $87, $53, $f8
'-'                 mov     hr1, hidr_count
	byte	$94, $89, $03, $f6
'-' .l1
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 call    #hpad_getbits
	byte	$28, $01, $b0, $fd
'-'                 call    #hpad_normalize
	byte	$88, $01, $b0, $fd
'-'                 cmp     hr0, #8         wcz
	byte	$08, $86, $1f, $f2
'-'         if_b    altgn   hr0, #hidr_usage
	byte	$86, $87, $5f, $c9
'-'         if_b    getnib  hr2
	byte	$00, $8a, $43, $c8
'-'         if_b    altsw   hr2, #hidr_axis
	byte	$88, $8b, $77, $c9
'-'         if_b    setword retval
	byte	$5f, $01, $20, $c9
'-'         if_b    add     hr0, #1
	byte	$01, $86, $07, $c1
'-'                 add     hidr_offset, hidr_size
	byte	$93, $21, $03, $f1
'-'                 djnz    hr1, #.l1
	byte	$f4, $89, $6f, $fb
'-' 
'-'                 setnib  hidr_flags, hr0, #2
	byte	$c3, $0f, $13, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.next
	byte	$dc, $fe, $9f, $fd
'-' .hats
'-'                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 call    #hpad_getbits
	byte	$ec, $00, $b0, $fd
'-'                 setbyte hidr_hats, retval, #0
	byte	$5f, $1b, $c3, $f8
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.skip
	byte	$90, $ff, $9f, $fd
'-' .buttons
'-'                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 mul     hpar2, hidr_count
	byte	$94, $91, $03, $fa
'-'                 call    #hpad_getbits
	byte	$cc, $00, $b0, $fd
'-'                 getbyte htmp, hidr_flags, #0
	byte	$87, $73, $e3, $f8
'-'                 shl     retval, htmp
	byte	$b9, $bf, $62, $f0
'-'                 or      hidr_buttons, retval
	byte	$5f, $19, $43, $f5
'-'                 add     htmp, hidr_count
	byte	$94, $73, $03, $f1
'-'                 setbyte hidr_flags, htmp, #0
	byte	$b9, $0f, $c3, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.skip
	byte	$64, $ff, $9f, $fd
'-' .report_id
'-'                 cmp     hidr_id, #0     wz
	byte	$00, $1e, $0f, $f2
'-'         if_nz   ret     wcz
	byte	$2d, $00, $7c, $5d
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 'debug(".report_id",udec(htmp,hpar2))
'-'                 cmp     htmp, hpar2     wz
	byte	$c8, $73, $0b, $f2
'-'         if_z    mov     hidr_id, htmp
	byte	$b9, $1f, $03, $a6
'-'         if_nz   neg     hidr_state,#1
	byte	$01, $24, $67, $56
'-'         if_nz   sub     ptrb,#1
	byte	$01, $f2, $87, $51
'-'                 jmp     #.next
	byte	$74, $fe, $9f, $fd
'-' .usage_page
'-'                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
	byte	$09, $90, $0f, $f2
'-'         if_z    cmp     hidr_state, #1  wz
	byte	$01, $24, $0f, $a2
'-'         if_z    mov     hidr_state, #4
	byte	$04, $24, $07, $a6
'-'                 jmp     #.next
	byte	$64, $fe, $9f, $fd
'-' .usage
'-'                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
	byte	$04, $90, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
	byte	$05, $90, $0f, $52
'-'         if_z    cmp     hidr_type,#HID_READY        wz
	byte	$06, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $24, $07, $a6
'-'         if_z    jmp     #.next
	byte	$50, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_MOUSE     wz
	byte	$02, $90, $0f, $f2
'-'         if_z    cmp     hidr_type,#M_READY          wz
	byte	$04, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $24, $07, $a6
'-'         if_z    jmp     #.next
	byte	$40, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_X     wc
	byte	$30, $90, $17, $f2
'-'         if_nc   cmpr    hpar2, #HID_USAGE_WHEEL wc   
	byte	$38, $90, $97, $32
'-'         if_nc   jmp     #.usage_axis
	byte	$10, $00, $90, $3d
'-'                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
	byte	$39, $90, $0f, $f2
'-'         if_z    cmp     hidr_state, #1      wz
	byte	$01, $24, $0f, $a2
'-'         if_z    mov     hidr_state, #3
	byte	$03, $24, $07, $a6
'-'                 jmp     #.next
	byte	$24, $fe, $9f, $fd
'-' .usage_axis
'-'                 cmps    hidr_state, #1          wc
	byte	$01, $24, $57, $f2
'-'         if_b    jmp     #.next
	byte	$1c, $fe, $9f, $cd
'-'                 fle     hpar2, #HID_USAGE_DIAL   ' Let's just say wheel and dial are the same to keep sane
	byte	$37, $90, $27, $f3
'-'                 altsn   hidr_usage_idx, #hidr_usage
	byte	$86, $23, $57, $f9
'-'                 setnib  hpar2
	byte	$c8, $01, $00, $f8
'-' 
'-'                 sub     hpar2, #HID_USAGE_X - 16
	byte	$20, $90, $87, $f1
'-'                 bith    hidr_flags, hpar2
	byte	$c8, $0f, $23, $f4
'-' 
'-'                 add     hidr_usage_idx, #1
	byte	$01, $22, $07, $f1
'-'                 mov     hidr_state, #2
	byte	$02, $24, $07, $f6
'-'                 jmp     #.next
	byte	$fc, $fd, $9f, $fd
'-' .pushpop
'-'                 ' Entering with C set if PUSH  
'-'                 loc     pb, #hid_stack
	byte	$4c, $0f, $b0, $fe
'-'         if_c    setq    #(hidr_end-hidr_state)-1
	byte	$28, $08, $64, $cd
'-'         if_c    wrlong  hidr_state, pb
	byte	$f7, $25, $63, $cc
'-'         if_nc   setq    #(hidr_end-hidr_state)-1
	byte	$28, $08, $64, $3d
'-'         if_nc   rdlong  hidr_state, pb
	byte	$f7, $25, $03, $3b
'-'                 jmp     #.next
	byte	$e4, $fd, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Read bits from report data buffer
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRB - report buffer
'-' '   hpar1 - start bit
'-' '   hpar2 - number of bits
'-' ' On exit:
'-' '   retval - bits
'-' '------------------------------------------------------------------------------
'-' hpad_getbits
'-'                 mov     htmp, hpar1
	byte	$c7, $73, $03, $f6
'-'                 shr     htmp, #3        ' byte offset
	byte	$03, $72, $47, $f0
'-'                 add     htmp, ptrb
	byte	$f9, $73, $03, $f1
'-'                 rdlong  retval, htmp
	byte	$b9, $bf, $02, $fb
'-' 
'-'                 mov     htmp1, hpar1
	byte	$c7, $75, $03, $f6
'-'                 and     htmp1, #$07     ' shift
	byte	$07, $74, $07, $f5
'-'                 shr     retval, htmp1
	byte	$ba, $bf, $42, $f0
'-' 
'-'                 cmp     hpar2, #24      wcz
	byte	$18, $90, $1f, $f2
'-'         if_a    jmp     #.l1
	byte	$10, $00, $90, $1d
'-' 
'-'                 decod   hpar2
	byte	$c8, $91, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $90, $87, $f1
'-'                 and     retval, hpar2
	byte	$c8, $bf, $02, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .l1
'-'                 and     retval, ##$00_FFFFFF
	byte	$ff, $7f, $00, $ff, $ff, $bf, $06, $f5
'-'                 add     htmp, #3
	byte	$03, $72, $07, $f1
'-'                 rdlong  htmp2, htmp
	byte	$b9, $77, $03, $fb
'-'                 sub     hpar2, #24
	byte	$18, $90, $87, $f1
'-'                 decod   hpar2
	byte	$c8, $91, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $90, $87, $f1
'-'                 shr     htmp2, htmp1
	byte	$ba, $77, $43, $f0
'-'                 and     htmp2, hpar2
	byte	$c8, $77, $03, $f5
'-'                 shl     htmp2, #24
	byte	$18, $76, $67, $f0
'-'                 or      retval, htmp2
	byte	$bb, $bf, $42, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Normalize value to signed word (-32768 / 32767)
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - value to normalize
'-' '   hidr_lminmax - min (word 1) max (word 0) value range
'-' '   - or -
'-' '   hidr_pminmax - min (word 1) max (word 0) value range
'-' '   hidr_size - value bits length
'-' ' On exit:
'-' '   retval - normalized value
'-' '------------------------------------------------------------------------------
'-' hpad_normalize
'-'                 mov     htmp, hidr_lminmax  wz
	byte	$95, $73, $0b, $f6
'-'         if_z    mov     htmp, hidr_pminmax  wz
	byte	$96, $73, $0b, $a6
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 getword htmp1, htmp, #1     ' htmp1 = min
	byte	$b9, $75, $3b, $f9
'-'                 getword htmp, htmp, #0      ' htmp = max
	byte	$b9, $73, $33, $f9
'-'                 signx   htmp1, #15      wc
	byte	$0f, $74, $77, $f7
'-'         if_c    alts    hidr_size, #511
	byte	$ff, $27, $97, $c9
'-'         if_c    signx   retval, #0-0
	byte	$00, $be, $66, $c7
'-'                 ' slightly crappy hack: if in mouse mode, don't normalize
'-'                 cmp     hidr_type, #M_READY wz
	byte	$04, $1c, $0f, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 subs    htmp, htmp1         ' htmp = (max - min)
	byte	$ba, $73, $c3, $f1
'-'                 subs    retval, htmp1       ' retval = (retval - min)
	byte	$ba, $bf, $c2, $f1
'-'                 shl     retval, #16         ' retval = (retval - min) << 16
	byte	$10, $be, $66, $f0
'-'                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
	byte	$01, $be, $c6, $f1
'-'                 abs     htmp            wc
	byte	$b9, $73, $53, $f6
'-'                 testb   retval, #31     wz
	byte	$1f, $be, $0e, $f4
'-'                 abs     retval
	byte	$5f, $bf, $42, $f6
'-'                 qdiv    retval, htmp
	byte	$b9, $bf, $12, $fd
'-'                 getqx   retval
	byte	$18, $be, $62, $fd
'-'     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
	byte	$5f, $bf, $62, $66
'-'                 adds    retval, ##$8000 signx 15
	byte	$c0, $ff, $7f, $ff, $00, $be, $46, $f1
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if _HAVE_GAMEPAD
'-' '------------------------------------------------------------------------------
'-' ' Handle XInput controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_xinput
'-'                 rdbyte  htmp, ptrb      wz
	byte	$80, $73, $cf, $fa
'-'         if_nz   ret                         ' Ignore message type <> $00
	byte	$2d, $00, $64, $5d
'-'                 rdbyte  htmp, ptrb[1]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #$14      wz
	byte	$14, $72, $0f, $f2
'-'         if_nz   ret                         ' Ignore report length <> $14 (20)
	byte	$2d, $00, $64, $5d
'-' 
'-'                 'debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
	byte	$83, $11, $e7, $fa
'-'                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
	byte	$84, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
	byte	$85, $13, $e7, $fa
'-'                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
	byte	$86, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $2a, $07, $f6
'-'                 rdbyte  retval, ptrb[4]     ' left analog trigger
	byte	$84, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
	byte	$06, $18, $27, $34
'-'                 call    #hpad_normalize
	byte	$54, $ff, $bf, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[5]     ' right analog trigger
	byte	$85, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
	byte	$07, $18, $27, $34
'-'                 call    #hpad_normalize
	byte	$40, $ff, $bf, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 rdword  retval, ptrb[1]
	byte	$81, $bf, $e6, $fa
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $18, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $18, $47, $f4
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $18, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $18, $47, $f4
'-'                 testb   retval, #8      wc  ' LB
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $18, $47, $f4
'-'                 testb   retval, #9      wc  ' RB
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $18, $47, $f4
'-'                 testb   retval, #5      wc  ' SELECT
	byte	$05, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $18, $47, $f4
'-'                 testb   retval, #4      wc  ' START
	byte	$04, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $18, $47, $f4
'-'                 testb   retval, #6      wc  ' L3
	byte	$06, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $18, $47, $f4
'-'                 testb   retval, #7      wc  ' R3
	byte	$07, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $18, $47, $f4
'-'                 testb   retval, #10     wc  ' XBOX
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $18, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
	byte	$5f, $73, $43, $f8
'-'                 mov     htmp1, ##$F576_F40F
	byte	$7a, $bb, $7a, $ff, $0f, $74, $07, $f6
'-'                 mov     htmp2, ##$FFFF_F312
	byte	$f9, $ff, $7f, $ff, $12, $77, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$ba, $73, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $72, $43, $f8
'-'         _ret_   setbyte hidr_hats, htmp, #0
	byte	$b9, $1b, $c3, $08
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle PS3 controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_ps3
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     htmp, #$01      wz
	byte	$01, $72, $0f, $f2
'-'         if_nz   ret                         ' Ignore report ID <> $01
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $2a, $07, $f6
'-'                 rdbyte  retval, ptrb[5]         ' X = left stick X
	byte	$85, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$98, $fe, $bf, $fd
'-'                 setword hidr_axis, retval, #0
	byte	$5f, $11, $23, $f9
'-'                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
	byte	$86, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$8c, $fe, $bf, $fd
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdbyte  retval, ptrb[7]         ' Z = right stick X
	byte	$87, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$80, $fe, $bf, $fd
'-'                 setword hidr_axis+1, retval, #0
	byte	$5f, $13, $23, $f9
'-'                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
	byte	$88, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$74, $fe, $bf, $fd
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-'                 rdbyte  retval, ptrb[17]        ' RX = L2 analog
	byte	$91, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$68, $fe, $bf, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[18]        ' RY = R2 analog
	byte	$92, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$5c, $fe, $bf, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 mov     hpar1, #8
	byte	$08, $8e, $07, $f6
'-'                 mov     hpar2, #19
	byte	$13, $90, $07, $f6
'-'                 call    #hpad_getbits
	byte	$e8, $fd, $bf, $fd
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $18, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $18, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $18, $47, $f4
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $18, $47, $f4
'-'                 testb   retval, #10     wc  ' L1
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $18, $47, $f4
'-'                 testb   retval, #11     wc  ' R1
	byte	$0b, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $18, $47, $f4
'-'                 testb   retval, #8      wc  ' L2
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #6
	byte	$06, $18, $47, $f4
'-'                 testb   retval, #9      wc  ' R2
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #7
	byte	$07, $18, $47, $f4
'-'                 testb   retval, #0      wc  ' SELECT
	byte	$00, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $18, $47, $f4
'-'                 testb   retval, #3      wc  ' START
	byte	$03, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $18, $47, $f4
'-'                 testb   retval, #1      wc  ' LEFT STICK
	byte	$01, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $18, $47, $f4
'-'                 testb   retval, #2      wc  ' RIGHT STICK
	byte	$02, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $18, $47, $f4
'-'                 testb   retval, #16     wc  ' HOME
	byte	$10, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $18, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
	byte	$5f, $73, $4b, $f8
'-'                 mov     htmp1, ##$F3F4_120F
	byte	$09, $fa, $79, $ff, $0f, $74, $07, $f6
'-'                 mov     htmp2, ##$FFF5_FF76
	byte	$ff, $fa, $7f, $ff, $76, $77, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$ba, $73, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $72, $43, $f8
'-'         _ret_   setbyte hidr_hats, htmp, #0
	byte	$b9, $1b, $c3, $08
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform controller actions
'-' ' On entry:
'-' '    hidr_id        report id
'-' '    hidr_axis      axis value (signed word, 2 axes per long)
'-' '                      X = hidr_axis+0, #0
'-' '                      Y = hidr_axis+0, #1
'-' '                      Z = hidr_axis+1, #0
'-' '                     RX = hidr_axis+1, #1
'-' '                     RY = hidr_axis+2, #0
'-' '                     RZ = hidr_axis+2, #1
'-' '                     Sl = hidr_axis+3, #0
'-' '                     Wh = hidr_axis+3, #1
'-' '    hidr_buttons   buttons state (bits 0 to 31)
'-' '    hidr_hats      hats state (byte 0, 1, 2, 3)
'-' '
'-' '                     -------3 -------2 -------1 -------0 byte
'-' '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'-' '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
'-' '                              hlzyx||| |||||||| ++++++++ n. buttons
'-' '                              |||||||| ||||++++--------- n. axes
'-' '                              |||||||| ++++------------- n. hats
'-' '                              ++++++++------------------ valid axes
'-' '------------------------------------------------------------------------------
'-' hpad_translate
'-' 
'-' 
'-'         if HAVE_HIDPAD
'-'                 loc     ptrb,#hidpad_report
	byte	$a0, $0c, $f0, $fe
'-'                 mov     htmp,hdev_port          wz
	byte	$2d, $73, $0b, $f6
'-'         if_z    mov     htmp,hidr_id
	byte	$8f, $73, $03, $a6
'-'                 cmpsub  htmp,#1
	byte	$01, $72, $e7, $f2
'-'         if_z    cmp     hidr_id, #MAX_DEVICES   wc
	byte	$07, $1e, $17, $a2
'-'         if_nz   cmp     hidr_id, #2             wc
	byte	$02, $1e, $17, $52
'-'         if_ae   ret     wcz
	byte	$2d, $00, $7c, $3d
'-'                 mul     htmp, #HIDPAD_REPORT_SIZE
	byte	$20, $72, $07, $fa
'-'                 add     ptrb,htmp
	byte	$b9, $f3, $03, $f1
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
	byte	$00, $0c, $03, $f6
'-'                 setq    #8-1
	byte	$28, $0e, $64, $fd
'-'                 wrlong  hidr_usage,ptrb
	byte	$80, $0d, $67, $fc
'-'         end
'-' 
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' .emupad_no_hat
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' .emupad_slot_over
'-'         end
'-' 
'-'         if 0
'-'                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
'-' 
'-'                 debug("    btn: ", ubin_long_(hidr_buttons))
'-' 
'-'         end
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' '------------------------------------------------------------------------------
'-' ' Clear EmuPad state
'-' '------------------------------------------------------------------------------
'-' emupad_reset
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get EmuPad Player number for current device (into retval)
'-' ' Z flag is also set if current device is valid
'-' ' (Value may be larger than EMUPAD_MAX_PLAYER !)
'-' '------------------------------------------------------------------------------
'-' emupad_getnum
'-' .loop
'-' '------------------------------------------------------------------------------
'-' ' Handle disconnect of device (call after emupad_getnum returns with Z set)
'-' '------------------------------------------------------------------------------
'-' emupad_discon
'-' .loop         
'-'         
'-'         ' FALL THROUGH!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Update EmuPad reports (all of them...)
'-' '------------------------------------------------------------------------------
'-' emupad_write_reports
'-' .devloop
'-' 
'-' end
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_hub_status
'-'                 mov     ep_addr_pid, hhub_ep_addr
	byte	$77, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 setword hpar3, hub_next_datax, #0
	byte	$32, $93, $23, $f9
'-'                 setword hpar3, #1, #1
	byte	$01, $92, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.data
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
	byte	$1a, $01, $80, $5d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .data
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 cmp     hub_next_datax, #PID_DATA0  wz
	byte	$c3, $64, $0e, $f2
'-'         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
	byte	$4b, $64, $06, $a6
'-'         if_nz   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $56
'-'                 rdlong  hub_status_chg, urx_buff_p
	byte	$27, $67, $02, $fb
'-'                 debug(ubin_long(hub_status_chg))
'-' 
'-'                 mov     hdev_port, #1
	byte	$01, $5a, $06, $f6
'-' .loop
'-'                 testb   hub_status_chg, hdev_port wz
	byte	$2d, $67, $0a, $f4
'-'         if_x1   call    #hub_port_handler
	byte	$0c, $00, $b0, $ad
'-'                 incmod  hdev_port, #7           wcz
	byte	$07, $5a, $1e, $f7
'-'         if_nc   jmp     #.loop
	byte	$f0, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' hub_port_handler
'-'                 mov     ep_addr_pid, hhub_ctrl_ep
	byte	$76, $bd, $02, $f6
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$8c, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-' 
'-'                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
	byte	$10, $68, $0e, $f4
'-'         if_x0   jmp     #.other
	byte	$50, $01, $90, $5d
'-'                 loc     ptra, #clr_port_feat
	byte	$68, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
	byte	$01, $21, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
	byte	$00, $68, $0e, $f4
'-'         if_x0   jmp     #.disconnect
	byte	$7c, $01, $90, $5d
'-'                 mov     hctwait, _100ms_
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 loc     ptra, #set_port_feat            ' reset port
	byte	$40, $02, $d0, $fe
'-'                 wrword  #HUB_PORT_RESET, ptra[wValue]
	byte	$01, $09, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp3, #2
	byte	$02, $78, $07, $f6
'-' .wait_reset
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$34, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
	byte	$14, $68, $0e, $f4
'-'         if_x0   djnz    htmp3, #.wait_reset
	byte	$f7, $79, $6f, $5b
'-' 
'-'                 loc     ptra, #clr_port_feat
	byte	$10, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
	byte	$24, $72, $07, $f6
'-' .wait_recover
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 djnz    htmp,#.wait_recover
	byte	$fd, $73, $6f, $fb
'-' 
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$8c, $01, $d0, $fe
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$48, $01, $90, $5d
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
	byte	$80, $01, $d0, $fe
'-'                 mov     htmp, hdev_port             ' Address is hub port number
	byte	$2d, $73, $03, $f6
'-'                 wrword  htmp, ptra[wValue]
	byte	$01, $73, $57, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$24, $01, $90, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$ef, $02, $a0, $fd
'-'                 mov     ep_addr_pid, hdev_port
	byte	$2d, $bd, $02, $f6
'-'                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
	byte	$08, $bc, $66, $f0
'-'                 call    #calc_crc5
	byte	$be, $00, $a0, $fd
'-'                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
	byte	$3c, $01, $d0, $fe
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$f4, $00, $90, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
'-'                 mov     hctwait, _500us_
	byte	$a0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$18, $01, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$cc, $00, $90, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $87, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $89, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $73, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $86, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $88, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $73, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #.done
	byte	$a4, $00, $90, $cd
'-'                 call    #hparse_con_desc
	byte	$68, $f0, $bf, $fd
'-'                 jmp     #.done
	byte	$9c, $00, $90, $fd
'-' 
'-' .other
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz
	byte	$14, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$28, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
	byte	$11, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
	byte	$01, $23, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$1c, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
	byte	$12, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
	byte	$01, $25, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$10, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
	byte	$13, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
	byte	$01, $27, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$04, $00, $90, $ad
'-'                 jmp     #.done
	byte	$68, $00, $90, $fd
'-' .reset_feature
'-'                 loc     ptra, #clr_port_feat
	byte	$e4, $00, $d0, $fe
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 jmp     #.done
	byte	$58, $00, $90, $fd
'-' .disconnect
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $72, $e3, $f8
'-'                 cmp     htmp,#KB_READY wz
	byte	$03, $72, $0f, $f2
'-'         if_nz   cmp     htmp,#KBM_READY wz
	byte	$05, $72, $0f, $52
'-'         if_z    mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $a6
'-'         if_z    mov     hkbd_ctrl_ep, #0
	byte	$00, $f0, $06, $a6
'-'         if_z    mov     kb_led_states, #0
	byte	$00, $76, $06, $a6
'-'         if_z    mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $a6
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $72, $0f, $f2
'-'         if_nz   cmp     htmp, #KBM_READY        wz
	byte	$05, $72, $0f, $52
'-'         if_z    mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $a6
'-'         end
'-'         if HAVE_HIDPAD
'-'                 loc ptrb,#hidpad_report
	byte	$30, $0a, $f0, $fe
'-'                 mov htmp,hdev_port
	byte	$2d, $73, $03, $f6
'-'                 cmpsub htmp,#1
	byte	$01, $72, $e7, $f2
'-'                 mul htmp,#HIDPAD_REPORT_SIZE
	byte	$20, $72, $07, $fa
'-'                 add ptrb,htmp
	byte	$b9, $f3, $03, $f1
'-'                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
	byte	$28, $0e, $64, $fd
'-'                 wrlong #0,ptrb
	byte	$80, $01, $6c, $fc
'-'         end
'-' 
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte #0
	byte	$00, $00, $c4, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' 
'-' .done
'-'                 bitl    _usb_h_ls_nco_, #14     wcz
	byte	$0e, $6a, $1f, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $cc
'-'                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a4, $9b, $02, $f6
'-' 
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$6c, $00, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, ptra
	byte	$00, $69, $06, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Partially populated SETUP packets
'-' '------------------------------------------------------------------------------
'-' get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_DEVICE << 8
	byte	$00, $01
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_CONFIG << 8
	byte	$00, $02
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_CONFIG
	byte	$09
'-'                 word    0       ' Configuration value
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
	byte	$00, $00
'-' set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_ADDR
	byte	$05
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
'-' ' wValue field dictates which protocol should be used.
'-' '
'-' ' When initialized, all devices default to report protocol. However the host
'-' ' should not make any assumptions about the device state and should set the
'-' ' desired protocol whenever initializing a device.
'-' '------------------------------------------------------------------------------
'-' set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_PROTO
	byte	$0b
'-'                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
	byte	$00, $00
'-'                                                 ' (HID 1.11 Section 7.2.6).
'-'                 word    0               ' Interface index number.
	byte	$00, $00
'-'                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_IDLE
	byte	$0a
'-'                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
	byte	$00, $00
'-'                                         ' reporting until a change is detected in the report data
'-' 
'-'                                         ' (HID 1.11 Section 7.2.4).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
	byte	$00, $00
'-' set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_REPORT
	byte	$09
'-'                 word    0       ' Byte1 = report type, byte0 = ReportID.
	byte	$00, $00
'-'                                         ' (HID 1.11 Section 7.2.2).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Size of the report, in bytes.
	byte	$00, $00
'-' get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
	byte	$81
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_REPORT << 8
	byte	$00, $22
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
	byte	$a0
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_HUB << 8
	byte	$00, $29
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_SET_FEATURE
	byte	$03
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_CLEAR_FEATURE
	byte	$01
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
	byte	$a3
'-'                 byte    REQ_GET_STATUS
	byte	$00
'-'                 word    0
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    4       ' Number of bytes to transfer if there is a data stage
	byte	$04, $00
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' ps3_enable_cmd  byte    $42, $0C, $00, $00
	byte	$42, $0c, $00, $00
'-' ps3_command_buff
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
	byte	$00, $00, $00, $00, $02
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' '------------------------------------------------------------------------------
'-' xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
	byte	$01, $03, $06
'-'                                         ' 0x01 All blinking
'-'                                         ' 0x02 1 flashes, then on
'-'                                         ' 0x03 2 flashes, then on
'-'                                         ' 0x04 3 flashes, then on
'-'                                         ' 0x05 4 flashes, then on
'-'                                         ' 0x06 1 on
'-'                                         ' 0x07 2 on
'-'                                         ' 0x08 3 on
'-'                                         ' 0x09 4 on
'-'                                         ' 0x0A Rotating (e.g. 1-2-4-3)
'-'                                         ' 0x0B Blinking*
'-'                                         ' 0x0C Slow blinking*
'-'                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
'-' xinp_rumble_cmd byte    $00, $08, $00
	byte	$00, $08, $00
'-'                 byte    $00             ' Left rumble
	byte	$00
'-'                 byte    $00             ' Right rumble
	byte	$00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' 
'-' xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
'-'                 '' of certain wired 8bitdo gamepads.
'-'                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_STRING << 8 + 4
	byte	$04, $03
'-'                 word    $0409   ' Zero or Language ID (Section 9.6.7)
	byte	$09, $04
'-'                 word    2       ' Number of bytes to transfer if there is a data stage
	byte	$02, $00
'-' end
	byte	$00
'-' alignl
'-' 
'-' if HAVE_MOUSE
'-' mouse_limits long 0[2]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' mouse_outptr long 0
	byte	$00, $00, $00, $00
'-' end
'-' 
'-' if KEYQUEUE_SIZE > 0
'-' keyq_head byte 0
	byte	$00
'-' keyq_tail byte 0
	byte	$00
'-' keyq_data long 0[KEYQUEUE_SIZE]
	byte	$00[514]
'-' alignl
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_rule_buffer
'-' if EMUPAD_BUILTIN_RULES
'-' file "padmap_builtin.dat"
'-' end
'-' byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
'-' '' Default rule directly follows!
'-' byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The USB data cache area gets zero-filled at every device disconnect
'-' '------------------------------------------------------------------------------
'-' usb_cache_start
'-' 
'-' ' HID descriptor and report buffers
'-' if !!OVERLAP_MEMORY
'-' hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
	byte	$00[1792]
'-' end
'-' hkbd_report     byte    0[8]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' hkbd_led_rep    byte    0
	byte	$00, $00, $00, $00
'-' alignl
'-' 
'-' hid_stack       long 0[(hidr_end - hidr_state) * 1]
	byte	$00[20]
'-' 
'-' if HAVE_HIDPAD
'-' hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
	byte	$00[224]
'-' end
'-' 
'-' ' HUB descriptor
'-' hub_descr       byte    0   ' bDescLength
	byte	$00
'-'                 byte    0   ' bDescriptorType
	byte	$00
'-'                 byte    0   ' bNbrPorts
	byte	$00
'-'                 word    0   ' wHubCharacteristics
	byte	$00, $00
'-'                 byte    0   ' bPwrOn2PwrGood
	byte	$00
'-'                 byte    0   ' bHubContrCurrent
	byte	$00
'-'                 byte    0   ' DeviceRemoveable
	byte	$00
'-'                 byte    0   ' PortPwrCtrlMask
	byte	$00
'-' 
'-' usb_cache_end
'-' 
'-' if HAVE_MOUSE
'-' mouse_xacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_yacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_zacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_bstate    byte 0
	byte	$00
'-' mouse_lpending  byte 0
	byte	$00
'-' mouse_rpending  byte 0
	byte	$00
'-' mouse_mpending  byte 0
	byte	$00
'-' mouse_lock      byte 0
	byte	$00
'-'                 byte 0[3] ' padding
	byte	$00, $00, $00
'-' end
'-' 
'-' urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
	byte	$00[128]
'-' dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
	byte	$00[18]
'-' con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
	byte	$00[256]
'-' 
'-' driver_cog      byte    0                       ' Current driver cog + 1
	byte	$00
	alignl
_Audio2_004_spin2_dat_
'-' 
'-' audio       	org     0
'-' 
'-'             	rdlong  mailbox2, ptra++     	' get start address of all mailboxes
	byte	$61, $79, $05, $fb
'-'             	rdlong  scbase, ptra++       	' get start address of scope buffer
	byte	$61, $b1, $05, $fb
'-'             	rdlong  hubptr, ptra++       	' get start address of PSRAM cache
	byte	$61, $bd, $05, $fb
'-' 
'-'             	cogid   pa                   	' compute cogid
	byte	$01, $ec, $63, $fd
'-'             	mul     pa, #12              	' and mailbox spacing
	byte	$0c, $ec, $07, $fa
'-'             	add     mailbox2, pa         	' add offset to find this COG's mailbox
	byte	$f6, $79, $01, $f1
'-'             	mov     mailbox, mailbox2     	' we need 2 copies of this to enable switching between hub and psram
	byte	$bc, $76, $01, $f6
'-' 
'-'             	wrpin   dac2,#left           	' PWM DACs at 44100@339 MHz
	byte	$0e, $ba, $05, $fc
'-'             	wxpin   sr44100,#left      	' 30*256
	byte	$0e, $be, $15, $fc
'-'             	wrpin   dac2,#right
	byte	$0f, $ba, $05, $fc
'-'             	wxpin   sr44100,#right    
	byte	$0f, $be, $15, $fc
'-'             	dirh    #left addpins 1
	byte	$41, $9c, $64, $fd
'-'             	setse1  #%001<<6 + left      	' Set the event - DAC empty
	byte	$20, $9c, $64, $fd
'-'   'debug(uhex(mailbox))
'-'             
'-' '---------------------------------------------------------------------------------        
'-' '----------------- The main loop -------------------------------------------------
'-' '---------------------------------------------------------------------------------
'-' 
'-' loop       	mov 	    cn,#15 '7
	byte	$0f, $a8, $05, $f6
'-'               					'   waitx ##3300000  		'for debug
'-'             
'-' '----------------------------------------------------------------------------------
'-' '------------- Get parameters and execute commands if any -------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' 
'-' p401        	getct ct1
	byte	$1a, $f6, $61, $fd
'-'                 mov     channeladd,cn             	' compute the pointer to channel parameters block
	byte	$d4, $70, $01, $f6
'-'             	shl     channeladd,#6
	byte	$06, $70, $65, $f0
'-'             	add     ptra,channeladd
	byte	$b8, $f0, $03, $f1
'-' 
'-'             	setq    #13                       	' read parameters
	byte	$28, $1a, $64, $fd
'-'             	rdlong  pointer0,ptra
	byte	$00, $7f, $05, $fb
'-' p408        	bitl    command0,#31 wcz	      	' bit #31 command - set the DAC sample rate
	byte	$1f, $92, $1d, $f4
'-'     	if_nc   jmp     #p404                     	' if not set, proceed
	byte	$2c, $00, $90, $3d
'-'             	mov     qq,command0             	' get the new rate
	byte	$c9, $72, $01, $f6
'-'             	wxpin   qq,#left addpins 1        	' and program the pins
	byte	$4e, $72, $15, $fc
'-'             	getbyte qq,qq,#0 		      	' check if the rate is n*256
	byte	$b9, $72, $e1, $f8
'-'             	cmp     qq,#0 wz                         
	byte	$00, $72, $0d, $f2
'-'     	if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
	byte	$4e, $ba, $05, $ac
'-'     	if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
	byte	$4e, $b8, $05, $5c
'-'                 
'-'                	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $88, $1d, $f4
'-'     	if_z    mov     pointer0, #0  
	byte	$00, $7e, $05, $a6
'-'     	if_z    mov     pointer0h, #0  
	byte	$00, $80, $05, $a6
'-'     	if_z    mov     envph0, #0  
	byte	$00, $86, $05, $a6
'-'     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
	byte	$05, $89, $65, $ac
'-'     	
'-' p404        	mov     qq,sstart0		     	' check if start>$80000
	byte	$c4, $72, $01, $f6
'-' 		and 	qq,##$7FFFFFF 
	byte	$ff, $ff, $03, $ff, $ff, $73, $05, $f5
'-'                 cmp 	qq,##$80000 wcz
	byte	$00, $04, $00, $ff, $00, $72, $1d, $f2
'-'     	if_ge   mov     mailbox,mailbox2          	' if yes, use PSRAM
	byte	$bc, $76, $01, $36
'-'     	if_lt   mov     mailbox,#0                	' if not, use HUB 
	byte	$00, $76, $05, $c6
'-'  ''debug(uhex(sstart0,mailbox))
'-' p405           	getword apan0,volpan0,#1          	' extract vol,pan from longs 
	byte	$c7, $a4, $39, $f9
'-'     	    	getword avol0,volpan0,#0
	byte	$c7, $a2, $31, $f9
'-'     	'   debug(uhex(pointer0,pointer0h,sstart0)) 	
'-' '----------------------------------------------------------------------------------
'-' '------------- Compute the envelope, if exists ------------------------------------
'-' '----------------------------------------------------------------------------------
'-'             
'-'             	cmp     envptr0,#0 wcz     		' read the pointer
	byte	$00, $94, $1d, $f2
'-'     	if_z    mov     envs1,##$4000			' if 0, no envelope, load $4000=1 for scas
	byte	$20, $00, $00, $af, $00, $f0, $05, $a6
'-'     	if_z    jmp     #p410				' and run away	
	byte	$54, $00, $90, $ad
'-' 
'-'            	add     envph0,envspd0			' envelope PA update
	byte	$cb, $86, $01, $f1
'-'            	           
'-'       	    	mov     envhi, envph0			' move phase acc to high part of env pointer
	byte	$c3, $ec, $01, $f6
'-' 		shr     envhi,#6			' leave 10 bits in hi
	byte	$06, $ec, $45, $f0
'-' 	   	getword envlo,envhi,#0              	' and 16 bit in lo
	byte	$f6, $ee, $31, $f9
'-' 	    	shr     envhi,#16			' move 10 bits of hi to the lower word
	byte	$10, $ec, $45, $f0
'-' 	    	cmp     envhi,envlen0 wcz		' compare this to envelope length
	byte	$cc, $ec, $19, $f2
'-' 	    											'debug(udec(envhi,envlen0))
'-'     	if_ge  	mov     envhi,envlen0			' if greater than, set it at envlen
	byte	$cc, $ec, $01, $36
'-'     	if_ge   mov     envlo,#0
	byte	$00, $ee, $05, $36
'-'     	if_ge   mov     envph0,envlen0             	' and set envph0 at the end of the envelope
	byte	$cc, $86, $01, $36
'-'     	if_ge   shl     envph0,#22
	byte	$16, $86, $65, $30
'-' 
'-'             	mov 	envs1,envhi			' 10 high bits of PA is the offset to the envelope entry
	byte	$f6, $f0, $01, $f6
'-'             	shl 	envs1,#1                        ' these entries are 16 bit so multiply the offset by 2
	byte	$01, $f0, $65, $f0
'-'             	add 	envs1,envptr0                   ' and add it to the pointer
	byte	$ca, $f0, $01, $f1
'-'             	rdlong 	envs1,envs1			' and then read 2 entries in one rdlong
	byte	$f8, $f0, $01, $fb
'-'             	getword envs2,envs1,#1			' then separate them		
	byte	$f8, $f2, $39, $f9
'-'            	getword envs1,envs1,#0
	byte	$f8, $f0, $31, $f9
'-'             	mul     envs2,envlo                     ' and do linear interpolation based on lower bits of the offset
	byte	$f7, $f2, $01, $fa
'-'             	not     envlo
	byte	$f7, $ee, $21, $f6
'-'             	mul     envs1,envlo
	byte	$f7, $f0, $01, $fa
'-'             	add     envs1,envs2
	byte	$f9, $f0, $01, $f1
'-'             	shr     envs1,#18			' we need only 14 bits for scas
	byte	$12, $f0, $45, $f0
'-'               
'-' '----------------------------------------------------------------------------------
'-' '------------- Generate the noise if bit 27 of the pointer is set -----------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' 
'-'     	
'-' '----------------------------------------------------------------------------------
'-' '------------- Get the sample -----------------------------------------------------
'-' '----------------------------------------------------------------------------------    	
'-'  
'-' p410  		mov	oldptrh,pointer0h
	byte	$c0, $a6, $01, $f6
'-'            	getbyte	afreq0,freqskip0,#3         	' the frequency is in 8:24 format, so get integer in afreq0
	byte	$c8, $a0, $f9, $f8
'-'            	shl	freqskip0,#8                	' and keep the fractional in freqskip0
	byte	$08, $90, $65, $f0
'-'            	add     pointer0,freqskip0 wcz      	' compute the pointer to the next sample   
	byte	$c8, $7e, $19, $f1
'-'            	addx	pointer0h,afreq0  
	byte	$d0, $80, $21, $f1
'-'           	
'-'    	   	testb   sstart0, #27 wz
	byte	$1b, $88, $0d, $f4
'-'     	if_nz	jmp #p412   	
	byte	$10, $00, $90, $5d
'-'    	if_c  	getrnd  spl
	byte	$1b, $74, $61, $cd
'-'    	if_c	rolword rawspl0,spl,#0	
	byte	$ba, $84, $41, $c9
'-'    		getword spl,rawspl0,#0
	byte	$c2, $74, $31, $f9
'-'       	        jmp     #p406          	
	byte	$90, $00, $90, $fd
'-'            	
'-'            	
'-' p412 		cmp	pointer0h,oldptrh wcz
	byte	$d3, $80, $19, $f2
'-'  	if_e 	jmp 	#p411				' if the pointer didn't change, no sample has to be read
	byte	$58, $00, $90, $ad
'-'      	
'-'             	testb   sstart0,#31 wz       	   	' bit 31 : 16 bit sample  
	byte	$1f, $88, $0d, $f4
'-'      	if_z    shl     pointer0h,#1        
	byte	$01, $80, $65, $a0
'-'             	testb   sstart0,#28 wz  		' bit 28 : interleaved sample         
	byte	$1c, $88, $0d, $f4
'-'      	if_z    shl     pointer0h,#1        
	byte	$01, $80, $65, $a0
'-' 												
'-'             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
	byte	$c6, $80, $19, $f2
'-'    	if_ge   sub     pointer0h,lend0       
	byte	$c6, $80, $81, $31
'-'         if_ge   add     pointer0h,lstart0
	byte	$c5, $80, $01, $31
'-'             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
	byte	$c6, $80, $19, $f2
'-'         if_ge   mov	pointer0h,lend0	
	byte	$c6, $80, $01, $36
'-'  
'-'              	mov     qq,pointer0h              	' compute place in the memory from where the sample will be loaded
	byte	$c0, $72, $01, $f6
'-'            	add     qq,sstart0            
	byte	$c4, $72, $01, $f1
'-'            	and  	qq,##$1FF_FFFF
	byte	$ff, $ff, $00, $ff, $ff, $73, $05, $f5
'-'            	cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
	byte	$ff, $77, $5d, $f2
'-'     	if_le   rdword  spl,qq                      	' if not, use HUB RAM for samples
	byte	$b9, $74, $e1, $ea
'-'     	if_gt   call    #cache_read
	byte	$00, $01, $b0, $1d
'-'                 testb   sstart0,#31 wz 
	byte	$1f, $88, $0d, $f4
'-'     	if_nz   shl     spl,#8				' convert 8 to 16 bit if needed
	byte	$08, $74, $65, $50
'-'         if_z    shr     pointer0h,#1
	byte	$01, $80, $45, $a0
'-'                 testb   sstart0,#28 wz            
	byte	$1c, $88, $0d, $f4
'-'     	if_z    shr     pointer0h,#1    
	byte	$01, $80, $45, $a0
'-'                 rolword rawspl0,spl,#0			' now rawspl0 has oldsample:newsample in it
	byte	$ba, $84, $41, $f9
'-'               
'-' p411	      	getword spl,rawspl0,#0
	byte	$c2, $74, $31, $f9
'-' 		getword oldspl,rawspl0,#1		' then separate them		
	byte	$c2, $9e, $39, $f9
'-' 
'-'           '  debug(uhex(pointer0h,pointer0,spl,oldspl))
'-' 
'-' 
'-' 		mov	envlo,pointer0
	byte	$bf, $ee, $01, $f6
'-' 		shr 	envlo,#18
	byte	$12, $ee, $45, $f0
'-' 	
'-'             	scas    spl,envlo                   	' and do linear interpolation
	byte	$f7, $74, $31, $fa
'-'             	mov 	spl,0-0
	byte	$00, $74, $01, $f6
'-'             	not     envlo
	byte	$f7, $ee, $21, $f6
'-'           	and     envlo,##$3FFF
	byte	$1f, $00, $00, $ff, $ff, $ef, $05, $f5
'-'            	scas    oldspl,envlo
	byte	$f7, $9e, $31, $fa
'-'             	mov     oldspl,0-0
	byte	$00, $9e, $01, $f6
'-'                 add     spl, oldspl
	byte	$cf, $74, $01, $f1
'-' 	 
'-' p406        	scas    spl, envs1
	byte	$f8, $74, $31, $fa
'-'             	mov     spl,0-0
	byte	$00, $74, $01, $f6
'-'             	scas    spl,avol0                 	' apply volume
	byte	$d1, $74, $31, $fa
'-'             	mov     spl,0-0
	byte	$00, $74, $01, $f6
'-'  
'-'             	scas    spl,apan0                 	' apply pan
	byte	$d2, $74, $31, $fa
'-'             	mov     ls0,0-0
	byte	$00, $aa, $01, $f6
'-'             	mov     qq,##16384
	byte	$20, $00, $00, $ff, $00, $72, $05, $f6
'-'             	sub     qq,apan0
	byte	$d2, $72, $81, $f1
'-'             	scas    spl,qq
	byte	$b9, $74, $31, $fa
'-'             	mov     rs0, 0-0
	byte	$00, $ac, $01, $f6
'-'       
'-'                 setword sample0,rs0,#1           	' pack samples into long
	byte	$d6, $82, $29, $f9
'-'                 setword sample0,ls0,#0
	byte	$d5, $82, $21, $f9
'-'                 
'-'                 add  lsample,ls0
	byte	$d5, $7a, $01, $f1
'-'                 add  rsample,rs0
	byte	$d6, $7c, $01, $f1
'-'              
'-'             	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $88, $1d, $f4
'-'     	if_z    mov     pointer0, #0  
	byte	$00, $7e, $05, $a6
'-'     	if_z    mov     pointer0h, #0  
	byte	$00, $80, $05, $a6
'-'     	if_z    mov     envph0, #0  
	byte	$00, $86, $05, $a6
'-'     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
	byte	$05, $89, $65, $ac
'-'             
'-' p403        	setq #4                          	' write new pointer, sample values and env pointer to the hub
	byte	$28, $08, $64, $fd
'-' 	       	wrlong  pointer0,ptra
	byte	$00, $7f, $65, $fc
'-'             	sub     ptra, channeladd         	' reset the pointer to channel parameters
	byte	$b8, $f0, $83, $f1
'-' 
'-'             	djnf    cn, #p401
	byte	$84, $a9, $7d, $fb
'-' 
'-'             	bitnot rsample, #15
	byte	$0f, $7c, $e5, $f4
'-'             	bitnot lsample, #15
	byte	$0f, $7a, $e5, $f4
'-'   							           	getct ct2  	'debug
	byte	$1a, $f8, $61, $fd
'-'   							          	sub ct2,ct1
	byte	$fb, $f8, $81, $f1
'-'   							          	debug(udec(ct2))
'-'             	waitse1
	byte	$24, $28, $60, $fd
'-'           
'-'            	wypin   lsample, #left              
	byte	$0e, $7a, $25, $fc
'-'                 wypin   rsample, #right        
	byte	$0f, $7c, $25, $fc
'-' 
'-' 		setword oldsample, lsample,#0		' for oscilloscope
	byte	$bd, $ae, $21, $f9
'-' 		setword oldsample, rsample,#1
	byte	$be, $ae, $29, $f9
'-' 		
'-'             	mov rsample, #0
	byte	$00, $7c, $05, $f6
'-'             	mov lsample, #0
	byte	$00, $7a, $05, $f6
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- Oscilloscope  -----------------------------------------------------
'-' '----------------------------------------------------------------------------------   
'-' 		
'-' 	    	cmp     scbase,#0 wz
	byte	$00, $b0, $0d, $f2
'-'     	if_z    jmp #p302	   
	byte	$20, $00, $90, $ad
'-'  
'-'             	incmod  scope,#1 wc            		'  todo: scope speed instead of const  
	byte	$01, $b6, $15, $f7
'-'     	if_c    mov scptr2,scptr
	byte	$d9, $b4, $01, $c6
'-'     	if_c    shl scptr2,#2
	byte	$02, $b4, $65, $c0
'-'     	if_c    add scptr2,scbase     
	byte	$d8, $b4, $01, $c1
'-'             	wrlong scptr2,#$60
	byte	$60, $b4, $65, $fc
'-'     	if_c    wrlong oldsample,scptr2
	byte	$da, $ae, $61, $cc
'-'     	if_c    incmod scptr,##639
	byte	$01, $00, $00, $cf, $7f, $b2, $05, $c7
'-'             
'-'  p302           jmp     #loop            'loop
	byte	$b4, $fd, $9f, $fd
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- This is the end of the main loop -----------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- PSRAM cache ----------- --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' ' There are 16 cache pointers for 16 channels
'-' ' if 24 higher bits of address=cache, then get a word from the cache
'-' ' else load the cache from PSRAM, update the pointer, then read a sample
'-' 
'-' 
'-' cache_read  	getbyte addrlo,qq,#0 			' when this is called, qq is the addres of the sample			
	byte	$b9, $e6, $e1, $f8
'-'          '   debug ("cache")
'-' 	   	mov     addrhi,qq		
	byte	$b9, $e8, $01, $f6
'-' 	    	shr     addrhi,#8		        ' get 24 upper bits
	byte	$08, $e8, $45, $f0
'-' 	    	alts    cn,#cache1            
	byte	$e0, $a8, $95, $f9
'-' 	    	cmp	addrhi,0-0 wz               	' and compare with the cache pointer for the channel
	byte	$00, $e8, $09, $f2
'-'    	if_z    jmp     #p701	    			' if equal, cache hit, read the sample from it
	byte	$34, $00, $90, $ad
'-' 
'-' p702	    	altd    cn,#cache1			' cache miss. 
	byte	$e0, $a8, $8d, $f9
'-' 	    	mov     0-0,addrhi                  	' update the pointer
	byte	$f4, $00, $00, $f6
'-' 	    ''	 debug(uhex(addrhi))
'-' 	    	mov     cmd,addrhi			' prepare the mailbox
	byte	$f4, $e0, $01, $f6
'-' 	    	shl     cmd,#8
	byte	$08, $e0, $65, $f0
'-'             	setnib  cmd, #%1011, #7             	' read burst from the external memory
	byte	$0b, $e0, $3d, $f8
'-'             	mov     hubaddr,cn                  	' to the channel cache
	byte	$d4, $e2, $01, $f6
'-'             	shl     hubaddr,#8                  	'
	byte	$08, $e2, $65, $f0
'-'             	add     hubaddr,hubptr 
	byte	$de, $e2, $01, $f1
'-'             	mov     count,#256                  	' 256 bytes
	byte	$00, $e5, $05, $f6
'-'             	setq    #2                          	' write 3 longs
	byte	$28, $04, $64, $fd
'-'             	wrlong  cmd, mailbox                	' run it
	byte	$bb, $e0, $61, $fc
'-' poll1       	rdlong  cmd, mailbox                	' poll mailbox for result
	byte	$bb, $e0, $01, $fb
'-'             	tjs     cmd, #poll1                 	' retry until valid 
	byte	$fe, $e1, $b5, $fb
'-'             
'-' 	
'-' p701	    	mov     qq,cn				' cache hit
	byte	$d4, $72, $01, $f6
'-' 	    	shl     qq,#8				' compute the cache start
	byte	$08, $72, $65, $f0
'-' 	    	add     qq,hubptr
	byte	$de, $72, $01, $f1
'-' 	    	add	qq,addrlo			' add 8 lower bits to the cache addredd
	byte	$f3, $72, $01, $f1
'-'     	_ret_   rdword  spl,qq                      	' read a long from the cache
	byte	$b9, $74, $e1, $0a
'-'           
'-'   
'-' 
'-' 
'-' '---------------------------------------------------------------------------
'-' '------- Variables ---------------------------------------------------------
'-' '---------------------------------------------------------------------------
'-' 
'-' ' constants
'-' 
'-' channeladd 	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' temporary variables 
'-' 
'-' qq          	long 0
	byte	$00, $00, $00, $00
'-' spl         	long 0
	byte	$00, $00, $00, $00
'-' mailbox     	long 0
	byte	$00, $00, $00, $00
'-' mailbox2    	long 0
	byte	$00, $00, $00, $00
'-' lsample     	long 0
	byte	$00, $00, $00, $00
'-' rsample     	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' channel parameter block
'-' 
'-' pointer0    	long 0   
	byte	$00, $00, $00, $00
'-' pointer0h   	long 0  
	byte	$00, $00, $00, $00
'-' sample0     	long 0
	byte	$00, $00, $00, $00
'-' rawspl0	    	long 0
	byte	$00, $00, $00, $00
'-' envph0	    	long 0
	byte	$00, $00, $00, $00
'-' sstart0     	long 0     ' start pointer and type at bit 31
	byte	$00, $00, $00, $00
'-' lstart0     	long 0
	byte	$00, $00, $00, $00
'-' lend0       	long 0
	byte	$00, $00, $00, $00
'-' volpan0     	long 0
	byte	$00, $00, $00, $00
'-' freqskip0   	long 0
	byte	$00, $00, $00, $00
'-' command0    	long 0
	byte	$00, $00, $00, $00
'-' envptr0	    	long 0
	byte	$00, $00, $00, $00
'-' envspd0	    	long 0
	byte	$00, $00, $00, $00
'-' envlen0	    	long 0
	byte	$00, $00, $00, $00
'-' res5	    	long 0
	byte	$00, $00, $00, $00
'-' res6	    	long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldspl		long 0
	byte	$00, $00, $00, $00
'-' afreq0      	long 0
	byte	$00, $00, $00, $00
'-' 
'-' avol0       	long 0
	byte	$00, $00, $00, $00
'-' apan0       	long 0
	byte	$00, $00, $00, $00
'-' oldptrh	    	long 0
	byte	$00, $00, $00, $00
'-' cn          	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Samples
'-' 
'-' ls0         	long 0
	byte	$00, $00, $00, $00
'-' rs0         	long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldsample   	long 0
	byte	$00, $00, $00, $00
'-' 
'-' scbase 		long 0
	byte	$00, $00, $00, $00
'-' scptr 		long 0
	byte	$00, $00, $00, $00
'-' scptr2		long 0
	byte	$00, $00, $00, $00
'-' scope 		long 0
	byte	$00, $00, $00, $00
'-' 
'-' dac         	long %10111_00000000_01_00010_0     	'random dither
	byte	$44, $00, $17, $00
'-' dac2        	long %10111_00000000_01_00011_0     	'pwm
	byte	$46, $00, $17, $00
'-' 
'-' hubptr      	long $71800
	byte	$00, $18, $07, $00
'-' sr44100     	long 30*256
	byte	$00, $1e, $00, $00
'-' 
'-' cache1      	long 0
	byte	$00, $00, $00, $00
'-' cache2      	long 0
	byte	$00, $00, $00, $00
'-' cache3      	long 0
	byte	$00, $00, $00, $00
'-' cache4      	long 0
	byte	$00, $00, $00, $00
'-' cache5      	long 0
	byte	$00, $00, $00, $00
'-' cache6      	long 0
	byte	$00, $00, $00, $00
'-' cache7      	long 0
	byte	$00, $00, $00, $00
'-' cache8      	long 0
	byte	$00, $00, $00, $00
'-' cache9      	long 0
	byte	$00, $00, $00, $00
'-' cachea      	long 0
	byte	$00, $00, $00, $00
'-' cacheb      	long 0
	byte	$00, $00, $00, $00
'-' cachec      	long 0
	byte	$00, $00, $00, $00
'-' cached      	long 0
	byte	$00, $00, $00, $00
'-' cachee      	long 0
	byte	$00, $00, $00, $00
'-' cachef      	long 0
	byte	$00, $00, $00, $00
'-' cache0      	long 0
	byte	$00, $00, $00, $00
'-' 
'-' cmd         	long 0
	byte	$00, $00, $00, $00
'-' hubaddr    	long 0
	byte	$00, $00, $00, $00
'-' count       	long 256
	byte	$00, $01, $00, $00
'-' 
'-' addrlo 		long 0
	byte	$00, $00, $00, $00
'-' addrhi 		long 0
	byte	$00, $00, $00, $00
'-' pointer00 	long 0
	byte	$00, $00, $00, $00
'-' envhi 		long 0
	byte	$00, $00, $00, $00
'-' envlo 		long 0
	byte	$00, $00, $00, $00
'-' envs1 		long 0
	byte	$00, $00, $00, $00
'-' envs2 		long 0
	byte	$00, $00, $00, $00
'-' noise0 		long 0
	byte	$00, $00, $00, $00
'-' 
'-'  ct1 		long 0
	byte	$00, $00, $00, $00
'-'  ct2 		long 0
	byte	$00, $00, $00, $00
'-' 
'-' 		fit 256		'todo: maybe the better interpolation. Or all params in cog
'-' 		fit 256		'todo: maybe the better interpolation. Or all params in cog
'-' null  			long 	0,0           ' for channel reset
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	alignl
__system__dat_
	byte	$00[8]
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[660]
	long	(8 {__system____root_opendir})<<20
	long	(9 {__system____root_closedir})<<20
	long	(10 {__system____root_readdir})<<20
	long	(11 {__system____root_stat})<<20
	byte	$00[44]
	byte	$01, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(41 {__system___tx})<<20
	long	(42 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(43 {__system___rxtxioctl_0227})<<20
	long	(44 {__system____dummy_flush_0228})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(41 {__system___tx})<<20
	long	(42 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(43 {__system___rxtxioctl_0227})<<20
	long	(44 {__system____dummy_flush_0228})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(41 {__system___tx})<<20
	long	(42 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(43 {__system___rxtxioctl_0227})<<20
	long	(44 {__system____dummy_flush_0228})<<20
	byte	$00[372]
	alignl
_fatfs_cc_dat_
	byte	$c7, $00, $fc, $00, $e9, $00, $e2, $00, $e4, $00, $e0, $00, $e5, $00, $e7, $00
	byte	$ea, $00, $eb, $00, $e8, $00, $ef, $00, $ee, $00, $ec, $00, $c4, $00, $c5, $00
	byte	$c9, $00, $e6, $00, $c6, $00, $f4, $00, $f6, $00, $f2, $00, $fb, $00, $f9, $00
	byte	$ff, $00, $d6, $00, $dc, $00, $f8, $00, $a3, $00, $d8, $00, $d7, $00, $92, $01
	byte	$e1, $00, $ed, $00, $f3, $00, $fa, $00, $f1, $00, $d1, $00, $aa, $00, $ba, $00
	byte	$bf, $00, $ae, $00, $ac, $00, $bd, $00, $bc, $00, $a1, $00, $ab, $00, $bb, $00
	byte	$91, $25, $92, $25, $93, $25, $02, $25, $24, $25, $c1, $00, $c2, $00, $c0, $00
	byte	$a9, $00, $63, $25, $51, $25, $57, $25, $5d, $25, $a2, $00, $a5, $00, $10, $25
	byte	$14, $25, $34, $25, $2c, $25, $1c, $25, $00, $25, $3c, $25, $e3, $00, $c3, $00
	byte	$5a, $25, $54, $25, $69, $25, $66, $25, $60, $25, $50, $25, $6c, $25, $a4, $00
	byte	$f0, $00, $d0, $00, $ca, $00, $cb, $00, $c8, $00, $31, $01, $cd, $00, $ce, $00
	byte	$cf, $00, $18, $25, $0c, $25, $88, $25, $84, $25, $a6, $00, $cc, $00, $80, $25
	byte	$d3, $00, $df, $00, $d4, $00, $d2, $00, $f5, $00, $d5, $00, $b5, $00, $fe, $00
	byte	$de, $00, $da, $00, $db, $00, $d9, $00, $fd, $00, $dd, $00, $af, $00, $b4, $00
	byte	$ad, $00, $b1, $00, $17, $20, $be, $00, $b6, $00, $a7, $00, $f7, $00, $b8, $00
	byte	$b0, $00, $a8, $00, $b7, $00, $b9, $00, $b3, $00, $b2, $00, $a0, $25, $a0, $00
	byte	$61, $00, $1a, $03, $e0, $00, $17, $03, $f8, $00, $07, $03, $ff, $00, $01, $00
	byte	$78, $01, $00, $01, $30, $01, $32, $01, $06, $01, $39, $01, $10, $01, $4a, $01
	byte	$2e, $01, $79, $01, $06, $01, $80, $01, $4d, $00, $43, $02, $81, $01, $82, $01
	byte	$82, $01, $84, $01, $84, $01, $86, $01, $87, $01, $87, $01, $89, $01, $8a, $01
	byte	$8b, $01, $8b, $01, $8d, $01, $8e, $01, $8f, $01, $90, $01, $91, $01, $91, $01
	byte	$93, $01, $94, $01, $f6, $01, $96, $01, $97, $01, $98, $01, $98, $01, $3d, $02
	byte	$9b, $01, $9c, $01, $9d, $01, $20, $02, $9f, $01, $a0, $01, $a0, $01, $a2, $01
	byte	$a2, $01, $a4, $01, $a4, $01, $a6, $01, $a7, $01, $a7, $01, $a9, $01, $aa, $01
	byte	$ab, $01, $ac, $01, $ac, $01, $ae, $01, $af, $01, $af, $01, $b1, $01, $b2, $01
	byte	$b3, $01, $b3, $01, $b5, $01, $b5, $01, $b7, $01, $b8, $01, $b8, $01, $ba, $01
	byte	$bb, $01, $bc, $01, $bc, $01, $be, $01, $f7, $01, $c0, $01, $c1, $01, $c2, $01
	byte	$c3, $01, $c4, $01, $c5, $01, $c4, $01, $c7, $01, $c8, $01, $c7, $01, $ca, $01
	byte	$cb, $01, $ca, $01, $cd, $01, $10, $01, $dd, $01, $01, $00, $8e, $01, $de, $01
	byte	$12, $01, $f3, $01, $03, $00, $f1, $01, $f4, $01, $f4, $01, $f8, $01, $28, $01
	byte	$22, $02, $12, $01, $3a, $02, $09, $00, $65, $2c, $3b, $02, $3b, $02, $3d, $02
	byte	$66, $2c, $3f, $02, $40, $02, $41, $02, $41, $02, $46, $02, $0a, $01, $53, $02
	byte	$40, $00, $81, $01, $86, $01, $55, $02, $89, $01, $8a, $01, $58, $02, $8f, $01
	byte	$5a, $02, $90, $01, $5c, $02, $5d, $02, $5e, $02, $5f, $02, $93, $01, $61, $02
	byte	$62, $02, $94, $01, $64, $02, $65, $02, $66, $02, $67, $02, $97, $01, $96, $01
	byte	$6a, $02, $62, $2c, $6c, $02, $6d, $02, $6e, $02, $9c, $01, $70, $02, $71, $02
	byte	$9d, $01, $73, $02, $74, $02, $9f, $01, $76, $02, $77, $02, $78, $02, $79, $02
	byte	$7a, $02, $7b, $02, $7c, $02, $64, $2c, $7e, $02, $7f, $02, $a6, $01, $81, $02
	byte	$82, $02, $a9, $01, $84, $02, $85, $02, $86, $02, $87, $02, $ae, $01, $44, $02
	byte	$b1, $01, $b2, $01, $45, $02, $8d, $02, $8e, $02, $8f, $02, $90, $02, $91, $02
	byte	$b7, $01, $7b, $03, $03, $00, $fd, $03, $fe, $03, $ff, $03, $ac, $03, $04, $00
	byte	$86, $03, $88, $03, $89, $03, $8a, $03, $b1, $03, $11, $03, $c2, $03, $02, $00
	byte	$a3, $03, $a3, $03, $c4, $03, $08, $03, $cc, $03, $03, $00, $8c, $03, $8e, $03
	byte	$8f, $03, $d8, $03, $18, $01, $f2, $03, $0a, $00, $f9, $03, $f3, $03, $f4, $03
	byte	$f5, $03, $f6, $03, $f7, $03, $f7, $03, $f9, $03, $fa, $03, $fa, $03, $30, $04
	byte	$20, $03, $50, $04, $10, $07, $60, $04, $22, $01, $8a, $04, $36, $01, $c1, $04
	byte	$0e, $01, $cf, $04, $01, $00, $c0, $04, $d0, $04, $44, $01, $61, $05, $26, $04
	byte	$00, $00, $7d, $1d, $01, $00, $63, $2c, $00, $1e, $96, $01, $a0, $1e, $5a, $01
	byte	$00, $1f, $08, $06, $10, $1f, $06, $06, $20, $1f, $08, $06, $30, $1f, $08, $06
	byte	$40, $1f, $06, $06, $51, $1f, $07, $00, $59, $1f, $52, $1f, $5b, $1f, $54, $1f
	byte	$5d, $1f, $56, $1f, $5f, $1f, $60, $1f, $08, $06, $70, $1f, $0e, $00, $ba, $1f
	byte	$bb, $1f, $c8, $1f, $c9, $1f, $ca, $1f, $cb, $1f, $da, $1f, $db, $1f, $f8, $1f
	byte	$f9, $1f, $ea, $1f, $eb, $1f, $fa, $1f, $fb, $1f, $80, $1f, $08, $06, $90, $1f
	byte	$08, $06, $a0, $1f, $08, $06, $b0, $1f, $04, $00, $b8, $1f, $b9, $1f, $b2, $1f
	byte	$bc, $1f, $cc, $1f, $01, $00, $c3, $1f, $d0, $1f, $02, $06, $e0, $1f, $02, $06
	byte	$e5, $1f, $01, $00, $ec, $1f, $f3, $1f, $01, $00, $fc, $1f, $4e, $21, $01, $00
	byte	$32, $21, $70, $21, $10, $02, $84, $21, $01, $00, $83, $21, $d0, $24, $1a, $05
	byte	$30, $2c, $2f, $04, $60, $2c, $02, $01, $67, $2c, $06, $01, $75, $2c, $02, $01
	byte	$80, $2c, $64, $01, $00, $2d, $26, $08, $41, $ff, $1a, $03, $00, $00, $01, $03
	byte	$05, $07, $09, $0e, $10, $12, $14, $16, $18, $1c, $1e, $43, $55, $45, $41, $41
	byte	$41, $41, $43, $45, $45, $45, $49, $49, $49, $41, $41, $45, $92, $92, $4f, $4f
	byte	$4f, $55, $55, $59, $4f, $55, $4f, $9c, $4f, $9e, $9f, $41, $49, $4f, $55, $a5
	byte	$a5, $a6, $a7, $a8, $a9, $aa, $ab, $ac, $ad, $ae, $af, $b0, $b1, $b2, $b3, $b4
	byte	$41, $41, $41, $b8, $b9, $ba, $bb, $bc, $bd, $be, $bf, $c0, $c1, $c2, $c3, $c4
	byte	$c5, $41, $41, $c8, $c9, $ca, $cb, $cc, $cd, $ce, $cf, $d1, $d1, $45, $45, $45
	byte	$49, $49, $49, $49, $d9, $da, $db, $dc, $dd, $49, $df, $4f, $e1, $4f, $4f, $4f
	byte	$4f, $e6, $e8, $e8, $55, $55, $55, $59, $59, $ee, $ef, $f0, $f1, $f2, $f3, $f4
	byte	$f5, $f6, $f7, $f8, $f9, $fa, $fb, $fc, $fd, $fe, $ff, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $1f, $00, $00, $00, $1c, $00, $00, $00
	byte	$1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00
	byte	$1f, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00
	byte	$1e, $00, $00, $00, $1f, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00
	byte	$3b, $00, $00, $00, $5a, $00, $00, $00, $78, $00, $00, $00, $97, $00, $00, $00
	byte	$b5, $00, $00, $00, $d4, $00, $00, $00, $f3, $00, $00, $00, $11, $01, $00, $00
	byte	$30, $01, $00, $00, $4e, $01, $00, $00, $6d, $01, $00, $00, $ff, $ff, $ff, $ff
	byte	$00[36]
	long	@@@_fatfs_cc_dat_ + 1266
	long	@@@_fatfs_cc_dat_ + 1270
	byte	$00[18]
	byte	$3f, $3f, $3f, $00, $55, $43, $54, $00, $55, $43, $54, $00, $00, $00, $00, $00
	byte	$00[7]
	byte	$ca, $9a, $3b, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$91, $11, $11, $11, $11, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$01[7]
	byte	$90, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
	byte	$42[10]
	byte	$20[7]
	byte	$44[6]
	byte	$04[20]
	byte	$20[6]
	byte	$48[6]
	byte	$08[20]
	byte	$20, $20, $20, $20, $01, $00, $00, $00, $00
__methodtable__
	long	0
	long	@_hg010b_spin2_putchar
	long	@__system___struct___bas_wrap_sender_tx_
	long	@__system___struct___bas_wrap_sender_rx_
	long	@__system___struct___bas_wrap_sender_close_
	long	@__system___struct__s_vfs_file_t_putchar_
	long	@__system___struct__s_vfs_file_t_getchar_
	long	@__system____strs_cl_pfunc_
	long	@__system____root_opendir
	long	@__system____root_closedir
	long	@__system____root_readdir
	long	@__system____root_stat
	long	@__system____default_putc
	long	@__system____default_getc
	long	@__system____default_flush
	long	@_fatfs_cc_v_close
	long	@_fatfs_cc_v_read
	long	@_fatfs_cc_v_write
	long	@_fatfs_cc_v_lseek
	long	@_fatfs_cc_v_ioctl
	long	@_fatfs_cc_v_flush
	long	@_fatfs_cc_v_open
	long	@_fatfs_cc_v_creat
	long	@_fatfs_cc_v_opendir
	long	@_fatfs_cc_v_closedir
	long	@_fatfs_cc_v_readdir
	long	@_fatfs_cc_v_stat
	long	@_fatfs_cc_v_mkdir
	long	@_fatfs_cc_v_rmdir
	long	@_fatfs_cc_v_remove
	long	@_fatfs_cc_v_rename
	long	@_fatfs_cc_v_init
	long	@_fatfs_cc_v_deinit
	long	@_sdmm_cc_v_read
	long	@_sdmm_cc_v_write
	long	@_sdmm_cc_v_close
	long	@_sdmm_cc_v_ioctl
	long	@_sdmm_cc_v_flush
	long	@_sdmm_cc_v_lseek
	long	@_sdmm_cc_v_putc
	long	@_sdmm_cc_v_getc
	long	@__system___tx
	long	@__system___rx
	long	@__system___rxtxioctl_0227
	long	@__system____dummy_flush_0228
__heap_base
	long	0[24002]
objmem
	long	0[4761]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
_var04
	res	1
_var05
	res	1
_var06
	res	1
_var07
	res	1
_var08
	res	1
_var09
	res	1
_var10
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
arg06
	res	1
arg07
	res	1
arg08
	res	1
arg09
	res	1
arg10
	res	1
arg11
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
local12
	res	1
local13
	res	1
local14
	res	1
local15
	res	1
local16
	res	1
local17
	res	1
local18
	res	1
local19
	res	1
local20
	res	1
local21
	res	1
local22
	res	1
local23
	res	1
local24
	res	1
local25
	res	1
local26
	res	1
local27
	res	1
local28
	res	1
local29
	res	1
local30
	res	1
local31
	res	1
local32
	res	1
local33
	res	1
local34
	res	1
local35
	res	1
local36
	res	1
local37
	res	1
local38
	res	1
local39
	res	1
local40
	res	1
local41
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	480
